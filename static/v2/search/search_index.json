{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Sequelize library provides easy access to MySQL, MariaDB, SQLite or PostgreSQL databases by mapping database entries to objects and vice versa. To put it in a nutshell, it's an ORM (Object-Relational-Mapper). The library is written entirely in JavaScript and can be used in the Node.JS environment. Easy installation $ npm install sequelize $ npm install mysql Simple usage var Sequelize = require('sequelize') , sequelize = new Sequelize('database', 'username', 'password') var User = sequelize.define('User', { username: Sequelize.STRING, birthday: Sequelize.DATE }) sequelize.sync().success(function() { User.create({ username: 'sdepold', birthday: new Date(1986, 06, 28) }).success(function(sdepold) { console.log(sdepold.values) }) }) Trusted and used by (c) Sascha Depold, et al. 2006 - 2014 Imprint","title":"Welcome"},{"location":"#easy-installation","text":"$ npm install sequelize $ npm install mysql","title":"Easy installation"},{"location":"#simple-usage","text":"var Sequelize = require('sequelize') , sequelize = new Sequelize('database', 'username', 'password') var User = sequelize.define('User', { username: Sequelize.STRING, birthday: Sequelize.DATE }) sequelize.sync().success(function() { User.create({ username: 'sdepold', birthday: new Date(1986, 06, 28) }).success(function(sdepold) { console.log(sdepold.values) }) })","title":"Simple usage"},{"location":"#trusted-and-used-by","text":"(c) Sascha Depold, et al. 2006 - 2014 Imprint","title":"Trusted and used by"},{"location":"imprint/","text":"Imprint - Boring legal stuff for the rest of us. As there are people who are suing for fun and glory, you can find the respective information about the author of the page right here. Have fun reading ... AUTHOR(S) Main author: Sascha Depold Uhlandstr. 122 10717 Berlin sascha [at] depold [dot] com INHALTLICHE VERANTWORTUNG Ich \u00fcbernehme keine Haftung f\u00fcr ausgehende Links. Daher musst du dich bei Problemen an deren Betreiber wenden!","title":"Imprint"},{"location":"imprint/#imprint-boring-legal-stuff-for-the-rest-of-us","text":"As there are people who are suing for fun and glory, you can find the respective information about the author of the page right here. Have fun reading ...","title":"Imprint - Boring legal stuff for the rest of us."},{"location":"imprint/#authors","text":"Main author: Sascha Depold Uhlandstr. 122 10717 Berlin sascha [at] depold [dot] com","title":"AUTHOR(S)"},{"location":"imprint/#inhaltliche-verantwortung","text":"Ich \u00fcbernehme keine Haftung f\u00fcr ausgehende Links. Daher musst du dich bei Problemen an deren Betreiber wenden!","title":"INHALTLICHE VERANTWORTUNG"},{"location":"api/associations/","text":"Mixin Mixin View code Creating assocations in sequelize is done by calling one of the belongsTo / hasOne / hasMany functions on a model (the source), and prodiving another model as the first argument to the function (the target). hasOne - adds a foreign key to target belongsTo - add a foreign key to source hasMany - adds a foreign key to target, unless you also specifiy that target hasMany source, in which case a junction table is created with sourceId and targetId Creating an association will add a foreign key constraint to the attributes. All associations use CASCADE on update and SET NULL on delete, except for n:m, which also uses CASCADE on delete. When creating associations, you can provide an alias, via the as option. This is usefull if the same model is associated twice, or you want your association to be called something other than the name of the target model. As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a userId , but in addition the user model also has a profilePictureId , to be able to easily load the user's profile picture. User.hasMany(Picture) User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false }) user.getPictures() // gets you all pictures user.getProfilePicture() // gets you only the profile picture User.findAll({ where: ..., include: [ { model: Picture }, // load all pictures { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association ] }) To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define . User.hasMany(Picture, { foreignKey: 'uid' }) The foreign key column in Picture will now be called uid instead of the default userId . User.hasMany(Picture, { foreignKey: { name: 'uid' allowNull: false } }) This specifies that the uid column can not be null. In most cases this will already be covered by the foreign key costraints, which sequelize creates automatically, but can be usefull in case where the foreign keys are disabled, e.g. due to circular references (see constraints: false below). When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to find / findAll . To only get pictures in JPG, you can do: user.getPictures({ where: { format: 'jpg' } }) There are several ways to update and add new assoications. Continuing with our example of users and pictures: user.addPicture(p) // Add a single picture user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations You don't have to pass in a complete object to the association functions, if your associated model has a single primary key: user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it. Note how we also specified constraints: false for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of Error: Cyclic dependency found. 'users' is dependent of itself . If you encounter this, you should either disable some constraints, or rethink your associations completely. hasOne(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasOne(Profile) . This will add userId to the profile table. The following methods are injected on the source: get[AS] - for example getProfile(finder). The finder object is passed to target.find . set[AS] - for example setProfile(instance, options). Options are passed to target.save create[AS] - for example createProfile(value, options). Builds and saves a new instance of the associated model. Values and options are passed on to target.create All methods return a promise Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of source + primary key of source [options.onDelete='SET NULL'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. belongsTo(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the source. Example: Profile.belongsTo(User) . This will add userId to the profile table. The following methods are injected on the source: get[AS] - for example getUser(finder). The finder object is passed to target.find . set[AS] - for example setUser(instance, options). Options are passed to this.save create[AS] - for example createUser(value, options). Builds and saves a new instance of the associated model. Values and options are passed on to target.create All methods return a promise Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the source table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of target + primary key of target [options.onDelete='SET NULL'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. hasMany(target, [options]) View code Create an association that is either 1:m or n:m. // Create a 1:m association between user and project User.hasMany(Project) // Create a n:m association between user and project User.hasMany(Project) Project.hasMany(User) By default, the name of the join table will be source+target, so in this case projectsusers. This can be overridden by providing either a string or a Model as through in the options. The following methods are injected on the source: get[AS] - for example getPictures(finder). The finder object is passed to target.find . set[AS] - for example setPictures(instances, defaultAttributes|options). Update the associations. All currently associated models that are not in instances will be removed. add[AS] - for example addPicture(instance, defaultAttributes|options). Add another associated object. add[AS] [plural] - for example addPictures([instance1, instance2], defaultAttributes|options). Add some more associated objects. create[AS] - for example createPicture(values, options). Build and save a new association. remove[AS] - for example removePicture(instance). Remove a single association. remove[AS] [plural] - for example removePictures(instance). Remove multiple association. has[AS] - for example hasPicture(instance). Is source associated to this target? has[AS] [plural] - for example hasPictures(instances). Is source associated to all these targets? All methods return a promise If you use a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet: var UserProjects = sequelize.define('userprojects', { started: Sequelize.BOOLEAN }) User.hasMany(Project, { through: UserProjects }) Project.hasMany(User, { through: UserProjects }) jan.addProject(homework, { started: false }) // The homework project is not started yet jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model: p1.userprojects { started: true } user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that. Similarily, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model. user.getProjects().success(function (projects) { var p1 = projects[0] p1.userprojects.started // Is this project started yet? }) Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.through] Model | string object [options.through.model] Model The model used to join both sides of the N:M association. [options.through.scope] object A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model) [options.through.unique=true] boolean If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes) [options.as] string | object The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the target table / join table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of source + primary key of source [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.onDelete='SET NULL CASCADE'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Associations"},{"location":"api/associations/#mixin-mixin","text":"View code Creating assocations in sequelize is done by calling one of the belongsTo / hasOne / hasMany functions on a model (the source), and prodiving another model as the first argument to the function (the target). hasOne - adds a foreign key to target belongsTo - add a foreign key to source hasMany - adds a foreign key to target, unless you also specifiy that target hasMany source, in which case a junction table is created with sourceId and targetId Creating an association will add a foreign key constraint to the attributes. All associations use CASCADE on update and SET NULL on delete, except for n:m, which also uses CASCADE on delete. When creating associations, you can provide an alias, via the as option. This is usefull if the same model is associated twice, or you want your association to be called something other than the name of the target model. As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a userId , but in addition the user model also has a profilePictureId , to be able to easily load the user's profile picture. User.hasMany(Picture) User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false }) user.getPictures() // gets you all pictures user.getProfilePicture() // gets you only the profile picture User.findAll({ where: ..., include: [ { model: Picture }, // load all pictures { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association ] }) To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define . User.hasMany(Picture, { foreignKey: 'uid' }) The foreign key column in Picture will now be called uid instead of the default userId . User.hasMany(Picture, { foreignKey: { name: 'uid' allowNull: false } }) This specifies that the uid column can not be null. In most cases this will already be covered by the foreign key costraints, which sequelize creates automatically, but can be usefull in case where the foreign keys are disabled, e.g. due to circular references (see constraints: false below). When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to find / findAll . To only get pictures in JPG, you can do: user.getPictures({ where: { format: 'jpg' } }) There are several ways to update and add new assoications. Continuing with our example of users and pictures: user.addPicture(p) // Add a single picture user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations You don't have to pass in a complete object to the association functions, if your associated model has a single primary key: user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it. Note how we also specified constraints: false for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of Error: Cyclic dependency found. 'users' is dependent of itself . If you encounter this, you should either disable some constraints, or rethink your associations completely.","title":"Mixin Mixin"},{"location":"api/associations/#hasonetarget-options","text":"View code Creates an association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasOne(Profile) . This will add userId to the profile table. The following methods are injected on the source: get[AS] - for example getProfile(finder). The finder object is passed to target.find . set[AS] - for example setProfile(instance, options). Options are passed to target.save create[AS] - for example createProfile(value, options). Builds and saves a new instance of the associated model. Values and options are passed on to target.create All methods return a promise Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of source + primary key of source [options.onDelete='SET NULL'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key.","title":"hasOne(target, [options])"},{"location":"api/associations/#belongstotarget-options","text":"View code Creates an association between this (the source) and the provided target. The foreign key is added on the source. Example: Profile.belongsTo(User) . This will add userId to the profile table. The following methods are injected on the source: get[AS] - for example getUser(finder). The finder object is passed to target.find . set[AS] - for example setUser(instance, options). Options are passed to this.save create[AS] - for example createUser(value, options). Builds and saves a new instance of the associated model. Values and options are passed on to target.create All methods return a promise Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the source table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of target + primary key of target [options.onDelete='SET NULL'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key.","title":"belongsTo(target, [options])"},{"location":"api/associations/#hasmanytarget-options","text":"View code Create an association that is either 1:m or n:m. // Create a 1:m association between user and project User.hasMany(Project) // Create a n:m association between user and project User.hasMany(Project) Project.hasMany(User) By default, the name of the join table will be source+target, so in this case projectsusers. This can be overridden by providing either a string or a Model as through in the options. The following methods are injected on the source: get[AS] - for example getPictures(finder). The finder object is passed to target.find . set[AS] - for example setPictures(instances, defaultAttributes|options). Update the associations. All currently associated models that are not in instances will be removed. add[AS] - for example addPicture(instance, defaultAttributes|options). Add another associated object. add[AS] [plural] - for example addPictures([instance1, instance2], defaultAttributes|options). Add some more associated objects. create[AS] - for example createPicture(values, options). Build and save a new association. remove[AS] - for example removePicture(instance). Remove a single association. remove[AS] [plural] - for example removePictures(instance). Remove multiple association. has[AS] - for example hasPicture(instance). Is source associated to this target? has[AS] [plural] - for example hasPictures(instances). Is source associated to all these targets? All methods return a promise If you use a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet: var UserProjects = sequelize.define('userprojects', { started: Sequelize.BOOLEAN }) User.hasMany(Project, { through: UserProjects }) Project.hasMany(User, { through: UserProjects }) jan.addProject(homework, { started: false }) // The homework project is not started yet jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model: p1.userprojects { started: true } user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that. Similarily, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model. user.getProjects().success(function (projects) { var p1 = projects[0] p1.userprojects.started // Is this project started yet? }) Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.through] Model | string object [options.through.model] Model The model used to join both sides of the N:M association. [options.through.scope] object A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model) [options.through.unique=true] boolean If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes) [options.as] string | object The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the assocition, you should provide the same alias when eager loading and when getting assocated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the target table / join table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the colum. Defaults to the name of source + primary key of source [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.onDelete='SET NULL CASCADE'] string [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"hasMany(target, [options])"},{"location":"api/datatypes/","text":"Class DataTypes View code A convenience class holding commonly used data types. The datatypes are used when definining a new model using Sequelize.define , like this: sequelize.define('model', { column: DataTypes.INTEGER }) When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using DataTypes.BLOB , mean that that column will be returned as an instance of Buffer when being fetched by sequelize. Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do DataTypes.INTEGER.UNSIGNED.ZEROFILL . The order you access the properties in do not matter, so DataTypes.INTEGER.ZEROFILL.UNSIGNED is fine as well. The available properties are listed under each data type. To provide a length for the data type, you can invoke it like a function: INTEGER(2) Three of the values provided here ( NOW , UUIDV1 and UUIDV4 ) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard: sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV1, primaryKey: true } }) STRING View code A variable length string. Default length 255 Available properties: BINARY CHAR View code A fixed length string. Default length 255 Available properties: BINARY TEXT View code An unlimited length text column INTEGER View code A 32 bit integer. Available properties: UNSIGNED , ZEROFILL BIGINT View code A 64 bit integer. Available properties: UNSIGNED , ZEROFILL DATE View code A datetime column DATEONLY View code A date only column BOOLEAN View code A boolean / tinyint column, depending on dialect FLOAT View code Floating point number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL NOW View code A default value of the current timestamp BLOB View code Binary storage. Available lengths: tiny , medium , long DECIMAL View code Decimal number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL UUID View code A column storing a unique univeral identifier. Use with UUIDV1 or UUIDV4 for default values. UUIDV1 View code A default unique universal identifier generated following the UUID v1 standard UUIDV4 View code A default unique universal identifier generated following the UUID v2 standard HSTORE View code A key / value column. Only available in postgres. VIRTUAL View code A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB. You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example: sequelize.define('user', { password_hash: DataTypes.STRING password: { type: DataTypes.VIRTUAL, set: function (val) { this.setDataValue('password', val); this.setDataValue('password_hash', this.salt + val); }, validate: { isLongEnough: function (val) { if (val.length < 7) { throw new Error(\"Please choose a longer password\") } } } } }) In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB. Aliases: NONE ENUM View code An enumeration. DataTypes.ENUM('value', 'another value') . ARRAY() View code An array of type , e.g. DataTypes.ARRAY(DataTypes.DECIMAL) . Only available in postgres. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Datatypes"},{"location":"api/datatypes/#class-datatypes","text":"View code A convenience class holding commonly used data types. The datatypes are used when definining a new model using Sequelize.define , like this: sequelize.define('model', { column: DataTypes.INTEGER }) When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using DataTypes.BLOB , mean that that column will be returned as an instance of Buffer when being fetched by sequelize. Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do DataTypes.INTEGER.UNSIGNED.ZEROFILL . The order you access the properties in do not matter, so DataTypes.INTEGER.ZEROFILL.UNSIGNED is fine as well. The available properties are listed under each data type. To provide a length for the data type, you can invoke it like a function: INTEGER(2) Three of the values provided here ( NOW , UUIDV1 and UUIDV4 ) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard: sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV1, primaryKey: true } })","title":"Class DataTypes"},{"location":"api/datatypes/#string","text":"View code A variable length string. Default length 255 Available properties: BINARY","title":"STRING"},{"location":"api/datatypes/#char","text":"View code A fixed length string. Default length 255 Available properties: BINARY","title":"CHAR"},{"location":"api/datatypes/#text","text":"View code An unlimited length text column","title":"TEXT"},{"location":"api/datatypes/#integer","text":"View code A 32 bit integer. Available properties: UNSIGNED , ZEROFILL","title":"INTEGER"},{"location":"api/datatypes/#bigint","text":"View code A 64 bit integer. Available properties: UNSIGNED , ZEROFILL","title":"BIGINT"},{"location":"api/datatypes/#date","text":"View code A datetime column","title":"DATE"},{"location":"api/datatypes/#dateonly","text":"View code A date only column","title":"DATEONLY"},{"location":"api/datatypes/#boolean","text":"View code A boolean / tinyint column, depending on dialect","title":"BOOLEAN"},{"location":"api/datatypes/#float","text":"View code Floating point number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"FLOAT"},{"location":"api/datatypes/#now","text":"View code A default value of the current timestamp","title":"NOW"},{"location":"api/datatypes/#blob","text":"View code Binary storage. Available lengths: tiny , medium , long","title":"BLOB"},{"location":"api/datatypes/#decimal","text":"View code Decimal number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"DECIMAL"},{"location":"api/datatypes/#uuid","text":"View code A column storing a unique univeral identifier. Use with UUIDV1 or UUIDV4 for default values.","title":"UUID"},{"location":"api/datatypes/#uuidv1","text":"View code A default unique universal identifier generated following the UUID v1 standard","title":"UUIDV1"},{"location":"api/datatypes/#uuidv4","text":"View code A default unique universal identifier generated following the UUID v2 standard","title":"UUIDV4"},{"location":"api/datatypes/#hstore","text":"View code A key / value column. Only available in postgres.","title":"HSTORE"},{"location":"api/datatypes/#virtual","text":"View code A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB. You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example: sequelize.define('user', { password_hash: DataTypes.STRING password: { type: DataTypes.VIRTUAL, set: function (val) { this.setDataValue('password', val); this.setDataValue('password_hash', this.salt + val); }, validate: { isLongEnough: function (val) { if (val.length < 7) { throw new Error(\"Please choose a longer password\") } } } } }) In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB. Aliases: NONE","title":"VIRTUAL"},{"location":"api/datatypes/#enum","text":"View code An enumeration. DataTypes.ENUM('value', 'another value') .","title":"ENUM"},{"location":"api/datatypes/#array","text":"View code An array of type , e.g. DataTypes.ARRAY(DataTypes.DECIMAL) . Only available in postgres. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"ARRAY()"},{"location":"api/errors/","text":"Class Errors View code Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object. new BaseError() View code The Base Error all Sequelize Errors inherit from. Aliases: Error new ValidationError(message, [errors]) View code Validation Error. Thrown when the sequelize validation has failed. The error contains an errors property, which is an array with 1 or more ValidationErrorItems, one for each validation that failed. Params: Name Type Description message string Error message [errors] Array Array of ValidationErrorItem objects describing the validation errors Extends: BaseError get(path) View code Gets all validation error items for the path / field specified. Params: Name Type Description path string The path to be checked for error items errors() View code An array of ValidationErrorItems new DatabaseError() View code A base class for all database related errors. Extends: BaseError parent() View code The database specific error which triggered this one sql() View code The SQL that triggered the error new TimeoutError() View code Thrown when a database query times out because of a deadlock Extends: DatabaseError new UniqueConstraintError() View code Thrown when a unique constraint is violated in the database Extends: DatabaseError new ForeignKeyConstraintError() View code Thrown when a foreign key constraint is violated in the database Extends: DatabaseError message() View code The message from the DB. fields() View code The fields of the unique constraint value() View code The value(s) which triggered the error index() View code The name of the index that triggered the error new ValidationErrorItem(message, type, path, value) View code Validation Error Item Instances of this class are included in the ValidationError.errors property. Params: Name Type Description message string An error message type string The type of the validation error path string The field that triggered the validation error value string The value that generated the error This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Errors"},{"location":"api/errors/#class-errors","text":"View code Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object.","title":"Class Errors"},{"location":"api/errors/#new-baseerror","text":"View code The Base Error all Sequelize Errors inherit from. Aliases: Error","title":"new BaseError()"},{"location":"api/errors/#new-validationerrormessage-errors","text":"View code Validation Error. Thrown when the sequelize validation has failed. The error contains an errors property, which is an array with 1 or more ValidationErrorItems, one for each validation that failed. Params: Name Type Description message string Error message [errors] Array Array of ValidationErrorItem objects describing the validation errors Extends: BaseError","title":"new ValidationError(message, [errors])"},{"location":"api/errors/#getpath","text":"View code Gets all validation error items for the path / field specified. Params: Name Type Description path string The path to be checked for error items","title":"get(path)"},{"location":"api/errors/#errors","text":"View code An array of ValidationErrorItems","title":"errors()"},{"location":"api/errors/#new-databaseerror","text":"View code A base class for all database related errors. Extends: BaseError","title":"new DatabaseError()"},{"location":"api/errors/#parent","text":"View code The database specific error which triggered this one","title":"parent()"},{"location":"api/errors/#sql","text":"View code The SQL that triggered the error","title":"sql()"},{"location":"api/errors/#new-timeouterror","text":"View code Thrown when a database query times out because of a deadlock Extends: DatabaseError","title":"new TimeoutError()"},{"location":"api/errors/#new-uniqueconstrainterror","text":"View code Thrown when a unique constraint is violated in the database Extends: DatabaseError","title":"new UniqueConstraintError()"},{"location":"api/errors/#new-foreignkeyconstrainterror","text":"View code Thrown when a foreign key constraint is violated in the database Extends: DatabaseError","title":"new ForeignKeyConstraintError()"},{"location":"api/errors/#message","text":"View code The message from the DB.","title":"message()"},{"location":"api/errors/#fields","text":"View code The fields of the unique constraint","title":"fields()"},{"location":"api/errors/#value","text":"View code The value(s) which triggered the error","title":"value()"},{"location":"api/errors/#index","text":"View code The name of the index that triggered the error","title":"index()"},{"location":"api/errors/#new-validationerroritemmessage-type-path-value","text":"View code Validation Error Item Instances of this class are included in the ValidationError.errors property. Params: Name Type Description message string An error message type string The type of the validation error path string The field that triggered the validation error value string The value that generated the error This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"new ValidationErrorItem(message, type, path, value)"},{"location":"api/hooks/","text":"Mixin Hooks View code Hooks are function that are called before and after (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways: By specifying them as options in sequelize.define By calling hook() with a string and your hook handler function By calling the function with the same name as the hook you want // Method 1 sequelize.define(name, { attributes }, { hooks: { beforeBulkCreate: function () { // can be a single function }, beforeValidate: [ function () {}, function() {} // Or an array of several ] } }) // Method 2 Model.hook('afterDestroy', function () {}) // Method 3 Model.afterBulkUpdate(function () {}) See: Sequelize#define addHook(hooktype, [name], fn) View code Add a hook to the model Params: Name Type Description hooktype String [name] String Provide a name for the hook function. This serves no purpose, other than the ability to be able to order hooks based on some sort of priority system in the future. fn Function The hook function Aliases: hook beforeValidate(name, fn) View code A hook that is run before validation Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) afterValidate(name, fn) View code A hook that is run after validation Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) beforeCreate(name, fn) View code A hook that is run before creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err) afterCreate(name, fn) View code A hook that is run after creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err) beforeDestroy(name, fn) View code A hook that is run before destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) Aliases: beforeDelete afterDestroy(name, fn) View code A hook that is run after destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) Aliases: afterDelete beforeUpdate(name, fn) View code A hook that is run before updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) afterUpdate(name, fn) View code A hook that is run after updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) beforeBulkCreate(name, fn) View code A hook that is run before creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options, callback(err) afterBulkCreate(name, fn) View code A hook that is run after creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options, callback(err) beforeBulkDestroy(name, fn) View code A hook that is run before destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) Aliases: beforeBulkDelete afterBulkDestroy(name, fn) View code A hook that is run after destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) Aliases: afterBulkDelete beforeBulkUpdate(name, fn) View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) afterBulkUpdate(name, fn) View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) beforeFind(name, fn) View code A hook that is run before a find (select) query Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) beforeFindAfterExpandIncludeAll(name, fn) View code A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) beforeFindAfterOptions(name, fn) View code A hook that is run before a find (select) query, after all option parsing is complete Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) afterFind(name, fn) View code A hook that is run after a find (select) query Params: Name Type Description name String fn Function A callback function that is called with instance(s), options, callback(err) beforeDefine(name, fn) View code A hook that is run before a define call Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err) afterDefine(name, fn) View code A hook that is run after a define call Params: Name Type Description name String fn Function A callback function that is called with factory, callback(err) beforeInit(name, fn) View code A hook that is run before Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with config, options, callback(err) afterInit(name, fn) View code A hook that is run after Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with sequelize, callback(err) This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Hooks"},{"location":"api/hooks/#mixin-hooks","text":"View code Hooks are function that are called before and after (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways: By specifying them as options in sequelize.define By calling hook() with a string and your hook handler function By calling the function with the same name as the hook you want // Method 1 sequelize.define(name, { attributes }, { hooks: { beforeBulkCreate: function () { // can be a single function }, beforeValidate: [ function () {}, function() {} // Or an array of several ] } }) // Method 2 Model.hook('afterDestroy', function () {}) // Method 3 Model.afterBulkUpdate(function () {}) See: Sequelize#define","title":"Mixin Hooks"},{"location":"api/hooks/#addhookhooktype-name-fn","text":"View code Add a hook to the model Params: Name Type Description hooktype String [name] String Provide a name for the hook function. This serves no purpose, other than the ability to be able to order hooks based on some sort of priority system in the future. fn Function The hook function Aliases: hook","title":"addHook(hooktype, [name], fn)"},{"location":"api/hooks/#beforevalidatename-fn","text":"View code A hook that is run before validation Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err)","title":"beforeValidate(name, fn)"},{"location":"api/hooks/#aftervalidatename-fn","text":"View code A hook that is run after validation Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err)","title":"afterValidate(name, fn)"},{"location":"api/hooks/#beforecreatename-fn","text":"View code A hook that is run before creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err)","title":"beforeCreate(name, fn)"},{"location":"api/hooks/#aftercreatename-fn","text":"View code A hook that is run after creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err)","title":"afterCreate(name, fn)"},{"location":"api/hooks/#beforedestroyname-fn","text":"View code A hook that is run before destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) Aliases: beforeDelete","title":"beforeDestroy(name, fn)"},{"location":"api/hooks/#afterdestroyname-fn","text":"View code A hook that is run after destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err) Aliases: afterDelete","title":"afterDestroy(name, fn)"},{"location":"api/hooks/#beforeupdatename-fn","text":"View code A hook that is run before updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err)","title":"beforeUpdate(name, fn)"},{"location":"api/hooks/#afterupdatename-fn","text":"View code A hook that is run after updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options, callback(err)","title":"afterUpdate(name, fn)"},{"location":"api/hooks/#beforebulkcreatename-fn","text":"View code A hook that is run before creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options, callback(err)","title":"beforeBulkCreate(name, fn)"},{"location":"api/hooks/#afterbulkcreatename-fn","text":"View code A hook that is run after creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options, callback(err)","title":"afterBulkCreate(name, fn)"},{"location":"api/hooks/#beforebulkdestroyname-fn","text":"View code A hook that is run before destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) Aliases: beforeBulkDelete","title":"beforeBulkDestroy(name, fn)"},{"location":"api/hooks/#afterbulkdestroyname-fn","text":"View code A hook that is run after destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err) Aliases: afterBulkDelete","title":"afterBulkDestroy(name, fn)"},{"location":"api/hooks/#beforebulkupdatename-fn","text":"View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err)","title":"beforeBulkUpdate(name, fn)"},{"location":"api/hooks/#afterbulkupdatename-fn","text":"View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options, callback(err)","title":"afterBulkUpdate(name, fn)"},{"location":"api/hooks/#beforefindname-fn","text":"View code A hook that is run before a find (select) query Params: Name Type Description name String fn Function A callback function that is called with options, callback(err)","title":"beforeFind(name, fn)"},{"location":"api/hooks/#beforefindafterexpandincludeallname-fn","text":"View code A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded Params: Name Type Description name String fn Function A callback function that is called with options, callback(err)","title":"beforeFindAfterExpandIncludeAll(name, fn)"},{"location":"api/hooks/#beforefindafteroptionsname-fn","text":"View code A hook that is run before a find (select) query, after all option parsing is complete Params: Name Type Description name String fn Function A callback function that is called with options, callback(err)","title":"beforeFindAfterOptions(name, fn)"},{"location":"api/hooks/#afterfindname-fn","text":"View code A hook that is run after a find (select) query Params: Name Type Description name String fn Function A callback function that is called with instance(s), options, callback(err)","title":"afterFind(name, fn)"},{"location":"api/hooks/#beforedefinename-fn","text":"View code A hook that is run before a define call Params: Name Type Description name String fn Function A callback function that is called with attributes, options, callback(err)","title":"beforeDefine(name, fn)"},{"location":"api/hooks/#afterdefinename-fn","text":"View code A hook that is run after a define call Params: Name Type Description name String fn Function A callback function that is called with factory, callback(err)","title":"afterDefine(name, fn)"},{"location":"api/hooks/#beforeinitname-fn","text":"View code A hook that is run before Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with config, options, callback(err)","title":"beforeInit(name, fn)"},{"location":"api/hooks/#afterinitname-fn","text":"View code A hook that is run after Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with sequelize, callback(err) This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"afterInit(name, fn)"},{"location":"api/instance/","text":"Class Instance View code This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not instantiate the Instance class directly, instead you access it using the finder and creation methods on the model. Instance instances operate with the concept of a dataValues property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is: instance.field // is the same as instance.get('field') // is the same as instance.getDataValue('field') However, if getters and/or setters are defined for field they will be invoked, instead of returning the value from dataValues . Accessing properties directly or using get is preferred for regular use, getDataValue should only be used for custom getters. See: Sequelize#define isNewRecord -> Boolean View code Returns true if this instance has not yet been persisted to the database Model() -> Model View code Returns the Model the instance was created from. See: Model sequelize() -> Sequelize View code A reference to the sequelize instance See: Sequelize isDeleted() -> Boolean View code If timestamps and paranoid are enabled, returns whether the deletedAt timestamp of this instance is set. Otherwise, always returns false. values() -> Object View code Get the values of this Instance. Proxies to this.get See: Instance#get isDirty() -> Boolean View code A getter for this.changed() . Returns true if any keys have changed. See: Instance#changed primaryKeyValues() -> Object View code Get the values of the primary keys of this instance. getDataValue(key) -> any View code Get the value of the underlying data value Params: Name Type Description key String setDataValue(key, value) View code Update the underlying data value Params: Name Type Description key String value any get([key], [options]) -> Object|any View code If no key is given, returns all values of the instance, also invoking virtual getters. If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key. Params: Name Type Description [key] String [options] Object [options.plain=false] Boolean If set to true, included instances will be returned as plain objects set(key, value, [options]) View code Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call save ). In its most basic form set will update a value stored in the underlying dataValues object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass raw: true in the options object. If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values. When set is called, the previous value of the field is stored, so that you can later see which fields changed (see changed ). Set can also be used to build instances for associations, if you have values for those. TODO - mick should probably write something here about how includes in set works - perhaps also even some tests? See: Model#find Params: Name Type Description key String | Object value any [options] Object [options.raw=false] Boolean If set to true, field and virtual setters will be ignored [options.reset=false] Boolean Clear all previously set data values [options.include] Object Aliases: setAttributes changed([key]) -> Boolean|Array View code If changed is called with a string it will return a boolean indicating whether the value of that key in dataValues is different from the value in _previousDataValues . If changed is called without an argument, it will return an array of keys that have changed. Params: Name Type Description [key] String previous(key) -> any View code Returns the previous value for key from _previousDataValues . Params: Name Type Description key String save([fields], [options]) -> Promise<this|Errors.ValidationError> View code Validate this instance, and if the validation passes, persist it to the database. On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of Sequelize.ValidationError . This error will have a property for each of the fields for which validation failed, with the error message for that field. Params: Name Type Description [fields] Array An optional array of strings, representing database columns. If fields is provided, only those columns will be validation and saved. [options] Object [options.fields] Object An alternative way of setting which fields should be persisted [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. [options.transaction] Transaction reload([options]) -> Promise<this> View code Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a find(Instance.id) , because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created. See: Model#find Params: Name Type Description [options] Object Options that are passed on to Model.find validate([options]) -> Promise<undefined|Errors.ValidationError> View code Validate the attribute of this instance according to validation rules set in the model definition. Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries. See: InstanceValidator Params: Name Type Description [options] Object Options that are passed to the validator [options.skip] Array An array of strings. All properties that are in this array will not be validated updateAttributes(updates, options) -> Promise<this> View code This is the same as calling setAttributes , then calling save . See: Instance#setAttributes Instance#save Params: Name Type Description updates Object See setAttributes options Object See save destroy([options={}]) -> Promise<undefined> View code Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time. Params: Name Type Description [options={}] Object [options.force=false] Boolean If set to true, paranoid models will actually be deleted restore([options={}]) -> Promise<undefined> View code Restore the row corresponding to this instance. Only available for paranoid models. Params: Name Type Description [options={}] Object increment(fields, [options]) -> Promise View code Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a SET column = column + X query. To get the correct value after an increment into the Instance you should do a reload. instance.increment('number') // increment number by 1 instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2 instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array Object [options] Object [options.by=1] Integer The number to increment by [options.transaction=null] Transaction decrement(fields, [options]) -> Promise View code Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a SET column = column - X query. To get the correct value after an decrement into the Instance you should do a reload. instance.decrement('number') // decrement number by 1 instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2 instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array Object [options] Object [options.by=1] Integer The number to decrement by [options.transaction=null] Transaction equals(other) -> Boolean View code Check whether all values of this and other Instance are the same Params: Name Type Description other Instance equalsOneOf(others) -> Boolean View code Check if this is eqaul to one of others by calling equals Params: Name Type Description others Array toJSON() -> object View code Convert the instance to a JSON representation. Proxies to calling get with no keys. This means get all values gotten from the DB, and apply all custom getters. See: Instance#get This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Instance"},{"location":"api/instance/#class-instance","text":"View code This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not instantiate the Instance class directly, instead you access it using the finder and creation methods on the model. Instance instances operate with the concept of a dataValues property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is: instance.field // is the same as instance.get('field') // is the same as instance.getDataValue('field') However, if getters and/or setters are defined for field they will be invoked, instead of returning the value from dataValues . Accessing properties directly or using get is preferred for regular use, getDataValue should only be used for custom getters. See: Sequelize#define","title":"Class Instance"},{"location":"api/instance/#isnewrecord-boolean","text":"View code Returns true if this instance has not yet been persisted to the database","title":"isNewRecord -&gt; Boolean"},{"location":"api/instance/#model-model","text":"View code Returns the Model the instance was created from. See: Model","title":"Model() -&gt; Model"},{"location":"api/instance/#sequelize-sequelize","text":"View code A reference to the sequelize instance See: Sequelize","title":"sequelize() -&gt; Sequelize"},{"location":"api/instance/#isdeleted-boolean","text":"View code If timestamps and paranoid are enabled, returns whether the deletedAt timestamp of this instance is set. Otherwise, always returns false.","title":"isDeleted() -&gt; Boolean"},{"location":"api/instance/#values-object","text":"View code Get the values of this Instance. Proxies to this.get See: Instance#get","title":"values() -&gt; Object"},{"location":"api/instance/#isdirty-boolean","text":"View code A getter for this.changed() . Returns true if any keys have changed. See: Instance#changed","title":"isDirty() -&gt; Boolean"},{"location":"api/instance/#primarykeyvalues-object","text":"View code Get the values of the primary keys of this instance.","title":"primaryKeyValues() -&gt; Object"},{"location":"api/instance/#getdatavaluekey-any","text":"View code Get the value of the underlying data value Params: Name Type Description key String","title":"getDataValue(key) -&gt; any"},{"location":"api/instance/#setdatavaluekey-value","text":"View code Update the underlying data value Params: Name Type Description key String value any","title":"setDataValue(key, value)"},{"location":"api/instance/#getkey-options-objectany","text":"View code If no key is given, returns all values of the instance, also invoking virtual getters. If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key. Params: Name Type Description [key] String [options] Object [options.plain=false] Boolean If set to true, included instances will be returned as plain objects","title":"get([key], [options]) -&gt; Object|any"},{"location":"api/instance/#setkey-value-options","text":"View code Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call save ). In its most basic form set will update a value stored in the underlying dataValues object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass raw: true in the options object. If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values. When set is called, the previous value of the field is stored, so that you can later see which fields changed (see changed ). Set can also be used to build instances for associations, if you have values for those. TODO - mick should probably write something here about how includes in set works - perhaps also even some tests? See: Model#find Params: Name Type Description key String | Object value any [options] Object [options.raw=false] Boolean If set to true, field and virtual setters will be ignored [options.reset=false] Boolean Clear all previously set data values [options.include] Object Aliases: setAttributes","title":"set(key, value, [options])"},{"location":"api/instance/#changedkey-booleanarray","text":"View code If changed is called with a string it will return a boolean indicating whether the value of that key in dataValues is different from the value in _previousDataValues . If changed is called without an argument, it will return an array of keys that have changed. Params: Name Type Description [key] String","title":"changed([key]) -&gt; Boolean|Array"},{"location":"api/instance/#previouskey-any","text":"View code Returns the previous value for key from _previousDataValues . Params: Name Type Description key String","title":"previous(key) -&gt; any"},{"location":"api/instance/#savefields-options-promisethiserrorsvalidationerror","text":"View code Validate this instance, and if the validation passes, persist it to the database. On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of Sequelize.ValidationError . This error will have a property for each of the fields for which validation failed, with the error message for that field. Params: Name Type Description [fields] Array An optional array of strings, representing database columns. If fields is provided, only those columns will be validation and saved. [options] Object [options.fields] Object An alternative way of setting which fields should be persisted [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. [options.transaction] Transaction","title":"save([fields], [options]) -&gt; Promise&lt;this|Errors.ValidationError&gt;"},{"location":"api/instance/#reloadoptions-promisethis","text":"View code Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a find(Instance.id) , because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created. See: Model#find Params: Name Type Description [options] Object Options that are passed on to Model.find","title":"reload([options]) -&gt; Promise&lt;this&gt;"},{"location":"api/instance/#validateoptions-promiseundefinederrorsvalidationerror","text":"View code Validate the attribute of this instance according to validation rules set in the model definition. Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries. See: InstanceValidator Params: Name Type Description [options] Object Options that are passed to the validator [options.skip] Array An array of strings. All properties that are in this array will not be validated","title":"validate([options]) -&gt; Promise&lt;undefined|Errors.ValidationError&gt;"},{"location":"api/instance/#updateattributesupdates-options-promisethis","text":"View code This is the same as calling setAttributes , then calling save . See: Instance#setAttributes Instance#save Params: Name Type Description updates Object See setAttributes options Object See save","title":"updateAttributes(updates, options) -&gt; Promise&lt;this&gt;"},{"location":"api/instance/#destroyoptions-promiseundefined","text":"View code Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time. Params: Name Type Description [options={}] Object [options.force=false] Boolean If set to true, paranoid models will actually be deleted","title":"destroy([options={}]) -&gt; Promise&lt;undefined&gt;"},{"location":"api/instance/#restoreoptions-promiseundefined","text":"View code Restore the row corresponding to this instance. Only available for paranoid models. Params: Name Type Description [options={}] Object","title":"restore([options={}]) -&gt; Promise&lt;undefined&gt;"},{"location":"api/instance/#incrementfields-options-promise","text":"View code Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a SET column = column + X query. To get the correct value after an increment into the Instance you should do a reload. instance.increment('number') // increment number by 1 instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2 instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array Object [options] Object [options.by=1] Integer The number to increment by [options.transaction=null] Transaction","title":"increment(fields, [options]) -&gt; Promise"},{"location":"api/instance/#decrementfields-options-promise","text":"View code Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a SET column = column - X query. To get the correct value after an decrement into the Instance you should do a reload. instance.decrement('number') // decrement number by 1 instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2 instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array Object [options] Object [options.by=1] Integer The number to decrement by [options.transaction=null] Transaction","title":"decrement(fields, [options]) -&gt; Promise"},{"location":"api/instance/#equalsother-boolean","text":"View code Check whether all values of this and other Instance are the same Params: Name Type Description other Instance","title":"equals(other) -&gt; Boolean"},{"location":"api/instance/#equalsoneofothers-boolean","text":"View code Check if this is eqaul to one of others by calling equals Params: Name Type Description others Array","title":"equalsOneOf(others) -&gt; Boolean"},{"location":"api/instance/#tojson-object","text":"View code Convert the instance to a JSON representation. Proxies to calling get with no keys. This means get all values gotten from the DB, and apply all custom getters. See: Instance#get This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"toJSON() -&gt; object"},{"location":"api/model/","text":"Class Model View code A Model represents a table in the database. Sometimes you might also see it refererred to as model, or simply as factory. This class should not be instantiated directly, it is created using sequelize.define , and already created models can be loaded using sequelize.import Mixes: Hooks Associations removeAttribute([attribute]) View code Remove attribute from model definition Params: Name Type Description [attribute] String sync() -> Promise<this> View code Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this) See: Sequelize#sync drop([options]) -> Promise View code Drop the table represented by this Model Params: Name Type Description [options] Object [options.cascade=false] Boolean Also drop all objects depending on this table, such as views. Only works in postgres schema(schema, [options]) -> this View code Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - \"schema\".\"tableName\" , while the schema will be prepended to the table name for mysql and sqlite - 'schema.tablename' . Params: Name Type Description schema String The name of the schema [options] Object [options.schemaDelimiter='.'] String The character(s) that separates the schema name from the table name getTableName(options) -> String|Object View code Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with tableName , schema and delimiter properties. Params: Name Type Description options Object The hash of options from any query. You can use one model to access tables with matching schemas by overriding getTableName and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2) scope(options*) -> Model View code Apply a scope created in define to the model. First let's look at how to create scopes: var Model = sequelize.define('model', attributes, { defaultScope: { where: { username: 'dan' }, limit: 12 }, scopes: { isALie: { where: { stuff: 'cake' } }, complexFunction: function(email, accessLevel) { return { where: ['email like ? AND access_level >= ?', email + '%', accessLevel] } }, } }) Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples: Model.findAll() // WHERE username = 'dan' Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan' To invoke scope functions you can do: Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll() // WHERE email like 'dan@sequelize.com%' AND access_level >= 42 Params: Name Type Description options* Array | Object String Returns: A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope. findAll([options], [queryOptions]) -> Promise<Array<Instance>> View code Search for multiple instances. Simple search using AND and = Model.find({ where: { attr1: 42, attr2: 'cake' } }) WHERE attr1 = 42 AND attr2 = 'cake' Using greater than, less than etc. Model.find({ where: { attr1: { gt: 50 }, attr2: { lte: 45 }, attr3: { in: [1,2,3] }, attr4: { ne: 5 } } }) WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5 Possible options are: gt, gte, lt, lte, ne, between/.., nbetween/notbetween/!.., in, not, like, nlike/notlike Queries using OR Model.find({ where: Sequelize.and( { name: 'a project' }, Sequelize.or( { id: [1,2,3] }, { id: { gt: 10 } } ) ) }) WHERE name = 'a project' AND (id` IN (1,2,3) OR id > 10) The success listener is called with an array of instances if the query succeeds. See: Sequelize#query Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.where] Object A hash of attributes to describe your search. See above for examples. [options.attributes] Array<String> A list of the attributes that you want to select. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as Sequelize.literal , Sequelize.fn and so on), and the second is the name you want the attribute to have in the returned instance [options.paranoid=true] Boolean If false, will include columns which have a non-null deletedAt column. [options.include] Array<Object | Model> A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, ...]} or { include: [{ model: Model1, as: 'Alias' }]} . If your association are set up with an as (eg. X.hasMany(Y, { as: 'Z } , you need to specify Z in the as attribute when eager loading Y). [options.include[].model] Model The model you want to eagerly load [options.include[].as] String The alias of the relation, in case the model you want to eagerly load is aliassed. For hasOne / belongsTo , this should be the singular name, and for hasMany , it should be the plural [options.include[].association] Association The association you want to eagerly load. (This can be used instead of providing a model/as pair) [options.include[].where] Object Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set required: false [options.include[].attributes] Array<String> A list of attributes to select from the child model [options.include[].required] Boolean If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if include.where is set, false otherwise. [options.include[].include] Array<Object | Model> Load further nested related models [options.order] String | Array Sequelize.fn [options.limit] Number [options.offset] Number [queryOptions] Object Set the query options, e.g. raw, specifying that you want raw data instead of built Instances. See sequelize.query for options [queryOptions.transaction] Transaction [queryOptions.lock] String Lock the selected rows in either share or update mode. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. See transaction.LOCK for an example Aliases: all findOne([options], [queryOptions]) -> Promise<Instance> View code Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance. See: Model#findAll Params: Name Type Description [options] Object | Number A hash of options to describe the scope of the search, or a number to search by id. [queryOptions] Object Aliases: find aggregate(field, aggregateFunction, [options]) -> Promise<options.dataType> View code Run an aggregation method on the specified field Params: Name Type Description field String The field to aggregate over. Can be a field name or * aggregateFunction String The function to use for aggregation, e.g. sum, max etc. [options] Object Query options. See sequelize.query for full options [options.dataType] DataType | String The type of the result. If field is a field in this Model, the default will be the type of that field, otherwise defaults to float. [options.distinct] boolean Applies DISTINCT to the field being aggregated over count([options]) -> Promise<Integer> View code Count the number of records matching the provided where clause. If you provide an include option, the number of matching associations will be counted instead. Params: Name Type Description [options] Object [options.include] Object Include options. See find for details [options.distinct] boolean Appliy COUNT(DISTINCT(col)) findAndCountAll([findOptions], [queryOptions]) -> Promise<Object> View code Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very usefull for paging Model.findAndCountAll({ where: ..., limit: 12, offset: 12 }).success(function (result) { }) In the above example, result.rows will contain rows 13 through 24, while result.count will return the total number of rows that matched your query. See: Model#findAll Params: Name Type Description [findOptions] Object See findAll [queryOptions] Object See Sequelize.query max(field, [options]) -> Promise<Any> View code Find the maximum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate min(field, [options]) -> Promise<Any> View code Find the minimum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate sum(field, [options]) -> Promise<Number> View code Find the sum of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate build(values, [options]) -> Instance View code Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty. Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.isDirty=true] Boolean [options.include] Array an array of include options - Used to build prefetched/included model instances. See set create(values, [options]) -> Promise<Instance> View code Builds a new model instance and calls save on it. See: Instance#build Instance#save Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.isDirty=true] Boolean [options.fields] Array If set, only columns matching those in fields will be saved [options.include] Array an array of include options - Used to build prefetched/included model instances [options.transaction] Transaction (options) -> Promise<Instance> View code Find a row that matches the query, or build (but don't save) the row if none is found. The successfull result of the promise will be (instance, initialized) - Make sure to use .spread() Params: Name Type Description options Object options.where Object A hash of search attributes. [options.defaults] Object Default values to use if building a new instance [options.transaction] Object Transaction to run query under Aliases: findOrBuild findOrCreate(options, [queryOptions]) -> Promise<Instance|created> View code Find a row that matches the query, or build and save the row if none is found The successfull result of the promise will be (instance, created) - Make sure to use .spread() If no transaction is passed in the queryOptions object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has comitted. In this case, an instance of sequelize.TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally. Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance [queryOptions] Object Options passed to the find and create calls bulkCreate(records, [options]) -> Promise<Array<Instance>> View code Create and insert multiple instances in bulk. The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again. Params: Name Type Description records Array List of objects (key/value pairs) to create instances from [options] Object [options.fields] Array Fields to insert (defaults to all fields) [options.validate=false] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk create hooks? [options.individualHooks=false] Boolean Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true. [options.ignoreDuplicates=false] Boolean Ignore duplicate values for primary keys? (not supported by postgres) destroy() -> Promise<undefined> View code Delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled. Params: Name Type Description [options.where] Object Filter the destroy [options.hooks=true] Boolean Run before / after bulk destroy hooks? [options.individualHooks=false] Boolean If set to true, destroy will find all records within the where parameter and will execute before / after bulkDestroy hooks on each row [options.limit] Number How many rows to delete [options.force=false] Boolean Delete instead of setting deletedAt to current timestamp (only applicable if paranoid is enabled) [options.truncate=false] Boolean If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored [options.cascade=false] Boolean Only used in conjuction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. restore() -> Promise<undefined> View code Restore multiple instances if paranoid is enabled. Params: Name Type Description [options.where] Object Filter the restore [options.hooks=true] Boolean Run before / after bulk restore hooks? [options.individualHooks=false] Boolean If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row [options.limit] Number How many rows to undelete update(values, options) -> Promise<Array<affectedCount|affectedRows>> View code Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with options.returning true.) Params: Name Type Description values Object options Object options.where Object Options to describe the scope of the search. [options.validate=true] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk update hooks? [options.individualHooks=false] Boolean Run before / after update hooks? [options.returning=false] Boolean Return the affected rows (only for postgres) [options.limit] Number How many rows to update (only for mysql and mariadb) describe() -> Promise View code Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types. dataset() -> node-sql View code A proxy to the node-sql query builder, which allows you to build your query through a chain of method calls. The returned instance already has all the fields property populated with the field of the model. See: Returns: A node-sql instance This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Model"},{"location":"api/model/#class-model","text":"View code A Model represents a table in the database. Sometimes you might also see it refererred to as model, or simply as factory. This class should not be instantiated directly, it is created using sequelize.define , and already created models can be loaded using sequelize.import","title":"Class Model"},{"location":"api/model/#mixes","text":"Hooks Associations","title":"Mixes:"},{"location":"api/model/#removeattributeattribute","text":"View code Remove attribute from model definition Params: Name Type Description [attribute] String","title":"removeAttribute([attribute])"},{"location":"api/model/#sync-promisethis","text":"View code Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this) See: Sequelize#sync","title":"sync() -&gt; Promise&lt;this&gt;"},{"location":"api/model/#dropoptions-promise","text":"View code Drop the table represented by this Model Params: Name Type Description [options] Object [options.cascade=false] Boolean Also drop all objects depending on this table, such as views. Only works in postgres","title":"drop([options]) -&gt; Promise"},{"location":"api/model/#schemaschema-options-this","text":"View code Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - \"schema\".\"tableName\" , while the schema will be prepended to the table name for mysql and sqlite - 'schema.tablename' . Params: Name Type Description schema String The name of the schema [options] Object [options.schemaDelimiter='.'] String The character(s) that separates the schema name from the table name","title":"schema(schema, [options]) -&gt; this"},{"location":"api/model/#gettablenameoptions-stringobject","text":"View code Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with tableName , schema and delimiter properties. Params: Name Type Description options Object The hash of options from any query. You can use one model to access tables with matching schemas by overriding getTableName and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2)","title":"getTableName(options) -&gt; String|Object"},{"location":"api/model/#scopeoptions-model","text":"View code Apply a scope created in define to the model. First let's look at how to create scopes: var Model = sequelize.define('model', attributes, { defaultScope: { where: { username: 'dan' }, limit: 12 }, scopes: { isALie: { where: { stuff: 'cake' } }, complexFunction: function(email, accessLevel) { return { where: ['email like ? AND access_level >= ?', email + '%', accessLevel] } }, } }) Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples: Model.findAll() // WHERE username = 'dan' Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan' To invoke scope functions you can do: Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll() // WHERE email like 'dan@sequelize.com%' AND access_level >= 42 Params: Name Type Description options* Array | Object String Returns: A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.","title":"scope(options*) -&gt; Model"},{"location":"api/model/#findalloptions-queryoptions-promisearrayinstance","text":"View code Search for multiple instances. Simple search using AND and = Model.find({ where: { attr1: 42, attr2: 'cake' } }) WHERE attr1 = 42 AND attr2 = 'cake' Using greater than, less than etc. Model.find({ where: { attr1: { gt: 50 }, attr2: { lte: 45 }, attr3: { in: [1,2,3] }, attr4: { ne: 5 } } }) WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5 Possible options are: gt, gte, lt, lte, ne, between/.., nbetween/notbetween/!.., in, not, like, nlike/notlike Queries using OR Model.find({ where: Sequelize.and( { name: 'a project' }, Sequelize.or( { id: [1,2,3] }, { id: { gt: 10 } } ) ) }) WHERE name = 'a project' AND (id` IN (1,2,3) OR id > 10) The success listener is called with an array of instances if the query succeeds. See: Sequelize#query Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.where] Object A hash of attributes to describe your search. See above for examples. [options.attributes] Array<String> A list of the attributes that you want to select. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as Sequelize.literal , Sequelize.fn and so on), and the second is the name you want the attribute to have in the returned instance [options.paranoid=true] Boolean If false, will include columns which have a non-null deletedAt column. [options.include] Array<Object | Model> A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, ...]} or { include: [{ model: Model1, as: 'Alias' }]} . If your association are set up with an as (eg. X.hasMany(Y, { as: 'Z } , you need to specify Z in the as attribute when eager loading Y). [options.include[].model] Model The model you want to eagerly load [options.include[].as] String The alias of the relation, in case the model you want to eagerly load is aliassed. For hasOne / belongsTo , this should be the singular name, and for hasMany , it should be the plural [options.include[].association] Association The association you want to eagerly load. (This can be used instead of providing a model/as pair) [options.include[].where] Object Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set required: false [options.include[].attributes] Array<String> A list of attributes to select from the child model [options.include[].required] Boolean If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if include.where is set, false otherwise. [options.include[].include] Array<Object | Model> Load further nested related models [options.order] String | Array Sequelize.fn [options.limit] Number [options.offset] Number [queryOptions] Object Set the query options, e.g. raw, specifying that you want raw data instead of built Instances. See sequelize.query for options [queryOptions.transaction] Transaction [queryOptions.lock] String Lock the selected rows in either share or update mode. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. See transaction.LOCK for an example Aliases: all","title":"findAll([options], [queryOptions]) -&gt; Promise&lt;Array&lt;Instance&gt;&gt;"},{"location":"api/model/#findoneoptions-queryoptions-promiseinstance","text":"View code Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance. See: Model#findAll Params: Name Type Description [options] Object | Number A hash of options to describe the scope of the search, or a number to search by id. [queryOptions] Object Aliases: find","title":"findOne([options], [queryOptions]) -&gt; Promise&lt;Instance&gt;"},{"location":"api/model/#aggregatefield-aggregatefunction-options-promiseoptionsdatatype","text":"View code Run an aggregation method on the specified field Params: Name Type Description field String The field to aggregate over. Can be a field name or * aggregateFunction String The function to use for aggregation, e.g. sum, max etc. [options] Object Query options. See sequelize.query for full options [options.dataType] DataType | String The type of the result. If field is a field in this Model, the default will be the type of that field, otherwise defaults to float. [options.distinct] boolean Applies DISTINCT to the field being aggregated over","title":"aggregate(field, aggregateFunction, [options]) -&gt; Promise&lt;options.dataType&gt;"},{"location":"api/model/#countoptions-promiseinteger","text":"View code Count the number of records matching the provided where clause. If you provide an include option, the number of matching associations will be counted instead. Params: Name Type Description [options] Object [options.include] Object Include options. See find for details [options.distinct] boolean Appliy COUNT(DISTINCT(col))","title":"count([options]) -&gt; Promise&lt;Integer&gt;"},{"location":"api/model/#findandcountallfindoptions-queryoptions-promiseobject","text":"View code Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very usefull for paging Model.findAndCountAll({ where: ..., limit: 12, offset: 12 }).success(function (result) { }) In the above example, result.rows will contain rows 13 through 24, while result.count will return the total number of rows that matched your query. See: Model#findAll Params: Name Type Description [findOptions] Object See findAll [queryOptions] Object See Sequelize.query","title":"findAndCountAll([findOptions], [queryOptions]) -&gt; Promise&lt;Object&gt;"},{"location":"api/model/#maxfield-options-promiseany","text":"View code Find the maximum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"max(field, [options]) -&gt; Promise&lt;Any&gt;"},{"location":"api/model/#minfield-options-promiseany","text":"View code Find the minimum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"min(field, [options]) -&gt; Promise&lt;Any&gt;"},{"location":"api/model/#sumfield-options-promisenumber","text":"View code Find the sum of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"sum(field, [options]) -&gt; Promise&lt;Number&gt;"},{"location":"api/model/#buildvalues-options-instance","text":"View code Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty. Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.isDirty=true] Boolean [options.include] Array an array of include options - Used to build prefetched/included model instances. See set","title":"build(values, [options]) -&gt; Instance"},{"location":"api/model/#createvalues-options-promiseinstance","text":"View code Builds a new model instance and calls save on it. See: Instance#build Instance#save Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.isDirty=true] Boolean [options.fields] Array If set, only columns matching those in fields will be saved [options.include] Array an array of include options - Used to build prefetched/included model instances [options.transaction] Transaction","title":"create(values, [options]) -&gt; Promise&lt;Instance&gt;"},{"location":"api/model/#options-promiseinstance","text":"View code Find a row that matches the query, or build (but don't save) the row if none is found. The successfull result of the promise will be (instance, initialized) - Make sure to use .spread() Params: Name Type Description options Object options.where Object A hash of search attributes. [options.defaults] Object Default values to use if building a new instance [options.transaction] Object Transaction to run query under Aliases: findOrBuild","title":"(options) -&gt; Promise&lt;Instance&gt;"},{"location":"api/model/#findorcreateoptions-queryoptions-promiseinstancecreated","text":"View code Find a row that matches the query, or build and save the row if none is found The successfull result of the promise will be (instance, created) - Make sure to use .spread() If no transaction is passed in the queryOptions object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has comitted. In this case, an instance of sequelize.TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally. Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance [queryOptions] Object Options passed to the find and create calls","title":"findOrCreate(options, [queryOptions]) -&gt; Promise&lt;Instance|created&gt;"},{"location":"api/model/#bulkcreaterecords-options-promisearrayinstance","text":"View code Create and insert multiple instances in bulk. The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again. Params: Name Type Description records Array List of objects (key/value pairs) to create instances from [options] Object [options.fields] Array Fields to insert (defaults to all fields) [options.validate=false] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk create hooks? [options.individualHooks=false] Boolean Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true. [options.ignoreDuplicates=false] Boolean Ignore duplicate values for primary keys? (not supported by postgres)","title":"bulkCreate(records, [options]) -&gt; Promise&lt;Array&lt;Instance&gt;&gt;"},{"location":"api/model/#destroy-promiseundefined","text":"View code Delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled. Params: Name Type Description [options.where] Object Filter the destroy [options.hooks=true] Boolean Run before / after bulk destroy hooks? [options.individualHooks=false] Boolean If set to true, destroy will find all records within the where parameter and will execute before / after bulkDestroy hooks on each row [options.limit] Number How many rows to delete [options.force=false] Boolean Delete instead of setting deletedAt to current timestamp (only applicable if paranoid is enabled) [options.truncate=false] Boolean If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored [options.cascade=false] Boolean Only used in conjuction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.","title":"destroy() -&gt; Promise&lt;undefined&gt;"},{"location":"api/model/#restore-promiseundefined","text":"View code Restore multiple instances if paranoid is enabled. Params: Name Type Description [options.where] Object Filter the restore [options.hooks=true] Boolean Run before / after bulk restore hooks? [options.individualHooks=false] Boolean If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row [options.limit] Number How many rows to undelete","title":"restore() -&gt; Promise&lt;undefined&gt;"},{"location":"api/model/#updatevalues-options-promisearrayaffectedcountaffectedrows","text":"View code Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with options.returning true.) Params: Name Type Description values Object options Object options.where Object Options to describe the scope of the search. [options.validate=true] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk update hooks? [options.individualHooks=false] Boolean Run before / after update hooks? [options.returning=false] Boolean Return the affected rows (only for postgres) [options.limit] Number How many rows to update (only for mysql and mariadb)","title":"update(values, options) -&gt; Promise&lt;Array&lt;affectedCount|affectedRows&gt;&gt;"},{"location":"api/model/#describe-promise","text":"View code Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types.","title":"describe() -&gt; Promise"},{"location":"api/model/#dataset-node-sql","text":"View code A proxy to the node-sql query builder, which allows you to build your query through a chain of method calls. The returned instance already has all the fields property populated with the field of the model. See: Returns: A node-sql instance This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"dataset() -&gt; node-sql"},{"location":"api/promise/","text":"Class Promise View code A slightly modified version of bluebird promises. This means that, on top of the methods below, you can also call all the methods listed on the link below. The main difference is that sequelize promises allows you to attach a listener that will be called with the generated SQL, each time a query is run. The sequelize promise class works seamlessly with other A+/thenable libraries, with one exception. If you want to propagate SQL events across then , all calls etc., you must use sequelize promises exclusively. Mixes: https://github.com/petkaantonov/bluebird/blob/master/API.md on(evt, fct) View code Listen for events, event emitter style. Mostly for backwards compat. with EventEmitter Deprecated Params: Name Type Description evt String fct Function emit(type, value(s)*) View code Emit an event from the emitter Deprecated Params: Name Type Description type string The type of event value(s)* any All other arguments will be passed to the event listeners success(onSuccess) -> this View code Listen for success events. promise.success(function (result) { //... }); Deprecated Params: Name Type Description onSuccess function Aliases: ok error(onError) -> this View code Listen for error events promise.error(function (err) { //... }); Deprecated Params: Name Type Description onError function Aliases: fail, failure done(onDone) -> this View code Listen for both success and error events. promise.done(function (err, result) { //... }); Deprecated done(fct) is deprecated, done() is regular promise syntax to explicitly signal the end of a promise chain and will not be deprecated Params: Name Type Description onDone function Aliases: complete sql(onSQL) -> this View code Attach a function that is called every time the function that created this emitter executes a query. Params: Name Type Description onSQL function proxy(promise, [options]) -> this View code Proxy every event of this promise to another one. Deprecated Params: Name Type Description promise SequelizePromise The promise that should receive the events. [options] Object [options.events] Array An array of the events to proxy. Defaults to sql, error and success This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Promise"},{"location":"api/promise/#class-promise","text":"View code A slightly modified version of bluebird promises. This means that, on top of the methods below, you can also call all the methods listed on the link below. The main difference is that sequelize promises allows you to attach a listener that will be called with the generated SQL, each time a query is run. The sequelize promise class works seamlessly with other A+/thenable libraries, with one exception. If you want to propagate SQL events across then , all calls etc., you must use sequelize promises exclusively.","title":"Class Promise"},{"location":"api/promise/#mixes","text":"https://github.com/petkaantonov/bluebird/blob/master/API.md","title":"Mixes:"},{"location":"api/promise/#onevt-fct","text":"View code Listen for events, event emitter style. Mostly for backwards compat. with EventEmitter Deprecated Params: Name Type Description evt String fct Function","title":"on(evt, fct)"},{"location":"api/promise/#emittype-values","text":"View code Emit an event from the emitter Deprecated Params: Name Type Description type string The type of event value(s)* any All other arguments will be passed to the event listeners","title":"emit(type, value(s)*)"},{"location":"api/promise/#successonsuccess-this","text":"View code Listen for success events. promise.success(function (result) { //... }); Deprecated Params: Name Type Description onSuccess function Aliases: ok","title":"success(onSuccess) -&gt; this"},{"location":"api/promise/#erroronerror-this","text":"View code Listen for error events promise.error(function (err) { //... }); Deprecated Params: Name Type Description onError function Aliases: fail, failure","title":"error(onError) -&gt; this"},{"location":"api/promise/#doneondone-this","text":"View code Listen for both success and error events. promise.done(function (err, result) { //... }); Deprecated done(fct) is deprecated, done() is regular promise syntax to explicitly signal the end of a promise chain and will not be deprecated Params: Name Type Description onDone function Aliases: complete","title":"done(onDone) -&gt; this"},{"location":"api/promise/#sqlonsql-this","text":"View code Attach a function that is called every time the function that created this emitter executes a query. Params: Name Type Description onSQL function","title":"sql(onSQL) -&gt; this"},{"location":"api/promise/#proxypromise-options-this","text":"View code Proxy every event of this promise to another one. Deprecated Params: Name Type Description promise SequelizePromise The promise that should receive the events. [options] Object [options.events] Array An array of the events to proxy. Defaults to sql, error and success This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"proxy(promise, [options]) -&gt; this"},{"location":"api/sequelize/","text":"Class Sequelize View code This is the main class, the entry point to sequelize. To use it, you just need to import sequelize: var Sequelize = require('sequelize'); In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that. new Sequelize(database, [username=null], [password=null], [options={}]) View code Instantiate sequelize with name of database, username and password Example usage // without password and options var sequelize = new Sequelize('database', 'username') // without options var sequelize = new Sequelize('database', 'username', 'password') // without password / with blank password var sequelize = new Sequelize('database', 'username', null, {}) // with password and options var sequelize = new Sequelize('my_database', 'john', 'doe', {}) // with uri (see below) var sequelize = new Sequelize('mysql://localhost:3306/database', {}) Params: Name Type Description database String The name of the database [username=null] String The username which is used to authenticate against the database. [password=null] String The password which is used to authenticate against the database. [options={}] Object An object with options. [options.dialect='mysql'] String The dialect you of the database you are connecting to. One of mysql, postgres, sqlite and mariadb [options.dialectModulePath=null] String If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here [options.dialectOptions] Object An object of additional options, which are passed directly to the connection library [options.storage] String Only used by sqlite. Defaults to ':memory:' [options.host='localhost'] String The host of the relational database. [options.port=] Integer The port of the relational database. [options.protocol='tcp'] String The protocol of the relational database. [options.define={}] Object Default options for model definitions. See sequelize.define for options [options.query={}] Object Default options for sequelize.query [options.set={}] Object Default options for sequelize.set [options.sync={}] Object Default options for sequelize.sync [options.timezone='+00:00'] String The timezone used when converting a date from the database into a javascript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. [options.logging=console.log] Function A function that gets executed everytime Sequelize would log something. [options.omitNull=false] Boolean A flag that defines if null values should be passed to SQL queries or not. [options.queue=true] Boolean Queue queries, so that only maxConcurrentQueries number of queries are executing at once. If false, all queries will be executed immediately. [options.maxConcurrentQueries=50] Integer The maximum number of queries that should be executed at once if queue is true. [options.native=false] Boolean A flag that defines if native library shall be used or not. Currently only has an effect for postgres [options.replication=false] Boolean Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: host , port , username , password , database [options.pool={}] Object Should sequelize use a connection pool. Default is true [options.pool.maxConnections] Integer [options.pool.minConnections] Integer [options.pool.maxIdleTime] Integer The maximum time, in milliseconds, that a connection can be idle before being released [options.pool.validateConnection] Function A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected [options.quoteIdentifiers=true] Boolean Set to false to make table names and attributes case-insensitive on Postgres and skip double quoting of them. new Sequelize(uri, [options={}]) View code Instantiate sequlize with an URI Params: Name Type Description uri String A full database URI [options={}] object See above for possible options models View code Models are stored here under the name given to sequelize.define Sequelize View code A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc. See: Sequelize Utils View code A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use Sequelize.Utils._ , which is a reference to the lodash library, if you don't already have it imported in your project. See: Utils Promise View code A modified version of bluebird promises, that allows listening for sql events See: Promise Validator View code Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor. See: Transaction View code A reference to the sequelize transaction class. Use this to access isolationLevels when creating a transaction See: Transaction Sequelize#transaction Instance View code A reference to the sequelize instance class. See: Instance Error View code A general error class See: Errors#BaseError ValidationError View code Emitted when a validation fails See: Errors#ValidationError ValidationErrorItem View code Describes a validation error on an instance path See: Errors#ValidationErrorItem DatabaseError View code A base class for all database related errors. See: Errors#DatabaseError TimeoutError View code Thrown when a database query times out because of a deadlock See: Errors#TimeoutError UniqueConstraintError View code Thrown when a unique constraint is violated in the database See: Errors#UniqueConstraintError ForeignKeyConstraintError View code Thrown when a foreign key constraint is violated in the database See: Errors#ForeignKeyConstraintError getDialect() -> String View code Returns the specified dialect. Returns: The specified dialect. getQueryInterface() -> QueryInterface View code Returns an instance of QueryInterface. See: QueryInterface Returns: An instance (singleton) of QueryInterface. getMigrator([options={}], [force=false]) -> Migrator View code Returns an instance (singleton) of Migrator. See: Migrator Params: Name Type Description [options={}] Object See Migrator for options [force=false] Boolean A flag that defines if the migrator should get instantiated or not. Returns: An instance of Migrator. define(modelName, attributes, [options]) -> Model View code Define a new model, representing a table in the DB. The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this: sequelize.define('modelName', { columnA: { type: Sequelize.BOOLEAN, validate: { is: [\"[a-z]\",'i'], // will only allow letters max: 23, // only allow values <= 23 isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } }, field: 'column_a' // Other attributes here }, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE' }) sequelize.models.modelName // The model will now be available in models under the name given to define As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters. For a list of possible data types, see http://sequelizejs.com/docs/latest/models#data-types For more about getters and setters, see http://sequelizejs.com/docs/latest/models#getters---setters For more about instance and class methods, see http://sequelizejs.com/docs/latest/models#expansion-of-models For more about validation, see http://sequelizejs.com/docs/latest/models#validations See: DataTypes Hooks Params: Name Type Description modelName String The name of the model. The model will be stored in sequelize.models under this name attributes Object An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below: attributes.column String | DataType Object attributes.column.type String | DataType A string or a data type [attributes.column.allowNull=true] Boolean If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved. [attributes.column.defaultValue=null] Any A literal default value, a javascript function, or an SQL function (see sequelize.fn ) [attributes.column.unique=false] String | Boolean If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index [attributes.column.primaryKey=false] Boolean [attributes.column.field=null] String If set, sequelize will map the attribute name to a different name in the database [attributes.column.autoIncrement=false] Boolean [attributes.column.comment=null] String [attributes.column.references] String | Model If this column references another table, provide it here as a Model, or a string [attributes.column.referencesKey='id'] String The column of the foreign table that this column references [attributes.column.onUpdate] String What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.onDelete] String What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.get] Function Provide a custom getter for this column. Use this.getDataValue(String) to manipulate the underlying values. [attributes.column.set] Function Provide a custom setter for this column. Use this.setDataValue(String, Value) to manipulate the underlying values. [attributes.validate] Object An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the DAOValidator property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text. [options] Object These options are merged with the default define options provided to the Sequelize constructor [options.defaultScope] Object Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll [options.scopes] Object More scopes, defined in the same way as defaultScope above. See Model.scope for more information about how scopes are defined, and what you can do with them [options.omitNull] Boolean Don't persits null values. This means that all columns with null values will not be saved [options.timestamps=true] Boolean Adds createdAt and updatedAt timestamps to the model. [options.paranoid=false] Boolean Calling destroy will not delete the model, but instead set a deletedAt timestamp if this is true. Needs timestamps=true to work [options.underscored=false] Boolean Converts all camelCased columns to underscored if true [options.underscoredAll=false] Boolean Converts camelCased model names to underscored tablenames if true [options.freezeTableName=false] Boolean If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the dao name will be pluralized [options.name] Object An object with two attributes, singular and plural , which are used when this model is associated to others. [options.name.singular=inflection.singularize(modelName)] String [options.name.plural=inflection.pluralize(modelName)] String [options.indexes] Array<Object> [options.indexes[].name] String The name of the index. Defaults to model name + _ + fields concatenated [options.indexes[].type] String Index type. Only used by mysql. One of UNIQUE , FULLTEXT and SPATIAL [options.indexes[].method] String The method to create the index by ( USING statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN. [options.indexes[].unique=false] Boolean Should the index by unique? Can also be triggered by setting type to UNIQUE [options.indexes[].concurrently=false] Boolean PostgreSQL will build the index without taking any write locks. Postgres only [options.indexes[].fields] Array<String | Object> An array of the fields to index. Each field can either be a string containing the name of the field, or an object with the following attributes: attribute (field name), length (create a prefix index of length chars), order (the direction the column should be sorted in), collate (the collation (sort order) for the column) [options.createdAt] String | Boolean Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true [options.updatedAt] String | Boolean Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true [options.deletedAt] String | Boolean Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true [options.tableName] String Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim [options.getterMethods] Object Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values [options.setterMethods] Object Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted [options.instanceMethods] Object Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using this.constructor.super_.prototype , e.g. this.constructor.super_.prototype.toJSON.apply(this, arguments) [options.classMethods] Object Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using this.constructor.prototype , e.g. this.constructor.prototype.find.apply(this, arguments) [options.schema='public'] String [options.engine] String [options.charset] String [options.comment] String [options.collate] String [options.hooks] Object An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions. [options.validate] Object An object of model wide validations. Validations have access to all model values via this . If the validator function takes an argument, it is asumed to be async, and is called with a callback that accepts an optional error. model(modelName) -> Model View code Fetch a DAO factory which is already defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define isDefined(modelName) -> Boolean View code Checks whether a model with the given name is defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define import(path) -> Model View code Imports a model defined in another file Imported models are cached, so multiple calls to import with the same path will not load the file multiple times See https://github.com/sequelize/sequelize/blob/master/examples/using-multiple-model-files/Task.js for a short example of how to define your models in separate files so that they can be imported by sequelize.import Params: Name Type Description path String The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file query(sql, [callee], [options={}], [replacements]) -> Promise View code Execute a query on the DB, with the posibility to bypass all the sequelize goodness. If you do not provide other arguments than the SQL, raw will be assumed to the true, and sequelize will not try to do any formatting to the results of the query. See: Model#build Params: Name Type Description sql String [callee] Instance If callee is provided, the returned data will be put into the callee [options={}] Object Query options. [options.raw] Boolean If true, sequelize will not try to format the results of the query, or build an instance of a model from the result [options.transaction=null] Transaction The transaction that the query should be executed under [options.type='SELECT'] String The type of query you are executing. The query type affects how results are formatted before they are passed back. If no type is provided sequelize will try to guess the right type based on the sql, and fall back to SELECT. The type is a string, but Sequelize.QueryTypes is provided is convenience shortcuts. Current options are SELECT, BULKUPDATE and BULKDELETE [options.nest=false] Boolean If true, transforms objects with . separated property names into nested objects using dottie.js . For example { 'user.username': 'john' } becomes { user: { username: 'john' }} [replacements] Object | Array Either an object of named parameter replacements in the format :param or an array of unnamed replacements to replace ? in your SQL. set(variables, options) -> Promise View code Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL. Params: Name Type Description variables Object Object with multiple variables. options Object Query options. options.transaction Transaction The transaction that the query should be executed under createSchema(schema) -> Promise View code Create a new database schema. Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this command will do nothing. See: Model#schema Params: Name Type Description schema String Name of the schema showAllSchemas() -> Promise View code Show all defined schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this will show all tables. dropSchema(schema) -> Promise View code Drop a single schema Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this drop a table matching the schema name Params: Name Type Description schema String Name of the schema dropAllSchemas() -> Promise View code Drop all schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this is the equivalent of drop all tables. sync([options={}]) -> Promise View code Sync all defined DAOs to the DB. Params: Name Type Description [options={}] Object [options.force=false] Boolean If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table [options.match] RegEx Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code [options.logging=console.log] Boolean | function A function that logs sql queries, or false for no logging [options.schema='public'] String The schema that the tables should be created in. This can be overriden for each table in sequelize.define drop(options) -> Promise View code Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model See: Model#drop Params: Name Type Description options object The options passed to each call to Model.drop authenticate() -> Promise View code Test the connection by trying to authenticate Aliases: validate fn (fn, args) -> Sequelize.fn View code Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use sequelize.col , so that the columns are properly interpreted as columns and not a strings. Convert a user's username to upper case instance.updateAttributes({ username: self.sequelize.fn('upper', self.sequelize.col('username')) }) See: Model#find Model#findAll Model#define Sequelize#col Params: Name Type Description fn String The function you want to call args any All further arguments will be passed as arguments to the function col(col) -> Sequelize.col View code Creates a object representing a column in the DB. This is often useful in conjunction with sequelize.fn , since raw string arguments to fn will be escaped. See: Sequelize#fn Params: Name Type Description col String The name of the column cast(val, type) -> Sequelize.cast View code Creates a object representing a call to the cast function. Params: Name Type Description val any The value to cast type String The type to cast it to literal(val) -> Sequelize.literal View code Creates a object representing a literal, i.e. something that will not be escaped. Params: Name Type Description val any Aliases: asIs and(args) -> Sequelize.and View code An AND query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by AND or(args) -> Sequelize.or View code An OR query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by OR json(conditions, [value]) -> Sequelize.json View code Creates an object representing nested where conditions for postgres's json data-type. See: Model#find Params: Name Type Description conditions String | Object A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax. [value] String | Number Boolean where(attr, [comparator='='], logic) -> Sequelize.where View code A way of specifying attr = condition. The attr can either be an object taken from Model.rawAttributes (for example Model.rawAttributes.id or Model.rawAttributes.name ). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions ( sequelize.fn , sequelize.col etc.) For string attributes, use the regular { where: { attr: something }} syntax. If you don't want your string to be escaped, use sequelize.literal . See: Model#find Params: Name Type Description attr Object The attribute, which can be either an attribute object from Model.rawAttributes or a sequelize object, for example an instance of sequelize.fn . For simple string attributes, use the POJO syntax [comparator='='] string logic String | Object The condition. Can be both a simply type, or a further condition ( .or , .and , .literal etc.) Aliases: condition transaction([options={}]) -> Promise View code Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction sequelize.transaction().then(function (t) { return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }) .then(t.commit.bind(t)) .catch(t.rollback.bind(t)); }) A syntax for automatically committing or rolling back based on the promise chain resolution is also supported: sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then() return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }); }).then(function () { // Commited }).catch(function (err) { // Rolled back console.error(err); }); See: Transaction Params: Name Type Description [options={}] Object [options.autocommit=true] Boolean [options.isolationLevel='REPEATABLE String READ'] See Sequelize.Transaction.ISOLATION_LEVELS for possible options This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Sequelize"},{"location":"api/sequelize/#class-sequelize","text":"View code This is the main class, the entry point to sequelize. To use it, you just need to import sequelize: var Sequelize = require('sequelize'); In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that.","title":"Class Sequelize"},{"location":"api/sequelize/#new-sequelizedatabase-usernamenull-passwordnull-options","text":"View code Instantiate sequelize with name of database, username and password","title":"new Sequelize(database, [username=null], [password=null], [options={}])"},{"location":"api/sequelize/#example-usage","text":"// without password and options var sequelize = new Sequelize('database', 'username') // without options var sequelize = new Sequelize('database', 'username', 'password') // without password / with blank password var sequelize = new Sequelize('database', 'username', null, {}) // with password and options var sequelize = new Sequelize('my_database', 'john', 'doe', {}) // with uri (see below) var sequelize = new Sequelize('mysql://localhost:3306/database', {}) Params: Name Type Description database String The name of the database [username=null] String The username which is used to authenticate against the database. [password=null] String The password which is used to authenticate against the database. [options={}] Object An object with options. [options.dialect='mysql'] String The dialect you of the database you are connecting to. One of mysql, postgres, sqlite and mariadb [options.dialectModulePath=null] String If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here [options.dialectOptions] Object An object of additional options, which are passed directly to the connection library [options.storage] String Only used by sqlite. Defaults to ':memory:' [options.host='localhost'] String The host of the relational database. [options.port=] Integer The port of the relational database. [options.protocol='tcp'] String The protocol of the relational database. [options.define={}] Object Default options for model definitions. See sequelize.define for options [options.query={}] Object Default options for sequelize.query [options.set={}] Object Default options for sequelize.set [options.sync={}] Object Default options for sequelize.sync [options.timezone='+00:00'] String The timezone used when converting a date from the database into a javascript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. [options.logging=console.log] Function A function that gets executed everytime Sequelize would log something. [options.omitNull=false] Boolean A flag that defines if null values should be passed to SQL queries or not. [options.queue=true] Boolean Queue queries, so that only maxConcurrentQueries number of queries are executing at once. If false, all queries will be executed immediately. [options.maxConcurrentQueries=50] Integer The maximum number of queries that should be executed at once if queue is true. [options.native=false] Boolean A flag that defines if native library shall be used or not. Currently only has an effect for postgres [options.replication=false] Boolean Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: host , port , username , password , database [options.pool={}] Object Should sequelize use a connection pool. Default is true [options.pool.maxConnections] Integer [options.pool.minConnections] Integer [options.pool.maxIdleTime] Integer The maximum time, in milliseconds, that a connection can be idle before being released [options.pool.validateConnection] Function A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected [options.quoteIdentifiers=true] Boolean Set to false to make table names and attributes case-insensitive on Postgres and skip double quoting of them.","title":"Example usage"},{"location":"api/sequelize/#new-sequelizeuri-options","text":"View code Instantiate sequlize with an URI Params: Name Type Description uri String A full database URI [options={}] object See above for possible options","title":"new Sequelize(uri, [options={}])"},{"location":"api/sequelize/#models","text":"View code Models are stored here under the name given to sequelize.define","title":"models"},{"location":"api/sequelize/#sequelize","text":"View code A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc. See: Sequelize","title":"Sequelize"},{"location":"api/sequelize/#utils","text":"View code A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use Sequelize.Utils._ , which is a reference to the lodash library, if you don't already have it imported in your project. See: Utils","title":"Utils"},{"location":"api/sequelize/#promise","text":"View code A modified version of bluebird promises, that allows listening for sql events See: Promise","title":"Promise"},{"location":"api/sequelize/#validator","text":"View code Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor. See:","title":"Validator"},{"location":"api/sequelize/#transaction","text":"View code A reference to the sequelize transaction class. Use this to access isolationLevels when creating a transaction See: Transaction Sequelize#transaction","title":"Transaction"},{"location":"api/sequelize/#instance","text":"View code A reference to the sequelize instance class. See: Instance","title":"Instance"},{"location":"api/sequelize/#error","text":"View code A general error class See: Errors#BaseError","title":"Error"},{"location":"api/sequelize/#validationerror","text":"View code Emitted when a validation fails See: Errors#ValidationError","title":"ValidationError"},{"location":"api/sequelize/#validationerroritem","text":"View code Describes a validation error on an instance path See: Errors#ValidationErrorItem","title":"ValidationErrorItem"},{"location":"api/sequelize/#databaseerror","text":"View code A base class for all database related errors. See: Errors#DatabaseError","title":"DatabaseError"},{"location":"api/sequelize/#timeouterror","text":"View code Thrown when a database query times out because of a deadlock See: Errors#TimeoutError","title":"TimeoutError"},{"location":"api/sequelize/#uniqueconstrainterror","text":"View code Thrown when a unique constraint is violated in the database See: Errors#UniqueConstraintError","title":"UniqueConstraintError"},{"location":"api/sequelize/#foreignkeyconstrainterror","text":"View code Thrown when a foreign key constraint is violated in the database See: Errors#ForeignKeyConstraintError","title":"ForeignKeyConstraintError"},{"location":"api/sequelize/#getdialect-string","text":"View code Returns the specified dialect. Returns: The specified dialect.","title":"getDialect() -&gt; String"},{"location":"api/sequelize/#getqueryinterface-queryinterface","text":"View code Returns an instance of QueryInterface. See: QueryInterface Returns: An instance (singleton) of QueryInterface.","title":"getQueryInterface() -&gt; QueryInterface"},{"location":"api/sequelize/#getmigratoroptions-forcefalse-migrator","text":"View code Returns an instance (singleton) of Migrator. See: Migrator Params: Name Type Description [options={}] Object See Migrator for options [force=false] Boolean A flag that defines if the migrator should get instantiated or not. Returns: An instance of Migrator.","title":"getMigrator([options={}], [force=false]) -&gt; Migrator"},{"location":"api/sequelize/#definemodelname-attributes-options-model","text":"View code Define a new model, representing a table in the DB. The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this: sequelize.define('modelName', { columnA: { type: Sequelize.BOOLEAN, validate: { is: [\"[a-z]\",'i'], // will only allow letters max: 23, // only allow values <= 23 isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } }, field: 'column_a' // Other attributes here }, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE' }) sequelize.models.modelName // The model will now be available in models under the name given to define As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters. For a list of possible data types, see http://sequelizejs.com/docs/latest/models#data-types For more about getters and setters, see http://sequelizejs.com/docs/latest/models#getters---setters For more about instance and class methods, see http://sequelizejs.com/docs/latest/models#expansion-of-models For more about validation, see http://sequelizejs.com/docs/latest/models#validations See: DataTypes Hooks Params: Name Type Description modelName String The name of the model. The model will be stored in sequelize.models under this name attributes Object An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below: attributes.column String | DataType Object attributes.column.type String | DataType A string or a data type [attributes.column.allowNull=true] Boolean If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved. [attributes.column.defaultValue=null] Any A literal default value, a javascript function, or an SQL function (see sequelize.fn ) [attributes.column.unique=false] String | Boolean If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index [attributes.column.primaryKey=false] Boolean [attributes.column.field=null] String If set, sequelize will map the attribute name to a different name in the database [attributes.column.autoIncrement=false] Boolean [attributes.column.comment=null] String [attributes.column.references] String | Model If this column references another table, provide it here as a Model, or a string [attributes.column.referencesKey='id'] String The column of the foreign table that this column references [attributes.column.onUpdate] String What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.onDelete] String What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.get] Function Provide a custom getter for this column. Use this.getDataValue(String) to manipulate the underlying values. [attributes.column.set] Function Provide a custom setter for this column. Use this.setDataValue(String, Value) to manipulate the underlying values. [attributes.validate] Object An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the DAOValidator property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text. [options] Object These options are merged with the default define options provided to the Sequelize constructor [options.defaultScope] Object Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll [options.scopes] Object More scopes, defined in the same way as defaultScope above. See Model.scope for more information about how scopes are defined, and what you can do with them [options.omitNull] Boolean Don't persits null values. This means that all columns with null values will not be saved [options.timestamps=true] Boolean Adds createdAt and updatedAt timestamps to the model. [options.paranoid=false] Boolean Calling destroy will not delete the model, but instead set a deletedAt timestamp if this is true. Needs timestamps=true to work [options.underscored=false] Boolean Converts all camelCased columns to underscored if true [options.underscoredAll=false] Boolean Converts camelCased model names to underscored tablenames if true [options.freezeTableName=false] Boolean If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the dao name will be pluralized [options.name] Object An object with two attributes, singular and plural , which are used when this model is associated to others. [options.name.singular=inflection.singularize(modelName)] String [options.name.plural=inflection.pluralize(modelName)] String [options.indexes] Array<Object> [options.indexes[].name] String The name of the index. Defaults to model name + _ + fields concatenated [options.indexes[].type] String Index type. Only used by mysql. One of UNIQUE , FULLTEXT and SPATIAL [options.indexes[].method] String The method to create the index by ( USING statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN. [options.indexes[].unique=false] Boolean Should the index by unique? Can also be triggered by setting type to UNIQUE [options.indexes[].concurrently=false] Boolean PostgreSQL will build the index without taking any write locks. Postgres only [options.indexes[].fields] Array<String | Object> An array of the fields to index. Each field can either be a string containing the name of the field, or an object with the following attributes: attribute (field name), length (create a prefix index of length chars), order (the direction the column should be sorted in), collate (the collation (sort order) for the column) [options.createdAt] String | Boolean Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true [options.updatedAt] String | Boolean Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true [options.deletedAt] String | Boolean Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true [options.tableName] String Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim [options.getterMethods] Object Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values [options.setterMethods] Object Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted [options.instanceMethods] Object Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using this.constructor.super_.prototype , e.g. this.constructor.super_.prototype.toJSON.apply(this, arguments) [options.classMethods] Object Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using this.constructor.prototype , e.g. this.constructor.prototype.find.apply(this, arguments) [options.schema='public'] String [options.engine] String [options.charset] String [options.comment] String [options.collate] String [options.hooks] Object An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions. [options.validate] Object An object of model wide validations. Validations have access to all model values via this . If the validator function takes an argument, it is asumed to be async, and is called with a callback that accepts an optional error.","title":"define(modelName, attributes, [options]) -&gt; Model"},{"location":"api/sequelize/#modelmodelname-model","text":"View code Fetch a DAO factory which is already defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define","title":"model(modelName) -&gt; Model"},{"location":"api/sequelize/#isdefinedmodelname-boolean","text":"View code Checks whether a model with the given name is defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define","title":"isDefined(modelName) -&gt; Boolean"},{"location":"api/sequelize/#importpath-model","text":"View code Imports a model defined in another file Imported models are cached, so multiple calls to import with the same path will not load the file multiple times See https://github.com/sequelize/sequelize/blob/master/examples/using-multiple-model-files/Task.js for a short example of how to define your models in separate files so that they can be imported by sequelize.import Params: Name Type Description path String The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file","title":"import(path) -&gt; Model"},{"location":"api/sequelize/#querysql-callee-options-replacements-promise","text":"View code Execute a query on the DB, with the posibility to bypass all the sequelize goodness. If you do not provide other arguments than the SQL, raw will be assumed to the true, and sequelize will not try to do any formatting to the results of the query. See: Model#build Params: Name Type Description sql String [callee] Instance If callee is provided, the returned data will be put into the callee [options={}] Object Query options. [options.raw] Boolean If true, sequelize will not try to format the results of the query, or build an instance of a model from the result [options.transaction=null] Transaction The transaction that the query should be executed under [options.type='SELECT'] String The type of query you are executing. The query type affects how results are formatted before they are passed back. If no type is provided sequelize will try to guess the right type based on the sql, and fall back to SELECT. The type is a string, but Sequelize.QueryTypes is provided is convenience shortcuts. Current options are SELECT, BULKUPDATE and BULKDELETE [options.nest=false] Boolean If true, transforms objects with . separated property names into nested objects using dottie.js . For example { 'user.username': 'john' } becomes { user: { username: 'john' }} [replacements] Object | Array Either an object of named parameter replacements in the format :param or an array of unnamed replacements to replace ? in your SQL.","title":"query(sql, [callee], [options={}], [replacements]) -&gt; Promise"},{"location":"api/sequelize/#setvariables-options-promise","text":"View code Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL. Params: Name Type Description variables Object Object with multiple variables. options Object Query options. options.transaction Transaction The transaction that the query should be executed under","title":"set(variables, options) -&gt; Promise"},{"location":"api/sequelize/#createschemaschema-promise","text":"View code Create a new database schema. Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this command will do nothing. See: Model#schema Params: Name Type Description schema String Name of the schema","title":"createSchema(schema) -&gt; Promise"},{"location":"api/sequelize/#showallschemas-promise","text":"View code Show all defined schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this will show all tables.","title":"showAllSchemas() -&gt; Promise"},{"location":"api/sequelize/#dropschemaschema-promise","text":"View code Drop a single schema Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this drop a table matching the schema name Params: Name Type Description schema String Name of the schema","title":"dropSchema(schema) -&gt; Promise"},{"location":"api/sequelize/#dropallschemas-promise","text":"View code Drop all schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this is the equivalent of drop all tables.","title":"dropAllSchemas() -&gt; Promise"},{"location":"api/sequelize/#syncoptions-promise","text":"View code Sync all defined DAOs to the DB. Params: Name Type Description [options={}] Object [options.force=false] Boolean If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table [options.match] RegEx Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code [options.logging=console.log] Boolean | function A function that logs sql queries, or false for no logging [options.schema='public'] String The schema that the tables should be created in. This can be overriden for each table in sequelize.define","title":"sync([options={}]) -&gt; Promise"},{"location":"api/sequelize/#dropoptions-promise","text":"View code Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model See: Model#drop Params: Name Type Description options object The options passed to each call to Model.drop","title":"drop(options) -&gt; Promise"},{"location":"api/sequelize/#authenticate-promise","text":"View code Test the connection by trying to authenticate Aliases: validate","title":"authenticate() -&gt; Promise"},{"location":"api/sequelize/#fn-fn-args-sequelizefn","text":"View code Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use sequelize.col , so that the columns are properly interpreted as columns and not a strings. Convert a user's username to upper case instance.updateAttributes({ username: self.sequelize.fn('upper', self.sequelize.col('username')) }) See: Model#find Model#findAll Model#define Sequelize#col Params: Name Type Description fn String The function you want to call args any All further arguments will be passed as arguments to the function","title":"fn (fn, args) -&gt; Sequelize.fn"},{"location":"api/sequelize/#colcol-sequelizecol","text":"View code Creates a object representing a column in the DB. This is often useful in conjunction with sequelize.fn , since raw string arguments to fn will be escaped. See: Sequelize#fn Params: Name Type Description col String The name of the column","title":"col(col) -&gt; Sequelize.col"},{"location":"api/sequelize/#castval-type-sequelizecast","text":"View code Creates a object representing a call to the cast function. Params: Name Type Description val any The value to cast type String The type to cast it to","title":"cast(val, type) -&gt; Sequelize.cast"},{"location":"api/sequelize/#literalval-sequelizeliteral","text":"View code Creates a object representing a literal, i.e. something that will not be escaped. Params: Name Type Description val any Aliases: asIs","title":"literal(val) -&gt; Sequelize.literal"},{"location":"api/sequelize/#andargs-sequelizeand","text":"View code An AND query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by AND","title":"and(args) -&gt; Sequelize.and"},{"location":"api/sequelize/#orargs-sequelizeor","text":"View code An OR query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by OR","title":"or(args) -&gt; Sequelize.or"},{"location":"api/sequelize/#jsonconditions-value-sequelizejson","text":"View code Creates an object representing nested where conditions for postgres's json data-type. See: Model#find Params: Name Type Description conditions String | Object A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax. [value] String | Number Boolean","title":"json(conditions, [value]) -&gt; Sequelize.json"},{"location":"api/sequelize/#whereattr-comparator-logic-sequelizewhere","text":"View code A way of specifying attr = condition. The attr can either be an object taken from Model.rawAttributes (for example Model.rawAttributes.id or Model.rawAttributes.name ). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions ( sequelize.fn , sequelize.col etc.) For string attributes, use the regular { where: { attr: something }} syntax. If you don't want your string to be escaped, use sequelize.literal . See: Model#find Params: Name Type Description attr Object The attribute, which can be either an attribute object from Model.rawAttributes or a sequelize object, for example an instance of sequelize.fn . For simple string attributes, use the POJO syntax [comparator='='] string logic String | Object The condition. Can be both a simply type, or a further condition ( .or , .and , .literal etc.) Aliases: condition","title":"where(attr, [comparator='='], logic) -&gt; Sequelize.where"},{"location":"api/sequelize/#transactionoptions-promise","text":"View code Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction sequelize.transaction().then(function (t) { return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }) .then(t.commit.bind(t)) .catch(t.rollback.bind(t)); }) A syntax for automatically committing or rolling back based on the promise chain resolution is also supported: sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then() return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }); }).then(function () { // Commited }).catch(function (err) { // Rolled back console.error(err); }); See: Transaction Params: Name Type Description [options={}] Object [options.autocommit=true] Boolean [options.isolationLevel='REPEATABLE String READ'] See Sequelize.Transaction.ISOLATION_LEVELS for possible options This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"transaction([options={}]) -&gt; Promise"},{"location":"api/transaction/","text":"Class Transaction View code The transaction object is used to identify a running transaction. It is created by calling Sequelize.transaction() . To run a query under a transaction, you should pass the transaction in the options object. ISOLATION_LEVELS View code The possible isolations levels to use when starting a transaction { READ_UNCOMMITTED: \"READ UNCOMMITTED\", READ_COMMITTED: \"READ COMMITTED\", REPEATABLE_READ: \"REPEATABLE READ\", SERIALIZABLE: \"SERIALIZABLE\" } LOCK View code Possible options for row locking. Used in conjuction with find calls: t1 // is a transaction Model.findAll({ where: ... }, { transaction: t1, lock: t1.LOCK.UPDATE, lock: t1.LOCK.SHARE }) commit() -> this View code Commit the transaction rollback() -> this View code Rollback (abort) the transaction This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Transaction"},{"location":"api/transaction/#class-transaction","text":"View code The transaction object is used to identify a running transaction. It is created by calling Sequelize.transaction() . To run a query under a transaction, you should pass the transaction in the options object.","title":"Class Transaction"},{"location":"api/transaction/#isolation_levels","text":"View code The possible isolations levels to use when starting a transaction { READ_UNCOMMITTED: \"READ UNCOMMITTED\", READ_COMMITTED: \"READ COMMITTED\", REPEATABLE_READ: \"REPEATABLE READ\", SERIALIZABLE: \"SERIALIZABLE\" }","title":"ISOLATION_LEVELS"},{"location":"api/transaction/#lock","text":"View code Possible options for row locking. Used in conjuction with find calls: t1 // is a transaction Model.findAll({ where: ... }, { transaction: t1, lock: t1.LOCK.UPDATE, lock: t1.LOCK.SHARE })","title":"LOCK"},{"location":"api/transaction/#commit-this","text":"View code Commit the transaction","title":"commit() -&gt; this"},{"location":"api/transaction/#rollback-this","text":"View code Rollback (abort) the transaction This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"rollback() -&gt; this"},{"location":"articles/express/","text":"fromGithub = function (partialId, ext) { ext = ext || ''; var $partial = $(\"#\" + partialId) $.get(\"https://cdn.rawgit.com/sequelize/express-example/master/\" + partialId.replace(\"_\", \"/\") + ext, function (code) { if (ext === '.js') { code = hljs.highlight('js', code).value; } code = '<div class=\"highlight\"><pre>' + code + '</pre></div>'; $partial.replaceWith(code); }, 'html'); } Introduction This article explains the usage of Sequelize with the MVC framework Express.You will learn how and where to define models and how to load them when needed. A minimal express application In order to create a minimal express application, we need to install express first and scaffold a project. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express express-generator $ node_modules/.bin/express . -f $ npm install $ ./bin/www You should now be able to see a tiny welcome page on http://localhost:3000 Adding Sequelize to the application Now that we have the express application in place, we can start adding Sequelize to it. What we need for that are the following packages: sequelize, sequelize-cli, sqlite3. Please note, that for the sake of simplicity this tutorial will use SQLite. $ npm install --save sequelize@2.0.0-rc1 sequelize-cli sqlite3 This will install the respective packages and uses the upcoming major release of sequelize. We can now let the sequelize CLI initialize the project's directory: $ node_modules/.bin/sequelize init Running this command will create the folders config , migrations and models . Implementing a todo app As an example application we will create a very basic and simple todo tool, which allows the creation of users and the management of their tasks. bin/www In order to create a maintainable application, we will put all the database logic into the models folder. When the application gets fired up, sequelize will sync the models with the database and afterwards start the server. This way we don't clutter the application while making use of sequelize's features. $(function () { fromGithub(\"bin_www\") }) models/index.js This file has been generated with the sequelize CLI and collects all the models from the models directory and associates them if needed. $(function () { fromGithub(\"models_index\", '.js') }) models/user.js All models of our application are located as separate files in the models folder. If you want to add a new model, just add it to this folder and everything will work automagically. Also you can use the sequelize CLI's sequelize model:create . Notice that the associate method receives a parameter models , which contains every declared model within the models directory. $(function () { fromGithub(\"models_user\", '.js') }) models/task.js The other needed model is Task . It relates to the User . $(function () { fromGithub(\"models_task\", '.js') }) routes/index.js The file routes/index.js contains the logic for a request against the main homepage. It loads the models module and uses it to load all the users and tasks from the database. $(function () { fromGithub(\"routes_index\", '.js') }) This will allow us to iterate over the users in the view file. We will skip the rest of the route files for this article. views/index.jade As we passed the users to the view and include the tasks for each user, we can access the data in the view's template file. Besides listing the users and tasks, there are also forms for creating new instances. $(function () { fromGithub(\"views_index\", '.jade') }) What's next? This article shows a basic approach of how to integrate Sequelize into an ExpressJS application. It allows the very easy management of models by adding new files to a specific folder. Starting the application will automatically sync the schema with the database. If you don't want to have automatic schema synchronization and instead want migrations, just add a respective step to your deployment script. When you use the CLI for the model generation, you will gain the migration scripts for free as well. You can find the complete application code on Github . Feel free to add pull requests to it. Besides the use of Sequelize as model backend in your ExpressJS application, you might also want to turn your server into a restful API. If that is the case, check out the repository on Github","title":"Usage with Express.JS"},{"location":"articles/express/#introduction","text":"This article explains the usage of Sequelize with the MVC framework Express.You will learn how and where to define models and how to load them when needed.","title":"Introduction"},{"location":"articles/express/#a-minimal-express-application","text":"In order to create a minimal express application, we need to install express first and scaffold a project. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express express-generator $ node_modules/.bin/express . -f $ npm install $ ./bin/www You should now be able to see a tiny welcome page on http://localhost:3000","title":"A minimal express application"},{"location":"articles/express/#adding-sequelize-to-the-application","text":"Now that we have the express application in place, we can start adding Sequelize to it. What we need for that are the following packages: sequelize, sequelize-cli, sqlite3. Please note, that for the sake of simplicity this tutorial will use SQLite. $ npm install --save sequelize@2.0.0-rc1 sequelize-cli sqlite3 This will install the respective packages and uses the upcoming major release of sequelize. We can now let the sequelize CLI initialize the project's directory: $ node_modules/.bin/sequelize init Running this command will create the folders config , migrations and models .","title":"Adding Sequelize to the application"},{"location":"articles/express/#implementing-a-todo-app","text":"As an example application we will create a very basic and simple todo tool, which allows the creation of users and the management of their tasks.","title":"Implementing a todo app"},{"location":"articles/express/#binwww","text":"In order to create a maintainable application, we will put all the database logic into the models folder. When the application gets fired up, sequelize will sync the models with the database and afterwards start the server. This way we don't clutter the application while making use of sequelize's features. $(function () { fromGithub(\"bin_www\") })","title":"bin/www"},{"location":"articles/express/#modelsindexjs","text":"This file has been generated with the sequelize CLI and collects all the models from the models directory and associates them if needed. $(function () { fromGithub(\"models_index\", '.js') })","title":"models/index.js"},{"location":"articles/express/#modelsuserjs","text":"All models of our application are located as separate files in the models folder. If you want to add a new model, just add it to this folder and everything will work automagically. Also you can use the sequelize CLI's sequelize model:create . Notice that the associate method receives a parameter models , which contains every declared model within the models directory. $(function () { fromGithub(\"models_user\", '.js') })","title":"models/user.js"},{"location":"articles/express/#modelstaskjs","text":"The other needed model is Task . It relates to the User . $(function () { fromGithub(\"models_task\", '.js') })","title":"models/task.js"},{"location":"articles/express/#routesindexjs","text":"The file routes/index.js contains the logic for a request against the main homepage. It loads the models module and uses it to load all the users and tasks from the database. $(function () { fromGithub(\"routes_index\", '.js') }) This will allow us to iterate over the users in the view file. We will skip the rest of the route files for this article.","title":"routes/index.js"},{"location":"articles/express/#viewsindexjade","text":"As we passed the users to the view and include the tasks for each user, we can access the data in the view's template file. Besides listing the users and tasks, there are also forms for creating new instances. $(function () { fromGithub(\"views_index\", '.jade') })","title":"views/index.jade"},{"location":"articles/express/#whats-next","text":"This article shows a basic approach of how to integrate Sequelize into an ExpressJS application. It allows the very easy management of models by adding new files to a specific folder. Starting the application will automatically sync the schema with the database. If you don't want to have automatic schema synchronization and instead want migrations, just add a respective step to your deployment script. When you use the CLI for the model generation, you will gain the migration scripts for free as well. You can find the complete application code on Github . Feel free to add pull requests to it. Besides the use of Sequelize as model backend in your ExpressJS application, you might also want to turn your server into a restful API. If that is the case, check out the repository on Github","title":"What's next?"},{"location":"articles/getting-started/","text":"Introduction This article explains the basic concepts of Sequelize. You will learn how to use the supported dialects, which ways of database setup approaches are available and how common scenarios can be achieved. Premise We will skip the very basic things and directly dive into the Sequelize related stuff. Here is a list of things that have to be in place before you can start: Node.JS at v0.8 or higher One of the supported databases / SQLite bindings The credentials for the respective database A basic understanding of how databases are working Optional but recommended: Coffee :) A word about promises TODO - a link to bluebird + general promise syntax + catch / error handling Setting up a project Now that your computer is prepared and your coffee sits next to your keyboard, we can finally get started. First things first: Create a directory and initializeit with NPM! $ mkdir my-project $ cd my-project $ npm init NPM will ask you a couple of questions. Answer them or just hit the return key until it's satisfied. Once done, you can install Sequelize and the connector for your database of choice. $ npm install --save sequelize $ npm install --save pg # for postgres $ npm install --save mysql # for mysql $ npm install --save sqlite3 # for sqlite $ npm install --save mariasql # for mariasql Connecting to the database Open the created directory in your favorite text editor and add a new file called app.js with the following content. var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password', { dialect: \"mysql\", // or 'sqlite', 'postgres', 'mariadb' port: 3306, // or 5432 (for postgres) }); sequelize .authenticate() .then(function(err) { console.log('Connection has been established successfully.'); }, function (err) { console.log('Unable to connect to the database:', err); }); Managing the schema of your database Sequelize supports two way of schema management. You can either define so called migrations, which are programmatically changing your database's structure. Or you can let Sequelize create the tables for you. While the first possibility of using migrations takes more time to setup, it's most likely the way to go, if you want to deploy your application on many different server environments. The reason for that is based on the fact, that migrations are consistently changing your database according to the current state of the schema. However, the automated way of using Sequelize's function sequelize.sync will probably be a good choice on your local machine or if you just want to quickly spin up a prototype. As this article is for beginners, we will skip migrations for now and take a closer look at the automated way. Defining a model In order to let Sequelize create a schemas in the database, you need to describe, what kind of data you want to store. This can be done with sequelize.define : var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }); This will define a user model that has a username and password. Furthermore, Sequelize will automatically add the columns id , createdAt and updatedAt . createdAt and updatedAt are controlled by sequelize - when you create a model through sequelize createdAt will be set, and whenever you call updateAttributes / save on a model, updatedAt will be set. Synchronizing the schema As we want to store data in the database, we need to create a representation of the model. sequelize .sync({ force: true }) .then(function(err) { console.log('It worked!'); }, function (err) { console.log('An error occurred while creating the table:', err); }); Once executed, the database will contain a table Users (note the plural) with the columns: id - INT(11) username - VARCHAR(255) password - VARCHAR(255) createdAt - DATETIME updatedAt - DATETIME Please note, that { force: true } will drop the Users table and re-create it. Configuration You might not need the timestamps or you might not want the plural of the model's name as table name, right? Luckily there are configuration possibilities for that. var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { tableName: 'my_user_table', // this will define the table's name timestamps: false // this will deactivate the timestamp columns }) And just in case you want to customize the timestamp field names, you can do it like this: var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { updatedAt: 'last_update', createdAt: 'date_of_creation' }) Furthermore you can introduce a deletedAt timestamp so models are not actually deleted when you call destroy . Adding a deletedAt timestamp is called making the model 'paranoid': var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { paranoid: true }); Creating and persisting instances Sequelize allows the creation of instances in two ways. You can either build an object and save it afterwards. Or you can directly create an instance in the database: var user = User.build({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }) user.save().then(function() { /* ... */ }) This persists the instance in a two step way. If you want to do everything at once, use the following approach: User.create({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }).then(function(user) { /* ... */ }) Reading data from the database Every defined model has finder methods, with which you can read the database. Searching for a single item can be done with Model.find . Retrieval of multiple items needs the use of Model.findAll . User .find({ where: { username: 'john-doe' } }) .then(function(err, johnDoe) { if (!johnDoe) { console.log('No user with the username \"john-doe\" has been found.'); } else { console.log('Hello ' + johnDoe.username + '!'); console.log('All attributes of john:', johnDoe.get()); } }); Please note that there won't be any error if no user with the name \"john-doe\" has been found. This is intended, as there is not internal or authentication error. Defining associations A very common use case is the definition of associations between two or even more models. Once declared, Sequelize will know how to query the database to get or set associated data. Furthermore it will be able to automatically create the respective foreign key columns for you. Before taking a closer look at the code, it is critical to understand some details about the three different association types. One to one An association between one source and one target is called \"one to one\" or 1:1 association. It consists of a source that has one target and a target that belongs to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasOne(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! }); One to many An association between one source and many target is called \"one to many\" or 1:N association. It consists of a source that has many targets and some targets which belong to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasMany(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! }) Many to many An association between many sources and many targets is called \"many to many\" or N:M association. It consists of sources which have many targets and some targets which have many sources. Sequelize expects a junction table which contains a foreign key to the source table and a foreign key to the target table. A row in the table connects a source with a target. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasMany(Target) Target.hasMany(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // Sequelize will create a table SourcesTargets. }) Getting/Setting associations Defining associations is nice, but won't give you any advantage if you cannot read or set associations. Of course Sequelize will add respective functions to your models. Depending on the type of association you will find different methods: var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}); Source.hasOne(Target); Target.belongsTo(Source); sequelize.Promise.all([ Source.create({}), Target.create({}) ]).spread(function (source, target) { // Set the association return source.setTarget(target).return(source); }).then(function(source) { // Get the association return source.getTarget(); }).then(function(_target) { console.log(_target.values) /* { id: 1, createdAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), updatedAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), SourceId: 1 } */ }); Clearing associations Assuming we already defined the models (as in the previous code example) and synced the schema with the database, we can clear the associations like this: source.setTarget(null).then(function() { return source.getTarget(); }).then(function(target) { console.log(target); }); Adding / removing associations For 1:N and N:M associations it makes sense to not only set the associations, but also to add or remove associations. Furthermore checking for an association can be handy. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}); Source.hasMany(Target); Target.belongsTo(Source); return sequelize.Promise.all([ Source.create({}), Target.create({}); Target.create({}), ]).bind({}).spread(function (source, target1, target2) { // Set the association this.source = source; this.target1 = target1; this.target2 = target2; return source.setTargets([target1, target2]); }).then(function() { // Get the association return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 // Remove an association return this.source.removeTarget(this.target1); }).then(function() { return source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 1 // Check for an association return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // false // Adding an association return this.source.addTarget(this.target1); }).then(function() { return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // true }); A combined example Now that you know the basics of Sequelize, you might want to see everything in a single program. var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password') , User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }); sequelize.sync({ force: true }).then(function() { return User.create({ username: 'john', password: '1111' }); }).then(function(user1) { return User.find({ username: 'john' }) }).then(function(user2) { console.log(user2.get()); // Get returns a JSON representation of the user }); What's next? As there are some more advanced features in Sequelize which are a bit inappropriate for this article, you can check the following resources for further advice: Migrations Data types Configuration of the model Validations Finders Associations","title":"Getting started"},{"location":"articles/getting-started/#introduction","text":"This article explains the basic concepts of Sequelize. You will learn how to use the supported dialects, which ways of database setup approaches are available and how common scenarios can be achieved.","title":"Introduction"},{"location":"articles/getting-started/#premise","text":"We will skip the very basic things and directly dive into the Sequelize related stuff. Here is a list of things that have to be in place before you can start: Node.JS at v0.8 or higher One of the supported databases / SQLite bindings The credentials for the respective database A basic understanding of how databases are working Optional but recommended: Coffee :)","title":"Premise"},{"location":"articles/getting-started/#a-word-about-promises","text":"TODO - a link to bluebird + general promise syntax + catch / error handling","title":"A word about promises"},{"location":"articles/getting-started/#setting-up-a-project","text":"Now that your computer is prepared and your coffee sits next to your keyboard, we can finally get started. First things first: Create a directory and initializeit with NPM! $ mkdir my-project $ cd my-project $ npm init NPM will ask you a couple of questions. Answer them or just hit the return key until it's satisfied. Once done, you can install Sequelize and the connector for your database of choice. $ npm install --save sequelize $ npm install --save pg # for postgres $ npm install --save mysql # for mysql $ npm install --save sqlite3 # for sqlite $ npm install --save mariasql # for mariasql","title":"Setting up a project"},{"location":"articles/getting-started/#connecting-to-the-database","text":"Open the created directory in your favorite text editor and add a new file called app.js with the following content. var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password', { dialect: \"mysql\", // or 'sqlite', 'postgres', 'mariadb' port: 3306, // or 5432 (for postgres) }); sequelize .authenticate() .then(function(err) { console.log('Connection has been established successfully.'); }, function (err) { console.log('Unable to connect to the database:', err); });","title":"Connecting to the database"},{"location":"articles/getting-started/#managing-the-schema-of-your-database","text":"Sequelize supports two way of schema management. You can either define so called migrations, which are programmatically changing your database's structure. Or you can let Sequelize create the tables for you. While the first possibility of using migrations takes more time to setup, it's most likely the way to go, if you want to deploy your application on many different server environments. The reason for that is based on the fact, that migrations are consistently changing your database according to the current state of the schema. However, the automated way of using Sequelize's function sequelize.sync will probably be a good choice on your local machine or if you just want to quickly spin up a prototype. As this article is for beginners, we will skip migrations for now and take a closer look at the automated way.","title":"Managing the schema of your database"},{"location":"articles/getting-started/#defining-a-model","text":"In order to let Sequelize create a schemas in the database, you need to describe, what kind of data you want to store. This can be done with sequelize.define : var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }); This will define a user model that has a username and password. Furthermore, Sequelize will automatically add the columns id , createdAt and updatedAt . createdAt and updatedAt are controlled by sequelize - when you create a model through sequelize createdAt will be set, and whenever you call updateAttributes / save on a model, updatedAt will be set.","title":"Defining a model"},{"location":"articles/getting-started/#synchronizing-the-schema","text":"As we want to store data in the database, we need to create a representation of the model. sequelize .sync({ force: true }) .then(function(err) { console.log('It worked!'); }, function (err) { console.log('An error occurred while creating the table:', err); }); Once executed, the database will contain a table Users (note the plural) with the columns: id - INT(11) username - VARCHAR(255) password - VARCHAR(255) createdAt - DATETIME updatedAt - DATETIME Please note, that { force: true } will drop the Users table and re-create it.","title":"Synchronizing the schema"},{"location":"articles/getting-started/#configuration","text":"You might not need the timestamps or you might not want the plural of the model's name as table name, right? Luckily there are configuration possibilities for that. var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { tableName: 'my_user_table', // this will define the table's name timestamps: false // this will deactivate the timestamp columns }) And just in case you want to customize the timestamp field names, you can do it like this: var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { updatedAt: 'last_update', createdAt: 'date_of_creation' }) Furthermore you can introduce a deletedAt timestamp so models are not actually deleted when you call destroy . Adding a deletedAt timestamp is called making the model 'paranoid': var User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }, { paranoid: true });","title":"Configuration"},{"location":"articles/getting-started/#creating-and-persisting-instances","text":"Sequelize allows the creation of instances in two ways. You can either build an object and save it afterwards. Or you can directly create an instance in the database: var user = User.build({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }) user.save().then(function() { /* ... */ }) This persists the instance in a two step way. If you want to do everything at once, use the following approach: User.create({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }).then(function(user) { /* ... */ })","title":"Creating and persisting instances"},{"location":"articles/getting-started/#reading-data-from-the-database","text":"Every defined model has finder methods, with which you can read the database. Searching for a single item can be done with Model.find . Retrieval of multiple items needs the use of Model.findAll . User .find({ where: { username: 'john-doe' } }) .then(function(err, johnDoe) { if (!johnDoe) { console.log('No user with the username \"john-doe\" has been found.'); } else { console.log('Hello ' + johnDoe.username + '!'); console.log('All attributes of john:', johnDoe.get()); } }); Please note that there won't be any error if no user with the name \"john-doe\" has been found. This is intended, as there is not internal or authentication error.","title":"Reading data from the database"},{"location":"articles/getting-started/#defining-associations","text":"A very common use case is the definition of associations between two or even more models. Once declared, Sequelize will know how to query the database to get or set associated data. Furthermore it will be able to automatically create the respective foreign key columns for you. Before taking a closer look at the code, it is critical to understand some details about the three different association types.","title":"Defining associations"},{"location":"articles/getting-started/#one-to-one","text":"An association between one source and one target is called \"one to one\" or 1:1 association. It consists of a source that has one target and a target that belongs to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasOne(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! });","title":"One to one"},{"location":"articles/getting-started/#one-to-many","text":"An association between one source and many target is called \"one to many\" or 1:N association. It consists of a source that has many targets and some targets which belong to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasMany(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! })","title":"One to many"},{"location":"articles/getting-started/#many-to-many","text":"An association between many sources and many targets is called \"many to many\" or N:M association. It consists of sources which have many targets and some targets which have many sources. Sequelize expects a junction table which contains a foreign key to the source table and a foreign key to the target table. A row in the table connects a source with a target. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}) Source.hasMany(Target) Target.hasMany(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // Sequelize will create a table SourcesTargets. })","title":"Many to many"},{"location":"articles/getting-started/#gettingsetting-associations","text":"Defining associations is nice, but won't give you any advantage if you cannot read or set associations. Of course Sequelize will add respective functions to your models. Depending on the type of association you will find different methods: var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}); Source.hasOne(Target); Target.belongsTo(Source); sequelize.Promise.all([ Source.create({}), Target.create({}) ]).spread(function (source, target) { // Set the association return source.setTarget(target).return(source); }).then(function(source) { // Get the association return source.getTarget(); }).then(function(_target) { console.log(_target.values) /* { id: 1, createdAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), updatedAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), SourceId: 1 } */ });","title":"Getting/Setting associations"},{"location":"articles/getting-started/#clearing-associations","text":"Assuming we already defined the models (as in the previous code example) and synced the schema with the database, we can clear the associations like this: source.setTarget(null).then(function() { return source.getTarget(); }).then(function(target) { console.log(target); });","title":"Clearing associations"},{"location":"articles/getting-started/#adding-removing-associations","text":"For 1:N and N:M associations it makes sense to not only set the associations, but also to add or remove associations. Furthermore checking for an association can be handy. var Source = sequelize.define('Source', {}) , Target = sequelize.define('Target', {}); Source.hasMany(Target); Target.belongsTo(Source); return sequelize.Promise.all([ Source.create({}), Target.create({}); Target.create({}), ]).bind({}).spread(function (source, target1, target2) { // Set the association this.source = source; this.target1 = target1; this.target2 = target2; return source.setTargets([target1, target2]); }).then(function() { // Get the association return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 // Remove an association return this.source.removeTarget(this.target1); }).then(function() { return source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 1 // Check for an association return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // false // Adding an association return this.source.addTarget(this.target1); }).then(function() { return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // true });","title":"Adding / removing associations"},{"location":"articles/getting-started/#a-combined-example","text":"Now that you know the basics of Sequelize, you might want to see everything in a single program. var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password') , User = sequelize.define('User', { username: Sequelize.STRING, password: Sequelize.STRING }); sequelize.sync({ force: true }).then(function() { return User.create({ username: 'john', password: '1111' }); }).then(function(user1) { return User.find({ username: 'john' }) }).then(function(user2) { console.log(user2.get()); // Get returns a JSON representation of the user });","title":"A combined example"},{"location":"articles/getting-started/#whats-next","text":"As there are some more advanced features in Sequelize which are a bit inappropriate for this article, you can check the following resources for further advice: Migrations Data types Configuration of the model Validations Finders Associations","title":"What's next?"},{"location":"articles/heroku/","text":"Introduction This section covers the use of Sequelize on Heroku. It will explain how to get started with Heroku and what is necessary to setup a proper environment. We will use MySQL on the development machine and PostgreSQL on the remote servers. Getting started with Heroku Before we can roll out any software on the Heroku cluster, we need to sign up and have to connect our development environment. Here are the most basic steps: Sign up for a Heroku account. Install the Heroku Toolbelt. This tool will let you create applications and is a handy way to configure them on the command line. Use the new binary to login. Run the following command on command line: heroku login And that's it. You should now be able to do things like heroku apps . This should list all applications you've currently created on the Heroku cluster. If you've just created a new account, this should show you an empty list. You can get further information about the registration process here . A minimal express application In order to create a minimal express application, we need to install express first. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ node app.js So now we have a default express application. If you point your browser to http://localhost:8080 , you will see a tiny page welcoming you. Next step: Deploy the application to Heroku. Deployment to Heroku First of all, we need to add the right version of Node.JS and NPM to the package.json . The file should look similiar to this: { \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node app.js\" }, \"dependencies\": { \"express\": \"3.1.1\", \"jade\": \"*\" }, \"engines\": { \"node\": \"0.8.x\", \"npm\": \"1.1.x\" } } Now we can create a Heroku application and deploy to it: $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku open You should now see a browser with the same application as on your local machine. Spawning a database on Heroku In order to get a database on Heroku we can use their CLI. Just run the following command and take a closer look at it's output: $ heroku addons:add heroku-postgresql:dev This will result in something like this: Adding heroku-postgresql:dev on fast-dusk-7858... done, v5 (free) Attached as HEROKU_POSTGRESQL_BRONZE_URL Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore. Use `heroku addons:docs heroku-postgresql:dev` to view documentation. What we will need is the color (sounds strange right?) of the database. In this case we just created a bronze one. That means, that we will have an environment variable HEROKU_POSTGRESQL_BRONZE_URL containing the URI of the database. If you are interested in the URI, you can just run this command: $ heroku config:get HEROKU_POSTGRESQL_BRONZE_URL $ # => postgres://pfforbjhkrletg:aic5oO6Cran1g3hk6mJa5QqNZB@ec2-23-21-91-97.compute-1.amazonaws.com:5432/dek11b2j1g3mfb Adding Sequelize to the application The following commands will install sequelize , the needed PostgreSQL library as well as the MySQL bindings. Also we will create a folder models , that will contain the model definitions. $ npm install --save sequelize pg mysql $ mkdir models app.js In order to create a maintainable application, we will put all the database logic into the models folder. The application's main file will then just sync the models with the database and run the server. This way we don't clutter the application. var express = require('express') , routes = require('./routes') , user = require('./routes/user') , http = require('http') , path = require('path') , db = require('./models'); var app = express(); // all environments app.set('port', process.env.PORT || 3000); app.set('views', __dirname + '/views'); app.set('view engine', 'jade'); app.use(express.favicon()); app.use(express.logger('dev')); app.use(express.bodyParser()); app.use(express.methodOverride()); app.use(app.router); app.use(express.static(path.join(__dirname, 'public'))); // development only if ('development' === app.get('env')) { app.use(express.errorHandler()); } app.get('/', routes.index); app.get('/users', user.list); db.sequelize.sync().then(function() { http.createServer(app).listen(app.get('port'), function(){ console.log('Express server listening on port ' + app.get('port')); }); }); models/index.js The idea of this file is to configure a connection to the database and to collect all model definitions. Once everything is in place we will store the stuff in a singleton. This will make it possible to load the file whenever we need database access without running into issues with duplicated database access. This file will also differ between the local machine and the Heroku server. if (!global.hasOwnProperty('db')) { var Sequelize = require('sequelize') , sequelize = null if (process.env.HEROKU_POSTGRESQL_BRONZE_URL) { // the application is executed on Heroku ... use the postgres database sequelize = new Sequelize(process.env.HEROKU_POSTGRESQL_BRONZE_URL, { dialect: 'postgres', protocol: 'postgres', port: match[4], host: match[3], logging: true //false }) } else { // the application is executed on the local machine ... use mysql sequelize = new Sequelize('example-app-db', 'root', null) } global.db = { Sequelize: Sequelize, sequelize: sequelize, User: sequelize.import(__dirname + '/user') // add your other models here } /* Associations can be defined here. E.g. like this: global.db.User.hasMany(global.db.SomethingElse) */ } module.exports = global.db models/user.js All the other models of our application will be located as separate files in the models folder. We will use the import -method of Sequelize to load those files. module.exports = function(sequelize, DataTypes) { return sequelize.define(\"User\", { username: DataTypes.STRING }) } Running Migrations To run migrations on Heroku you must have the following entry in your config/config.json file: \"production\": { \"use_env_variable\": \"DATABASE_URL\" } Which also means you must make sure your Heroku environment has a promoted database. Then from the command line run $ heroku run bash $ sequelize -m tl;dr This article explains a straight-forward but maintainable approach for hosting an express application on Heroku. If you don't want to read all the stuff mentioned, just execute the following stuff and have fun. $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/459c923dd0a14841c932bb95ff3be8a8170bd563/package.json > package.json $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ npm install --save sequelize pg mysql $ mkdir models $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku addons:add heroku-postgresql:dev $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/6db41e130a8b901cd0843bf52390b7cb11db5f15/app.js > app.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/26c5a94d74db4a242464b02aa8e0ae4b3bac6880/models-index.js > models/index.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/3b37b0e5d459b2e4b3833a63a018b600a1001795/models-user.js > models/user.js $ clear $ # Now run the following command and change HEROKU_POSTGRESQL_BRONZE_URL in $ # the file \"models/index.js\" to its result: $ heroku config|grep HEROKU_POSTGRESQL|cut -d : -f 1 $ git add . $ git commit -m \"sequelize application\" $ git push heroku master $ heroku open","title":"Heroku"},{"location":"articles/heroku/#introduction","text":"This section covers the use of Sequelize on Heroku. It will explain how to get started with Heroku and what is necessary to setup a proper environment. We will use MySQL on the development machine and PostgreSQL on the remote servers.","title":"Introduction"},{"location":"articles/heroku/#getting-started-with-heroku","text":"Before we can roll out any software on the Heroku cluster, we need to sign up and have to connect our development environment. Here are the most basic steps: Sign up for a Heroku account. Install the Heroku Toolbelt. This tool will let you create applications and is a handy way to configure them on the command line. Use the new binary to login. Run the following command on command line: heroku login And that's it. You should now be able to do things like heroku apps . This should list all applications you've currently created on the Heroku cluster. If you've just created a new account, this should show you an empty list. You can get further information about the registration process here .","title":"Getting started with Heroku"},{"location":"articles/heroku/#a-minimal-express-application","text":"In order to create a minimal express application, we need to install express first. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ node app.js So now we have a default express application. If you point your browser to http://localhost:8080 , you will see a tiny page welcoming you. Next step: Deploy the application to Heroku.","title":"A minimal express application"},{"location":"articles/heroku/#deployment-to-heroku","text":"First of all, we need to add the right version of Node.JS and NPM to the package.json . The file should look similiar to this: { \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node app.js\" }, \"dependencies\": { \"express\": \"3.1.1\", \"jade\": \"*\" }, \"engines\": { \"node\": \"0.8.x\", \"npm\": \"1.1.x\" } } Now we can create a Heroku application and deploy to it: $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku open You should now see a browser with the same application as on your local machine.","title":"Deployment to Heroku"},{"location":"articles/heroku/#spawning-a-database-on-heroku","text":"In order to get a database on Heroku we can use their CLI. Just run the following command and take a closer look at it's output: $ heroku addons:add heroku-postgresql:dev This will result in something like this: Adding heroku-postgresql:dev on fast-dusk-7858... done, v5 (free) Attached as HEROKU_POSTGRESQL_BRONZE_URL Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore. Use `heroku addons:docs heroku-postgresql:dev` to view documentation. What we will need is the color (sounds strange right?) of the database. In this case we just created a bronze one. That means, that we will have an environment variable HEROKU_POSTGRESQL_BRONZE_URL containing the URI of the database. If you are interested in the URI, you can just run this command: $ heroku config:get HEROKU_POSTGRESQL_BRONZE_URL $ # => postgres://pfforbjhkrletg:aic5oO6Cran1g3hk6mJa5QqNZB@ec2-23-21-91-97.compute-1.amazonaws.com:5432/dek11b2j1g3mfb","title":"Spawning a database on Heroku"},{"location":"articles/heroku/#adding-sequelize-to-the-application","text":"The following commands will install sequelize , the needed PostgreSQL library as well as the MySQL bindings. Also we will create a folder models , that will contain the model definitions. $ npm install --save sequelize pg mysql $ mkdir models","title":"Adding Sequelize to the application"},{"location":"articles/heroku/#appjs","text":"In order to create a maintainable application, we will put all the database logic into the models folder. The application's main file will then just sync the models with the database and run the server. This way we don't clutter the application. var express = require('express') , routes = require('./routes') , user = require('./routes/user') , http = require('http') , path = require('path') , db = require('./models'); var app = express(); // all environments app.set('port', process.env.PORT || 3000); app.set('views', __dirname + '/views'); app.set('view engine', 'jade'); app.use(express.favicon()); app.use(express.logger('dev')); app.use(express.bodyParser()); app.use(express.methodOverride()); app.use(app.router); app.use(express.static(path.join(__dirname, 'public'))); // development only if ('development' === app.get('env')) { app.use(express.errorHandler()); } app.get('/', routes.index); app.get('/users', user.list); db.sequelize.sync().then(function() { http.createServer(app).listen(app.get('port'), function(){ console.log('Express server listening on port ' + app.get('port')); }); });","title":"app.js"},{"location":"articles/heroku/#modelsindexjs","text":"The idea of this file is to configure a connection to the database and to collect all model definitions. Once everything is in place we will store the stuff in a singleton. This will make it possible to load the file whenever we need database access without running into issues with duplicated database access. This file will also differ between the local machine and the Heroku server. if (!global.hasOwnProperty('db')) { var Sequelize = require('sequelize') , sequelize = null if (process.env.HEROKU_POSTGRESQL_BRONZE_URL) { // the application is executed on Heroku ... use the postgres database sequelize = new Sequelize(process.env.HEROKU_POSTGRESQL_BRONZE_URL, { dialect: 'postgres', protocol: 'postgres', port: match[4], host: match[3], logging: true //false }) } else { // the application is executed on the local machine ... use mysql sequelize = new Sequelize('example-app-db', 'root', null) } global.db = { Sequelize: Sequelize, sequelize: sequelize, User: sequelize.import(__dirname + '/user') // add your other models here } /* Associations can be defined here. E.g. like this: global.db.User.hasMany(global.db.SomethingElse) */ } module.exports = global.db","title":"models/index.js"},{"location":"articles/heroku/#modelsuserjs","text":"All the other models of our application will be located as separate files in the models folder. We will use the import -method of Sequelize to load those files. module.exports = function(sequelize, DataTypes) { return sequelize.define(\"User\", { username: DataTypes.STRING }) }","title":"models/user.js"},{"location":"articles/heroku/#running-migrations","text":"To run migrations on Heroku you must have the following entry in your config/config.json file: \"production\": { \"use_env_variable\": \"DATABASE_URL\" } Which also means you must make sure your Heroku environment has a promoted database. Then from the command line run $ heroku run bash $ sequelize -m","title":"Running Migrations"},{"location":"articles/heroku/#tldr","text":"This article explains a straight-forward but maintainable approach for hosting an express application on Heroku. If you don't want to read all the stuff mentioned, just execute the following stuff and have fun. $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/459c923dd0a14841c932bb95ff3be8a8170bd563/package.json > package.json $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ npm install --save sequelize pg mysql $ mkdir models $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku addons:add heroku-postgresql:dev $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/6db41e130a8b901cd0843bf52390b7cb11db5f15/app.js > app.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/26c5a94d74db4a242464b02aa8e0ae4b3bac6880/models-index.js > models/index.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/3b37b0e5d459b2e4b3833a63a018b600a1001795/models-user.js > models/user.js $ clear $ # Now run the following command and change HEROKU_POSTGRESQL_BRONZE_URL in $ # the file \"models/index.js\" to its result: $ heroku config|grep HEROKU_POSTGRESQL|cut -d : -f 1 $ git add . $ git commit -m \"sequelize application\" $ git push heroku master $ heroku open","title":"tl;dr"},{"location":"docs/associations/","text":"With Sequelize you can also specify associations between multiple classes. Doing so will help you to easily access and set those associated objects. The library therefore provides for each defined class different methods, which are explained in the following chapters. Note: Associations with models that use custom primaryKeys (so not the field 'id') are currently unsupported. One-To-One associations One-To-One associations are connecting one source with exactly one target. In order to define a proper database schema, Sequelize utilizes the methods belongsTo and hasOne . You can use them as follows: var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // One-way associations Project.hasOne(User) /* In this example hasOne will add an attribute ProjectId to the User model! Furthermore, Project.prototype will gain the methods getUser and setUser according to the first parameter passed to define. If you have underscore style enabled, the added attribute will be project_id instead of ProjectId. You can also define the foreign key, e.g. if you already have an existing database and want to work on it: */ Project.hasOne(User, { foreignKey: 'initiator_id' }) /* Because Sequelize will use the model's name (first parameter of define) for the accessor methods, it is also possible to pass a special option to hasOne: */ Project.hasOne(User, { as: 'Initiator' }) // Now you will get Project#getInitiator and Project#setInitiator // Or let's define some self references var Person = sequelize.define('Person', { /* ... */}) Person.hasOne(Person, {as: 'Father'}) // this will add the attribute FatherId to Person // also possible: Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) // this will add the attribute DadId to Person // In both cases you will be able to do: Person#setFather Person#getFather // If you need to join a table twice you can double join the same table Team .hasOne(Game, {foreignKey : 'homeTeamId'}); .hasOne(Game, {foreignKey : 'awayTeamId'}); Game .belongsTo(Team); // Since v1.3.0 you can also chain associations: Project .hasOne(User) .hasOne(Deadline) .hasOne(Attachment) To get the association working the other way around (so from User to Project ), it's necessary to do this: var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // One-way back associations Project.belongsTo(User) /* In this example belongsTo will add an attribute UserId to the Project model! That's the only difference to hasMany. Self references are working the very same way! */ One-To-Many associations One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source. var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // OK. Now things get more complicated (not really visible to the user :)). // First let's define a hasMany association Project.hasMany(User, {as: 'Workers'}) This will add the attribute ProjectId or project_id to User. Instances of Project will get the accessors getWorkers and setWorkers. We could just leave it the way it is and let it be a one-way association. But we want more! Let's define it the other way around by creating a many to many assocation in the next section: Many-To-Many associations Many-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources. // again the Project association to User Project.hasMany(User) // now comes the association between User and Project User.hasMany(Project) This will remove the attribute ProjectId (or project_id ) from User and create a new model called ProjectsUsers with the equivalent foreign keys ProjectId (or project_id ) and UserId (or user_id ). Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project). This will add methods getUsers , setUsers , addUsers to Project , and getProjects , setProjects and addProject to User . Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias ( as ) option: User.hasMany(Project, { as: 'Tasks', through: 'worker_tasks' }) Project.hasMany(User, { as: 'Workers', through: 'worker_tasks' }) Notice how we used the through option together with the alias in the code above. This is needed to tell sequelize that the two hasMany calls are actually two sides of the same association. If you don't use an alias (as shown in the first example of this section) this matching happens automagically, but with aliassed assocations through is required. Of course you can also define self references with hasMany: Person.hasMany(Person, { as: 'Children' }) // This will create the table ChildrenPersons which stores the ids of the objects. // You can also reference the same Model without creating a junction // table (but only if each object will have just one 'parent'). If you need that, // use the option foreignKey and set through to null Comment.hasMany(Comment, { as: 'Children', foreignKey: 'ParentId', through: null }) By default, sequelize will handle everything related to the join table for you. However, sometimes you might want some more control over the table. This is where th e through options comes in handy. If you just want to control the name of the join table, you can pass a string: Project.hasMany(User, {through: 'project_has_users'}) User.hasMany(Project, {through: 'project_has_users'}) If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one: User = sequelize.define('User', {}) Project = sequelize.define('Project', {}) UserProjects = sequelize.define('UserProjects', { status: DataTypes.STRING }) User.hasMany(Project, { through: UserProjects }) Project.hasMany(User, { through: UserProjects }) To add a new project to a user and set it's status, you pass an extra object to the setter, which contains the attributes for the join table user.addProject(project, { status: 'started' }) By default the code above will add ProjectId and UserId to the UserProjects table, and_remove any previsouly defined primary key attribute _- the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the UserProjects model you can add it manually. UserProjects = sequelize.define('UserProjects', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, status: DataTypes.STRING }) Naming strategy By default sequelize will use the model name (the name passed to sequelize.define ) to figure out the name of the model when used in associations. For example, a model named user will add the functions get/set/add User to instances of the associated model, and a property named .user in eager loading, while a model named User will add the same functions, but a property named .User (notice the upper case U) in eager loading. As we've already seen, you can alias models in associations using as . In single assocations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the inflection library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias: User.hasMany(Project, { as: { singular: 'task', plural: 'tasks' }}) // Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes. If you know that a model will always use the same alias in associations, you can provide it when creating the model var Project = sequelize.define('project', attributes, { name: { singular: 'task', plural: 'tasks', } }) User.hasMany(Project); This will add the functions add/set/get Tasks to user instances. Associating objects Because Sequelize is doing a lot of magic, you have to call Sequelize.sync after setting the associations! Doing so will allow you the following: Project.hasMany(Task) Task.hasMany(Project) Project.create()... Task.create()... Task.create()... // save them... and then: project.setTasks([task1, task2]).success(function() { // saved! }) // ok now they are save... how do I get them later on? project.getTasks().success(function(associatedTasks) { // associatedTasks is an array of tasks }) // You can also pass filters to the getter method. // They are equal to the options you can pass to a usual finder method. project.getTasks({ where: 'id > 10' }).success(function(tasks) { // tasks with an id greater than 10 :) }) // You can also only retrieve certain fields of a associated object. // This example will retrieve the attibutes \"title\" and \"id\" project.getTasks({attributes: ['title']}).success(function(tasks) { // tasks with an id greater than 10 :) }) To remove created associations you can just call the set method without a specific id: // remove the association with task1 project.setTasks([task2]).success(function(associatedTasks) { // you will get task2 only }) // remove 'em all project.setTasks([]).success(function(associatedTasks) { // you will get an empty array }) // or remove 'em more directly project.removeTask(task1).success(function() { // it's gone }) // and add 'em again project.addTask(task1).success(function() { // it's back again }) You can of course also do it vice versa: // project is associated with task1 and task2 task2.setProject(null).success(function() { // and it's gone }) For hasOne/belongsTo its basically the same: Task.hasOne(User, {as: \"Author\"}) Task#setAuthor(anAuthor) Adding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter): // Either by adding a property with the name of the join table model to the object, before creating the association project.UserProjects = { status: 'active' } u.addProject(project) // Or by providing a second argument when adding the association, containing the data that should go in the join table u.addProject(project, { status: 'active' }) // When associating multiple objects, you can combine the two options above. In this case the second argument // will be treated as a defaults object, that will be used if no data is provided project1.UserProjects = { status: 'inactive' } u.setProjects([project1, project2], { status: 'active' }) // The code above will record inactive for project one, and active for project two in the join table When getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance: u.getProjects().success(function(projects) { var project = projects[0] if (project.UserProjects.status === 'active') { // .. do magic // since this is a real DAO instance, you can save it directly after you are done doing magic project.UserProjects.save() } }) If you only need some of the attributes from the join table, you can provide an array with the attributes you want: // This will select only name from the Projects table, and only status from the UserProjects table user.getProjects({ attributes: ['name'], joinTableAttributes: ['status']}) Check associations You can also check if an object is already associated with another one (N:M only). Here is how you'd do it: // check if an object is one of associated ones: Project.create({ /* */ }).success(function(project) { User.create({ /* */ }).success(function(user) { project.hasUser(user).success(function(result) { // result would be false project.addUser(user).success(function() { project.hasUser(user).success(function(result) { // result would be true }) }) }) }) }) // check if all associated objects are as expected: // let's assume we have already a project and two users project.setUsers([user1, user2]).success(function() { project.hasUsers([user1]).success(function(result) { // result would be false project.hasUsers([user1, user2]).success(function(result) { // result would be true }) }) }) Foreign Keys When you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below: var Task = this.sequelize.define('Task', { title: Sequelize.STRING }) , User = this.sequelize.define('User', { username: Sequelize.STRING }) User.hasMany(Task) Task.belongsTo(User) Will generate the following SQL: CREATE TABLE IF NOT EXISTS `User` ( `id` INTEGER PRIMARY KEY, `username` VARCHAR(255) ); CREATE TABLE IF NOT EXISTS `Task` ( `id` INTEGER PRIMARY KEY, `title` VARCHAR(255), `user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); The relation between task and user injects the user_id foreign key on tasks, and marks it as a reference to the User table. By default user_id will be set to NULL if the referenced user is deleted, and updated if the id of the user id updated. These options can be overriden by passing onUpdate and onDelete options to the association calls. The validation options are RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL . For 1:1 and 1:m associations the default option is SET NULL for deletion, and CASCADE for updates. For n:m, the default for both is CASCADE . This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table refrencing that row will also be deleted or updated. Adding constriants between tables means that tables must be created in the database in a certain order, when using sequelize.sync . If Task has a reference to User, the User table must be created before the Task table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has an reference to it's current version. var Document = this.sequelize.define('Document', { author: Sequelize.STRING }) , Version = this.sequelize.define('Version', { timestamp: Sequelize.DATE }) Document.hasMany(Version) // This adds document_id to version Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id'}) // This adds current_version_id to document However, the code above will result in the following error: Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document . In order to alleviate that, we can pass constraints: false to one of the associations: Document.hasMany(Version) Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false}) Which will allow us to sync the tables correctly: CREATE TABLE IF NOT EXISTS `Document` ( `id` INTEGER PRIMARY KEY, `author` VARCHAR(255), `current_version_id` INTEGER ); CREATE TABLE IF NOT EXISTS `Version` ( `id` INTEGER PRIMARY KEY, `timestamp` DATETIME, `document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); Enforcing a foreign key reference without constraints Some times you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them. var Series, Trainer, Video // Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series) Series = sequelize.define('Series', { title: DataTypes.STRING, sub_title: DataTypes.STRING, description: DataTypes.TEXT, // Set FK relationship (hasMany) with `Trainer` trainer_id: { type: DataTypes.INTEGER, references: \"Trainer\", referencesKey: \"id\" } }) Trainer = sequelize.define('Trainer', { first_name: DataTypes.STRING, last_name: DataTypes.STRING }); // Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)... Video = sequelize.define('Video', { title: DataTypes.STRING, sequence: DataTypes.INTEGER, description: DataTypes.TEXT, // set relationship (hasOne) with `Series` series_id: { type: DataTypes.INTEGER, references: Series, // Can be both a string representing the table name, or a reference to the model referencesKey: \"id\" } }); Series.hasOne(Video); Trainer.hasMany(Series);","title":"Associations"},{"location":"docs/associations/#one-to-one-associations","text":"One-To-One associations are connecting one source with exactly one target. In order to define a proper database schema, Sequelize utilizes the methods belongsTo and hasOne . You can use them as follows: var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // One-way associations Project.hasOne(User) /* In this example hasOne will add an attribute ProjectId to the User model! Furthermore, Project.prototype will gain the methods getUser and setUser according to the first parameter passed to define. If you have underscore style enabled, the added attribute will be project_id instead of ProjectId. You can also define the foreign key, e.g. if you already have an existing database and want to work on it: */ Project.hasOne(User, { foreignKey: 'initiator_id' }) /* Because Sequelize will use the model's name (first parameter of define) for the accessor methods, it is also possible to pass a special option to hasOne: */ Project.hasOne(User, { as: 'Initiator' }) // Now you will get Project#getInitiator and Project#setInitiator // Or let's define some self references var Person = sequelize.define('Person', { /* ... */}) Person.hasOne(Person, {as: 'Father'}) // this will add the attribute FatherId to Person // also possible: Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) // this will add the attribute DadId to Person // In both cases you will be able to do: Person#setFather Person#getFather // If you need to join a table twice you can double join the same table Team .hasOne(Game, {foreignKey : 'homeTeamId'}); .hasOne(Game, {foreignKey : 'awayTeamId'}); Game .belongsTo(Team); // Since v1.3.0 you can also chain associations: Project .hasOne(User) .hasOne(Deadline) .hasOne(Attachment) To get the association working the other way around (so from User to Project ), it's necessary to do this: var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // One-way back associations Project.belongsTo(User) /* In this example belongsTo will add an attribute UserId to the Project model! That's the only difference to hasMany. Self references are working the very same way! */","title":"One-To-One associations"},{"location":"docs/associations/#one-to-many-associations","text":"One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source. var User = sequelize.define('User', {/* ... */}) var Project = sequelize.define('Project', {/* ... */}) // OK. Now things get more complicated (not really visible to the user :)). // First let's define a hasMany association Project.hasMany(User, {as: 'Workers'}) This will add the attribute ProjectId or project_id to User. Instances of Project will get the accessors getWorkers and setWorkers. We could just leave it the way it is and let it be a one-way association. But we want more! Let's define it the other way around by creating a many to many assocation in the next section:","title":"One-To-Many associations"},{"location":"docs/associations/#many-to-many-associations","text":"Many-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources. // again the Project association to User Project.hasMany(User) // now comes the association between User and Project User.hasMany(Project) This will remove the attribute ProjectId (or project_id ) from User and create a new model called ProjectsUsers with the equivalent foreign keys ProjectId (or project_id ) and UserId (or user_id ). Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project). This will add methods getUsers , setUsers , addUsers to Project , and getProjects , setProjects and addProject to User . Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias ( as ) option: User.hasMany(Project, { as: 'Tasks', through: 'worker_tasks' }) Project.hasMany(User, { as: 'Workers', through: 'worker_tasks' }) Notice how we used the through option together with the alias in the code above. This is needed to tell sequelize that the two hasMany calls are actually two sides of the same association. If you don't use an alias (as shown in the first example of this section) this matching happens automagically, but with aliassed assocations through is required. Of course you can also define self references with hasMany: Person.hasMany(Person, { as: 'Children' }) // This will create the table ChildrenPersons which stores the ids of the objects. // You can also reference the same Model without creating a junction // table (but only if each object will have just one 'parent'). If you need that, // use the option foreignKey and set through to null Comment.hasMany(Comment, { as: 'Children', foreignKey: 'ParentId', through: null }) By default, sequelize will handle everything related to the join table for you. However, sometimes you might want some more control over the table. This is where th e through options comes in handy. If you just want to control the name of the join table, you can pass a string: Project.hasMany(User, {through: 'project_has_users'}) User.hasMany(Project, {through: 'project_has_users'}) If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one: User = sequelize.define('User', {}) Project = sequelize.define('Project', {}) UserProjects = sequelize.define('UserProjects', { status: DataTypes.STRING }) User.hasMany(Project, { through: UserProjects }) Project.hasMany(User, { through: UserProjects }) To add a new project to a user and set it's status, you pass an extra object to the setter, which contains the attributes for the join table user.addProject(project, { status: 'started' }) By default the code above will add ProjectId and UserId to the UserProjects table, and_remove any previsouly defined primary key attribute _- the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the UserProjects model you can add it manually. UserProjects = sequelize.define('UserProjects', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, status: DataTypes.STRING })","title":"Many-To-Many associations"},{"location":"docs/associations/#naming-strategy","text":"By default sequelize will use the model name (the name passed to sequelize.define ) to figure out the name of the model when used in associations. For example, a model named user will add the functions get/set/add User to instances of the associated model, and a property named .user in eager loading, while a model named User will add the same functions, but a property named .User (notice the upper case U) in eager loading. As we've already seen, you can alias models in associations using as . In single assocations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the inflection library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias: User.hasMany(Project, { as: { singular: 'task', plural: 'tasks' }}) // Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes. If you know that a model will always use the same alias in associations, you can provide it when creating the model var Project = sequelize.define('project', attributes, { name: { singular: 'task', plural: 'tasks', } }) User.hasMany(Project); This will add the functions add/set/get Tasks to user instances.","title":"Naming strategy"},{"location":"docs/associations/#associating-objects","text":"Because Sequelize is doing a lot of magic, you have to call Sequelize.sync after setting the associations! Doing so will allow you the following: Project.hasMany(Task) Task.hasMany(Project) Project.create()... Task.create()... Task.create()... // save them... and then: project.setTasks([task1, task2]).success(function() { // saved! }) // ok now they are save... how do I get them later on? project.getTasks().success(function(associatedTasks) { // associatedTasks is an array of tasks }) // You can also pass filters to the getter method. // They are equal to the options you can pass to a usual finder method. project.getTasks({ where: 'id > 10' }).success(function(tasks) { // tasks with an id greater than 10 :) }) // You can also only retrieve certain fields of a associated object. // This example will retrieve the attibutes \"title\" and \"id\" project.getTasks({attributes: ['title']}).success(function(tasks) { // tasks with an id greater than 10 :) }) To remove created associations you can just call the set method without a specific id: // remove the association with task1 project.setTasks([task2]).success(function(associatedTasks) { // you will get task2 only }) // remove 'em all project.setTasks([]).success(function(associatedTasks) { // you will get an empty array }) // or remove 'em more directly project.removeTask(task1).success(function() { // it's gone }) // and add 'em again project.addTask(task1).success(function() { // it's back again }) You can of course also do it vice versa: // project is associated with task1 and task2 task2.setProject(null).success(function() { // and it's gone }) For hasOne/belongsTo its basically the same: Task.hasOne(User, {as: \"Author\"}) Task#setAuthor(anAuthor) Adding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter): // Either by adding a property with the name of the join table model to the object, before creating the association project.UserProjects = { status: 'active' } u.addProject(project) // Or by providing a second argument when adding the association, containing the data that should go in the join table u.addProject(project, { status: 'active' }) // When associating multiple objects, you can combine the two options above. In this case the second argument // will be treated as a defaults object, that will be used if no data is provided project1.UserProjects = { status: 'inactive' } u.setProjects([project1, project2], { status: 'active' }) // The code above will record inactive for project one, and active for project two in the join table When getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance: u.getProjects().success(function(projects) { var project = projects[0] if (project.UserProjects.status === 'active') { // .. do magic // since this is a real DAO instance, you can save it directly after you are done doing magic project.UserProjects.save() } }) If you only need some of the attributes from the join table, you can provide an array with the attributes you want: // This will select only name from the Projects table, and only status from the UserProjects table user.getProjects({ attributes: ['name'], joinTableAttributes: ['status']})","title":"Associating objects"},{"location":"docs/associations/#check-associations","text":"You can also check if an object is already associated with another one (N:M only). Here is how you'd do it: // check if an object is one of associated ones: Project.create({ /* */ }).success(function(project) { User.create({ /* */ }).success(function(user) { project.hasUser(user).success(function(result) { // result would be false project.addUser(user).success(function() { project.hasUser(user).success(function(result) { // result would be true }) }) }) }) }) // check if all associated objects are as expected: // let's assume we have already a project and two users project.setUsers([user1, user2]).success(function() { project.hasUsers([user1]).success(function(result) { // result would be false project.hasUsers([user1, user2]).success(function(result) { // result would be true }) }) })","title":"Check associations"},{"location":"docs/associations/#foreign-keys","text":"When you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below: var Task = this.sequelize.define('Task', { title: Sequelize.STRING }) , User = this.sequelize.define('User', { username: Sequelize.STRING }) User.hasMany(Task) Task.belongsTo(User) Will generate the following SQL: CREATE TABLE IF NOT EXISTS `User` ( `id` INTEGER PRIMARY KEY, `username` VARCHAR(255) ); CREATE TABLE IF NOT EXISTS `Task` ( `id` INTEGER PRIMARY KEY, `title` VARCHAR(255), `user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); The relation between task and user injects the user_id foreign key on tasks, and marks it as a reference to the User table. By default user_id will be set to NULL if the referenced user is deleted, and updated if the id of the user id updated. These options can be overriden by passing onUpdate and onDelete options to the association calls. The validation options are RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL . For 1:1 and 1:m associations the default option is SET NULL for deletion, and CASCADE for updates. For n:m, the default for both is CASCADE . This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table refrencing that row will also be deleted or updated. Adding constriants between tables means that tables must be created in the database in a certain order, when using sequelize.sync . If Task has a reference to User, the User table must be created before the Task table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has an reference to it's current version. var Document = this.sequelize.define('Document', { author: Sequelize.STRING }) , Version = this.sequelize.define('Version', { timestamp: Sequelize.DATE }) Document.hasMany(Version) // This adds document_id to version Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id'}) // This adds current_version_id to document However, the code above will result in the following error: Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document . In order to alleviate that, we can pass constraints: false to one of the associations: Document.hasMany(Version) Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false}) Which will allow us to sync the tables correctly: CREATE TABLE IF NOT EXISTS `Document` ( `id` INTEGER PRIMARY KEY, `author` VARCHAR(255), `current_version_id` INTEGER ); CREATE TABLE IF NOT EXISTS `Version` ( `id` INTEGER PRIMARY KEY, `timestamp` DATETIME, `document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE );","title":"Foreign Keys"},{"location":"docs/associations/#enforcing-a-foreign-key-reference-without-constraints","text":"Some times you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them. var Series, Trainer, Video // Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series) Series = sequelize.define('Series', { title: DataTypes.STRING, sub_title: DataTypes.STRING, description: DataTypes.TEXT, // Set FK relationship (hasMany) with `Trainer` trainer_id: { type: DataTypes.INTEGER, references: \"Trainer\", referencesKey: \"id\" } }) Trainer = sequelize.define('Trainer', { first_name: DataTypes.STRING, last_name: DataTypes.STRING }); // Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)... Video = sequelize.define('Video', { title: DataTypes.STRING, sequence: DataTypes.INTEGER, description: DataTypes.TEXT, // set relationship (hasOne) with `Series` series_id: { type: DataTypes.INTEGER, references: Series, // Can be both a string representing the table name, or a reference to the model referencesKey: \"id\" } }); Series.hasOne(Video); Trainer.hasMany(Series);","title":"Enforcing a foreign key reference without constraints"},{"location":"docs/hooks/","text":"Hooks (also known as callbacks or lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a beforeUpdate hook. Order of Operations (1) beforeBulkCreate(daos, fields, fn) beforeBulkDestroy(daos, fields, fn) beforeBulkUpdate(daos, fields, fn) (2) beforeValidate(dao, fn) (-) validate (3) afterValidate(dao, fn) (4) beforeCreate(dao, fn) beforeDestroy(dao, fn) beforeUpdate(dao, fn) (-) create destroy update (5) afterCreate(dao, fn) afterDestroy(dao, fn) afterUpdate(dao, fn) (6) afterBulkCreate(daos, fields, fn) afterBulkDestory(daos, fields, fn) afterBulkUpdate(daos, fields, fn) Declaring Hooks There are currently three ways to programmatically add hooks. A hook function always runs asynchronous\u013ay, and can be resolved either by calling a callback (passed as the last argument), or by returning a promise. // Method 1 via the .define() method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: function(user, fn) { user.mood = 'happy' fn(null, user) }, afterValidate: function(user, fn) { user.username = 'Toni' fn(null, user) } } }) // Method 2 via the .hook() method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }) User.hook('beforeValidate', function(user, fn) { user.mood = 'happy' fn(null, user) }) User.hook('afterValidate', function(user) { return sequelize.Promise.reject(\"I'm afraid I can't let you do that!\") }) // Method 3 via the direct method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }) User.beforeValidate(function(user) { user.mood = 'happy' return sequelize.Promise.resolve(user) }) User.afterValidate(function(user, fn) { user.username = 'Toni' fn(null, user) }) Instance hooks The following hooks will emit whenever you're editing a single object... beforeValidate afterValidate beforeCreate / beforeUpdate / beforeDestroy afterCreate / afterUpdate / afterDestroy // ...define ... User.beforeCreate(function(user, fn) { if (user.accessLevel > 10 && user.username !== \"Boss\") { return fn(\"You can't grant this user an access level above 10!\") } return fn() }) This example will emit an error: User.create({username: 'Not a Boss', accessLevel: 20}).error(function(err) { console.log(err) // You can't grant this user an access level above 10! }) The following example would emit a success event: User.create({username: 'Boss', accessLevel: 20}).success(function(user) { console.log(user) // user object with username as Boss and accessLevel of 20 }) Model hooks Sometimes you'll be editing more than one record at a time by utilizing the bulkCreate, update, destroy methods on the model. The following will emit whenever you're using one of those methods. beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy afterBulkCreate / afterBulkUpdate / afterBulkDestroy If you want to emit hooks for each individual record, along with the bulk hooks you can pass individualHooks: true to the call. Model.destroy({accessLevel: 0}, {individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Destroy on each instance Model.update({username: 'Toni'}, {accessLevel: 0}, {individualHooks: true}) // Will select all records that are about to be updated and emit before- + after- Update on each instance Model.bulkCreate({accessLevel: 0}, null, {individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Create on each instance Some model hooks have two or three parameters sent to each hook depending on it's type. Model.beforeBulkCreate(function(records, fields, fn) { // records = the first argument sent to .bulkCreate // fields = the second argument sent to .bulkCreate }) Model.bulkCreate([ {username: 'Toni'}, // part of records argument {username: 'Tobi'} // part of records argument ], ['username'] /* part of fields argument */) Model.beforeBulkUpdate(function(attributes, where, fn) { // attributes = first argument sent to Model.update // where = second argument sent to Model.update }) Model.update({gender: 'Male'} /*attributes argument*/, {username: 'Tom'} /*where argument*/) Model.beforeBulkDestroy(function(whereClause, fn) { // whereClause = first argument sent to Model.destroy }) Model.destroy({username: 'Tom'} /*whereClause argument*/) Associations For the most part hooks will work the same for instances when being associated except a few things When using add/set[s] functions the beforeUpdate/afterUpdate hooks will run. The only way to call beforeDestroy/afterDestroy hooks are on associations with onDelete: 'cascade' and the option hooks: true . For instance: var Projects = sequelize.define('Projects', { title: DataTypes.STRING }) var Tasks = sequelize.define('Tasks', { title: DataTypes.STRING }) Projects.hasMany(Tasks, {onDelete: 'cascade', hooks: true}) Tasks.belongsTo(Projects) This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a DELETE FROM `table` WHERE associatedIdentifiier = associatedIdentifier.primaryKey However, adding hooks: true explicitly tells Sequelize that optimization is not of your concern and will perform a SELECT on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters. A Note About Transactions Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction is specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet: // Here we use the promise-style of async hooks rather than // the callback. User.hook('afterCreate', function(user, options) { // 'trans' will be available in options.transaction // This operation will be part of the same transaction as the // original User.create call. return User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); sequelize.transaction(function(trans) { User.create({ username: 'someguy', mood: 'happy' }, { transaction: trans }); }); If we had not included the transaction option in our call to User.update in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed. Internal Transactions It is very important to recognize that sequelize may make use of transactions internally for certain operations such as Model.findOrCreate . If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify { transaction: options.transaction } . If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified { transaction: null } and can expect the default behaviour.","title":"Hooks"},{"location":"docs/hooks/#order-of-operations","text":"(1) beforeBulkCreate(daos, fields, fn) beforeBulkDestroy(daos, fields, fn) beforeBulkUpdate(daos, fields, fn) (2) beforeValidate(dao, fn) (-) validate (3) afterValidate(dao, fn) (4) beforeCreate(dao, fn) beforeDestroy(dao, fn) beforeUpdate(dao, fn) (-) create destroy update (5) afterCreate(dao, fn) afterDestroy(dao, fn) afterUpdate(dao, fn) (6) afterBulkCreate(daos, fields, fn) afterBulkDestory(daos, fields, fn) afterBulkUpdate(daos, fields, fn)","title":"Order of Operations"},{"location":"docs/hooks/#declaring-hooks","text":"There are currently three ways to programmatically add hooks. A hook function always runs asynchronous\u013ay, and can be resolved either by calling a callback (passed as the last argument), or by returning a promise. // Method 1 via the .define() method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: function(user, fn) { user.mood = 'happy' fn(null, user) }, afterValidate: function(user, fn) { user.username = 'Toni' fn(null, user) } } }) // Method 2 via the .hook() method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }) User.hook('beforeValidate', function(user, fn) { user.mood = 'happy' fn(null, user) }) User.hook('afterValidate', function(user) { return sequelize.Promise.reject(\"I'm afraid I can't let you do that!\") }) // Method 3 via the direct method var User = sequelize.define('User', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }) User.beforeValidate(function(user) { user.mood = 'happy' return sequelize.Promise.resolve(user) }) User.afterValidate(function(user, fn) { user.username = 'Toni' fn(null, user) })","title":"Declaring Hooks"},{"location":"docs/hooks/#instance-hooks","text":"The following hooks will emit whenever you're editing a single object... beforeValidate afterValidate beforeCreate / beforeUpdate / beforeDestroy afterCreate / afterUpdate / afterDestroy // ...define ... User.beforeCreate(function(user, fn) { if (user.accessLevel > 10 && user.username !== \"Boss\") { return fn(\"You can't grant this user an access level above 10!\") } return fn() }) This example will emit an error: User.create({username: 'Not a Boss', accessLevel: 20}).error(function(err) { console.log(err) // You can't grant this user an access level above 10! }) The following example would emit a success event: User.create({username: 'Boss', accessLevel: 20}).success(function(user) { console.log(user) // user object with username as Boss and accessLevel of 20 })","title":"Instance hooks"},{"location":"docs/hooks/#model-hooks","text":"Sometimes you'll be editing more than one record at a time by utilizing the bulkCreate, update, destroy methods on the model. The following will emit whenever you're using one of those methods. beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy afterBulkCreate / afterBulkUpdate / afterBulkDestroy If you want to emit hooks for each individual record, along with the bulk hooks you can pass individualHooks: true to the call. Model.destroy({accessLevel: 0}, {individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Destroy on each instance Model.update({username: 'Toni'}, {accessLevel: 0}, {individualHooks: true}) // Will select all records that are about to be updated and emit before- + after- Update on each instance Model.bulkCreate({accessLevel: 0}, null, {individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Create on each instance Some model hooks have two or three parameters sent to each hook depending on it's type. Model.beforeBulkCreate(function(records, fields, fn) { // records = the first argument sent to .bulkCreate // fields = the second argument sent to .bulkCreate }) Model.bulkCreate([ {username: 'Toni'}, // part of records argument {username: 'Tobi'} // part of records argument ], ['username'] /* part of fields argument */) Model.beforeBulkUpdate(function(attributes, where, fn) { // attributes = first argument sent to Model.update // where = second argument sent to Model.update }) Model.update({gender: 'Male'} /*attributes argument*/, {username: 'Tom'} /*where argument*/) Model.beforeBulkDestroy(function(whereClause, fn) { // whereClause = first argument sent to Model.destroy }) Model.destroy({username: 'Tom'} /*whereClause argument*/)","title":"Model hooks"},{"location":"docs/hooks/#associations","text":"For the most part hooks will work the same for instances when being associated except a few things When using add/set[s] functions the beforeUpdate/afterUpdate hooks will run. The only way to call beforeDestroy/afterDestroy hooks are on associations with onDelete: 'cascade' and the option hooks: true . For instance: var Projects = sequelize.define('Projects', { title: DataTypes.STRING }) var Tasks = sequelize.define('Tasks', { title: DataTypes.STRING }) Projects.hasMany(Tasks, {onDelete: 'cascade', hooks: true}) Tasks.belongsTo(Projects) This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a DELETE FROM `table` WHERE associatedIdentifiier = associatedIdentifier.primaryKey However, adding hooks: true explicitly tells Sequelize that optimization is not of your concern and will perform a SELECT on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.","title":"Associations"},{"location":"docs/hooks/#a-note-about-transactions","text":"Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction is specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet: // Here we use the promise-style of async hooks rather than // the callback. User.hook('afterCreate', function(user, options) { // 'trans' will be available in options.transaction // This operation will be part of the same transaction as the // original User.create call. return User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); sequelize.transaction(function(trans) { User.create({ username: 'someguy', mood: 'happy' }, { transaction: trans }); }); If we had not included the transaction option in our call to User.update in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.","title":"A Note About Transactions"},{"location":"docs/hooks/#internal-transactions","text":"It is very important to recognize that sequelize may make use of transactions internally for certain operations such as Model.findOrCreate . If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify { transaction: options.transaction } . If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified { transaction: null } and can expect the default behaviour.","title":"Internal Transactions"},{"location":"docs/installation/","text":"Installation You have two options to install Sequelize: 1. Install it via NPM: # Use npm on the commandline: $ npm install sequelize // Then require the installed library in your application code: var Sequelize = require(\"sequelize\") 2. Download the code from the git repository and require it's entry file index.js: # Checkout the current code from the repository using the commandline $ cd path/to/lib $ git clone git://github.com/sequelize/sequelize.git // Then require the installed library in your application code&colon; var Sequelize = require(__dirname + \"/lib/sequelize/index\") This will make the class Sequelize available.","title":"Installation"},{"location":"docs/installation/#installation","text":"You have two options to install Sequelize: 1. Install it via NPM: # Use npm on the commandline: $ npm install sequelize // Then require the installed library in your application code: var Sequelize = require(\"sequelize\") 2. Download the code from the git repository and require it's entry file index.js: # Checkout the current code from the repository using the commandline $ cd path/to/lib $ git clone git://github.com/sequelize/sequelize.git // Then require the installed library in your application code&colon; var Sequelize = require(__dirname + \"/lib/sequelize/index\") This will make the class Sequelize available.","title":"Installation"},{"location":"docs/instances/","text":"Building a not-persistant instance In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the build -method will return an unsaved object, which you explicitly have to save. var project = Project.build({ title: 'my awesome project', description: 'woot woot. this will make me a rich man' }) var task = Task.build({ title: 'specify the project idea', description: 'bla', deadline: new Date() }) Built instances will automatically get default values when they were defined: // first define the model var Task = sequelize.define('Project', { title: Sequelize.STRING, rating: { type: Sequelize.STRING, defaultValue: 3 } }) // now instantiate an object var task = Task.build({title: 'very important task'}) task.title // ==> 'very important task' task.rating // ==> 3 To get it stored in the database, use the save -method and catch the events ... if needed: project.save().success(function() { // my nice callback stuff }) task.save().error(function(error) { // mhhh, wth! }) // you can also build, save and access the object with chaining: Task .build({ title: 'foo', description: 'bar', deadline: new Date() }) .save() .success(function(anotherTask) { // you can now access the currently saved task with the variable anotherTask... nice! }).error(function(error) { // Ooops, do some error-handling }) Creating persistant instances Besides constructing objects, that needs an explicit save call to get stored in the database, there is also the possibility to do all those steps with one single command. It's called create . Task.create({ title: 'foo', description: 'bar', deadline: new Date() }).success(function(task) { // you can now access the newly created task via the variable task }) It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the User model to set only a username and an address but not an admin flag: User.create({ username: 'barfooz', isAdmin: true }, [ 'username' ]).success(function(user) { // let's assume the default of isAdmin is false: console.log(user.values) // => { username: 'barfooz', isAdmin: false } }) Updating / Saving / Persisting an instance Now lets change some values and save changes to the database... There are two ways to do that: // way 1 task.title = 'a very different title now' task.save().success(function() {}) // way 2 task.updateAttributes({ title: 'a very different title now' }).success(function() {}) It's also possible to define which attributes should be saved when calling save , by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for updateAttributes . This is how it looks like: task.title = 'foooo' task.description = 'baaaaaar' task.save(['title']).success(function() { // title will now be 'foooo' but description is the very same as before }) // The equivalent call using updateAttributes looks like this: task.updateAttributes({ title: 'foooo', description: 'baaaaaar'}, ['title']).success(function() { // title will now be 'foooo' but description is the very same as before }) Destroying / Deleting persistant instances Once you created an object and got a reference to it, you can delete it from the database. The relevant method is destroy : Task.create({ title: 'a task' }).success(function(task) { // now you see me... task.destroy().success(function() { // now i'm gone :) }) }) If the paranoid options is true, the object will not be deleted, instead the deletedAt column will be set to the current timestamp. To force the deletion, you can pass force: true to the destroy call: task.destroy({ force: true }) Working in bulk (creating, updating and destroying multiple rows at once) In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called Model.bulkCreate Model.update Model.destroy Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike create , not have the resulting values of autoIncrement attributes. update and destroy will return the number of affected rows. First lets look at bulkCreate User.bulkCreate([ { username: 'barfooz', isAdmin: true }, { username: 'foo', isAdmin: true }, { username: 'bar', isAdmin: false } ]).success(function() { // Notice: There are no arguments here, as of right now you'll have to... User.findAll().success(function(users) { console.log(users) // ... in order to get the array of user objects }) }) To update several rows at once: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).success(function() { Task.update( {status: 'inactive'} /* set attributes' value */, {subject: 'programming'} /* where criteria */ ).success(function(affectedRows) { // affectedRows will be 2 Task.findAll().success(function(tasks) { console.log(tasks) // the 'programming' tasks will both have a status of 'inactive' }) }) }) And delete them: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).success(function() { Task.destroy( {subject: 'programming'} /* where criteria */, {truncate: true /* truncate the whole table, ignoring where criteria */} /* options */ ).success(function(affectedRows) { // affectedRows will be 2 Task.findAll().success(function(tasks) { console.log(tasks) // no programming, just reading :( }) }) }) If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. bulkCreate() accepts an options object as the second parameter. The object can have a fields parameter, (an array) to let it know which fields you want to build explicitly User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true} ], { fields: ['username'] }).success(function() { // nope bar, you can't be admin! }) bulkCreate was originally made to be a mainstream/fast way of inserting records, however, sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through. You can do by adding a validate: true property to the optons object. var Tasks = sequelize.define('Task', { name: { type: Sequelize.STRING, validate: { notNull: { args: true, msg: 'name cannot be null' } } }, code: { type: Sequelize.STRING, validate: { len: [3, 10] } } }) Tasks.bulkCreate([ {name: 'foo', code: '123'}, {code: '1234'}, {name: 'bar', code: '1'} ], { validate: true }).error(function(errors) { /* console.log(errors) would look like: [ { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } }, { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } } ] */ }) Values of an instance If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the values -attribute. Calling it will return only the values of an instance. Person.create({ name: 'Rambow', firstname: 'John' }).success(function(john) { console.log(john.values) }) // result: // { name: 'Rambow', // firstname: 'John', // id: 1, // createdAt: Tue, 01 May 2012 19:12:16 GMT, // updatedAt: Tue, 01 May 2012 19:12:16 GMT // } Hint: You can also transform an instance into JSON by using JSON.stringify(instance) . This will basically return the very same as values . Reloading instances If you need to get your instance in sync, you can use the method reload . It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on. Person.find({ where: { name: 'john' } }).success(function(person) { person.name = 'jane' console.log(person.name) // 'jane' person.reload().success(function() { console.log(person.name) // 'john' }) }) Incrementing certain values of an instance In order to increment values of an instance without running into concurrency issues, you may use increment . First of all you can define a field and the value you want to add to it. User.find(1).success(function(user) { user.increment('my-integer-field', 2).success(/* ... */) }) Second, you can define multiple fields and the value you want to add to them. User.find(1).success(function(user) { user.increment([ 'my-integer-field', 'my-very-other-field' ], 2).success(/* ... */) }) Third, you can define an object containing fields and its increment values. User.find(1).success(function(user) { user.increment({ 'my-integer-field': 2, 'my-very-other-field': 3 }).success(/* ... */) }) Decrementing certain values of an instance In order to decrement values of an instance without running into concurrency issues, you may use decrement . First of all you can define a field and the value you want to add to it. User.find(1).success(function(user) { user.decrement('my-integer-field', 2).success(/* ... */) }) Second, you can define multiple fields and the value you want to add to them. User.find(1).success(function(user) { user.decrement([ 'my-integer-field', 'my-very-other-field' ], 2).success(/* ... */) }) Third, you can define an object containing fields and its decrement values. User.find(1).success(function(user) { user.decrement({ 'my-integer-field': 2, 'my-very-other-field': 3 }).success(/* ... */) })","title":"Instances"},{"location":"docs/instances/#building-a-not-persistant-instance","text":"In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the build -method will return an unsaved object, which you explicitly have to save. var project = Project.build({ title: 'my awesome project', description: 'woot woot. this will make me a rich man' }) var task = Task.build({ title: 'specify the project idea', description: 'bla', deadline: new Date() }) Built instances will automatically get default values when they were defined: // first define the model var Task = sequelize.define('Project', { title: Sequelize.STRING, rating: { type: Sequelize.STRING, defaultValue: 3 } }) // now instantiate an object var task = Task.build({title: 'very important task'}) task.title // ==> 'very important task' task.rating // ==> 3 To get it stored in the database, use the save -method and catch the events ... if needed: project.save().success(function() { // my nice callback stuff }) task.save().error(function(error) { // mhhh, wth! }) // you can also build, save and access the object with chaining: Task .build({ title: 'foo', description: 'bar', deadline: new Date() }) .save() .success(function(anotherTask) { // you can now access the currently saved task with the variable anotherTask... nice! }).error(function(error) { // Ooops, do some error-handling })","title":"Building a not-persistant instance"},{"location":"docs/instances/#creating-persistant-instances","text":"Besides constructing objects, that needs an explicit save call to get stored in the database, there is also the possibility to do all those steps with one single command. It's called create . Task.create({ title: 'foo', description: 'bar', deadline: new Date() }).success(function(task) { // you can now access the newly created task via the variable task }) It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the User model to set only a username and an address but not an admin flag: User.create({ username: 'barfooz', isAdmin: true }, [ 'username' ]).success(function(user) { // let's assume the default of isAdmin is false: console.log(user.values) // => { username: 'barfooz', isAdmin: false } })","title":"Creating persistant instances"},{"location":"docs/instances/#updating-saving-persisting-an-instance","text":"Now lets change some values and save changes to the database... There are two ways to do that: // way 1 task.title = 'a very different title now' task.save().success(function() {}) // way 2 task.updateAttributes({ title: 'a very different title now' }).success(function() {}) It's also possible to define which attributes should be saved when calling save , by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for updateAttributes . This is how it looks like: task.title = 'foooo' task.description = 'baaaaaar' task.save(['title']).success(function() { // title will now be 'foooo' but description is the very same as before }) // The equivalent call using updateAttributes looks like this: task.updateAttributes({ title: 'foooo', description: 'baaaaaar'}, ['title']).success(function() { // title will now be 'foooo' but description is the very same as before })","title":"Updating / Saving / Persisting an instance"},{"location":"docs/instances/#destroying-deleting-persistant-instances","text":"Once you created an object and got a reference to it, you can delete it from the database. The relevant method is destroy : Task.create({ title: 'a task' }).success(function(task) { // now you see me... task.destroy().success(function() { // now i'm gone :) }) }) If the paranoid options is true, the object will not be deleted, instead the deletedAt column will be set to the current timestamp. To force the deletion, you can pass force: true to the destroy call: task.destroy({ force: true })","title":"Destroying / Deleting persistant instances"},{"location":"docs/instances/#working-in-bulk-creating-updating-and-destroying-multiple-rows-at-once","text":"In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called Model.bulkCreate Model.update Model.destroy Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike create , not have the resulting values of autoIncrement attributes. update and destroy will return the number of affected rows. First lets look at bulkCreate User.bulkCreate([ { username: 'barfooz', isAdmin: true }, { username: 'foo', isAdmin: true }, { username: 'bar', isAdmin: false } ]).success(function() { // Notice: There are no arguments here, as of right now you'll have to... User.findAll().success(function(users) { console.log(users) // ... in order to get the array of user objects }) }) To update several rows at once: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).success(function() { Task.update( {status: 'inactive'} /* set attributes' value */, {subject: 'programming'} /* where criteria */ ).success(function(affectedRows) { // affectedRows will be 2 Task.findAll().success(function(tasks) { console.log(tasks) // the 'programming' tasks will both have a status of 'inactive' }) }) }) And delete them: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).success(function() { Task.destroy( {subject: 'programming'} /* where criteria */, {truncate: true /* truncate the whole table, ignoring where criteria */} /* options */ ).success(function(affectedRows) { // affectedRows will be 2 Task.findAll().success(function(tasks) { console.log(tasks) // no programming, just reading :( }) }) }) If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. bulkCreate() accepts an options object as the second parameter. The object can have a fields parameter, (an array) to let it know which fields you want to build explicitly User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true} ], { fields: ['username'] }).success(function() { // nope bar, you can't be admin! }) bulkCreate was originally made to be a mainstream/fast way of inserting records, however, sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through. You can do by adding a validate: true property to the optons object. var Tasks = sequelize.define('Task', { name: { type: Sequelize.STRING, validate: { notNull: { args: true, msg: 'name cannot be null' } } }, code: { type: Sequelize.STRING, validate: { len: [3, 10] } } }) Tasks.bulkCreate([ {name: 'foo', code: '123'}, {code: '1234'}, {name: 'bar', code: '1'} ], { validate: true }).error(function(errors) { /* console.log(errors) would look like: [ { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } }, { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } } ] */ })","title":"Working in bulk (creating, updating and destroying multiple rows at once)"},{"location":"docs/instances/#values-of-an-instance","text":"If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the values -attribute. Calling it will return only the values of an instance. Person.create({ name: 'Rambow', firstname: 'John' }).success(function(john) { console.log(john.values) }) // result: // { name: 'Rambow', // firstname: 'John', // id: 1, // createdAt: Tue, 01 May 2012 19:12:16 GMT, // updatedAt: Tue, 01 May 2012 19:12:16 GMT // } Hint: You can also transform an instance into JSON by using JSON.stringify(instance) . This will basically return the very same as values .","title":"Values of an instance"},{"location":"docs/instances/#reloading-instances","text":"If you need to get your instance in sync, you can use the method reload . It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on. Person.find({ where: { name: 'john' } }).success(function(person) { person.name = 'jane' console.log(person.name) // 'jane' person.reload().success(function() { console.log(person.name) // 'john' }) })","title":"Reloading instances"},{"location":"docs/instances/#incrementing-certain-values-of-an-instance","text":"In order to increment values of an instance without running into concurrency issues, you may use increment . First of all you can define a field and the value you want to add to it. User.find(1).success(function(user) { user.increment('my-integer-field', 2).success(/* ... */) }) Second, you can define multiple fields and the value you want to add to them. User.find(1).success(function(user) { user.increment([ 'my-integer-field', 'my-very-other-field' ], 2).success(/* ... */) }) Third, you can define an object containing fields and its increment values. User.find(1).success(function(user) { user.increment({ 'my-integer-field': 2, 'my-very-other-field': 3 }).success(/* ... */) })","title":"Incrementing certain values of an instance"},{"location":"docs/instances/#decrementing-certain-values-of-an-instance","text":"In order to decrement values of an instance without running into concurrency issues, you may use decrement . First of all you can define a field and the value you want to add to it. User.find(1).success(function(user) { user.decrement('my-integer-field', 2).success(/* ... */) }) Second, you can define multiple fields and the value you want to add to them. User.find(1).success(function(user) { user.decrement([ 'my-integer-field', 'my-very-other-field' ], 2).success(/* ... */) }) Third, you can define an object containing fields and its decrement values. User.find(1).success(function(user) { user.decrement({ 'my-integer-field': 2, 'my-very-other-field': 3 }).success(/* ... */) })","title":"Decrementing certain values of an instance"},{"location":"docs/migrations/","text":"Sequelize 2.0.0 introduces a new CLI which is based on gulp and combines sequelize-cli and gulp-sequelize . The CLI ships support for migrations and project bootstrapping. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe the way how to get to the new state and how to revert the changes in order to get back to the old state. The CLI In order to use the CLI you need to install the respective package: $ npm install --save sequelize-cli The CLI currently supports the following commands: $ sequelize db:migrate # Run pending migrations. $ sequelize db:migrate:undo # Revert the last migration run. $ sequelize help # Display this help text. $ sequelize init # Initializes the project. $ sequelize migration:create # Generates a new migration file. $ sequelize version # Prints the version number. Further and more detailled information about the available commands can be obtained via the help command: $ sequelize help:init $ sequelize help:db:migrate $ sequelize help:db:migrate:undo # etc The latter one for example will print out the following output: Sequelize [CLI: v0.0.2, ORM: v1.7.5] COMMANDS sequelize db:migrate:undo -- Revert the last migration run. DESCRIPTION Revert the last migration run. OPTIONS --env The environment to run the command in. Default: development --options-path The path to a JSON file with additional options. Default: none --coffee Enables coffee script support. Default: false --config The path to the config file. Default: config/config.json Skeleton The following skeleton shows a typical migration file. All migrations are expected to be located in a folder called migrations at the very top of the project. The sequelize binary can generate a migration skeleton. See the aboves section for more details. module.exports = { up: function(migration, DataTypes, done) { // logic for transforming into the new state done() // sets the migration as finished }, down: function(migration, DataTypes, done) { // logic for reverting the changes done() // sets the migration as finished } } The passed migration object can be used to modify the database. The DataTypes object stores the available data types such as STRING or INTEGER . The third parameter is a callback function which needs to be called once everything was executed. The first parameter of the callback function can be used to pass a possible error. In that case, the migration will be marked as failed. Here is some code: module.exports = { up: function(migration, DataTypes, done) { migration.dropAllTables().complete(done) // equals: migration.dropAllTables().complete(function(err) { if (err) { done(err) } else { done(null) } }) } } The available methods of the migration object are the following. Functions Using the migration object describe before, you will have access to most of already introduced functions. Furthermore there are some other methods, which are designed to actually change the database schema. createTable(tableName, attributes, options) This method allows creation of new tables. It is allowed to pass simple or complex attribute definitions. You can define the encoding of the table and the table's engine via options migration.createTable( 'nameOfTheNewTable', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, createdAt: { type: DataTypes.DATE }, updatedAt: { type: DataTypes.DATE }, attr1: DataTypes.STRING, attr2: DataTypes.INTEGER, attr3: { type: DataTypes.BOOLEAN, defaultValue: false, allowNull: false } }, { engine: 'MYISAM', // default: 'InnoDB' charset: 'latin1' // default: null } ) dropTable(tableName) This method allows deletion of an existing table. migration.dropTable('nameOfTheExistingTable') dropAllTables() This method allows deletion of all existing tables in the database. migration.dropAllTables() renameTable(before, after) This method allows renaming of an existing table. migration.renameTable('Person', 'User') showAllTables() This method returns the name of all existing tables in the database. migration.showAllTables().success(function(tableNames) {}) describeTable(tableName) This method returns an array of hashes containing information about all attributes in the table. migration.describeTable('Person').success(function(attributes) { /* attributes will be something like: { name: { type: 'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg! allowNull: true, defaultValue: null }, isBetaMember: { type: 'TINYINT(1)', // this will be 'BOOLEAN' for pg! allowNull: false, defaultValue: false } } */ }) addColumn(tableName, attributeName, dataTypeOrOptions) This method allows adding columns to an existing table. The data type can be simple or complex. migration.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', DataTypes.STRING ) // or migration.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', { type: DataTypes.STRING, allowNull: false } ) removeColumn(tableName, attributeName) This method allows deletion of a specific column of an existing table. migration.removeColumn('Person', 'signature') changeColumn(tableName, attributeName, dataTypeOrOptions) This method changes the meta data of an attribute. It is possible to change the default value, allowance of null or the data type. Please make sure, that you are completely describing the new data type. Missing information are expected to be defaults. migration.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', DataTypes.STRING ) // or migration.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', { type: DataTypes.FLOAT, allowNull: false, default: 0.0 } ) renameColumn(tableName, attrNameBefore, attrNameAfter) This methods allows renaming attributes. migration.renameColumn('Person', 'signature', 'sig') addIndex(tableName, attributes, options) This methods creates indexes for specific attributes of a table. The index name will be automatically generated if it is not passed via in the options (see below). // This example will create the index person_firstname_lastname migration.addIndex('Person', ['firstname', 'lastname']) // This example will create a unique index with the name SuperDuperIndex using the optional 'options' field. // Possible options: // - indicesType: UNIQUE|FULLTEXT|SPATIAL // - indexName: The name of the index. Default is __ // - parser: For FULLTEXT columns set your parser // - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect migration.addIndex( 'Person', ['firstname', 'lastname'], { indexName: 'SuperDuperIndex', indicesType: 'UNIQUE' } ) removeIndex(tableName, indexNameOrAttributes) This method deletes an existing index of a table. migration.removeIndex('Person', 'SuperDuperIndex') // or migration.removeIndex('Person', ['firstname', 'lastname']) Programmatic use If you need to interact with the migrator within your code, you can easily achieve that via sequelize.getMigrator . You can specify the path to your migrations as well as a pattern which represents the files that contain the migrations. var migrator = sequelize.getMigrator({ path: process.cwd() + '/database/migrations', filesFilter: /\\.coffee$/ }) Once you have a migrator object, you can run its migration with migrator.migrate . By default, this will execute all the up methods within your pending migrations. If you want to rollback a migration, just call it like this: migrator .migrate({ method: 'down' }) .success(function() { // The migrations have been executed! })","title":"Migrations"},{"location":"docs/migrations/#the-cli","text":"In order to use the CLI you need to install the respective package: $ npm install --save sequelize-cli The CLI currently supports the following commands: $ sequelize db:migrate # Run pending migrations. $ sequelize db:migrate:undo # Revert the last migration run. $ sequelize help # Display this help text. $ sequelize init # Initializes the project. $ sequelize migration:create # Generates a new migration file. $ sequelize version # Prints the version number. Further and more detailled information about the available commands can be obtained via the help command: $ sequelize help:init $ sequelize help:db:migrate $ sequelize help:db:migrate:undo # etc The latter one for example will print out the following output: Sequelize [CLI: v0.0.2, ORM: v1.7.5] COMMANDS sequelize db:migrate:undo -- Revert the last migration run. DESCRIPTION Revert the last migration run. OPTIONS --env The environment to run the command in. Default: development --options-path The path to a JSON file with additional options. Default: none --coffee Enables coffee script support. Default: false --config The path to the config file. Default: config/config.json","title":"The CLI"},{"location":"docs/migrations/#skeleton","text":"The following skeleton shows a typical migration file. All migrations are expected to be located in a folder called migrations at the very top of the project. The sequelize binary can generate a migration skeleton. See the aboves section for more details. module.exports = { up: function(migration, DataTypes, done) { // logic for transforming into the new state done() // sets the migration as finished }, down: function(migration, DataTypes, done) { // logic for reverting the changes done() // sets the migration as finished } } The passed migration object can be used to modify the database. The DataTypes object stores the available data types such as STRING or INTEGER . The third parameter is a callback function which needs to be called once everything was executed. The first parameter of the callback function can be used to pass a possible error. In that case, the migration will be marked as failed. Here is some code: module.exports = { up: function(migration, DataTypes, done) { migration.dropAllTables().complete(done) // equals: migration.dropAllTables().complete(function(err) { if (err) { done(err) } else { done(null) } }) } } The available methods of the migration object are the following.","title":"Skeleton"},{"location":"docs/migrations/#functions","text":"Using the migration object describe before, you will have access to most of already introduced functions. Furthermore there are some other methods, which are designed to actually change the database schema.","title":"Functions"},{"location":"docs/migrations/#createtabletablename-attributes-options","text":"This method allows creation of new tables. It is allowed to pass simple or complex attribute definitions. You can define the encoding of the table and the table's engine via options migration.createTable( 'nameOfTheNewTable', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, createdAt: { type: DataTypes.DATE }, updatedAt: { type: DataTypes.DATE }, attr1: DataTypes.STRING, attr2: DataTypes.INTEGER, attr3: { type: DataTypes.BOOLEAN, defaultValue: false, allowNull: false } }, { engine: 'MYISAM', // default: 'InnoDB' charset: 'latin1' // default: null } )","title":"createTable&lpar;tableName&comma; attributes&comma; options&rpar;"},{"location":"docs/migrations/#droptabletablename","text":"This method allows deletion of an existing table. migration.dropTable('nameOfTheExistingTable')","title":"dropTable&lpar;tableName&rpar;"},{"location":"docs/migrations/#dropalltables","text":"This method allows deletion of all existing tables in the database. migration.dropAllTables()","title":"dropAllTables&lpar;&rpar;"},{"location":"docs/migrations/#renametablebefore-after","text":"This method allows renaming of an existing table. migration.renameTable('Person', 'User')","title":"renameTable&lpar;before&comma; after&rpar;"},{"location":"docs/migrations/#showalltables","text":"This method returns the name of all existing tables in the database. migration.showAllTables().success(function(tableNames) {})","title":"showAllTables&lpar;&rpar;"},{"location":"docs/migrations/#describetabletablename","text":"This method returns an array of hashes containing information about all attributes in the table. migration.describeTable('Person').success(function(attributes) { /* attributes will be something like: { name: { type: 'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg! allowNull: true, defaultValue: null }, isBetaMember: { type: 'TINYINT(1)', // this will be 'BOOLEAN' for pg! allowNull: false, defaultValue: false } } */ })","title":"describeTable&lpar;tableName&rpar;"},{"location":"docs/migrations/#addcolumntablename-attributename-datatypeoroptions","text":"This method allows adding columns to an existing table. The data type can be simple or complex. migration.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', DataTypes.STRING ) // or migration.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', { type: DataTypes.STRING, allowNull: false } )","title":"addColumn&lpar;tableName&comma; attributeName&comma; dataTypeOrOptions&rpar;"},{"location":"docs/migrations/#removecolumntablename-attributename","text":"This method allows deletion of a specific column of an existing table. migration.removeColumn('Person', 'signature')","title":"removeColumn&lpar;tableName&comma; attributeName&rpar;"},{"location":"docs/migrations/#changecolumntablename-attributename-datatypeoroptions","text":"This method changes the meta data of an attribute. It is possible to change the default value, allowance of null or the data type. Please make sure, that you are completely describing the new data type. Missing information are expected to be defaults. migration.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', DataTypes.STRING ) // or migration.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', { type: DataTypes.FLOAT, allowNull: false, default: 0.0 } )","title":"changeColumn&lpar;tableName&comma; attributeName&comma; dataTypeOrOptions&rpar;"},{"location":"docs/migrations/#renamecolumntablename-attrnamebefore-attrnameafter","text":"This methods allows renaming attributes. migration.renameColumn('Person', 'signature', 'sig')","title":"renameColumn&lpar;tableName&comma; attrNameBefore&comma; attrNameAfter&rpar;"},{"location":"docs/migrations/#addindextablename-attributes-options","text":"This methods creates indexes for specific attributes of a table. The index name will be automatically generated if it is not passed via in the options (see below). // This example will create the index person_firstname_lastname migration.addIndex('Person', ['firstname', 'lastname']) // This example will create a unique index with the name SuperDuperIndex using the optional 'options' field. // Possible options: // - indicesType: UNIQUE|FULLTEXT|SPATIAL // - indexName: The name of the index. Default is __ // - parser: For FULLTEXT columns set your parser // - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect migration.addIndex( 'Person', ['firstname', 'lastname'], { indexName: 'SuperDuperIndex', indicesType: 'UNIQUE' } )","title":"addIndex&lpar;tableName&comma; attributes&comma; options&rpar;"},{"location":"docs/migrations/#removeindextablename-indexnameorattributes","text":"This method deletes an existing index of a table. migration.removeIndex('Person', 'SuperDuperIndex') // or migration.removeIndex('Person', ['firstname', 'lastname'])","title":"removeIndex&lpar;tableName&comma; indexNameOrAttributes&rpar;"},{"location":"docs/migrations/#programmatic-use","text":"If you need to interact with the migrator within your code, you can easily achieve that via sequelize.getMigrator . You can specify the path to your migrations as well as a pattern which represents the files that contain the migrations. var migrator = sequelize.getMigrator({ path: process.cwd() + '/database/migrations', filesFilter: /\\.coffee$/ }) Once you have a migrator object, you can run its migration with migrator.migrate . By default, this will execute all the up methods within your pending migrations. If you want to rollback a migration, just call it like this: migrator .migrate({ method: 'down' }) .success(function() { // The migrations have been executed! })","title":"Programmatic use"},{"location":"docs/misc/","text":"Utils / Lodash.js Sequelize comes with some handy utils including references to lodash as well as some individual helpers. You can access them via Sequelize.Utils . You can access all the methods of lodash like this: Sequelize.Utils._.each(/* ... */) Sequelize.Utils._.map(/* ... */) Sequelize.Utils._... Check out the Lodash page for further information. Compatibility Sequelize is compatible to the following versions of Node.JS: 0.8.x 0.10.x Asynchronicity Since v1&period;3&period;0 there are multiple ways of adding listeners to asynchronous requests. First of all, each time you call a finder method or save an object, sequelize triggers asynchronous logic. To react to the success or the failure (or both) of the request, you can do the following: // the old, pre-v1.3.0 way Model.findAll().on('success', function(models) { /* foo */ }) Model.findAll().on('failure', function(err) { /* bar */ }) // the new, >=v1.3.0 way // each one is valid Model.findAll().on('success', function(models) { /* foo */ }) Model.findAll().success(function(models) { /* foo */ }) Model.findAll().ok(function(models) { /* foo */ }) // Model.findAll().on('failure', function(err) { /* bar */ }) ==> invalid since v1.5.0 Model.findAll().on('error', function(err) { /* bar */ }) // ==> new since v1.5.0 Model.findAll().error(function(err) { /* bar */ }) Model.findAll().failure(function(err) { /* bar */ }) Model.findAll().fail(function(err) { /* bar */ }) Model.findAll().complete(function(err, result) { /* bar */ }) Model.findAll().done(function(err, result) { /* bar */ }) // As of 1.7.0 we support Promises/A var self = User user.find(1).then(function(user1) { return user1.increment(['aNumber'], 2) }).then(function(user2) { return user.find(1) }).then(function(user3) { console.log(user3.aNumber) // 2 }, function(err) { // err... }) // For functions with multiple success values (e.g. findOrCreate) there is also spread user.findOrCreate(...).spread(function(user, wasCreated) { // all arguments are passed }) user.findOrCreate(...).then(function(user) { // only the first argument is passed }) Please notice: Since v1.5.0 the 'error' event is used to notify about errors. If such events aren't caught however, Node.JS will throw an error. So you would probably like to catch them :D Additional links If you want to keep track about latest development of sequelize or to just discuss things with other sequelize users you might want to take a look at the following resources: Twitter: @sdepold Twitter: @sequelizejs ADN: @sdepold IRC: sequelizejs@freenode.net XING Facebook Companies & Projects Here is a list of companies and projects that are using Sequelize in real world applications: Shutterstock Shutterstock Images LLC is a leading global provider of high-quality stock footage, stock photography, vectors and illustrations to creative industry professionals around the world. Shutterstock works closely with its growing contributor community of artists, photographers, videographers and illustrators to curate a global marketplace for royalty-free, top-quality imagery. Shutterstock adds tens of thousands of rights-cleared images and footage clips each week, with more than 18 million files currently available. Clevertech Clevertech builds web and mobile applications for startups using Lean and Agile methodologies. Clevertech relies on Sequelize for its applications, its speed, versatility and data flexibility. Clevertech contributes back to open source development and its expert developers support the continuing effort to make sequelize the best ORM for Node projects. Metamarkets Metamarkets enables buyers and sellers of digital media to visualize insights and make decisions with real-time pricing, performance, and audience data. filsh filsh allows you to download online videos from various video portals like YouTube, Vimeo and Dailymotion in a format you like. No software required. Using sequelize? If you want to get listed here, just drop me a line or send me a pull-request on Github!","title":"Misc"},{"location":"docs/misc/#utils-lodashjs","text":"Sequelize comes with some handy utils including references to lodash as well as some individual helpers. You can access them via Sequelize.Utils . You can access all the methods of lodash like this: Sequelize.Utils._.each(/* ... */) Sequelize.Utils._.map(/* ... */) Sequelize.Utils._... Check out the Lodash page for further information.","title":"Utils / Lodash.js"},{"location":"docs/misc/#compatibility","text":"Sequelize is compatible to the following versions of Node.JS: 0.8.x 0.10.x","title":"Compatibility"},{"location":"docs/misc/#asynchronicity","text":"Since v1&period;3&period;0 there are multiple ways of adding listeners to asynchronous requests. First of all, each time you call a finder method or save an object, sequelize triggers asynchronous logic. To react to the success or the failure (or both) of the request, you can do the following: // the old, pre-v1.3.0 way Model.findAll().on('success', function(models) { /* foo */ }) Model.findAll().on('failure', function(err) { /* bar */ }) // the new, >=v1.3.0 way // each one is valid Model.findAll().on('success', function(models) { /* foo */ }) Model.findAll().success(function(models) { /* foo */ }) Model.findAll().ok(function(models) { /* foo */ }) // Model.findAll().on('failure', function(err) { /* bar */ }) ==> invalid since v1.5.0 Model.findAll().on('error', function(err) { /* bar */ }) // ==> new since v1.5.0 Model.findAll().error(function(err) { /* bar */ }) Model.findAll().failure(function(err) { /* bar */ }) Model.findAll().fail(function(err) { /* bar */ }) Model.findAll().complete(function(err, result) { /* bar */ }) Model.findAll().done(function(err, result) { /* bar */ }) // As of 1.7.0 we support Promises/A var self = User user.find(1).then(function(user1) { return user1.increment(['aNumber'], 2) }).then(function(user2) { return user.find(1) }).then(function(user3) { console.log(user3.aNumber) // 2 }, function(err) { // err... }) // For functions with multiple success values (e.g. findOrCreate) there is also spread user.findOrCreate(...).spread(function(user, wasCreated) { // all arguments are passed }) user.findOrCreate(...).then(function(user) { // only the first argument is passed }) Please notice: Since v1.5.0 the 'error' event is used to notify about errors. If such events aren't caught however, Node.JS will throw an error. So you would probably like to catch them :D","title":"Asynchronicity"},{"location":"docs/misc/#additional-links","text":"If you want to keep track about latest development of sequelize or to just discuss things with other sequelize users you might want to take a look at the following resources: Twitter: @sdepold Twitter: @sequelizejs ADN: @sdepold IRC: sequelizejs@freenode.net XING Facebook","title":"Additional links"},{"location":"docs/misc/#companies-projects","text":"Here is a list of companies and projects that are using Sequelize in real world applications:","title":"Companies &amp; Projects"},{"location":"docs/misc/#shutterstock","text":"Shutterstock Images LLC is a leading global provider of high-quality stock footage, stock photography, vectors and illustrations to creative industry professionals around the world. Shutterstock works closely with its growing contributor community of artists, photographers, videographers and illustrators to curate a global marketplace for royalty-free, top-quality imagery. Shutterstock adds tens of thousands of rights-cleared images and footage clips each week, with more than 18 million files currently available.","title":"Shutterstock"},{"location":"docs/misc/#clevertech","text":"Clevertech builds web and mobile applications for startups using Lean and Agile methodologies. Clevertech relies on Sequelize for its applications, its speed, versatility and data flexibility. Clevertech contributes back to open source development and its expert developers support the continuing effort to make sequelize the best ORM for Node projects.","title":"Clevertech"},{"location":"docs/misc/#metamarkets","text":"Metamarkets enables buyers and sellers of digital media to visualize insights and make decisions with real-time pricing, performance, and audience data.","title":"Metamarkets"},{"location":"docs/misc/#filsh","text":"filsh allows you to download online videos from various video portals like YouTube, Vimeo and Dailymotion in a format you like. No software required.","title":"filsh"},{"location":"docs/misc/#using-sequelize","text":"If you want to get listed here, just drop me a line or send me a pull-request on Github!","title":"Using sequelize&quest;"},{"location":"docs/models/","text":"Definition To define mappings between a model and a table, use the define method. Sequelize will then automatically add the attributes createdAt and updatedAt to it. So you will be able to know when the database entry went into the db and when it was updated the last time. If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to configuration to see how to do that. var Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT }) var Task = sequelize.define('Task', { title: Sequelize.STRING, description: Sequelize.TEXT, deadline: Sequelize.DATE }) You can also set some options on each column: var Foo = sequelize.define('Foo', { // instantiating will automatically set the flag to true if not set flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // default values for dates => current time myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // setting allowNull to false will add NOT NULL to the column, which means an error will be // thrown from the DB when the query is executed if the column is null. If you want to check that a value // is not null before querying the DB, look at the validations section below. title: { type: Sequelize.STRING, allowNull: false}, // Creating two objects with the same value will throw an error. The unique property can be either a // boolean, or a string. If you provide the same string for multiple columns, they will form a // composite unique key. someUnique: {type: Sequelize.STRING, unique: true}, uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // Go on reading for further information about primary keys identifier: { type: Sequelize.STRING, primaryKey: true}, // autoIncrement can be used to create auto_incrementing integer columns incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, // Comments can be specified for each field for MySQL and PG hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // You can specify a custom field name via the \"field\" attribute: fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" } }) The comment option can also be used on a table, see model configuration Data types Sequelize currently supports the following datatypes: Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically) The BLOB data type allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer. If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser: require('pg').types.setTypeParser(1114, function(stringValue) { return new Date(stringValue + \"+0000\"); // e.g., UTC offset. Use any offset that you would like. }); In addition to the type mentioned above, integer, bigint and float also support unsigned and zerofill properties, which can be combined in any order: Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL The examples above only show integer, but the same can be done with bigint and float Usage in object notation: // for enums: sequelize.define('model', { states: { type: Sequelize.ENUM, values: ['active', 'pending', 'deleted'] } }) Getters & setters It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties. Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches!): as part of a single property definition as part of a model options N.B.: If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence. Defining as part of a property var Foo = sequelize.define('Foo', { name: { Sequelize.STRING }, title: { type : Sequelize.STRING, allowNull: false, get : function() { /* do your magic here and return something! 'this' allows you to access attributes of the model. example: this.getDataValue('name') works */ }, set : function(v) { /* do your magic with the input here! */ } } }); Defining as part of the model options Below is an example of defining the getters and setters in the model options, notice the title_slugslug getter, it shows how you can define pseudo properties on your models! (the slugify() function was taken from the Underscore.String module , it is slightly modified here so that the example remains self-contained), note that the this.title reference in the title_slug getter function will trigger a call to the title getter function. if you do not want that then use the getDataValue() method ( see below ). var defaultToWhiteSpace = function(characters) { if (characters == null) return '\\\\s'; else if (characters.source) return characters.source; else return ; }; var slugify = function(str) { var from = \"\u0105\u00e0\u00e1\u00e4\u00e2\u00e3\u00e5\u00e6\u0107\u0119\u00e8\u00e9\u00eb\u00ea\u00ec\u00ed\u00ef\u00ee\u0142\u0144\u00f2\u00f3\u00f6\u00f4\u00f5\u00f8\u015b\u00f9\u00fa\u00fc\u00fb\u00f1\u00e7\u017c\u017a\", to = \"aaaaaaaaceeeeeiiiilnoooooosuuuunczz\", regex = new RegExp('[' + from.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1') + ']', 'g'); if (str == null) return ''; str = String(str).toLowerCase().replace(regex, function(c) { return to.charAt(from.indexOf(c)) || '-'; }); return str.replace(/[^\\w\\s-]/g, '').replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase(); } var Foo = sequelize.define('Foo', { title: { type : Sequelize.STRING, allowNull: false, } }, { getterMethods : { title : function() { /* do your magic here and return something! */ }, title_slug : function() { return slugify(this.title); } }, setterMethods : { title : function(v) { /* do your magic with the input here! */ }, } }); Helper functions for use inside getter/setter definitions retrieving an underlying property value? always use this.getDataValu() , e.g: /* a getter for 'title' property */ function() { return this.getDataValue('title'); } setting an underlying property value? always use this.setDataValue() , e.g.: /* a setter for 'title' property */ function(title) { return this.setDataValue('title', title.toString().toLowerCase()); } N.B.: It is important to stick to using the setDataValue() and getDataValue() functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations (i.e. how and where data values are stored in your model instances) Setter methods and Object Initialization !!!TODO: write about how setters affect object initialization (both creating new objects with Model.build and retrieving existing objects from storage) !!!!! Validations Model validations, allow you to specify format/content/inheritance validations for each attribute of the model. You can perform the validation by calling the validate() method on an instance before saving. The validations are implemented by validator . Note: In v1.7.0 validations will now be called when executing the build() or create() functions. var ValidateMe = sequelize.define('Foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: [\"[a-z]\",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true // will only allow alphanumeric characters, so \"_abc\" will fail isNumeric: true // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: \"2011-11-05\", // only allow date strings after a specific date isBefore: \"2011-11-05\", // only allow date strings before a specific date max: 23, // only allow values min: 23, // only allow values >= 23 isArray: true, // only allow arrays isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }) Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for isIn , this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as [['one', 'two']] as shown above. To use a custom error message instead of that provided by node-validator, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with isInt: { msg: \"Must be an integer number of pennies\" } or if arguments need to also be passed add an args property: isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } When using custom validator functions the error message will be whatever message the thrown Error object holds. See the node-validator project for more details on the built in validation methods. Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged. Validators and allowNull Since v1.7.0 if a particular field of a model is set to allow null (with allowNull: true ) and that value has been set to null , its validators do not run. This means you can, for instance, have a string field which validates its length to be at least 5 characters, but which also allows null . Model validations Since v1.7.0 , validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of latitude and longitude are set or both, and fail if one but not the other is set. Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators. Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the validate option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors. (Note that the structure of validate() 's output is scheduled to change in v2.0 to avoid this awkward situation. In the mean time, an error is issued if a field exists with the same name as a custom model validation.) An example: var Pub = Sequelize.define('Pub', { name: { type: Sequelize.STRING }, address: { type: Sequelize.STRING }, latitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -90, max: 90 } }, longitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -180, max: 180 } }, }, { validate: { bothCoordsOrNone: function() { if ((this.latitude === null) === (this.longitude === null)) { throw new Error('Require either both latitude and longitude or neither') } } } }) In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and nolongitude, raging_bullock_arms.validate() might return { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither'] } Configuration You can also influence the way Sequelize handles your column names: var Bar = sequelize.define('Bar', { /* bla */ }, { // don't add the timestamp attributes (updatedAt, createdAt) timestamps: false, // don't delete database entries but set the newly added attribute deletedAt // to the current date (when deletion was done). paranoid will only work if // timestamps are enabled paranoid: true, // don't use camelcase for automatically added attributes but underscore style // so updatedAt will be updated_at underscored: true, // disable the modification of tablenames; By default, sequelize will automatically // transform all passed model names (first parameter of define) into plural. // if you don't want that, set the following freezeTableName: true, // define the table's name tableName: 'my_very_custom_table_name' }) If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually: var Foo = sequelize.define('Foo', { /* bla */ }, { // don't forget to enable timestamps! timestamps: true, // I don't want createdAt createdAt: false, // I want updatedAt to actually be called updateTimestamp updatedAt: 'updateTimestamp' // And deletedAt to be called destroyTime (remember to enable paranoid for this to work) deletedAt: 'destroyTime', paranoid: true }) You can also change the database engine, e.g. to MyISAM. InnoDB is the default. var Person = sequelize.define('Person', { /* attributes */ }, { engine: 'MYISAM' }) // or globally var sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) Finaly you can specify a comment for the table in MySQL and PG var Person = sequelize.define('Person', { /* attributes */ }, { comment: \"I'm a table comment!\" }) Import You can also store your model definitions in a single file using the import method. The returned object is exactly the same as defined in the imported file's function. Since v1:5.0 of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often. // in your server file - e.g. app.js var Project = sequelize.import(__dirname + \"/path/to/models/project\") // The model definition is done in /path/to/models/project.js // As you might notice, the DataTypes are the very same as explained above module.exports = function(sequelize, DataTypes) { return sequelize.define(\"Project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) } Since v1.7.0 the import method can now accept a callback as an argument. sequelize.import('Project', function(sequelize, DataTypes) { return sequelize.define(\"Project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) }) Database synchronization When starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables: // Create the tables: Project.sync() // will emit success or failure event Task.sync() // will emit success or failure event // Force the creation! Project.sync({force: true}) // this will drop the table first and re-create it afterwards // drop the tables: Project.drop() // will emit success or failure event Task.drop() // will emit success or failure event // event handling: Project.[sync|drop]().success(function() { // ok ... everything is nice! }).error(function(error) { // oooh, did you entered wrong database credentials? }) Because synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you: // create all tables... now! sequelize.sync() // will emit success or failure // force it! sequelize.sync({force: true}) // emit ... nomnomnom // want to drop 'em all? sequelize.drop() // I guess you've got it (emit) // emit handling: sequelize.[sync|drop]().success(function() { // woot woot }).error(function(error) { // whooops }) Expansion of models Sequelize allows you to pass custom methods to a model and it's instances. Just do the following: var Foo = sequelize.define('Foo', { /* attributes */}, { classMethods: { method1: function(){ return 'smth' } }, instanceMethods: { method2: function() { return 'foo' } } }) // Example: Foo.method1() Foo.build().method2() Of course you can also access the instance's data and generate virtual getters: var User = sequelize.define('User', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { instanceMethods: { getFullname: function() { return [this.firstname, this.lastname].join(' ') } } }) // Example: User.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar' You can also set custom methods to all of your models during the instantiation: var sequelize = new Sequelize('database', 'username', 'password', { // Other options during the initialization could be here define: { classMethods: { method1: function() {}, method2: function() {} }, instanceMethods: { method3: function() {} } } }) // Example: var Foo = sequelize.define('Foo', { /* attributes */}); Foo.method1() Foo.method2() Foo.build().method3() Data retrieval / Finders Finder methods are designed to get data from the database. The returned data isn't just a plain object, but instances of one of the defined classes. Check the next major chapter about instances for further information. But as those things are instances, you can e.g. use the just describe expanded instance methods. So, here is what you can do: find - Search for one specific element in the database // search for known ids Project.find(123).success(function(project) { // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null }) // search for attributes Project.find({ where: {title: 'aProject'} }).success(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null }) // since v1.3.0: only select some attributes and rename one Project.find({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).success(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null // project.title will contain the name of the project }) findOrCreate - Search for a specific element or create it if not available The method findOrCreate can be used to check if a certain element is already existing in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created. Let's assume we have an empty database with a User model which has a username and a job . User .findOrCreate({ username: 'sdepold' }, { job: 'Technical Lead JavaScript' }) .success(function(user, created) { console.log(user.values) console.log(created) /* { username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: true */ }) The code created a new instance. So when we already have an instance ... User .create({ username: 'fnord', job: 'omnomnom' }) .success(function() { User .findOrCreate({ username: 'fnord' }, { job: 'something else' }) .success(function(user, created) { console.log(user.values) console.log(created) /* { username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: false */ }) }) ... the existing entry will not be changed. See the job of the second user, and the fact that created was false. Notice that the success callback has two arguments. When using promises you should call spread (API ref) instead of then , since then will only recieve the first argument (the DAO), while spread will recieve both the DAO, and the created boolean. findAndCountAll - Search for multiple elements in the database, returns both data and total count This is a convienience method that combines findAll&lpar;&rpar; and count&lpar;&rpar; (see below), this is useful when dealing with queries related to pagination where you want to retrieve data with a limit and offset but also need to know the total number of records that match the query. The success handler will always receive an object with two properties: count - an integer, total number records (matching the where clause) rows - an array of objects, the records (matching the where clause) within the limit/offset range Project .findAndCountAll({ where: [\"title LIKE 'foo%'\"], offset: 10, limit: 2 }) .success(function(result) { console.log(result.count); console.log(result.rows); }); The options [object] that you pass to findAndCountAll&lpar;&rpar; is the same as for findAll&lpar;&rpar; (described below). findAll - Search for multiple elements in the database // find multiple entries Project.findAll().success(function(projects) { // projects will be an array of all Project instances }) // also possible: Project.all().success(function(projects) { // projects will be an array of all Project instances }) // search for specific attributes - hash usage Project.findAll({ where: { name: 'A Project' } }).success(function(projects) { // projects will be an array of Project instances with the specified name }) // search with string replacements Project.findAll({ where: [\"id > ?\", 25] }).success(function(projects) { // projects will be an array of Projects having a greater id than 25 }) // search within a specific range Project.findAll({ where: { id: [1,2,3] } }).success(function(projects) { // projects will be an array of Projects having the id 1, 2 or 3 // this is actually doing an IN query }) // or Project.findAll({ where: \"name = 'A Project'\" }).success(function(projects) { // the difference between this and the usage of hashes (objects) is, that string usage // is not sql injection safe. so make sure you know what you are doing! }) // since v1.7.0 we can now improve our where searches Project.findAll({ where: { id: { gt: 6, // id > 6 gte: 6, // id >= 6 lt: 10, // id < 10 lte: 10, // id ne: 20, // id != 20 between: [6, 10], // BETWEEN 6 AND 10 nbetween: [11, 15] // NOT BETWEEN 11 AND 15 } } }) Complex filtering / OR queries Since v1.7.0-rc3 , it is possible to do complex where queries with multiple levels of nested AND and OR conditions. In order to do that you can use Sequelize.or and Sequelize.and and pass an arbitrary amount of arguments to it. Every argument will get transformed into a proper SQL condition and gets joined with the either AND or OR . Project.find({ where: Sequelize.and( { name: 'a project' }, Sequelize.or( { id: [1,2,3] }, { id: { lt: 10 } } ) ) }) This code will generate the following query: SELECT * FROM `Projects` WHERE ( `Projects`.`name`='a project' AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` < 10) ) LIMIT 1 ; Notice, that instead of Sequelize.and you can also use a plain array which will be treated as Sequelize.and if it contains objects or hashes or other complex data types. Furthermore you can use Sequelize.or as value for the where clause. Manipulating the dataset with limit, offset, order and group To get more relevant data, you can use limit, offset, order and grouping: // limit the results of the query Project.findAll({ limit: 10 }) // step over the first 10 elements Project.findAll({ offset: 10 }) // step over the first 10 elements, and take 2 Project.findAll({ offset: 10, limit: 2 }) The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group Project.findAll({order: 'title DESC'}) // yields ORDER BY title DESC Project.findAll({group: 'name'}) // yields GROUP BY name Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order / group, this will always be the case as per v 1.7.0. If you want to escape column names, you should provide an array of arguments, even though you only want to order / group by a single column something.find({ order: [ 'name', // will return `name` 'username DESC', // will return `username DESC` -- i.e. don't do it! ['username', 'DESC'], // will return `username` DESC sequelize.fn('max', sequelize.col('age')), // will return max(`age`) [sequelize.fn('max', sequelize.col('age')), 'DESC'], // will return max(`age`) DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // will return otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite! [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC'] // This won't be quoted, but direction will be added ] }) To recap, the elements of the order / group array can be the following: String - will be quoted Array - first element will be qouted, second will be appended verbatim Object - Raw will be added verbatim without quoting Everything else is ignored, and if raw is not set, the query will fail Sequelize.fn and Sequelize.col returns functions and quoted cools Raw queries Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates a_DAO_, with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data. // Are you expecting a masssive dataset from the DB, and don't want to spend the time building DAOs for each entry? // You can pass an extra query option to get the raw data instead: Project.findAll({ where: ... }, { raw: true }) count - Count the occurences of elements in the database There is also a method for counting database objects: Project.count().success(function(c) { console.log(\"There are \" + c + \" projects!\") }) Project.count({ where: [\"id > ?\", 25] }).success(function(c) { console.log(\"There are \" + c + \" projects with an id greater than 25.\") }) max - Get the greatest value of a specific attribute within a specific table And here is a method for getting the max value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.max('age').success(function(max) { // this will return 40 }) Project.max('age', { where: { age: { lt: 20 } } }).success(function(max) { // will be 10 }) min - Get the least value of a specific attribute within a specific table And here is a method for getting the min value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.min('age').success(function(min) { // this will return 5 }) Project.min('age', { where: { age: { gt: 5 } } }).success(function(min) { // will be 10 }) sum - Sum the value of specific attributes In order to calculate the sum over a specific column of a table, you can use the sum method. /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.sum('age').success(function(sum) { // this will return 55 }) Project.sum('age', { where: { age: { gt: 5 } } }).success(function(sum) { // wil be 50 }) Eager loading When you are retrieving data from the database there is a fair chance that you also want to get their associations. This is possible since v1&period;6&period;0 and is called eager loading. The basic idea behind that, is the use of the attribute include when you are calling find or findAll . Lets assume the following setup: var User = sequelize.define('User', { name: Sequelize.STRING }) , Task = sequelize.define('Task', { name: Sequelize.STRING }) , Tool = sequelize.define('Tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().done(function() { // this is where we continue ... }) OK. So, first of all, let's load all tasks with their associated user. Task.findAll({ include: [ User ] }).success(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"UserId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) Notice that the accessor of the associated data is the name of the model in camelcase with lowercased first character. Also the accessor is singular as the association is one-to-something. Next thing: Loading of data with many-to-something associations! User.findAll({ include: [ Task ] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"UserId\": 1 }] }] */ }) Notice that the accessor is plural. This is because the association is many-to-something. If an association is aliased (using the as option), you_must_specify this alias when including the model. Notice how the user's Tool s are aliased as Instruments above. In order to get that right you have to specify the model you want to load, as well as the alias: User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"UserId\": 1 }] }] */ }) Ordering Eager Loaded Associations In the case of a one-to-many relationship. Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name' ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, 'name' ] ] }); In the case of many-to-many joins, you are also able to sort by attributes in the through table. Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, 'name' ] ] }); Nested eager loading User.findAll({ include: [ {model: Tool, as: 'Instruments', include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"instruments\": [{ // 1:M and N:M association \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"UserId\": 1, \"Teacher\": { // 1:1 association \"name\": \"Jimi Hendrix\" } }] }] */ }) Final note: If you include an object which is not associated, Sequelize will throw an error. Tool.findAll({ include: [ User ] }).success(function(tools) { console.log(JSON.stringify(tools)) }) // Error: User is not associated to Tool!","title":"Models"},{"location":"docs/models/#definition","text":"To define mappings between a model and a table, use the define method. Sequelize will then automatically add the attributes createdAt and updatedAt to it. So you will be able to know when the database entry went into the db and when it was updated the last time. If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to configuration to see how to do that. var Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT }) var Task = sequelize.define('Task', { title: Sequelize.STRING, description: Sequelize.TEXT, deadline: Sequelize.DATE }) You can also set some options on each column: var Foo = sequelize.define('Foo', { // instantiating will automatically set the flag to true if not set flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // default values for dates => current time myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // setting allowNull to false will add NOT NULL to the column, which means an error will be // thrown from the DB when the query is executed if the column is null. If you want to check that a value // is not null before querying the DB, look at the validations section below. title: { type: Sequelize.STRING, allowNull: false}, // Creating two objects with the same value will throw an error. The unique property can be either a // boolean, or a string. If you provide the same string for multiple columns, they will form a // composite unique key. someUnique: {type: Sequelize.STRING, unique: true}, uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // Go on reading for further information about primary keys identifier: { type: Sequelize.STRING, primaryKey: true}, // autoIncrement can be used to create auto_incrementing integer columns incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, // Comments can be specified for each field for MySQL and PG hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // You can specify a custom field name via the \"field\" attribute: fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" } }) The comment option can also be used on a table, see model configuration","title":"Definition"},{"location":"docs/models/#data-types","text":"Sequelize currently supports the following datatypes: Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically) The BLOB data type allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer. If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser: require('pg').types.setTypeParser(1114, function(stringValue) { return new Date(stringValue + \"+0000\"); // e.g., UTC offset. Use any offset that you would like. }); In addition to the type mentioned above, integer, bigint and float also support unsigned and zerofill properties, which can be combined in any order: Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL The examples above only show integer, but the same can be done with bigint and float Usage in object notation: // for enums: sequelize.define('model', { states: { type: Sequelize.ENUM, values: ['active', 'pending', 'deleted'] } })","title":"Data types"},{"location":"docs/models/#getters-setters","text":"It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties. Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches!): as part of a single property definition as part of a model options N.B.: If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence.","title":"Getters &amp; setters"},{"location":"docs/models/#defining-as-part-of-a-property","text":"var Foo = sequelize.define('Foo', { name: { Sequelize.STRING }, title: { type : Sequelize.STRING, allowNull: false, get : function() { /* do your magic here and return something! 'this' allows you to access attributes of the model. example: this.getDataValue('name') works */ }, set : function(v) { /* do your magic with the input here! */ } } });","title":"Defining as part of a property"},{"location":"docs/models/#defining-as-part-of-the-model-options","text":"Below is an example of defining the getters and setters in the model options, notice the title_slugslug getter, it shows how you can define pseudo properties on your models! (the slugify() function was taken from the Underscore.String module , it is slightly modified here so that the example remains self-contained), note that the this.title reference in the title_slug getter function will trigger a call to the title getter function. if you do not want that then use the getDataValue() method ( see below ). var defaultToWhiteSpace = function(characters) { if (characters == null) return '\\\\s'; else if (characters.source) return characters.source; else return ; }; var slugify = function(str) { var from = \"\u0105\u00e0\u00e1\u00e4\u00e2\u00e3\u00e5\u00e6\u0107\u0119\u00e8\u00e9\u00eb\u00ea\u00ec\u00ed\u00ef\u00ee\u0142\u0144\u00f2\u00f3\u00f6\u00f4\u00f5\u00f8\u015b\u00f9\u00fa\u00fc\u00fb\u00f1\u00e7\u017c\u017a\", to = \"aaaaaaaaceeeeeiiiilnoooooosuuuunczz\", regex = new RegExp('[' + from.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1') + ']', 'g'); if (str == null) return ''; str = String(str).toLowerCase().replace(regex, function(c) { return to.charAt(from.indexOf(c)) || '-'; }); return str.replace(/[^\\w\\s-]/g, '').replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase(); } var Foo = sequelize.define('Foo', { title: { type : Sequelize.STRING, allowNull: false, } }, { getterMethods : { title : function() { /* do your magic here and return something! */ }, title_slug : function() { return slugify(this.title); } }, setterMethods : { title : function(v) { /* do your magic with the input here! */ }, } });","title":"Defining as part of the model options"},{"location":"docs/models/#helper-functions-for-use-inside-gettersetter-definitions","text":"retrieving an underlying property value? always use this.getDataValu() , e.g: /* a getter for 'title' property */ function() { return this.getDataValue('title'); } setting an underlying property value? always use this.setDataValue() , e.g.: /* a setter for 'title' property */ function(title) { return this.setDataValue('title', title.toString().toLowerCase()); } N.B.: It is important to stick to using the setDataValue() and getDataValue() functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations (i.e. how and where data values are stored in your model instances)","title":"Helper functions for use inside getter&sol;setter definitions"},{"location":"docs/models/#setter-methods-and-object-initialization","text":"!!!TODO: write about how setters affect object initialization (both creating new objects with Model.build and retrieving existing objects from storage) !!!!!","title":"Setter methods and Object Initialization"},{"location":"docs/models/#validations","text":"Model validations, allow you to specify format/content/inheritance validations for each attribute of the model. You can perform the validation by calling the validate() method on an instance before saving. The validations are implemented by validator . Note: In v1.7.0 validations will now be called when executing the build() or create() functions. var ValidateMe = sequelize.define('Foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: [\"[a-z]\",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true // will only allow alphanumeric characters, so \"_abc\" will fail isNumeric: true // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: \"2011-11-05\", // only allow date strings after a specific date isBefore: \"2011-11-05\", // only allow date strings before a specific date max: 23, // only allow values min: 23, // only allow values >= 23 isArray: true, // only allow arrays isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }) Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for isIn , this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as [['one', 'two']] as shown above. To use a custom error message instead of that provided by node-validator, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with isInt: { msg: \"Must be an integer number of pennies\" } or if arguments need to also be passed add an args property: isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } When using custom validator functions the error message will be whatever message the thrown Error object holds. See the node-validator project for more details on the built in validation methods. Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.","title":"Validations"},{"location":"docs/models/#validators-andallownull","text":"Since v1.7.0 if a particular field of a model is set to allow null (with allowNull: true ) and that value has been set to null , its validators do not run. This means you can, for instance, have a string field which validates its length to be at least 5 characters, but which also allows null .","title":"Validators andallowNull"},{"location":"docs/models/#model-validations","text":"Since v1.7.0 , validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of latitude and longitude are set or both, and fail if one but not the other is set. Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators. Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the validate option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors. (Note that the structure of validate() 's output is scheduled to change in v2.0 to avoid this awkward situation. In the mean time, an error is issued if a field exists with the same name as a custom model validation.) An example: var Pub = Sequelize.define('Pub', { name: { type: Sequelize.STRING }, address: { type: Sequelize.STRING }, latitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -90, max: 90 } }, longitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -180, max: 180 } }, }, { validate: { bothCoordsOrNone: function() { if ((this.latitude === null) === (this.longitude === null)) { throw new Error('Require either both latitude and longitude or neither') } } } }) In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and nolongitude, raging_bullock_arms.validate() might return { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither'] }","title":"Model validations"},{"location":"docs/models/#configuration","text":"You can also influence the way Sequelize handles your column names: var Bar = sequelize.define('Bar', { /* bla */ }, { // don't add the timestamp attributes (updatedAt, createdAt) timestamps: false, // don't delete database entries but set the newly added attribute deletedAt // to the current date (when deletion was done). paranoid will only work if // timestamps are enabled paranoid: true, // don't use camelcase for automatically added attributes but underscore style // so updatedAt will be updated_at underscored: true, // disable the modification of tablenames; By default, sequelize will automatically // transform all passed model names (first parameter of define) into plural. // if you don't want that, set the following freezeTableName: true, // define the table's name tableName: 'my_very_custom_table_name' }) If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually: var Foo = sequelize.define('Foo', { /* bla */ }, { // don't forget to enable timestamps! timestamps: true, // I don't want createdAt createdAt: false, // I want updatedAt to actually be called updateTimestamp updatedAt: 'updateTimestamp' // And deletedAt to be called destroyTime (remember to enable paranoid for this to work) deletedAt: 'destroyTime', paranoid: true }) You can also change the database engine, e.g. to MyISAM. InnoDB is the default. var Person = sequelize.define('Person', { /* attributes */ }, { engine: 'MYISAM' }) // or globally var sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) Finaly you can specify a comment for the table in MySQL and PG var Person = sequelize.define('Person', { /* attributes */ }, { comment: \"I'm a table comment!\" })","title":"Configuration"},{"location":"docs/models/#import","text":"You can also store your model definitions in a single file using the import method. The returned object is exactly the same as defined in the imported file's function. Since v1:5.0 of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often. // in your server file - e.g. app.js var Project = sequelize.import(__dirname + \"/path/to/models/project\") // The model definition is done in /path/to/models/project.js // As you might notice, the DataTypes are the very same as explained above module.exports = function(sequelize, DataTypes) { return sequelize.define(\"Project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) } Since v1.7.0 the import method can now accept a callback as an argument. sequelize.import('Project', function(sequelize, DataTypes) { return sequelize.define(\"Project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) })","title":"Import"},{"location":"docs/models/#database-synchronization","text":"When starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables: // Create the tables: Project.sync() // will emit success or failure event Task.sync() // will emit success or failure event // Force the creation! Project.sync({force: true}) // this will drop the table first and re-create it afterwards // drop the tables: Project.drop() // will emit success or failure event Task.drop() // will emit success or failure event // event handling: Project.[sync|drop]().success(function() { // ok ... everything is nice! }).error(function(error) { // oooh, did you entered wrong database credentials? }) Because synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you: // create all tables... now! sequelize.sync() // will emit success or failure // force it! sequelize.sync({force: true}) // emit ... nomnomnom // want to drop 'em all? sequelize.drop() // I guess you've got it (emit) // emit handling: sequelize.[sync|drop]().success(function() { // woot woot }).error(function(error) { // whooops })","title":"Database synchronization"},{"location":"docs/models/#expansion-of-models","text":"Sequelize allows you to pass custom methods to a model and it's instances. Just do the following: var Foo = sequelize.define('Foo', { /* attributes */}, { classMethods: { method1: function(){ return 'smth' } }, instanceMethods: { method2: function() { return 'foo' } } }) // Example: Foo.method1() Foo.build().method2() Of course you can also access the instance's data and generate virtual getters: var User = sequelize.define('User', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { instanceMethods: { getFullname: function() { return [this.firstname, this.lastname].join(' ') } } }) // Example: User.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar' You can also set custom methods to all of your models during the instantiation: var sequelize = new Sequelize('database', 'username', 'password', { // Other options during the initialization could be here define: { classMethods: { method1: function() {}, method2: function() {} }, instanceMethods: { method3: function() {} } } }) // Example: var Foo = sequelize.define('Foo', { /* attributes */}); Foo.method1() Foo.method2() Foo.build().method3()","title":"Expansion of models"},{"location":"docs/models/#data-retrieval-finders","text":"Finder methods are designed to get data from the database. The returned data isn't just a plain object, but instances of one of the defined classes. Check the next major chapter about instances for further information. But as those things are instances, you can e.g. use the just describe expanded instance methods. So, here is what you can do:","title":"Data retrieval / Finders"},{"location":"docs/models/#find-search-for-one-specific-element-in-the-database","text":"// search for known ids Project.find(123).success(function(project) { // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null }) // search for attributes Project.find({ where: {title: 'aProject'} }).success(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null }) // since v1.3.0: only select some attributes and rename one Project.find({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).success(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null // project.title will contain the name of the project })","title":"find - Search for one specific element in the database"},{"location":"docs/models/#findorcreate-search-for-a-specific-element-or-create-it-if-not-available","text":"The method findOrCreate can be used to check if a certain element is already existing in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created. Let's assume we have an empty database with a User model which has a username and a job . User .findOrCreate({ username: 'sdepold' }, { job: 'Technical Lead JavaScript' }) .success(function(user, created) { console.log(user.values) console.log(created) /* { username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: true */ }) The code created a new instance. So when we already have an instance ... User .create({ username: 'fnord', job: 'omnomnom' }) .success(function() { User .findOrCreate({ username: 'fnord' }, { job: 'something else' }) .success(function(user, created) { console.log(user.values) console.log(created) /* { username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: false */ }) }) ... the existing entry will not be changed. See the job of the second user, and the fact that created was false. Notice that the success callback has two arguments. When using promises you should call spread (API ref) instead of then , since then will only recieve the first argument (the DAO), while spread will recieve both the DAO, and the created boolean.","title":"findOrCreate - Search for a specific element or create it if not available"},{"location":"docs/models/#findandcountall-search-for-multiple-elements-in-the-database-returns-both-data-and-total-count","text":"This is a convienience method that combines findAll&lpar;&rpar; and count&lpar;&rpar; (see below), this is useful when dealing with queries related to pagination where you want to retrieve data with a limit and offset but also need to know the total number of records that match the query. The success handler will always receive an object with two properties: count - an integer, total number records (matching the where clause) rows - an array of objects, the records (matching the where clause) within the limit/offset range Project .findAndCountAll({ where: [\"title LIKE 'foo%'\"], offset: 10, limit: 2 }) .success(function(result) { console.log(result.count); console.log(result.rows); }); The options [object] that you pass to findAndCountAll&lpar;&rpar; is the same as for findAll&lpar;&rpar; (described below).","title":"findAndCountAll - Search for multiple elements in the database&comma; returns both data and total count"},{"location":"docs/models/#findall-search-for-multiple-elements-in-the-database","text":"// find multiple entries Project.findAll().success(function(projects) { // projects will be an array of all Project instances }) // also possible: Project.all().success(function(projects) { // projects will be an array of all Project instances }) // search for specific attributes - hash usage Project.findAll({ where: { name: 'A Project' } }).success(function(projects) { // projects will be an array of Project instances with the specified name }) // search with string replacements Project.findAll({ where: [\"id > ?\", 25] }).success(function(projects) { // projects will be an array of Projects having a greater id than 25 }) // search within a specific range Project.findAll({ where: { id: [1,2,3] } }).success(function(projects) { // projects will be an array of Projects having the id 1, 2 or 3 // this is actually doing an IN query }) // or Project.findAll({ where: \"name = 'A Project'\" }).success(function(projects) { // the difference between this and the usage of hashes (objects) is, that string usage // is not sql injection safe. so make sure you know what you are doing! }) // since v1.7.0 we can now improve our where searches Project.findAll({ where: { id: { gt: 6, // id > 6 gte: 6, // id >= 6 lt: 10, // id < 10 lte: 10, // id ne: 20, // id != 20 between: [6, 10], // BETWEEN 6 AND 10 nbetween: [11, 15] // NOT BETWEEN 11 AND 15 } } })","title":"findAll - Search for multiple elements in the database"},{"location":"docs/models/#complex-filtering-or-queries","text":"Since v1.7.0-rc3 , it is possible to do complex where queries with multiple levels of nested AND and OR conditions. In order to do that you can use Sequelize.or and Sequelize.and and pass an arbitrary amount of arguments to it. Every argument will get transformed into a proper SQL condition and gets joined with the either AND or OR . Project.find({ where: Sequelize.and( { name: 'a project' }, Sequelize.or( { id: [1,2,3] }, { id: { lt: 10 } } ) ) }) This code will generate the following query: SELECT * FROM `Projects` WHERE ( `Projects`.`name`='a project' AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` < 10) ) LIMIT 1 ; Notice, that instead of Sequelize.and you can also use a plain array which will be treated as Sequelize.and if it contains objects or hashes or other complex data types. Furthermore you can use Sequelize.or as value for the where clause.","title":"Complex filtering / OR queries"},{"location":"docs/models/#manipulating-the-dataset-with-limit-offset-order-and-group","text":"To get more relevant data, you can use limit, offset, order and grouping: // limit the results of the query Project.findAll({ limit: 10 }) // step over the first 10 elements Project.findAll({ offset: 10 }) // step over the first 10 elements, and take 2 Project.findAll({ offset: 10, limit: 2 }) The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group Project.findAll({order: 'title DESC'}) // yields ORDER BY title DESC Project.findAll({group: 'name'}) // yields GROUP BY name Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order / group, this will always be the case as per v 1.7.0. If you want to escape column names, you should provide an array of arguments, even though you only want to order / group by a single column something.find({ order: [ 'name', // will return `name` 'username DESC', // will return `username DESC` -- i.e. don't do it! ['username', 'DESC'], // will return `username` DESC sequelize.fn('max', sequelize.col('age')), // will return max(`age`) [sequelize.fn('max', sequelize.col('age')), 'DESC'], // will return max(`age`) DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // will return otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite! [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC'] // This won't be quoted, but direction will be added ] }) To recap, the elements of the order / group array can be the following: String - will be quoted Array - first element will be qouted, second will be appended verbatim Object - Raw will be added verbatim without quoting Everything else is ignored, and if raw is not set, the query will fail Sequelize.fn and Sequelize.col returns functions and quoted cools","title":"Manipulating the dataset with limit&comma; offset&comma; order and group"},{"location":"docs/models/#raw-queries","text":"Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates a_DAO_, with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data. // Are you expecting a masssive dataset from the DB, and don't want to spend the time building DAOs for each entry? // You can pass an extra query option to get the raw data instead: Project.findAll({ where: ... }, { raw: true })","title":"Raw queries"},{"location":"docs/models/#count-count-the-occurences-of-elements-in-the-database","text":"There is also a method for counting database objects: Project.count().success(function(c) { console.log(\"There are \" + c + \" projects!\") }) Project.count({ where: [\"id > ?\", 25] }).success(function(c) { console.log(\"There are \" + c + \" projects with an id greater than 25.\") })","title":"count - Count the occurences of elements in the database"},{"location":"docs/models/#max-get-the-greatest-value-of-a-specific-attribute-within-a-specific-table","text":"And here is a method for getting the max value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.max('age').success(function(max) { // this will return 40 }) Project.max('age', { where: { age: { lt: 20 } } }).success(function(max) { // will be 10 })","title":"max - Get the greatest value of a specific attribute within a specific table"},{"location":"docs/models/#min-get-the-least-value-of-a-specific-attribute-within-a-specific-table","text":"And here is a method for getting the min value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.min('age').success(function(min) { // this will return 5 }) Project.min('age', { where: { age: { gt: 5 } } }).success(function(min) { // will be 10 })","title":"min - Get the least value of a specific attribute within a specific table"},{"location":"docs/models/#sum-sum-the-value-of-specific-attributes","text":"In order to calculate the sum over a specific column of a table, you can use the sum method. /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.sum('age').success(function(sum) { // this will return 55 }) Project.sum('age', { where: { age: { gt: 5 } } }).success(function(sum) { // wil be 50 })","title":"sum - Sum the value of specific attributes"},{"location":"docs/models/#eager-loading","text":"When you are retrieving data from the database there is a fair chance that you also want to get their associations. This is possible since v1&period;6&period;0 and is called eager loading. The basic idea behind that, is the use of the attribute include when you are calling find or findAll . Lets assume the following setup: var User = sequelize.define('User', { name: Sequelize.STRING }) , Task = sequelize.define('Task', { name: Sequelize.STRING }) , Tool = sequelize.define('Tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().done(function() { // this is where we continue ... }) OK. So, first of all, let's load all tasks with their associated user. Task.findAll({ include: [ User ] }).success(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"UserId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) Notice that the accessor of the associated data is the name of the model in camelcase with lowercased first character. Also the accessor is singular as the association is one-to-something. Next thing: Loading of data with many-to-something associations! User.findAll({ include: [ Task ] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"UserId\": 1 }] }] */ }) Notice that the accessor is plural. This is because the association is many-to-something. If an association is aliased (using the as option), you_must_specify this alias when including the model. Notice how the user's Tool s are aliased as Instruments above. In order to get that right you have to specify the model you want to load, as well as the alias: User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"UserId\": 1 }] }] */ })","title":"Eager loading"},{"location":"docs/models/#ordering-eager-loaded-associations","text":"In the case of a one-to-many relationship. Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name' ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, 'name' ] ] }); In the case of many-to-many joins, you are also able to sort by attributes in the through table. Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, 'name' ] ] });","title":"Ordering Eager Loaded Associations"},{"location":"docs/models/#nested-eager-loading","text":"User.findAll({ include: [ {model: Tool, as: 'Instruments', include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).success(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"instruments\": [{ // 1:M and N:M association \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"UserId\": 1, \"Teacher\": { // 1:1 association \"name\": \"Jimi Hendrix\" } }] }] */ }) Final note: If you include an object which is not associated, Sequelize will throw an error. Tool.findAll({ include: [ User ] }).success(function(tools) { console.log(JSON.stringify(tools)) }) // Error: User is not associated to Tool!","title":"Nested eager loading"},{"location":"docs/promises/","text":"TODO - something about how promises work","title":"Promises"},{"location":"docs/transactions/","text":"Transactions sequelize.transaction(function(t) { // we just opened a new connection to the database which is transaction exclusive. // also we send some first transaction queries to the database. // do some async stuff ... // if everything is ok ... commit the transaction t.commit().success(function() {}) // if something failed ... rollback the transaction t.rollback().success(function() {}) // the commit / rollback will emit events which can be observed via: t.done(function() { /* we will be here once the transaction has been committed / reverted */ }) }) sequelize.transaction(function(t) { User.create({ username: 'foo' }, { transaction: t }).success(function() { // this user will only be available inside the session User.all({ transaction: t }) // will return the user User.all() // will not return the user }) })","title":"Transactions"},{"location":"docs/transactions/#transactions","text":"sequelize.transaction(function(t) { // we just opened a new connection to the database which is transaction exclusive. // also we send some first transaction queries to the database. // do some async stuff ... // if everything is ok ... commit the transaction t.commit().success(function() {}) // if something failed ... rollback the transaction t.rollback().success(function() {}) // the commit / rollback will emit events which can be observed via: t.done(function() { /* we will be here once the transaction has been committed / reverted */ }) }) sequelize.transaction(function(t) { User.create({ username: 'foo' }, { transaction: t }).success(function() { // this user will only be available inside the session User.all({ transaction: t }) // will return the user User.all() // will not return the user }) })","title":"Transactions"},{"location":"docs/usage/","text":"Basic usage To get the ball rollin' you first have to create an instance of Sequelize. Use it the following way: var sequelize = new Sequelize('database', 'username'[, 'password']) This will save the passed database credentials and provide all further methods. Furthermore you can specify a non-default host/port: var sequelize = new Sequelize('database', 'username', 'password', { host: \"my.server.tld\", port: 12345 }) If you just don't have a password: var sequelize = new Sequelize('database', 'username') // or var sequelize = new Sequelize('database', 'username', null) You can also use a connection string: var sequelize = new Sequelize('mysql://user:pass@example.com:9821/dbname', { // Look to the next section for possible options }) Options Besides the host and the port, Sequelize comes with a whole bunch of options. Here they are: var sequelize = new Sequelize('database', 'username', 'password', { // custom host; default: localhost host: 'my.server.tld', // custom port; default: 3306 port: 12345, // custom protocol // - default: 'tcp' // - added in: v1.5.0 // - postgres only, useful for heroku protocol: null, // disable logging; default: console.log logging: false, // max concurrent database requests; default: 50 maxConcurrentQueries: 100, // the sql dialect of the database // - default is 'mysql' // - currently supported: 'mysql', 'sqlite', 'postgres', 'mariadb' dialect: 'mysql', // you can also pass any dialect options to the underlying dialect library // - default is empty // - currently supported: 'mysql', 'mariadb' dialectOptions: { socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock', supportBigNumbers: true, bigNumberStrings: true }, // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite', // disable inserting undefined values as NULL // - default: false omitNull: true, // a flag for using a native library or not. // in the case of 'pg' -- set this to true will allow SSL support // - default: false native: true, // Specify options, which are used when sequelize.define is called. // The following example: // define: {timestamps: false} // is basically the same as: // sequelize.define(name, attributes, { timestamps: false }) // so defining the timestamps for each model will be not necessary // Below you can see the possible keys for settings. All of them are explained on this page define: { underscored: false freezeTableName: false, syncOnAssociation: true, charset: 'utf8', collate: 'utf8_general_ci', classMethods: {method1: function() {}}, instanceMethods: {method2: function() {}}, timestamps: true }, // similiar for sync: you can define this to always force sync for models sync: { force: true }, // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true syncOnAssociation: true, // use pooling in order to reduce db connection overload and to increase speed // currently only for mysql and postgresql (since v1.5.0) pool: { maxConnections: 5, maxIdleTime: 30}, // language is used to determine how to translate words into singular or plural form based on the [lingo project](https://github.com/visionmedia/lingo) // options are: en [default], es language: 'en' }) Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged. Read replication Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is not handled by Sequelize, but should be set up in MySql). var sequelize = new Sequelize('database', null, null, { dialect: 'mysql', port: 3306 replication: { read: [ { host: '8.8.8.8', username: 'anotherusernamethanroot', password: 'lolcats!' }, { host: 'localhost', username: 'root', password: null } ], write: { host: 'localhost', username: 'root', password: null } }, pool: { // If you want to override the options used for the read pool you can do so here maxConnections: 20, maxIdleTime: 30000 }, }) If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options: host , port , username , password , database Sequelize uses a pool to manage connections to your replicas. The default options are: { maxConnections: 10, minConnections: 0, maxIdleTime: 1000 } If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above. Note: Read replication only works for MySQL at the moment! Dialects With the release of Sequelize v1&period;6&period;0 , the library got independent from specific dialects. This means, that you'll have to add the respective connector library to your project yourself. Version 1.7.0 stable has been released in bundles with the connector libraries (sequelize-mysql, sequelize-postgres etc.) but these bundles are not maintained, and will not be released for 2.0.0 upwards. MySQL In order to get Sequelize working nicely together with MySQL, you'll need to install mysql&commat;~2&period;0&period;0-alpha7 or higher. Once that's done you can use it like this: var sequelize = new Sequelize('database', 'username', 'password', { // mysql is the default dialect, but you know... // for demo purporses we are defining it nevertheless :) // so: we want mysql! dialect: 'mysql' }) Note: You can pass options directly to dialect library by setting the dialectOptions parameter. See Options for examples (currently only mysql and mariadb are supported). MariaDB For MariaDB compatibility you have to install the package mariasql@0.1.20 , or higher. The configuration needs to look like this: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mariadb' }) SQLite For SQLite compatibility you'll need sqlite3&commat;~2&period;1&period;5 . Configure Sequelize like this: var sequelize = new Sequelize('database', 'username', 'password', { // sqlite! now! dialect: 'sqlite', // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite' }) PostgreSQL The library for PostgreSQL is pg&commat;~2&period;0&period;0 . You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { // gimme postgres, please! dialect: 'postgres' }) Executing raw SQL queries As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize&period;query . Here is how it works: // Arguments for raw queries sequelize.query('your query', [, callee], [, options], [, replacements]) // Quick example sequelize.query(\"SELECT * FROM myTable\").success(function(myTableRows) { console.log(myTableRows) }) // Callee is the model definition. This allows you to easily map a query // to a predefined model for sequelizejs e.g: sequelize .query('SELECT * FROM projects', Projects) .success(function(projects){ // Each record will now be mapped to the project's DAO-Factory. console.log(projects) }) // Options is an object with the following keys: sequelize .query('SELECT 1', null, { // A function (or false) for logging your queries // Will get called for every SQL query that gets send // to the server. logging: console.log, // If plain is true, then sequelize will only return the first // record of the result set. In case of false it will all records. plain: false, // Set this to true if you don't have a model definition for your query. raw: false }) // Note the second argument being null! // Even if we declared a callee here, the raw: true would // supersede and return a raw object. sequelize .query('SELECT * FROM projects', null, { raw: true }) .success(function(projects) { console.log(projects) }) Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? The syntax used depends on the fourth argument passed to the function: If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice verca, an exception will be thrown. sequelize .query( 'SELECT * FROM projects WHERE status = ?', null, { raw: true }, ['active'] ) .success(function(projects) { console.log(projects) }) sequelize .query( 'SELECT * FROM projects WHERE status = :status ', null, { raw: true }, { status: 'active' } ) .success(function(projects) { console.log(projects) }) One note: If the attribute names of the table contain dots, the resulting objects will be nested: sequelize.query('select 1 as `foo.bar.baz`').success(function(rows) { console.log(JSON.stringify(rows)) /* [{ \"foo\": { \"bar\": { \"baz\": 1 } } }] */ })","title":"Usage"},{"location":"docs/usage/#basic-usage","text":"To get the ball rollin' you first have to create an instance of Sequelize. Use it the following way: var sequelize = new Sequelize('database', 'username'[, 'password']) This will save the passed database credentials and provide all further methods. Furthermore you can specify a non-default host/port: var sequelize = new Sequelize('database', 'username', 'password', { host: \"my.server.tld\", port: 12345 }) If you just don't have a password: var sequelize = new Sequelize('database', 'username') // or var sequelize = new Sequelize('database', 'username', null) You can also use a connection string: var sequelize = new Sequelize('mysql://user:pass@example.com:9821/dbname', { // Look to the next section for possible options })","title":"Basic usage"},{"location":"docs/usage/#options","text":"Besides the host and the port, Sequelize comes with a whole bunch of options. Here they are: var sequelize = new Sequelize('database', 'username', 'password', { // custom host; default: localhost host: 'my.server.tld', // custom port; default: 3306 port: 12345, // custom protocol // - default: 'tcp' // - added in: v1.5.0 // - postgres only, useful for heroku protocol: null, // disable logging; default: console.log logging: false, // max concurrent database requests; default: 50 maxConcurrentQueries: 100, // the sql dialect of the database // - default is 'mysql' // - currently supported: 'mysql', 'sqlite', 'postgres', 'mariadb' dialect: 'mysql', // you can also pass any dialect options to the underlying dialect library // - default is empty // - currently supported: 'mysql', 'mariadb' dialectOptions: { socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock', supportBigNumbers: true, bigNumberStrings: true }, // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite', // disable inserting undefined values as NULL // - default: false omitNull: true, // a flag for using a native library or not. // in the case of 'pg' -- set this to true will allow SSL support // - default: false native: true, // Specify options, which are used when sequelize.define is called. // The following example: // define: {timestamps: false} // is basically the same as: // sequelize.define(name, attributes, { timestamps: false }) // so defining the timestamps for each model will be not necessary // Below you can see the possible keys for settings. All of them are explained on this page define: { underscored: false freezeTableName: false, syncOnAssociation: true, charset: 'utf8', collate: 'utf8_general_ci', classMethods: {method1: function() {}}, instanceMethods: {method2: function() {}}, timestamps: true }, // similiar for sync: you can define this to always force sync for models sync: { force: true }, // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true syncOnAssociation: true, // use pooling in order to reduce db connection overload and to increase speed // currently only for mysql and postgresql (since v1.5.0) pool: { maxConnections: 5, maxIdleTime: 30}, // language is used to determine how to translate words into singular or plural form based on the [lingo project](https://github.com/visionmedia/lingo) // options are: en [default], es language: 'en' }) Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.","title":"Options"},{"location":"docs/usage/#read-replication","text":"Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is not handled by Sequelize, but should be set up in MySql). var sequelize = new Sequelize('database', null, null, { dialect: 'mysql', port: 3306 replication: { read: [ { host: '8.8.8.8', username: 'anotherusernamethanroot', password: 'lolcats!' }, { host: 'localhost', username: 'root', password: null } ], write: { host: 'localhost', username: 'root', password: null } }, pool: { // If you want to override the options used for the read pool you can do so here maxConnections: 20, maxIdleTime: 30000 }, }) If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options: host , port , username , password , database Sequelize uses a pool to manage connections to your replicas. The default options are: { maxConnections: 10, minConnections: 0, maxIdleTime: 1000 } If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above. Note: Read replication only works for MySQL at the moment!","title":"Read replication"},{"location":"docs/usage/#dialects","text":"With the release of Sequelize v1&period;6&period;0 , the library got independent from specific dialects. This means, that you'll have to add the respective connector library to your project yourself. Version 1.7.0 stable has been released in bundles with the connector libraries (sequelize-mysql, sequelize-postgres etc.) but these bundles are not maintained, and will not be released for 2.0.0 upwards.","title":"Dialects"},{"location":"docs/usage/#mysql","text":"In order to get Sequelize working nicely together with MySQL, you'll need to install mysql&commat;~2&period;0&period;0-alpha7 or higher. Once that's done you can use it like this: var sequelize = new Sequelize('database', 'username', 'password', { // mysql is the default dialect, but you know... // for demo purporses we are defining it nevertheless :) // so: we want mysql! dialect: 'mysql' }) Note: You can pass options directly to dialect library by setting the dialectOptions parameter. See Options for examples (currently only mysql and mariadb are supported).","title":"MySQL"},{"location":"docs/usage/#mariadb","text":"For MariaDB compatibility you have to install the package mariasql@0.1.20 , or higher. The configuration needs to look like this: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mariadb' })","title":"MariaDB"},{"location":"docs/usage/#sqlite","text":"For SQLite compatibility you'll need sqlite3&commat;~2&period;1&period;5 . Configure Sequelize like this: var sequelize = new Sequelize('database', 'username', 'password', { // sqlite! now! dialect: 'sqlite', // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite' })","title":"SQLite"},{"location":"docs/usage/#postgresql","text":"The library for PostgreSQL is pg&commat;~2&period;0&period;0 . You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { // gimme postgres, please! dialect: 'postgres' })","title":"PostgreSQL"},{"location":"docs/usage/#executing-raw-sql-queries","text":"As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize&period;query . Here is how it works: // Arguments for raw queries sequelize.query('your query', [, callee], [, options], [, replacements]) // Quick example sequelize.query(\"SELECT * FROM myTable\").success(function(myTableRows) { console.log(myTableRows) }) // Callee is the model definition. This allows you to easily map a query // to a predefined model for sequelizejs e.g: sequelize .query('SELECT * FROM projects', Projects) .success(function(projects){ // Each record will now be mapped to the project's DAO-Factory. console.log(projects) }) // Options is an object with the following keys: sequelize .query('SELECT 1', null, { // A function (or false) for logging your queries // Will get called for every SQL query that gets send // to the server. logging: console.log, // If plain is true, then sequelize will only return the first // record of the result set. In case of false it will all records. plain: false, // Set this to true if you don't have a model definition for your query. raw: false }) // Note the second argument being null! // Even if we declared a callee here, the raw: true would // supersede and return a raw object. sequelize .query('SELECT * FROM projects', null, { raw: true }) .success(function(projects) { console.log(projects) }) Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? The syntax used depends on the fourth argument passed to the function: If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice verca, an exception will be thrown. sequelize .query( 'SELECT * FROM projects WHERE status = ?', null, { raw: true }, ['active'] ) .success(function(projects) { console.log(projects) }) sequelize .query( 'SELECT * FROM projects WHERE status = :status ', null, { raw: true }, { status: 'active' } ) .success(function(projects) { console.log(projects) }) One note: If the attribute names of the table contain dots, the resulting objects will be nested: sequelize.query('select 1 as `foo.bar.baz`').success(function(rows) { console.log(JSON.stringify(rows)) /* [{ \"foo\": { \"bar\": { \"baz\": 1 } } }] */ })","title":"Executing raw SQL queries"}]}