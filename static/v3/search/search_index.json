{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sequelize Sequelize is a promise-based ORM for Node.js and io.js. It supports the dialects PostgreSQL, MySQL, MariaDB, SQLite and MSSQL and features solid transaction support, relations, read replication and more. Installation Example usage var Sequelize = require('sequelize'); var sequelize = new Sequelize('database', 'username', 'password'); var User = sequelize.define('user', { username: Sequelize.STRING, birthday: Sequelize.DATE }); sequelize.sync().then(function() { return User.create({ username: 'janedoe', birthday: new Date(1980, 6, 20) }); }).then(function(jane) { console.log(jane.get({ plain: true })); });","title":"Home"},{"location":"#example-usage","text":"var Sequelize = require('sequelize'); var sequelize = new Sequelize('database', 'username', 'password'); var User = sequelize.define('user', { username: Sequelize.STRING, birthday: Sequelize.DATE }); sequelize.sync().then(function() { return User.create({ username: 'janedoe', birthday: new Date(1980, 6, 20) }); }).then(function(jane) { console.log(jane.get({ plain: true })); });","title":"Example usage"},{"location":"changelog/","text":"Future v3.31.1 [FIXED] postgres/connection-manager: Only fetch OIDs once #8733 v3.31.0 [FIXED] Passing parameters to model getters #7404 [FIXED] changeColumn generates incorrect query with ENUM type #7456 [ADDED] ARRAY(ENUM) support for Postgres #8703 3.30.3 [ADDED] Ability to run transactions on a read-replica by marking transactions as read only #7323 [FIXED] Add quotes around column names for unique constraints in sqlite #4407 3.30.2 [FIXED] previous method gave wrong value back #7189 [FIXED] Fixes setAssociation with scope #7223 [FIXED] Including a virtual field can give an empty query #7164 [FIXED] Fixes creation of polymorphic belongsToMany associations in one step #7159 #7181 3.30.1 [FIXED] sourceKey FOR hasMany now also works if a where was specified in an include #7141 [CHANGED] Updated deprecated node-uuid package to uuid #7148 [FIXED] Updating VIRTUAL field throw ER_EMPTY_QUERY #6356 3.30.0 [FIXED] removeColumn method to support dropping primaryKey column (MSSQL) #7081 [ADDED] Support sourceKey for hasMany relationships #4258 3.29.0 [FIXED] Transaction Name too long, transaction savepoints for SQL Server #6972 3.28.0 [FIXED] Soft-delete not returning number of affected rows on mssql #6916 [ADDED] afterConnect hook [FIXED] Range integer parsing #6897 [FIXED] Upsert return value for mysql #6963 3.27.0 [FIXED] Incorrect column name for generateThroughJoin #6878 [ADDED] Support condition objects in utility functions #6685 3.26.0 [ADDED] Backport of mssql upsert #6875 3.25.1 [FIXED] fix instance.set '1970-01-01' to null field #6839 [FIXED] Can not execute raw SQL queries for sqlite3 #6865 3.25.0 [FIXED] Set timestamps and paranoid options from through model on belongsToMany association [FIXED] Properly apply paranoid condition when groupedLimit.on association is paranoid [FIXED] restore now uses field from deletedAt [ADDED] option.silent for increment and decrement #6793 3.24.7 [FIXED] MSSQL bulkInsertQuery when options and attributes are not passed [#6782] 3.24.6 [FIXED] groupedLimit.through.where support 3.24.5 [FIXED] GroupedLimit when foreignKey has a field alias 3.24.4 [FIXED] - ORDER clause was not included in subquery if order option value was provided as plain string (not as an array value) [FIXED] Issue with belongsTo association and foreign keys #6400 [FIXED] Check that parent exists before appending attributes #6472 [FIXED] Default options for insert queries #6644 3.24.3 [ADDED] Backport of grouped limit include support [ADDED] Export datatypes #6578 3.24.2 [FIXED] Accept dates as string while using typeValidation #6453 3.24.1 [FIXED] Add parent , original and sql properties to UniqueConstraintError 3.24.0 [ADDED] restartIdentity option for truncate in postgres #5356 3.23.5 3.23.4 [FIXED] Fixed an issue where custom-named model fields break when offsetting, ordering, and including hasMany simultaneously. #5985 [FIXED] Don't remove includes from count queries and unify findAndCount and count queries. #6123 [FIXED] Model.count don't include attributes #5057 [SECURITY] GEOMETRY and GEOGRAPHY SQL injection attacks #6194 3.23.3 [FIXED] Pass ResourceLock instead of raw connection in MSSQL disconnect handling 3.23.2 [FIXED] Type validation now works with non-strings due to updated validator@5.0.0 #5861 [FIXED] Improved offset and limit support for SQL server 2008 #5616 [FIXED] options object cloned in all Sequelize methods (so not modified within Sequelize) 3.23.1 [FIXED] Postgres DECIMAL precision. (PostgreSQL) #4893 [FIXED] removeColumn tries to delete non-existant foreign key constraint (mysql) #5808 [FIXED] Relation constraints not being applied correctly #5865 3.23.0 [FIXED] Invalid query generated when using LIKE + ANY #5736 [FIXED] Method QueryInterface.bulkDelete no longer working when the model parameter is missing. (PostgreSQL) #5615 [ADDED] Context and custom options for deep creation [FIXED] Dates with millisecond precision are inserted correctly in MySQL #5855 3.22.0 [FIXED] Fix defaultValues getting overwritten on build [FIXED] Queue queries against tedious connections [ADDED] Enable type validation for all queries 3.21.0 [FIXED] Confirmed that values modified in validation hooks are preserved #3534 [FIXED] Support lower case type names in SQLite #5482 [FIXED] Support calling setAssociation twice on hasOne #5315 [INTERNALS] Removed dependency on wellknown in favor of terraformer-wkt-parser [ADDED] Benchmarking feature #2494 [INTERNALS] Add Utils.mergeDeep - allows lodash to be updated to latest version 3.20.0 [ADDED] rejectOnEmpty mode #272 #5480 [ADDED] beforeCount hook #5209 [ADDED] validationFailed hook #1626 [ADDED] Support for IEEE floating point literals in postgres and sqlite #5194 [FIXED] addColumn with reference in mysql #5592 [FIXED] findAndCountAll generates invalid SQL, subQuery moves to LEFT OUTER JOIN #5445 [FIXED] count methods pollute the options.includes #4191 [FIXED] Invalid SQL generated when using group option along with attributes #3009 [FIXED] Mark index as unique: true when type: 'UNIQUE' . Fixes #5351 [FIXED] Improper escaping of bound arrays of strings on Postgres, SQLite, and Microsoft SQL Server 3.19.3 [FIXED] updatedAt and createdAt values are now set before validation #5367 [FIXED] describeTable maintains proper enum casing in mysql #5321 [FIXED] Parsing of dates in MySQL, when a named timezone is used #4208 [FIXED] Truncating in Postgres, when table has a schema #4306 [FIXED] Moved initialization of scopes later in the model init process. Fixes attribute exclusion in scopes, #4735 and #4925 [FIXED] Multiple custom unique validation messages being overwritten by the first-defined message, #4920 3.19.0 [ADDED] Geography support for postgres [FIXED] Migrations failed to add foreign key #966 [FIXED] Prevent race condition after transaction finished #5222 [FIXED] Fixed Instance.reload issues ( #4844 and #4452 ) [FIXED] Fix upsert when primary key contains .field (internal API change for queryInterface.upsert ) #4755 [FIXED] Default value for defaultScope is now an empty object. This fixes calling .scope('defaultScope') when no scope is explicitly defined, see #5277 3.18.0 [ADDED] Support silent: true in bulk update #5200 [ADDED] retry object now part of global settings and can be overridden per call. The default is 5 retries with a backoff function. retry object can be passed to options with max: 0 to turn off this behavior. [ADDED] Sqlite now retries database queries that return SQL_BUSY as the status. [ADDED] Add IF EXIST to postgres alter enum #4464 [FIXED] Postgres destroy with where fails on JSONB data #5092 [FIXED] hasMany.separate with foreign keys having field 3.17.3 [FIXED] Regression with array values from security fix in 3.17.2 3.17.2 [SECURITY] Force non-buffer blob values to string, https://github.com/nodejs/node/issues/4660 3.17.1 [FIXED] Reverted benchmarking feature since it does not compile on Node v4.0 3.17.0 [SECURITY] Fixed injection vulnerability for order/limit [FIXED] MySQL throws error when null GEOMETRY data results in empty buffer #4953 3.16.0 [ADDED] PostgreSQL tsrange (Range of timestamp without time zone) data type support. [ADDED] hasOne scope support #5113 [FIXED] attributes from multiple scopes does not merge #4856 [FIXED] Support Unicode strings in mssql #3752 [FIXED] Do not inject include twice in options.include #5106 [FIXED] Expand and validate include in aggregate 3.15.1 [FIXED] calling Model.update() modifies passed values #4520 [FIXED] Instance can be chained on .set() and other methods #4702 [FIXED] includes nested from a separate include now work properly #5080 3.15.0 [ADDED] Improve support for pg range type to handle unbound ranges, +/-infinity bounds and empty ranges [FIXED] Postgres issue when using named timezone #4307 [FIXED] Add support for Babel/ES6 imports #4881 3.14.2 [FIXED] Model.aggregate methods now support attributes and where conditions with fields. #4935 [FIXED] Don't overwrite options.foreignKey in associations #4927 [FIXED] Support nested $col keys. #4849 3.14.1 [FIXED] Issue with transaction options leaking and certain queries running outside of the transaction connection. 3.14.0 [FIXED] Apply scopes to aggregate #4764 [FIXED] Improved postgres enum schema handling #4796 [ADDED/FIXED] Lower case onDelete option to allow the use of onDelete: 'CASCADE', hooks: true . [FIXED] Ignore attributes in count #4566 3.13.0 [FIXED] timestamp columns are no longer undefined for associations loaded with separate . #4740 [FIXED] Mark unscoped model as .scoped , to prevent injection of default scope on includes #4663 [ADDED] .previous now returns and object of previous values when called without key . This brings the API in line with .changed 3.12.1 [FIXED] Mark postgres connection as invalid if the connection is reset #4661 [FIXED] Remove usage of \"limit\" in cases where it's unnecessary, which fixes some of the cases mentioned in [#4404] (https://github.com/sequelize/sequelize/issues/4404) [SECURITY] Security concern with $model.field$ , refactored to now require $col: 'model.field' 3.12.0 [ADDED] Preliminary support for include.on . [FIXED] Partial rollback of datatype validations by hiding it behind the typeValidation flag. [FIXED] Don't try to select the primary key for models without primary key #4607 [FIXED] Apply attributes when including a scoped model. #4625 [FIXED] Use bits instead of strings for mssql booleans. #4621 [FIXED] BulkCreate validation fails for properties with field #3787 3.11.0 [INTERNALS] Updated dependencies #4594 bluebird@2.10.1 dottie@1.0.0 wellknown@0.4.0 [INTERNALS] Updated devDependencies #4594 mysql@2.9.0 coffee-script [FIXED] Add limit to findOne when using queries like { id: { $gt ... #4416 [FIXED] Include all with scopes #4584 [INTERNALS] Corrected spelling seperate -> separate [ADDED] Added include and exclude to options.attributes . #4074 [FIXED/INTERNALS] Only recurse on plain objects in mapOptionFieldNames . #4596 3.10.0 [ADDED] support search_path for postgres with lots of schemas #4534 [ADDED] Expose Association constructor as Sequelize.Association [ADDED] beforeSync/afterSync/beforeBulkSync/afterBulksync hooks #4479 [FIXED] Calling set with dot.separated key on a JSON/JSONB attribute will not flag the entire object as changed #4379 [FIXED] instances returned from bulkCreate now has isNewRecord: false and should be updateable if using returning: true with dialects that support it. [FIXED] Find with Include with a where clause generates wrong SQL #3940 [FIXED] ON DELETE constraint should default to CASCADE if foreignKey has allowNull: false] #2831 [FIXED] sqlite file handle leak 3.9.0 [ADDED] beforeRestore/afterRestore hooks #4371 [ADDED] Map raw fields back to attributes names when using mapToModel or returning #3995 [ADDED] skip now supports filtering out modewl validators #4528 [INTERNALS] options has been renamed to $options in instance.js #4429 [FIXED] Reload doesn't synchronize a null include #4353 [FIXED] commit/rollback multiple times on same transaction #4491 [FIXED] memory leak / options mangle for scopes with include #4470 [FIXED] custom targetKey for belongsTo on a target with a primary key will now correctly create foreign key constraints #4455 3.8.0 [ADDED] version on Sequelize returning the current npm/package.json version #4459 3.7.0 [ADDED] Define field dependencies for VIRTUAL types that are automatically pulled into attributes #4420 [FIXED] Fall back to a default version when parsing the DB version fails #4368 [FIXED] Fix a bug where passing null as the second parameter to sequelize.where would fail #4334 [FIXED] An error is thrown if a column called id is added, but not marked as primary key, and no other pk is present. #4139 [FIXED] Cast to boolean when querying JSON #4257 3.6.0 [ADDED] Model.findCreateFind: A more performant findOrCreate that will not work under a transaction (atleast not in postgres) [FIXED] Show indexes query on Postgres fails to return functional indexes #3911 [FIXED] Custom field names in json queries [FIXED] JSON cast key using the equality operator. #3824 [FIXED] Map column names with .field in scopes with includes. #4210 [FIXED] addScope when the model does not have any initial scopes #4243 [FIXED] Fixed destroy with limit in PG when the primary key is aliassed #4027 [FIXED] Clone the options object in increment , decrement , destroy , reload , restore , and save . #4023 [FIXED] Throw a Sequelize.Error when authenticate fails #4209 [FIXED] BTM would remove any previously added association getters #4268 [FIXED] Pass through connection mode options to sqlite #4288 [INTERNALS] Updated dependencies #4332 toposort-class@1.0.1 validator@4.0.4 wkx@0.1.0 [INTERNALS] Updated devDependencies #4336 chai-spies@0.7.0 dox@0.8.0 mysql@2.8.0 3.5.1 [FIXED] Fix bug with nested includes where a middle include results in a null value which breaks $findSeparate. 3.5.0 [ADDED] include.separate with include.limit support for HasMany associations. [ADDED] Added default validation based on attribute types. #3472 . The validation cannot be disabled. If you really want to completely disable it, you can remove the validate function from the corresponding datatype, but know that this permanently disables the validation. [ADDED] describeTable now marks the primary key (Reroll of #3703 ) [ADDED] Automatically determine the version of the database upon first connection #4192 . This will be useful going forward in order to provide support for older database versions. [ADDED] addScope #3963 [FIXED] Fix findOrCreate regression trying to add a transaction even if there is none [FIXED] Fix save to be noop when nothing changed [FIXED] Call conformOptions on default scope #4157 [FIXED] Call conformOptions on scopes returned by functions #3991 [FIXED] Calling validateIncludedElements should not add an aliassed primary key multiple times #4127 [FIXED] Handle scoped model in includes properly #3700 [FIXED] Enum naming with schemas #3171 and #3563 [FIXED] Prevent polution of the lodash object by using runInContext #2281 3.4.1 [FIXED] Fix belongs-to-many countAssociations - ambigious id when through model has id 3.4.0 [ADDED] countAssociations for hasMany and belongsToMany [ADDED] Geometry support for postgres [FIXED] Fix wrong count for findAndCountAll with required includes #4016 [FIXED] Fix problems related to parsing of unique constraint errors #4017 and #4012 [FIXED] Fix postgres path variable being surrounded by quotes to often in unique constraint errors #4034 [FIXED] Fix removeAttributes(id) not setting this.primaryKeys to null [FIXED] Run validations on the through model during add, set and create for belongsToMany 3.3.2 [FIXED] upsert no longer updates with default values each time #3994 3.3.1 [FIXED] regression in attributes support for 'reload' #3976 3.3.0 [FIXED] Fix Promise#nodeify() and Promise#done() not passing CLS context [FIXED] Creating and dropping enums in transaction, only for PostgreSQL #3782 [FIXED] $or/$and inside a where clause always expects the input to be an array #3767 [ADDED] Unique constraints may now include custom error messages [ADDED] It's possible now to remove a hook by name [ADDED] Hook name can be passed via the direct method #3901 3.2.0 [ADDED] Add support for new option targetKey in a belongs-to relationship for situations where the target key is not the id field. [ADDED] Add support for keyword after in options of a field (useful for migrations), only for MySQL. #3166 [ADDED] There's a new sequelize.truncate function to truncate all tables defined through the sequelize models #2671 [ADDED] Add support for MySQLs TINYTEXT, MEDIUMTEXT and LONGTEXT. #3836 [ADDED] Provide warnings if you misuse data types. #3839 [FIXED] Fix a case where Postgres arrays containing JSONB type was being generated as JSON type. [FIXED] Fix a case where type in sequelize.query was not being set to raw. #3800 [FIXED] Fix an issue where include all was not being properly expanded for self-references #3804 [FIXED] Fix instance.changed regression to not return false negatives for not changed null values #3812 [FIXED] Fix isEmail validator to allow args: true #3770 [FIXED] Fix all occasions where options.logging was not used correctly #3834 [FIXED] Fix Model#destroy() to correctly use options.transaction [FIXED] Fix QueryInterface#showIndex() to correctly pass on options.transaction 3.1.1 [FIXED] Always quote aliases, even when quoteIdentifiers is false #1589 [FIXED] No longer clones Instances in model finder options [FIXED] Fix regression in util.toDefaultValue not returning the data types #3733 3.1.0 [ADDED] It is now possible to defer constraints in PostgreSQL by added a property deferrable to the references object of a field. [FIXED] Fix an issue with the build in isIP validator returning false negatives #3756 3.0.1 [FIXED] include.attributes = [] will no longer force the inclusion of the primary key, making it possible to write aggregates with includes. [CHANGED] The references property of model attributes has been transformed to an object: {type: Sequelize.INTEGER, references: { model: SomeModel, key: 'some_key' }} . The former format ( references and referecesKey ) still exists but is deprecated and will be removed in 4.0. 3.0.0 3.0.0 cleans up a lot of deprecated code, making it easier for us to develop and maintain features in the future. [ADDED] findById / findByPrimary takes a single value as argument representing the primary key to find. [CHANGED] belongsToMany relations MUST now be given a through argument. [CHANGED] findOne / findAll / findAndCount / findOrCreate now only takes a single options argument instead of a options and queryOptions argument. So set transaction, raw, etc on the first options argument. [CHANGED] The accessor for belongsToMany relationships is now either the as argument or the target model name pluralized. [REMOVED] N:M relationships can no longer be represented by 2 x hasMany [REMOVED] Model.create / Model.bulkCreate / Instance.save no longer takes an array of fields as its second argument, use options.fields instead. [REMOVED] Query Chainer has been removed [REMOVED] Migrations have been removed, use umzug instead [REMOVED] Model.findAllJoin has been removed [REMOVED] sequelize.query now only takes sql and options as arguments, the second and fourth argument callee and replacements have been removed and should be set via options.instance / options.model and options.replacements instead. [REMOVED] instance.isDirty has been removed, use instance.changed() instead [REMOVED] instance.values has been removed, use instance.get() instead [REMOVED] instance.primaryKeyValues has been removed. [REMOVED] instance.identifiers has been removed, use instance.where() instead [REMOVED] instance.isDeleted has been removed, simply check the timestamp with get('deletedAt') instead [REMOVED] instance.increment/decrement now longer takes a number as it's second argument. [REMOVED/SECURITY] findOne no longer takes a string / integer / binary argument to represent a primaryKey. Use findById instead [REMOVED/SECURITY] where: \"raw query\" is no longer legal, you must now explicitely use where: [\"raw query\", [replacements]] [FIXED] Fix showIndexQuery so appropriate indexes are returned when a schema is used [FIXED] Fix addIndexQuery error when the model has a schema [FIXED] Fix app crash in sqlite while running in special unique constraint errors #3730 [FIXED] Fix bulkCreate: do not insert NULL for undefined values #3729 [FIXED] Fix trying to roll back a comitted transaction if an error occured while comitting resulting in an unhandled rejection #3726 [FIXED] Fix regression in beforeUpdate hook where instance.changed() would always be false #3727 [FIXED] Fix trying to roll back a comitted transaction if an error occured while comitting Backwards compatibility changes Most of the changes in 3.0.0 are BC breaking, read the changelog for 3.0.0 carefully. The error that is thrown when a column is declared to be an enum but without any values used to \"Values for ENUM haven't been defined\" and is now \"Values for ENUM have not been defined\". 2.1.3 [BUG] Fix regression introduced in 2.1.2: updatedAt not set anymore #3667 [BUG] Fix managed transactions not rolling back if no thenable was provided in the transaction block #3667 2.1.2 [BUG] Model.create()/update() no longer attempts to save undefined fields. 2.1.1 [BUG] .get() now passes along options correctly when using a custom getter [BUG] Fix managed transactions not rolling back if an error occured the transaction block #3661 [BUG] Fix a node-webkit issue #3650 [FEATURE] Lock modes in Postgres now support OF table [FEATURE] New transaction lock modes FOR KEY SHARE and NO KEY UPDATE for Postgres 9.3+ [FEATURE/REFACTOR] Rewritten scopes with complete support for includes and scopes across associations 2.1.0 [BUG] Enable standards conforming strings on connection in postgres. Adresses #3545 [BUG] instance.removeAssociation(s) do not fire the select query twice anymore [BUG] Error messages thrown by the db in languages other than english do not crash the app anymore (mysql, mariadb and postgres only) #3567 [FEATURE] JSONB [FEATURE] All querys can be logged individually by inserting logging: fn in the query option. [FEATURE] Partial index support for Postgres with index.where [REFACTOR] .changed() now works proactively by setting a flag on set instead of matching reactively. Note that objects and arrays will not be checked for equality on set and will always result in a change if they are set . [DEPRECATED] The query-chainer is deprecated and will be removed in version 2.2. Please use promises instead. [REMOVED] Events are no longer supported. [INTERNALS] Updated dependencies. bluebird@2.9.24 Backwards compatibility changes Events support have been removed so using .on('success') or .success() is no longer supported. Try using .then() instead. Trying to apply a scope that does not exist will always throw an error 2.0.6 [BUG] Don't update virtual attributes in Model.update. Fixes #2860 [BUG] Fix for newlines in hstore #3383 [BUG] Fix unique key handling in Model.update #3474 [BUG] Fix issue with Model.create() using fields not specifying and non-incremental primary key #3458 [FEATURE] field support for Model.update #3498 [INTERNALS] Updated dependencies. Most notably we are moving up one major version on lodash. If you are using sequelize.Utils._ , notice that the semantics for many matching functions have changed to include a check for hasOwnProperty dottie@0.3.1 inflection@1.6.0 lodash@3.5.0 validator@3.34 generic-pool@2.2.0 [INTERNALS] Updated devDependencies. coffee-script@1.9.1 dox@0.7.1 mysql@2.6.2 2.0.5 [FEATURE] Highly experimental support for nested creation #3386 2.0.4 [BUG] Fixed support for 2 x belongsToMany without foreignKey defined and association getter/adder #3185 [BUG] No longer throws on Model.hasHook() if no hooks are defiend #3181 [BUG] Fixed issue with {$and: []} [BUG] Fixed issue with N:M relations with primary keys with field defined 2.0.3 [BUG] Support for plain strings, ints and bools on JSON insert [BUG] Fixed regression where {$in: []} would result in IN () rather than IN (NULL) #3105 #3132 [BUG] Fixed bug where 2 x belongsToMany with foreignKey but no otherKey defined would result in 3 keys instead of 2. #2991 [BUG] Fixed regression with where: sequelize.json() #3138 [BUG] Fixed support for field with $or / $and #3153 2.0.2 [BUG] Fixed regression with DataTypes.ARRAY(DataTypes.STRING(length)) #3106 [BUG] Fixed regression where .or([{key: value}, {key: value, key2: value}]) would result in 3 A OR B OR C rather than A OR (B AND C) #3107 [BUG] Fixed regression with DataTypes.DECIMAL(10) resulting in 10, undefined #3119 [BUG] Fixed issue with dangling WHERE query on Model.update(values, {where: {}}) #3113 2.0.1 [BUG] Fixed issue with empty include.where [BUG] Fixed issue with otherKey generation for self-association N:M 2.0.0 [BUG] Fixed field support for increment and decrement . [FEATURE/BUG] Raw queries always return all results (including affected rows etc). This means you should change all promise listeners on sequelize.query to use .spread instead of .then , unless you are passing a query type. [BUG] Support for composite primary keys in upsert #3065 [BUG] Support for field in upsert [FEATURE] Support for setting an initial autoincrement option in mysql #3076 [FEATURE] Test coverage for Node.js 0.12 and io.js 1.x Backwards compatibility changes The default query type for sequelize.query is now RAW - this means that two arguments (results and metadata) will be returned by default and you should use .spread The 4th argument to sequelize.query has been deprecated in favor of options.replacements 2.0.0-rc8 [FEATURE] CLS Support. CLS is also used to automatically pass the transaction to any calls within the callback chain when using sequelize.transaction(function() ... . [BUG] Fixed issue with paranoid deletes and deletedAt with a custom field. [BUG] No longer crahes on where: [] [FEATURE] Validations are now enabled by default for upsert. [FEATURE] Preliminary support for include.through.where [SECURITY/BUG] Fixed injection issue in direction param for order 2.0.0-rc7 [FEATURE] Throw an error if no where clause is given to Model.destroy() . [BUG] Fixed issue with order: sequelize.literal('string') [FEATURE] add clone: true support to .get() . Is needed when using delete on values from a .get() ( toJSON() , this.values ). (.get() is just a reference to the values for performance reasons when there's no custom getters or includes) [FEATURE] add sequelize.escape(value) convenience method [BUG] Fixes crash with findAll({include: [Model], order: sequelize.literal()}) [FEATURE] Now possible to pass createdAt and updatedAt values to Model.create / Model.bulkCreate when using silent: true (when importing datasets with existing timestamps) [FEATURE] instance.update() using default fields will now automatically also save and validate values provided via beforeUpdate hooks [BUG] Fixed bad SQL when updating a JSON attribute with a different field [BUG] Fixed issue with creating and updating values of a DataTypes.ARRAY(DataTypes.JSON) attribute [BUG] Model.bulkCreate([{}], {returning: true}) will now correctly result in instances with primary key values. [BUG] instance.save() with fields: [] (as a result of .changed() being [] ) will no result in a noop instead of an empty update query. [BUG] Fixed case where findOrCreate could return [null, true] when given a defaults value that triggered a unique constraint error. Backwards compatibility changes instance.update() using default fields will now automatically also save and validate values provided via beforeUpdate hooks Sequelize no longer supports case insensitive mysql enums pg-hstore has been moved to a devDependency, Postgres users will have to install pg-hstore manually alongside pg : $ npm install pg pg-hstore 2.0.0-rc6 [BUG] Fixed issue with including by association reference and where 2.0.0-rc5 [BUG] Fixed issue with subquery creating include.where and a paranoid main model.#2749/#2769 UniqueConstraintErrors will now extend from ValidationError making it possible to catch both with .catch(ValidationError) [FEATURE] Adds {save: false} for belongsTo relationship setters. user.setOrganization(organization, {save: false}) will then only set the foreign key value, but not trigger a save on user . [FEATURE] When updating an instance _previousDataValues will now be updated after afterUpdate hooks have been run rather than before allowing you to use changed in afterUpdate [BUG] Sequelize will no longer fail on a postgres constraint error not defined by Sequelize [FEATURE] It's now possible to pass an association reference to include. var Owner = Company.belongsTo(User, {as: 'owner'}; Company.findOne({include: [Owner]}); Backwards compatibility changes When updating an instance _previousDataValues will now be updated after afterUpdate hooks have been run rather than before allowing you to use changed in afterUpdate 2.0.0-rc4 [INTERNALS] Update inflection dependency to v1.5.3 [FEATURE] Replaced string error messages for connection errors with error objects. #2576 [FEATURE] Support for updating fields on duplicate key in bulk update (mysql only) #2692 [FEATURE] Basic support for Microsoft SQL Server [INTERNALS] Deprecate migration logic. This is now implemented in umzug and the CLI . [BUG] Fixed various inconsistencies with Instance.update and how it behaves together with create , fields and more. [BUG] Fixed crash/bug when using include.where together with association.scope [BUG] Fixed support for Instance.destroy() and field for postgres. Backwards compatibility changes Some of the string error messages for connection errors have been replaced with actual error instances. Checking for connection errors should now be more consistent. 2.0.0-rc3 [FEATURE] Added the possibility of removing multiple associations in 1 call #2338 [FEATURE] Undestroy method for paranoid models #2540 [FEATURE] Support for UPSERT [BUG] Add support for field named the same as the attribute in reload , bulkCreate and save #2348 [BUG] Copy the options object in association getters. #2311 [BUG] Model#destroy() now supports field , this also fixes an issue with N:M#removeAssociation and field [BUG] Customized error message can now be set for unique constraint that was created manually (not with sync, but e.g. with migrations) or that has fields with underscore naming. This was problem at least with postgres before. [BUG] Fixed a bug where plain objects like { in: [...] } were not properly converted to SQL when combined with a sequelize method ( fn , where etc.). Closes #2077 [BUG] Made the default for array search in postgres exact comparison instead of overlap [BUG] Allow logging from individual functions even though the global logging setting is false. Closes #2571 [BUG] Allow increment/decrement operations when using schemata [BUG] Allow createTable with schema [BUG] Fix some issues with findAndCount and include [INTERNALS] Update inflection dependency to v1.5.2 [REMOVED] Remove query generation syntactic sugar provided by node-sql , as well as the dependency on that module Backwards compatibility changes When eager-loading a many-to-many association, the attributes of the through table are now accessible through an attribute named after the through model rather than the through table name singularized. i.e. Task.find({include: Worker}) where the table name for through model TaskWorker is TableTaskWorkers used to produce { Worker: { ..., TableTaskWorker: {...} } } . It now produces { Worker: { ..., TaskWorker: {...} } } . Does not affect models where table name is auto-defined by Sequelize, or where table name is model name pluralized. When using Model#find() with an order clause, the table name is prepended to the ORDER BY SQL. e.g. ORDER BY Task.id rather than ORDER BY id . The change is to avoid ambiguous column names where there are eager-loaded associations with the same column names. A side effect is that code like Task.findAll( { include: [ User ], order: [ [ 'Users.id', 'ASC' ] ] } ) will now throw an error. This should be achieved with Task.findAll( { include: [ User ], order: [ [ User, 'id', 'ASC' ] ] } ) instead. Nested HSTORE objects are no longer supported. Use DataTypes.JSON instead. In PG where: { arr: [1, 2] } where the arr column is an array will now use strict comparison ( = ) instead of the overlap operator ( && ). To obtain the old behaviour, use where: { arr: { overlap: [1, 2] }} The default fields for Instance#save (when not a new record) is now an intersection of the model attributes and the changed attributes making saves more atomic while still allowing only defined attributes. Syntactic sugar for query generation was removed. You will no longer be able to call Model.dataset() to generate raw sql queries 2.0.0-rc2 [FEATURE] Added to posibility of using a sequelize object as key in sequelize.where . Also added the option of specifying a comparator [FEATURE] Added countercache functionality to hasMany associations #2375 [FEATURE] Basic JSON support #2314 [BUG] Fixes regression bug with multiple hasMany between the same models with different join tables. Closes #2316 [BUG] Don't set autocommit in nested transactions #2418 [BUG] Improved field support 2.0.0-rc1 [BUG] Fixed an issue with foreign key object syntax for hasOne and belongsTo [FEATURE] Added field and name to the object form of foreign key definitions [FEATURE] Added support for calling Promise.done , thus explicitly ending the promise chain by calling done with no arguments. Done with a function argument still continues the promise chain, to maintain BC. [FEATURE] Added scope to hasMany association definitions, provides default values to association setters/finders #2268 [FEATURE] We now support transactions that automatically commit/rollback based on the result of the promise chain returned to the callback. [BUG] Only try to create indexes which don't already exist. Closes #2162 [FEATURE] Hooks are passed options [FEATURE] Hooks need not return a result - undefined return is interpreted as a resolved promise [FEATURE] Added find() hooks Backwards compatibility changes The fieldName property, used in associations with a foreign key object (A.hasMany(B, { foreignKey: { ... }}) , has been renamed to name to avoid confusion with field . The naming of the join table entry for N:M association getters is now singular (like includes) Signature of hooks has changed to pass options to all hooks. Any hooks previously defined like Model.beforeCreate(values) now need to be Model.beforeCreate(values, options) etc. Results returned by hooks are ignored - changes to results by hooks should be made by reference Model.destroy() signature has been changed from (where, options) to (options) , options now take a where parameter. Model.update() signature has been changed from (values, where, options) to (values, options) , options now take a where parameter. The syntax for Model.findOrBuild has changed, to be more in line with the rest of the library. Model.findOrBuild(where, defaults); becomes Model.findOrBuild({ where: where, defaults: defaults }); . v2.0.0-dev13 We are working our way to the first 2.0.0 release candidate. [FEATURE] Added to option of setting a timezone offset in the sequelize constructor ( timezone option). This timezone is used when initializing a connection (using SET TIME ZONE or equivalent), and when converting a timestamp string from the DB to a JS date with mysql (postgres stores the timezone, so for postgres we rely on what's in the DB). [FEATURE] Allow setting plural and singular name on the model ( options.name in sequelize.define ) and in associations ( options.as ) to circumvent issues with weird pluralization. [FEATURE] Added support for passing an indexes array in options to sequelize.define . #1485 . See API reference for details. [FEATURE/INTERNALS] Standardized the output from QueryInterface.showIndex . [FEATURE] Include deleted rows in find #2083 [FEATURE] Make addSingular and addPlural for n:m associations (fx addUser and addUsers now both accept an array or an instance. [BUG] Hid dottie.transform on raw queries behind a flag ( nest ) #2064 [BUG] Fixed problems with transaction parameter being removed / not passed on in associations #1789 and #1968 [BUG] Fix problem with minConnections. #2048 [BUG] Fix default scope being overwritten #2087 [BUG] Fixed updatedAt timestamp not being set in bulk create when validate = true. #1962 [INTERNALS] Replaced lingo with inflection [INTERNALS] Removed underscore.string dependency and moved a couple of helper functions from Utils._ to Utils [INTERNALS] Update dependencies validator 3.2.0 -> 3.16.1 moment 2.5.0 -> 2.7.0 generic-pool 2.0.4 -> 2.1.1 sql 0.35.0 -> 0.39.0 [INTERNALS] Use a transaction inside findOrCreate , and handle unique constraint errors if multiple calls are issues concurrently on the same transaction Backwards compatibility changes We are using a new inflection library, which should make pluralization and singularization in general more robust. However, a couple of pluralizations have changed as a result: Person is now pluralized as people instead of persons Accesors for models with underscored names are no longer camel cased automatically. For example, if you have a model with name my_model , and my_other_model.hasMany(my_model) , the getter will now be instance_of_my_model.getMy_model instead of .getMyModel . Removed support for setting sequelize.language. If your model names are not in english, use the name option provided by sequelize.name to defined singular and plural forms for your model. Model names are now used more verbatim in associations. This means that if you have a model named Task (plural T), or an association specifying { as: 'Task' } , the tasks will be returned as relatedModel.Tasks instead of relatedModel.tasks . For more information and how to mitigate this, see https://github.com/sequelize/sequelize/wiki/Upgrading-to-2.0#inflection-replaces-lingo-and-changes-to-naming-conventions Removed the freezeAssociations option - use model and assocation names instead to provide the plural form yourself Removed sequelize.language option (not supported by inflection) Error handling has been refactored. Code that listens for : All Error classes properly inherit from Error and a common SequelizeBaseError base Instance Validator returns a single instance of a ValidationError which contains an errors array property. This property contains individual error items for each failed validation. ValidationError includes a get(path) method to find all broken validations for a path on an instance. To migrate existing error handling, switch from array indexing to using the get method: Old: err.validateCustom[0] New: err.get('validateCustom')[0] - The syntax for findOrCreate has changed, to be more in line with the rest of the library. Model.findOrCreate(where, defaults); becomes Model.findOrCreate({ where: where, defaults: defaults }); . v2.0.0-dev12 [FEATURE] You can now return a promise to a hook rather than use a callback [FEATURE] There is now basic support for assigning a field name to an attribute name: {type: DataTypes.STRING, field: 'full_name'} [FEATURE] It's now possible to add multiple relations to a hasMany association, modelInstance.addRelations([otherInstanceA, otherInstanceB]) [FEATURE] define() stores models in sequelize.models Object e.g. sequelize.models.MyModel [FEATURE] The set / add / has methods for associations now allow you to pass the value of a primary key, instead of a full Instance object, like so: user.addTask(15); . [FEATURE] Support for FOR UPDATE and FOR SHARE statements #1777 [FEATURE] n:m createAssocation now returns the target model instance instead of the join model instance [FEATURE] Extend the foreignKey option for associations to support a full data type definition, and not just a string [FEATURE] Extract CLI into separate projects . [FEATURE] Sqlite now inserts dates with millisecond precision [FEATURE] Sequelize.VIRTUAL datatype which provides regular attribute functionality (set, get, etc) but never persists to database. [BUG] An error is now thrown if an association would create a naming conflict between the association and the foreign key when doing eager loading. Closes #1272 [BUG] Fix logging options for sequelize.sync [BUG] find no longer applies limit: 1 if querying on a primary key, should fix a lot of subquery issues. [BUG] Transactions now use the pool so you will never go over your pool defined connection limit [BUG] Fix use of Sequelize.literal in eager loading and when renaming attributes #1916 [BUG] Use the provided name for a unique index if one is given, instead of concating the column names together #1944 [BUG] Create a composite primary key for doubled linked self reference #1891 [INTERNALS] bulkDeleteQuery was removed from the MySQL / abstract query generator, since it was never used internally. Please use deleteQuery instead. Backwards compatibility changes Sequelize now returns promises instead of its custom event emitter from most calls. This affects methods that return multiple values (like findOrCreate or findOrInitialize ). If your current callbacks do not accept the 2nd success parameter you might be seeing an array as the first param. Either use .spread() for these methods or add another argument to your callback: .success(instance) -> .success(instance, created) . .success() / .done() and any other non promise methods are now deprecated (we will keep the codebase around for a few versions though). on('sql') persists for debugging purposes. Model association calls (belongsTo/hasOne/hasMany) are no longer chainable. (this is to support being able to pass association references to include rather than model/as combinations) QueryInterface no longer emits global events. This means you can no longer do things like QueryInterface.on('showAllSchemas', function ... sequelize.showAllSchemas now returns an array of schemas, instead of an array containinig an array of schemas sequelize.transaction() now returns a promise rather than a instance of Sequelize.Transaction bulkCreate , bulkUpdate and bulkDestroy (and aliases) now take both a hooks and an individualHooks option, hooks defines whether or not to run the main hooks, and individualHooks defines whether to run hooks for each instance affected. It is no longer possible to disable pooling, disable pooling will just result in a 1/1 pool. v2.0.0-dev11 Caution: This release contains many changes and is highly experimental [PERFORMANCE] increased build performance when using include, which speeds up findAll etc. [BUG] Made it possible to use HSTORE both in attribute: HSTORE and attribute: { type: HSTORE } form. Thanks to @tomchentw #1458 [FEATURE] n:m now marks the columns of the through table as foreign keys and cascades them on delete and update by default. [FEATURE] 1:1 and 1:m marks columns as foreign keys, and sets them to cascade on update and set null on delete. If you are working with an existing DB which does not allow null values, be sure to override those options, or disable them completely by passing constraints: false to your assocation call ( M1.belongsTo(M2, { constraints: false}) ). [BUG] Removed the hard dependency on pg, allowing users to use pg.js [BUG] Fixed a bug with foreign keys pointing to attributes that were not integers. Now your primaryKey can be a string, and associations will still work. Thanks to @fixe #1544 [BUG] Fix a case where createdAt timestamp would not be set when updatedAt was disabled Thanks to @fixe #1543 [BUG] Fix a case where timestamps were not being write protected in set when underscored=true. janmeier #1523 [FEATURE/BUG] Prefetching/includes now fully support schemas [FEATURE] Centralize logging. #1566 [FEATURE/BUG] hstore values are now parsed on find/findAll. Thanks to @nunofgs #1560 [FEATURE] Read cli options from a file. Thanks to @codeinvain #1540 Backwards compatibility changes The notNull validator has been removed, use the Schema's allowNull property. All Validation errors now return a sequelize.ValidationError which inherits from Error. selectedValues has been removed for performance reasons, if you depend on this, please open an issue and we will help you work around it. foreign keys will now correctly be based on the alias of the model if you have any 1:1 relations where both sides use an alias, you'll need to set the foreign key, or they'll each use a different foreign key based on their alias. foreign keys for non-id primary keys will now be named for the foreign key, i.e. pub_name rather than pub_id if you have non-id primary keys you should go through your associations and set the foreignKey option if relying on a incorrect _id foreign key syncOnAssocation has been removed. It only worked for n:m, and having a synchronous function (hasMany) that invokes an asynchronous function (sync) without returning an emitter does not make a lot of sense. If you (implicitly) depended on this feature, sequelize.sync is your friend. If you do not want to do a full sync, use custom through models for n:m ( M1.hasMany(M2, { through: M3}) ) and sync the through model explicitly. Join tables will be no longer be paranoid (have a deletedAt timestamp added), even though other models are. All tables in select queries will now be aliased with the model names to be support schemas. This will affect people stuff like `where: {'table.attribute': value} v1.7.10 [FEATURE] ilike support for postgres #2122 [FEATURE] distinct option for count #2079 [BUG] various fixes v1.7.9 [BUG] fixes issue with custom primary keys and N:M join tables #1929 v1.7.8 [FEATURE] adds rlike support for mysql v1.7.7 [BUG] fixes issue where count/findAndCountAll would throw on empty rows #1849 v1.7.6 [BUG] fixes issue where primary key is also foreign key #1818 v1.7.5 [BUG] fixes bug with some methods relying on table information throwing strange errors #1686 v1.7.3 [BUG] fixes foreign key types for hasMany v1.7.2 [BUG] fixes transactions support for 1-to-1 association setters. v1.7.1 [BUG] fixes issue where relations would not use transactions probably in adders/setters. v1.7.0 [FEATURE] covers more advanced include cases with limiting and filtering (specifically cases where a include would be in the subquery but its child include wouldnt be, for cases where a 1:1 association had a 1:M association as a nested include) [BUG] fixes issue where connection would timeout before calling COMMIT resulting in data never reaching the database #1429 v1.7.0-rc9 [PERFORMANCE] fixes performance regression introduced in rc7 [FEATURE] include all relations for a model #1421 [BUG] N:M adder/getter with through model and custom primary keys now work v1.7.0-rc8 [BUG] fixes bug with required includes without wheres with subqueries v1.7.0-rc7 [BUG] ORDER BY statements when using includes should now be places in the appropriate sub/main query more intelligently. [BUG] using include.attributes with primary key attributes specified should no longer result in multiple primary key attributes being selected #1410 [DEPENDENCIES] all dependencies, including Validator have been updated to the latest versions. Backwards compatability changes .set() will no longer set values that are not a dynamic setter or defined in the model. This only breaks BC since .set() was introduced but restores original .updateAttributes functionality where it was possible to 'trust' user input. v1.7.0-rc6 [BUG] Encode binary strings as bytea in postgres, and fix a case where using a binary as key in an association would produce an error 1364 . Thanks to @SohumB v1.7.0-rc5 [FEATURE] sync() now correctly returns with an error when foreign key constraints reference unknown tables [BUG] sync() no longer fails with foreign key constraints references own table (toposort self-dependency error) [FEATURE] makes it possible to specify exactly what timestamp attributes you want to utilize #1334 [FEATURE] Support coffee script files in migrations. #1357 [FEATURE] include.where now supports Sequelize.and()/.or(). #1361 v1.7.0-rc4 [BUG] fixes issue with postgres sync and enums #1020 [BUG] fixes various issues with limit and includes #1322 [BUG] fixes issues with migrations/queryInterface createTable and enums [BUG] migration/queryInterface.addIndex() no longer fails on reserved keywords like 'from' [FEATURE] bulkCreate now supports a ignoreDuplicates option for MySQL, SQLite and MariaDB that will use INSERT IGNORE [BUG] fixes regression bug with 1:M self associations [FEATURE] significant performance improvements for 1:1 and single primary key includes for 500+ rows #1333 Backwards compatability changes find/findAll will now always return primary keys regardless of attributes settings. (Motivation was to fix various issues with eager loading) v1.7.0-rc3 [FEATURE] dropAllTables now takes an option parameter with skip as an option #1280 [FEATURE] implements .spread for eventemitters #1277 [BUG] fixes some of the mysql connection error bugs #1282 [Feature] Support for OR queries. [Feature] Support for HAVING queries. #1286 [FEATURE] bulkUpdate and bulkDestroy now returns affected rows. #1293 [BUG] fixes transaction memory leak issue [BUG] fixes security issue where it was possible to overwrite the id attribute when defined by sequelize (screwup - and fix - by mickhansen) v1.7.0-rc2 [BUG] fixes unixSocket connections for mariadb #1248 [BUG] fixes a hangup issue for mysql #1244 [BUG] improves handling of uncaught errors in eventemitter #1245 [BUG] fixes bug with mysql replication and pool settings #1251 [BUG] fixes bug where through models created by N:M associations would inherit hooks #1263 [FEATURE] .col()/.literal()/etc now works with findAll #1249 [BUG] now currectly handles connection timeouts as errors #1207 v2.0.0 (alpha1) [FEATURE] async validations. #580 . thanks to Interlock v1.7.0-rc1 [FEATURE] instance.createAssociationInstance functionality added #1213 [BUG] fixes a few bugs with transactions in regards to associations [FEATURE] add error handling for transaction creation [FEATURE] sequelize --undo will now actually undo migrations. Its basically an alias for sequelize --migrate --undo . #1059 [BUG] fix bug where {where: {ne: null}} would result in != NULL instead of IS NOT NULL #1231 [BUG] fixes a bug with validation skipping using the fields options. #1233 [BUG] fixes a bug with postgres and setters #1234 [BUG] fixes it so field: {type: Sequelize.ENUM(value1, value2)} works Backwards compatability changes Hooks are no longer passing value hashes. Instead, they are now passing instances of the model. Hook callbacks no longer take two arguments (previously: err, newValues ). They only take the error argument since values can be changed directly on the model instance. v1.7.0-beta8 [FEATURE] max()/min() now supports dates #1200 [FEATURE] findAndCountAll now supports the include option Backwards compatibility changes You will now need to include the relevant subtables to query on them in finders (find/findAll) Subquery logic no longer depends on where objects with keys containing '.', instead where options on the include options #1199 v1.7.0-beta7 [FEATURE] Nested eager loading / prefetching is now supported. Docs [FEATURE] Eager loading / prefetching now supports inner joins and extending the ON statement #1199 [FEATURE] Eager loading / prefetching now returns the attributes of through models aswell #1198 [FEATURE] New set/get/changed/previous feature #1182 Various bug fixes Backwards compatibility changes None v1.7.0-beta1 [DEPENDENCIES] Upgraded validator for IPv6 support. #603 . thanks to durango [DEPENDENCIES] replaced underscore by lodash. #954 . thanks to durango [DEPENDENCIES] Upgraded pg to 2.0.0. #711 . thanks to durango [DEPENDENCIES] Upgraded command to 2.0.0 and generic-pool to 2.0.4. thanks to durango [DEPENDENCIES] No longer require semver. thanks to durango [BUG] Fix string escape with postgresql on raw SQL queries. #586 . thanks to zanamixx [BUG] \"order by\" is now after \"group by\". #585 . thanks to mekanics [BUG] Added decimal support for min/max. #583 . thanks to durango [BUG] Null dates don't break SQLite anymore. #572 . thanks to mweibel [BUG] Correctly handle booleans in MySQL. #608 . Thanks to terraflubb [BUG] Fixed empty where conditions in MySQL. #619 . Thanks to terraflubb [BUG] Allow overriding of default columns. #635 . Thanks to sevastos [BUG] Fix where params for belongsTo #658 . Thanks to mweibel [BUG] Default ports are now declared in the connector manager, which means the default port for PG correctly becomes 5432. #633 . durango [BUG] Columns with type BOOLEAN were always added to toJSON output, even if they were not selected see . janmeier [BUG] Hstore is now fully supported #695 . thanks to tadman [BUG] Correct join table name for tables with custom names #698 . thanks to jjclark1982 [BUG] PostgreSQL should now be able to insert empty arrays with typecasting. #718 . thanks to durango [BUG] Fields should be escaped by quoteIdentifier for max/min functions which allows SQL reserved keywords to be used. #719 . thanks to durango [BUG] Fixed bug when trying to save objects with eagerly loaded attributes #716 . thanks to iamjochen [BUG] Strings for .find() should be fixed. Also added support for string primary keys to be found easily. #737 . thanks to durango [BUG] bulkCreate would have problems with a disparate field list #738 . thanks to durango [BUG] Fixed problems with quoteIdentifiers and {raw: false} option on raw queries #751 . thanks to janmeier [BUG] Fixed SQL escaping with sqlite and unified escaping #700 . thanks to PiPeep [BUG] Fixed Postgres' pools ff57af63 [BUG] Fixed BLOB/TEXT columns having a default value declared in MySQL #793 . thanks to durango [BUG] You can now use .find() on any single integer primary key when throwing just a number as an argument #796 . thanks to durango [BUG] Adding unique to a column for Postgres in the migrator should be fixed #795 . thanks to durango [BUG] For MySQL users, if their collation allows case insensitivity then allow enums to be case insensitive as well #794 . thanks to durango [BUG] Custom primary key (not keys, just singular) should no longer be a problem for models when using any of the data retrievals with just a number or through associations #771 . thanks to sdephold & durango [BUG] Default schemas should now be utilized when describing tables #812 . thanks to durango [BUG] Fixed eager loading for many-to-many associations. #834 . thanks to lemon-tree [BUG] allowNull: true enums can now be null #857 . thanks to durango [BUG] Fixes Postgres' ability to search within arrays. #879 . thanks to durango [BUG] Find and finAll would modify the options objects, now the objects are cloned at the start of the method #884 thanks to janmeier. Improved in #899 thanks to hackwaly [BUG] Add support for typed arrays in SqlString.escape and SqlString.arrayToList #891 . thanks to LJ1102 [BUG] Postgres requires empty array to be explicitly cast on update #890 . thanks to robraux [BUG] Added tests & bugfixes for DAO-Factory.update and array of values in where clause #880 . thanks to domasx2 [BUG] sqlite no longer leaks a global db variable #900 . thanks to xming [BUG] Fix for counts queries with no result #906 . thanks to iamjochem [BUG] Allow include when the same table is referenced multiple times using hasMany #913 . thanks to janmeier [BUG] Allow definition of defaultValue for the timestamp columns (createdAt, updatedAt, deletedAt) #930 . Thank to durango [BUG] Don't delete foreign keys of many-to-many associations, if still needed. #961 . thanks to sdepold [BUG] Update timestamps when incrementing and decrementing #1023 . durango [FEATURE] Validate a model before it gets saved. #601 . thanks to durango [FEATURE] Schematics. #564 . thanks to durango [FEATURE] Foreign key constraints. #595 . thanks to optilude [FEATURE] Support for bulk insert ( <DAOFactory>.bulkCreate() , update ( <DAOFactory>.update() ) and delete ( <DAOFactory>.destroy() ) #569 . thanks to optilude [FEATURE] Add an extra queryOptions parameter to DAOFactory.find and DAOFactory.findAll . This allows a user to specify { raw: true } , meaning that the raw result should be returned, instead of built DAOs. Usefull for queries returning large datasets, see #611 janmeier [FEATURE] Added convenient data types. #616 . Thanks to Costent [FEATURE] Binary is more verbose now. #612 . Thanks to terraflubb [FEATURE] Promises/A support. #626 . Thanks to kevinbeaty [FEATURE] Added Getters/Setters method for DAO. #538 . Thanks to iamjochem [FEATURE] Added model wide validations. #640 . Thanks to tremby [FEATURE] findOrCreate now returns an additional flag ( created ), that is true if a model was created, and false if it was found #648 . janmeier [FEATURE] Field and table comments for MySQL and PG. #523 . MySQL by iamjochen. PG by janmeier [FEATURE] BigInts can now be used for autoincrement/serial columns. #673 . thanks to sevastos [FEATURE] Use moment for better postgres timestamp strings. #710 . Thanks to seth-admittedly [FEATURE] Keep milliseconds in timestamps for postgres. #712 . Thanks to seth-admittedly [FEATURE] You can now set lingo's language through Sequelize. #713 . Thanks to durango [FEATURE] Added a findAndCountAll , useful for pagination. #533 . Thanks to iamjochen [FEATURE] Made explicit migrations possible. #728 . Thanks to freezy [FEATURE] Added support for where clauses containing !=, < etc. and support for date ranges #727 . Thanks to durango [FEATURE] Added support for model instances being referenced #761 thanks to sdepold [FEATURE] Added support for specifying the path to load a module for a dialect. #766 thanks to sonnym. [FEATURE] Drop index if exists has been added to sqlite #766 thanks to coderbuzz [FEATURE] bulkCreate() now has a third argument which gives you the ability to validate each row before attempting to bulkInsert #797 . thanks to durango [FEATURE] Added isDirty to model instances. #798 . Thanks to mstorgaard [FEATURE] Added possibility to use env variable for the database connection. #784 . Thanks to sykopomp. [FEATURE] Blob support. janmeier [FEATURE] We can now define our own custom timestamp columns #856 . thanks to durango [FEATURE] Scopes. #748 . durango [FEATURE] Model#find() / Model#findAll() is now working with strings. #855 . Thanks to whito. [FEATURE] Shortcut method for getting a defined model. #868 . Thanks to jwilm. [FEATURE] Added Sequelize.fn() and Sequelize.col() to properly call columns and functions within Sequelize. #882 . thanks to janmeier [FEATURE] Sequelize.import supports relative paths. #901 . thanks to accerqueira. [FEATURE] Sequelize.import can now handle functions. #911 . Thanks to davidrivera. [FEATURE] Uses sequelize.fn and sequelize.col functionality to allow you to use the value of another column or a function when updating. It also allows you to use a function as a default value when supported (in sqlite and postgres). #928 . thanks to janmeier [FEATURE] Added possibility to pass options to node-mysql. #929 . thanks to poying [FEATURE] Triggers for Postgres. #915 . Thanks to jonathana. [FEATURE] Support for join tables. #877 . Thanks to janmeier. [FEATURE] Support for hooks. #894 . Thanks to durango. [FEATURE] Support for literals and casts. #950 . Thanks to durango. [FEATURE] Model#findOrBuild. #960 . Thanks to durango. [FEATURE] Support for MariaDB. #948 . Thanks to reedog117 and janmeier. [FEATURE] Filter through associations. #991 . Thanks to snit-ram. [FEATURE] Possibility to disable loging for .sync #937 . Thanks to durango [FEATURE] Support for transactions. 1062 . [REFACTORING] hasMany now uses a single SQL statement when creating and destroying associations, instead of removing each association separately 690 . Inspired by #104 . janmeier [REFACTORING] Consistent handling of offset across dialects. Offset is now always applied, and limit is set to max table size of not limit is given #725 . janmeier [REFACTORING] Moved Jasmine to Buster and then Buster to Mocha + Chai. sdepold and durango v1.6.0 [DEPENDENCIES] upgrade mysql to alpha7. You MUST use this version or newer for DATETIMEs to work [DEPENDENCIES] upgraded most dependencies. most important: mysql was upgraded to 2.0.0-alpha-3 [DEPENDENCIES] mysql is now an optional dependency. #355 (thanks to clkao) [REFACTORING] separated tests for dialects [REFACTORING] reduced number of sql queries used for adding an element to a N:M association. #449 (thanks to innofluence/janmeier) [REFACTORING] dropped support for synchronous migrations. added third parameter which needs to get called once the migration has been finished. also this adds support for asynchronous actions in migrations. [OTHERS] code was formatted to fit the latest code style guidelines (thanks to durango) [OTHERS] Explicitly target ./docs folder for generate-docs script. #444 (thanks to carsondarling) [OTHERS] Overwrite existing daoFactoryDefinition if there already has been one. (thanks to robraux) [BUG] fixed wrong version in sequelize binary [BUG] local options have higher priority than global options (thanks to guersam) [BUG] fixed where clause when passing an empty array (thanks to kbackowski) [BUG] fixed updateAttributes for models/tables without primary key (thanks to durango) [BUG] fixed the location of the foreign key when using belongsTo (thanks to ricardograca) [BUG] don't return timestamps if only specific attributes have been seleceted (thanks to ricardograca) [BUG] fixed removeColumn for sqlite [BUG] fixed date equality check for instances. (thanks to solotimes) [FEATURE] added association prefetching /eager loading for find and findAll. #465 [FEATURE] it's now possible to use callbacks of async functions inside migrations (thanks to mphilpot) [FEATURE] improved comfort of sequelize.query. just pass an sql string to it and wait for the result [FEATURE] Migrations now understand NODE_ENV (thanks to gavri) [FEATURE] Performance improvements (thanks to Mick-Hansen and janmeier from innofluence) [FEATURE] Model.find and Model.findAll can now take a String with an ID. (thanks to ghernandez345) [FEATURE] Compatibility for JSON-like strings in Postgres (thanks to aslakhellesoy) [FEATURE] honor maxConcurrentQueries option (thanks to dchester) [FEATURE] added support for stored procedures (inspired by wuyuntao) [FEATURE] added possibility to use pg lib's native api (thanks to denysonique) [FEATURE] added possibility to define the attributes of received associations (thanks to joshm) [FEATURE] added findOrCreate, which returns a the already existing instance or creates one (thanks to eveiga) [FEATURE] minConnections option for MySQL pooling (thanks to dominiklessel) [FEATURE] added BIGINT data type which is treated like a string (thanks to adamsch1) [FEATURE] experimental support for read replication for mysql (thanks to Janzeh) [FEATURE] allow definition of a models table name (thanks to slamkajs) [FEATURE] allow usage of enums. #440 (thanks to KevinMartin) [FEATURE] allows updateAttributes to target specific fields only (thanks to Pasvaz) [FEATURE] timestamps are now stored as UTC. #461 (thanks to innofluence/janmeier) [FEATURE] results of raw queries are parsed with dottie. #468 (thanks to kozze89) [FEATURE] support for array serialization. pg only. #443 (thanks to clkao) [FEATURE] add increment and decrement methods on dao. #408 (thanks to janmeier/innofluence) [FEATURE] unified the result of describeTable [FEATURE] add support for decimals (thanks to alexyoung) [FEATURE] added DAO.reload(), which updates the attributes of the DAO in-place (as opposed to doing having to do a find() and returning a new model) v1.5.0 [REFACTORING] use underscore functions for Utils.isHash (thanks to Mick-Hansen/innofluence) [REFACTORING] removed the 'failure' event and replaced it with 'error' [BUG] fixed booleans for sqlite (thanks to vlmonk) [BUG] obsolete reference attribute for many-to-many associations are removed correctly [BUG] associations can be cleared via passing null to the set method [BUG] \"fixed\" quota handling (thanks to dgf) [BUG] fixed destroy in postgresql (thanks to robraux) [FEATURE] added possibility to set protocol and to remove port from postgresql connection uri (thanks to danielschwartz) [FEATURE] added possibility to not use a junction table for many-to-many associations on the same table (thanks to janmeier/innofluence) [FEATURE] results of the import method is now cached (thanks to janmeier/innofluence) [FEATURE] added possibility to check if a specific object or a whole bunch of objects is currently associated with another object (thanks to janmeier/innofluence) [FEATURE] added possibility to globally disable adding of NULL values to sql queries (thanks to janmeier/innofluence) [FEATURE] Model.create can now also be used to specify values for mass assignment (thanks to janmeier/innofluence) [FEATURE] QueryChainer will now provide the results of the added emitters in the order the emitters have been added (thanks to LaurentZuijdwijk and me ;)) [FEATURE] QueryChainer can now be initialized with serial items [FEATURE] node 0.8 compatibility [FEATURE] added options to hasMany getters (thanks to janmeier/innofluence) [FEATURE] pooling option is now correctly passed to postgres (thanks to megshark) v1.4.1 [DEPRECATION] Added deprecation warning for node < v0.6. [FEATURE] added selective saving of instances (thanks to kioopi) [FEATURE] added command to binary for creating a migration skeleton with current timestamp [FEATURE] added complete function for each finder method (thanks to sstoiana) [BUG] fixed quotation for sqlite statements (thanks to vlmonk) [BUG] fixed timestamp parsing in migratios (thanks to grn) [FEATURE] added consistent logging behaviour to postgres (thanks to reacuna) v1.4.0 [BUG] fixed booleans in sqlite (thanks to alexstrat) [BUG] fixed forced sync of many-to-many associations (thanks to SirUli) [FEATURE] objects are now compatible to JSON.stringify. (thanks to grayt0r) [FEATURE] When instantiating the sequelize object, you can now pass a function to logging. This allows you to customize the logging behavior. Default is now: console.log (thanks to kenperkins) [BUG] The default logging is still console.log but is wrapped after initialization as it crashes node < 0.6.x. [FEATURE] postgresql support. (thanks to swoodtke) [FEATURE] connection-pooling for mysql. (thanks to megshark) [FEATURE] added possibility to define NOW as default value for date data-types. Use Sequelize.NOW as defaultValue [BUG] Fixed date handling in sqlite (thanks to iizukanao) v1.3.7 [BUG] fixed issue where multiple belongsTo or hasOne associations to the same table overwrite each other [BUG] fixed memory leaks (thanks to megshark) v1.3.6 [BUG] don't update an existing updatedAt-attribute if timestamps option for a DAO is false v1.3.5 [BUG] fixed missed DAO renaming in migrations (thanks to nov) v1.3.4 [REFACTORING] renamed Model/ModelFactory/ModelFactoryManager to DAO/DAOFactory/DAOFactoryManager [IMPROVEMENT] npm test will run the test suite (thanks to gabrielfalcao) [IMPROVEMENT] documentation about setting up local development environment (thanks to gabrielfalcao) [REFACTORING] removed updatedAt + createdAt from SequelizeMeta v1.3.3 [BUG] fixed sql-event emitter in all possible locations (thanks to megshark) v1.3.2 [FEATURE] sqlite is now emitting the 'sql'-event as well (thanks to megshark) v1.3.1 [REFACTORING] renamed ModelManager to ModelFactoryManager [IMPROVEMENT] decreased delay of CustomEventEmitter execution from 5ms to 1ms [IMPROVEMENT] improved performance of association handling (many-to-many) (thanks to magshark) [FEATURE] added possibility to specify name of the join table (thanks to magshark) [FEATURE] mysql is emitting a 'sql'-event when executing a query [BUG] correctly delete existing SequelizeMeta entry from database after undoing migration [BUG] fix path of migration files in executable (thanks to bcg) v1.3.0 [REFACTORING] Model#all is now a function and not a getter. [REFACTORING] Renamed ModelDefinition to ModelFactory [REFACTORING] Private method scoping; Attributes are still public [REFACTORING] Use the new util module for node 0.6.2 [FEATURE] QueryChainer can now run serially [FEATURE] Association definition is chainable: Person.hasOne(House).hasMany(Address) [FEATURE] Validations (Thanks to hiddentao ) [FEATURE] jQuery-like event listeners: .success(callback) and .error(callback) [FEATURE] aliasing for select queries: Model.find({ where: 'id = 1', attributes: ['id', ['name', 'username']] }) ==> will return the user's name as username [FEATURE] cross-database support. currently supported: mysql, sqlite [FEATURE] migrations [TEST] removed all expresso tests and converted them to jasmine v1.2.1 [REFACTORING] renamed the global options for sync, query and define on sequelize; before: options.queryOptions; now: options.query [FEATURE] allow definition of charset via global define option in sequelize or via charset option in sequelize.define [FEATURE] allow definition of mysql engine via global define option in sequelize or via engine option in sequelize.define; default is InnoDB now [FEATURE] find and findAll will now search in a list of values via: Model.findAll({where: { id: [1,2,3] }}); will return all models with id 1, 2 and 3 [TEST] force latin1 charset for travis v1.2.0 [FEATURE] min/max function for models, which return the min/max value in a column [FEATURE] getModel for modelManager for getting a model without storing it in a variable; use it via sequelize.modelManager.getModel('User') [TEST] test suite refactoring for jasmine v1.1.4 [BUG] tables with identical prefix (e.g. wp_) can now be used in many-to-many associations v1.1.3 [BUG] scoped options in model => a model can now have the attribute options [FEATURE] added drop method for sequelize, that drops all currently registered tables v1.1.2 [BUG] prevent malfunction after being idle v1.1.1 [BUG] fixed memory leaks [FEATURE] added query queueing (adjustable via maxConcurrentQueries in config; default: 50) v1.1.0 [BUG] defaultValue 0 is now working [REMOVED] mysql-pool usage (will give it a new try later) [CHORE] updated node-mysql to 0.9.4 v1.0.2 [BUG] Fixed where clause generation for models with explicit primary keys (allanca) [BUG] Set insertId for non-default auto increment fields (allanca) v1.0.1 [FEATURE] Added Model.count(callback), which returns the number of elements saved in the database [BUG] Fixed self associations v1.0.0 complete rewrite added new emitter syntax sql injection protection select now supports hash usage of where select now supports array usage of where added a lot of options to find/findAll Wrapped queries correctly using foo using expresso 0.7.2 moved config for test database into seperated config file Added method for adding and deleting single associations v0.4.3 renamed loadAssociatedData to fetchAssociations renamed Model#associatedData to fetchedAssociations added fetchAssociations to finder methods store data found by finder method in the associatedData hash + grep them from there if reload is not forced added option to sequelize constructor for disabling the pluralization of tablenames: disableTableNameModification allow array as value for chainQueries => Sequelize.chainQueries([save: [a,b,c]], callback) remove the usage of an array => Sequelize.chainQueries({save: a}, {destroy: b}, callback) v0.4.2 fixed bugs from 0.4.1 added the model instance method loadAssociatedData which adds the hash Model#associatedData to an instance which contains all associated data v0.4.1 THIS UPDATE CHANGES TABLE STRUCTURES MASSIVELY! MAKE SURE TO DROP YOUR CURRENT TABLES AND LET THEM CREATE AGAIN! names of many-to-many-association-tables are chosen from passed association names foreign keys are chosen from passed association name added many-to-many association on the same model added hasManyAndBelongsTo added hasOneAndBelongsTo nodejs-mysql-native 0.4.2 v0.4.0 added error handling when defining invalid database credentials Sequelize#sync, Sequelize#drop, model#sync, model#drop returns errors via callback code is now located under lib/sequelize to use it with nDistro added possibility to use non default mysql database (host/port) added error handling when defining invalid database port/host schema definitions can now contain default values and null allowance database credentials can now also contain an empty / no password v0.3.0 added possibility to define class and instance methods for models added import method for loading model definition from a file v0.2.6 refactored Sequelize to fit CommonJS module conventions v0.2.5 added BOOLEAN type added FLOAT type fixed DATE type issue fixed npm package v0.2.4 fixed bug when using cross associated tables (many to many associations) v0.2.3 added latest mysql connection library fixed id handling on save fixed text handling (varchar > 255; text) using the inflection library for naming tables more convenient Sequelize.TEXT is now using MySQL datatype TEXT instead of varchar(4000) v0.2.2 released project as npm package v0.2.1 fixed date bug v0.2.0 added methods for setting associations added method for chaining an arbitraty amount of queries v0.1.0 first stable version implemented all basic functions associations are working","title":"Changelog"},{"location":"changelog/#future","text":"","title":"Future"},{"location":"changelog/#v3311","text":"[FIXED] postgres/connection-manager: Only fetch OIDs once #8733","title":"v3.31.1"},{"location":"changelog/#v3310","text":"[FIXED] Passing parameters to model getters #7404 [FIXED] changeColumn generates incorrect query with ENUM type #7456 [ADDED] ARRAY(ENUM) support for Postgres #8703","title":"v3.31.0"},{"location":"changelog/#3303","text":"[ADDED] Ability to run transactions on a read-replica by marking transactions as read only #7323 [FIXED] Add quotes around column names for unique constraints in sqlite #4407","title":"3.30.3"},{"location":"changelog/#3302","text":"[FIXED] previous method gave wrong value back #7189 [FIXED] Fixes setAssociation with scope #7223 [FIXED] Including a virtual field can give an empty query #7164 [FIXED] Fixes creation of polymorphic belongsToMany associations in one step #7159 #7181","title":"3.30.2"},{"location":"changelog/#3301","text":"[FIXED] sourceKey FOR hasMany now also works if a where was specified in an include #7141 [CHANGED] Updated deprecated node-uuid package to uuid #7148 [FIXED] Updating VIRTUAL field throw ER_EMPTY_QUERY #6356","title":"3.30.1"},{"location":"changelog/#3300","text":"[FIXED] removeColumn method to support dropping primaryKey column (MSSQL) #7081 [ADDED] Support sourceKey for hasMany relationships #4258","title":"3.30.0"},{"location":"changelog/#3290","text":"[FIXED] Transaction Name too long, transaction savepoints for SQL Server #6972","title":"3.29.0"},{"location":"changelog/#3280","text":"[FIXED] Soft-delete not returning number of affected rows on mssql #6916 [ADDED] afterConnect hook [FIXED] Range integer parsing #6897 [FIXED] Upsert return value for mysql #6963","title":"3.28.0"},{"location":"changelog/#3270","text":"[FIXED] Incorrect column name for generateThroughJoin #6878 [ADDED] Support condition objects in utility functions #6685","title":"3.27.0"},{"location":"changelog/#3260","text":"[ADDED] Backport of mssql upsert #6875","title":"3.26.0"},{"location":"changelog/#3251","text":"[FIXED] fix instance.set '1970-01-01' to null field #6839 [FIXED] Can not execute raw SQL queries for sqlite3 #6865","title":"3.25.1"},{"location":"changelog/#3250","text":"[FIXED] Set timestamps and paranoid options from through model on belongsToMany association [FIXED] Properly apply paranoid condition when groupedLimit.on association is paranoid [FIXED] restore now uses field from deletedAt [ADDED] option.silent for increment and decrement #6793","title":"3.25.0"},{"location":"changelog/#3247","text":"[FIXED] MSSQL bulkInsertQuery when options and attributes are not passed [#6782]","title":"3.24.7"},{"location":"changelog/#3246","text":"[FIXED] groupedLimit.through.where support","title":"3.24.6"},{"location":"changelog/#3245","text":"[FIXED] GroupedLimit when foreignKey has a field alias","title":"3.24.5"},{"location":"changelog/#3244","text":"[FIXED] - ORDER clause was not included in subquery if order option value was provided as plain string (not as an array value) [FIXED] Issue with belongsTo association and foreign keys #6400 [FIXED] Check that parent exists before appending attributes #6472 [FIXED] Default options for insert queries #6644","title":"3.24.4"},{"location":"changelog/#3243","text":"[ADDED] Backport of grouped limit include support [ADDED] Export datatypes #6578","title":"3.24.3"},{"location":"changelog/#3242","text":"[FIXED] Accept dates as string while using typeValidation #6453","title":"3.24.2"},{"location":"changelog/#3241","text":"[FIXED] Add parent , original and sql properties to UniqueConstraintError","title":"3.24.1"},{"location":"changelog/#3240","text":"[ADDED] restartIdentity option for truncate in postgres #5356","title":"3.24.0"},{"location":"changelog/#3235","text":"","title":"3.23.5"},{"location":"changelog/#3234","text":"[FIXED] Fixed an issue where custom-named model fields break when offsetting, ordering, and including hasMany simultaneously. #5985 [FIXED] Don't remove includes from count queries and unify findAndCount and count queries. #6123 [FIXED] Model.count don't include attributes #5057 [SECURITY] GEOMETRY and GEOGRAPHY SQL injection attacks #6194","title":"3.23.4"},{"location":"changelog/#3233","text":"[FIXED] Pass ResourceLock instead of raw connection in MSSQL disconnect handling","title":"3.23.3"},{"location":"changelog/#3232","text":"[FIXED] Type validation now works with non-strings due to updated validator@5.0.0 #5861 [FIXED] Improved offset and limit support for SQL server 2008 #5616 [FIXED] options object cloned in all Sequelize methods (so not modified within Sequelize)","title":"3.23.2"},{"location":"changelog/#3231","text":"[FIXED] Postgres DECIMAL precision. (PostgreSQL) #4893 [FIXED] removeColumn tries to delete non-existant foreign key constraint (mysql) #5808 [FIXED] Relation constraints not being applied correctly #5865","title":"3.23.1"},{"location":"changelog/#3230","text":"[FIXED] Invalid query generated when using LIKE + ANY #5736 [FIXED] Method QueryInterface.bulkDelete no longer working when the model parameter is missing. (PostgreSQL) #5615 [ADDED] Context and custom options for deep creation [FIXED] Dates with millisecond precision are inserted correctly in MySQL #5855","title":"3.23.0"},{"location":"changelog/#3220","text":"[FIXED] Fix defaultValues getting overwritten on build [FIXED] Queue queries against tedious connections [ADDED] Enable type validation for all queries","title":"3.22.0"},{"location":"changelog/#3210","text":"[FIXED] Confirmed that values modified in validation hooks are preserved #3534 [FIXED] Support lower case type names in SQLite #5482 [FIXED] Support calling setAssociation twice on hasOne #5315 [INTERNALS] Removed dependency on wellknown in favor of terraformer-wkt-parser [ADDED] Benchmarking feature #2494 [INTERNALS] Add Utils.mergeDeep - allows lodash to be updated to latest version","title":"3.21.0"},{"location":"changelog/#3200","text":"[ADDED] rejectOnEmpty mode #272 #5480 [ADDED] beforeCount hook #5209 [ADDED] validationFailed hook #1626 [ADDED] Support for IEEE floating point literals in postgres and sqlite #5194 [FIXED] addColumn with reference in mysql #5592 [FIXED] findAndCountAll generates invalid SQL, subQuery moves to LEFT OUTER JOIN #5445 [FIXED] count methods pollute the options.includes #4191 [FIXED] Invalid SQL generated when using group option along with attributes #3009 [FIXED] Mark index as unique: true when type: 'UNIQUE' . Fixes #5351 [FIXED] Improper escaping of bound arrays of strings on Postgres, SQLite, and Microsoft SQL Server","title":"3.20.0"},{"location":"changelog/#3193","text":"[FIXED] updatedAt and createdAt values are now set before validation #5367 [FIXED] describeTable maintains proper enum casing in mysql #5321 [FIXED] Parsing of dates in MySQL, when a named timezone is used #4208 [FIXED] Truncating in Postgres, when table has a schema #4306 [FIXED] Moved initialization of scopes later in the model init process. Fixes attribute exclusion in scopes, #4735 and #4925 [FIXED] Multiple custom unique validation messages being overwritten by the first-defined message, #4920","title":"3.19.3"},{"location":"changelog/#3190","text":"[ADDED] Geography support for postgres [FIXED] Migrations failed to add foreign key #966 [FIXED] Prevent race condition after transaction finished #5222 [FIXED] Fixed Instance.reload issues ( #4844 and #4452 ) [FIXED] Fix upsert when primary key contains .field (internal API change for queryInterface.upsert ) #4755 [FIXED] Default value for defaultScope is now an empty object. This fixes calling .scope('defaultScope') when no scope is explicitly defined, see #5277","title":"3.19.0"},{"location":"changelog/#3180","text":"[ADDED] Support silent: true in bulk update #5200 [ADDED] retry object now part of global settings and can be overridden per call. The default is 5 retries with a backoff function. retry object can be passed to options with max: 0 to turn off this behavior. [ADDED] Sqlite now retries database queries that return SQL_BUSY as the status. [ADDED] Add IF EXIST to postgres alter enum #4464 [FIXED] Postgres destroy with where fails on JSONB data #5092 [FIXED] hasMany.separate with foreign keys having field","title":"3.18.0"},{"location":"changelog/#3173","text":"[FIXED] Regression with array values from security fix in 3.17.2","title":"3.17.3"},{"location":"changelog/#3172","text":"[SECURITY] Force non-buffer blob values to string, https://github.com/nodejs/node/issues/4660","title":"3.17.2"},{"location":"changelog/#3171","text":"[FIXED] Reverted benchmarking feature since it does not compile on Node v4.0","title":"3.17.1"},{"location":"changelog/#3170","text":"[SECURITY] Fixed injection vulnerability for order/limit [FIXED] MySQL throws error when null GEOMETRY data results in empty buffer #4953","title":"3.17.0"},{"location":"changelog/#3160","text":"[ADDED] PostgreSQL tsrange (Range of timestamp without time zone) data type support. [ADDED] hasOne scope support #5113 [FIXED] attributes from multiple scopes does not merge #4856 [FIXED] Support Unicode strings in mssql #3752 [FIXED] Do not inject include twice in options.include #5106 [FIXED] Expand and validate include in aggregate","title":"3.16.0"},{"location":"changelog/#3151","text":"[FIXED] calling Model.update() modifies passed values #4520 [FIXED] Instance can be chained on .set() and other methods #4702 [FIXED] includes nested from a separate include now work properly #5080","title":"3.15.1"},{"location":"changelog/#3150","text":"[ADDED] Improve support for pg range type to handle unbound ranges, +/-infinity bounds and empty ranges [FIXED] Postgres issue when using named timezone #4307 [FIXED] Add support for Babel/ES6 imports #4881","title":"3.15.0"},{"location":"changelog/#3142","text":"[FIXED] Model.aggregate methods now support attributes and where conditions with fields. #4935 [FIXED] Don't overwrite options.foreignKey in associations #4927 [FIXED] Support nested $col keys. #4849","title":"3.14.2"},{"location":"changelog/#3141","text":"[FIXED] Issue with transaction options leaking and certain queries running outside of the transaction connection.","title":"3.14.1"},{"location":"changelog/#3140","text":"[FIXED] Apply scopes to aggregate #4764 [FIXED] Improved postgres enum schema handling #4796 [ADDED/FIXED] Lower case onDelete option to allow the use of onDelete: 'CASCADE', hooks: true . [FIXED] Ignore attributes in count #4566","title":"3.14.0"},{"location":"changelog/#3130","text":"[FIXED] timestamp columns are no longer undefined for associations loaded with separate . #4740 [FIXED] Mark unscoped model as .scoped , to prevent injection of default scope on includes #4663 [ADDED] .previous now returns and object of previous values when called without key . This brings the API in line with .changed","title":"3.13.0"},{"location":"changelog/#3121","text":"[FIXED] Mark postgres connection as invalid if the connection is reset #4661 [FIXED] Remove usage of \"limit\" in cases where it's unnecessary, which fixes some of the cases mentioned in [#4404] (https://github.com/sequelize/sequelize/issues/4404) [SECURITY] Security concern with $model.field$ , refactored to now require $col: 'model.field'","title":"3.12.1"},{"location":"changelog/#3120","text":"[ADDED] Preliminary support for include.on . [FIXED] Partial rollback of datatype validations by hiding it behind the typeValidation flag. [FIXED] Don't try to select the primary key for models without primary key #4607 [FIXED] Apply attributes when including a scoped model. #4625 [FIXED] Use bits instead of strings for mssql booleans. #4621 [FIXED] BulkCreate validation fails for properties with field #3787","title":"3.12.0"},{"location":"changelog/#3110","text":"[INTERNALS] Updated dependencies #4594 bluebird@2.10.1 dottie@1.0.0 wellknown@0.4.0 [INTERNALS] Updated devDependencies #4594 mysql@2.9.0 coffee-script [FIXED] Add limit to findOne when using queries like { id: { $gt ... #4416 [FIXED] Include all with scopes #4584 [INTERNALS] Corrected spelling seperate -> separate [ADDED] Added include and exclude to options.attributes . #4074 [FIXED/INTERNALS] Only recurse on plain objects in mapOptionFieldNames . #4596","title":"3.11.0"},{"location":"changelog/#3100","text":"[ADDED] support search_path for postgres with lots of schemas #4534 [ADDED] Expose Association constructor as Sequelize.Association [ADDED] beforeSync/afterSync/beforeBulkSync/afterBulksync hooks #4479 [FIXED] Calling set with dot.separated key on a JSON/JSONB attribute will not flag the entire object as changed #4379 [FIXED] instances returned from bulkCreate now has isNewRecord: false and should be updateable if using returning: true with dialects that support it. [FIXED] Find with Include with a where clause generates wrong SQL #3940 [FIXED] ON DELETE constraint should default to CASCADE if foreignKey has allowNull: false] #2831 [FIXED] sqlite file handle leak","title":"3.10.0"},{"location":"changelog/#390","text":"[ADDED] beforeRestore/afterRestore hooks #4371 [ADDED] Map raw fields back to attributes names when using mapToModel or returning #3995 [ADDED] skip now supports filtering out modewl validators #4528 [INTERNALS] options has been renamed to $options in instance.js #4429 [FIXED] Reload doesn't synchronize a null include #4353 [FIXED] commit/rollback multiple times on same transaction #4491 [FIXED] memory leak / options mangle for scopes with include #4470 [FIXED] custom targetKey for belongsTo on a target with a primary key will now correctly create foreign key constraints #4455","title":"3.9.0"},{"location":"changelog/#380","text":"[ADDED] version on Sequelize returning the current npm/package.json version #4459","title":"3.8.0"},{"location":"changelog/#370","text":"[ADDED] Define field dependencies for VIRTUAL types that are automatically pulled into attributes #4420 [FIXED] Fall back to a default version when parsing the DB version fails #4368 [FIXED] Fix a bug where passing null as the second parameter to sequelize.where would fail #4334 [FIXED] An error is thrown if a column called id is added, but not marked as primary key, and no other pk is present. #4139 [FIXED] Cast to boolean when querying JSON #4257","title":"3.7.0"},{"location":"changelog/#360","text":"[ADDED] Model.findCreateFind: A more performant findOrCreate that will not work under a transaction (atleast not in postgres) [FIXED] Show indexes query on Postgres fails to return functional indexes #3911 [FIXED] Custom field names in json queries [FIXED] JSON cast key using the equality operator. #3824 [FIXED] Map column names with .field in scopes with includes. #4210 [FIXED] addScope when the model does not have any initial scopes #4243 [FIXED] Fixed destroy with limit in PG when the primary key is aliassed #4027 [FIXED] Clone the options object in increment , decrement , destroy , reload , restore , and save . #4023 [FIXED] Throw a Sequelize.Error when authenticate fails #4209 [FIXED] BTM would remove any previously added association getters #4268 [FIXED] Pass through connection mode options to sqlite #4288 [INTERNALS] Updated dependencies #4332 toposort-class@1.0.1 validator@4.0.4 wkx@0.1.0 [INTERNALS] Updated devDependencies #4336 chai-spies@0.7.0 dox@0.8.0 mysql@2.8.0","title":"3.6.0"},{"location":"changelog/#351","text":"[FIXED] Fix bug with nested includes where a middle include results in a null value which breaks $findSeparate.","title":"3.5.1"},{"location":"changelog/#350","text":"[ADDED] include.separate with include.limit support for HasMany associations. [ADDED] Added default validation based on attribute types. #3472 . The validation cannot be disabled. If you really want to completely disable it, you can remove the validate function from the corresponding datatype, but know that this permanently disables the validation. [ADDED] describeTable now marks the primary key (Reroll of #3703 ) [ADDED] Automatically determine the version of the database upon first connection #4192 . This will be useful going forward in order to provide support for older database versions. [ADDED] addScope #3963 [FIXED] Fix findOrCreate regression trying to add a transaction even if there is none [FIXED] Fix save to be noop when nothing changed [FIXED] Call conformOptions on default scope #4157 [FIXED] Call conformOptions on scopes returned by functions #3991 [FIXED] Calling validateIncludedElements should not add an aliassed primary key multiple times #4127 [FIXED] Handle scoped model in includes properly #3700 [FIXED] Enum naming with schemas #3171 and #3563 [FIXED] Prevent polution of the lodash object by using runInContext #2281","title":"3.5.0"},{"location":"changelog/#341","text":"[FIXED] Fix belongs-to-many countAssociations - ambigious id when through model has id","title":"3.4.1"},{"location":"changelog/#340","text":"[ADDED] countAssociations for hasMany and belongsToMany [ADDED] Geometry support for postgres [FIXED] Fix wrong count for findAndCountAll with required includes #4016 [FIXED] Fix problems related to parsing of unique constraint errors #4017 and #4012 [FIXED] Fix postgres path variable being surrounded by quotes to often in unique constraint errors #4034 [FIXED] Fix removeAttributes(id) not setting this.primaryKeys to null [FIXED] Run validations on the through model during add, set and create for belongsToMany","title":"3.4.0"},{"location":"changelog/#332","text":"[FIXED] upsert no longer updates with default values each time #3994","title":"3.3.2"},{"location":"changelog/#331","text":"[FIXED] regression in attributes support for 'reload' #3976","title":"3.3.1"},{"location":"changelog/#330","text":"[FIXED] Fix Promise#nodeify() and Promise#done() not passing CLS context [FIXED] Creating and dropping enums in transaction, only for PostgreSQL #3782 [FIXED] $or/$and inside a where clause always expects the input to be an array #3767 [ADDED] Unique constraints may now include custom error messages [ADDED] It's possible now to remove a hook by name [ADDED] Hook name can be passed via the direct method #3901","title":"3.3.0"},{"location":"changelog/#320","text":"[ADDED] Add support for new option targetKey in a belongs-to relationship for situations where the target key is not the id field. [ADDED] Add support for keyword after in options of a field (useful for migrations), only for MySQL. #3166 [ADDED] There's a new sequelize.truncate function to truncate all tables defined through the sequelize models #2671 [ADDED] Add support for MySQLs TINYTEXT, MEDIUMTEXT and LONGTEXT. #3836 [ADDED] Provide warnings if you misuse data types. #3839 [FIXED] Fix a case where Postgres arrays containing JSONB type was being generated as JSON type. [FIXED] Fix a case where type in sequelize.query was not being set to raw. #3800 [FIXED] Fix an issue where include all was not being properly expanded for self-references #3804 [FIXED] Fix instance.changed regression to not return false negatives for not changed null values #3812 [FIXED] Fix isEmail validator to allow args: true #3770 [FIXED] Fix all occasions where options.logging was not used correctly #3834 [FIXED] Fix Model#destroy() to correctly use options.transaction [FIXED] Fix QueryInterface#showIndex() to correctly pass on options.transaction","title":"3.2.0"},{"location":"changelog/#311","text":"[FIXED] Always quote aliases, even when quoteIdentifiers is false #1589 [FIXED] No longer clones Instances in model finder options [FIXED] Fix regression in util.toDefaultValue not returning the data types #3733","title":"3.1.1"},{"location":"changelog/#310","text":"[ADDED] It is now possible to defer constraints in PostgreSQL by added a property deferrable to the references object of a field. [FIXED] Fix an issue with the build in isIP validator returning false negatives #3756","title":"3.1.0"},{"location":"changelog/#301","text":"[FIXED] include.attributes = [] will no longer force the inclusion of the primary key, making it possible to write aggregates with includes. [CHANGED] The references property of model attributes has been transformed to an object: {type: Sequelize.INTEGER, references: { model: SomeModel, key: 'some_key' }} . The former format ( references and referecesKey ) still exists but is deprecated and will be removed in 4.0.","title":"3.0.1"},{"location":"changelog/#300","text":"3.0.0 cleans up a lot of deprecated code, making it easier for us to develop and maintain features in the future. [ADDED] findById / findByPrimary takes a single value as argument representing the primary key to find. [CHANGED] belongsToMany relations MUST now be given a through argument. [CHANGED] findOne / findAll / findAndCount / findOrCreate now only takes a single options argument instead of a options and queryOptions argument. So set transaction, raw, etc on the first options argument. [CHANGED] The accessor for belongsToMany relationships is now either the as argument or the target model name pluralized. [REMOVED] N:M relationships can no longer be represented by 2 x hasMany [REMOVED] Model.create / Model.bulkCreate / Instance.save no longer takes an array of fields as its second argument, use options.fields instead. [REMOVED] Query Chainer has been removed [REMOVED] Migrations have been removed, use umzug instead [REMOVED] Model.findAllJoin has been removed [REMOVED] sequelize.query now only takes sql and options as arguments, the second and fourth argument callee and replacements have been removed and should be set via options.instance / options.model and options.replacements instead. [REMOVED] instance.isDirty has been removed, use instance.changed() instead [REMOVED] instance.values has been removed, use instance.get() instead [REMOVED] instance.primaryKeyValues has been removed. [REMOVED] instance.identifiers has been removed, use instance.where() instead [REMOVED] instance.isDeleted has been removed, simply check the timestamp with get('deletedAt') instead [REMOVED] instance.increment/decrement now longer takes a number as it's second argument. [REMOVED/SECURITY] findOne no longer takes a string / integer / binary argument to represent a primaryKey. Use findById instead [REMOVED/SECURITY] where: \"raw query\" is no longer legal, you must now explicitely use where: [\"raw query\", [replacements]] [FIXED] Fix showIndexQuery so appropriate indexes are returned when a schema is used [FIXED] Fix addIndexQuery error when the model has a schema [FIXED] Fix app crash in sqlite while running in special unique constraint errors #3730 [FIXED] Fix bulkCreate: do not insert NULL for undefined values #3729 [FIXED] Fix trying to roll back a comitted transaction if an error occured while comitting resulting in an unhandled rejection #3726 [FIXED] Fix regression in beforeUpdate hook where instance.changed() would always be false #3727 [FIXED] Fix trying to roll back a comitted transaction if an error occured while comitting","title":"3.0.0"},{"location":"changelog/#backwards-compatibility-changes","text":"Most of the changes in 3.0.0 are BC breaking, read the changelog for 3.0.0 carefully. The error that is thrown when a column is declared to be an enum but without any values used to \"Values for ENUM haven't been defined\" and is now \"Values for ENUM have not been defined\".","title":"Backwards compatibility changes"},{"location":"changelog/#213","text":"[BUG] Fix regression introduced in 2.1.2: updatedAt not set anymore #3667 [BUG] Fix managed transactions not rolling back if no thenable was provided in the transaction block #3667","title":"2.1.3"},{"location":"changelog/#212","text":"[BUG] Model.create()/update() no longer attempts to save undefined fields.","title":"2.1.2"},{"location":"changelog/#211","text":"[BUG] .get() now passes along options correctly when using a custom getter [BUG] Fix managed transactions not rolling back if an error occured the transaction block #3661 [BUG] Fix a node-webkit issue #3650 [FEATURE] Lock modes in Postgres now support OF table [FEATURE] New transaction lock modes FOR KEY SHARE and NO KEY UPDATE for Postgres 9.3+ [FEATURE/REFACTOR] Rewritten scopes with complete support for includes and scopes across associations","title":"2.1.1"},{"location":"changelog/#210","text":"[BUG] Enable standards conforming strings on connection in postgres. Adresses #3545 [BUG] instance.removeAssociation(s) do not fire the select query twice anymore [BUG] Error messages thrown by the db in languages other than english do not crash the app anymore (mysql, mariadb and postgres only) #3567 [FEATURE] JSONB [FEATURE] All querys can be logged individually by inserting logging: fn in the query option. [FEATURE] Partial index support for Postgres with index.where [REFACTOR] .changed() now works proactively by setting a flag on set instead of matching reactively. Note that objects and arrays will not be checked for equality on set and will always result in a change if they are set . [DEPRECATED] The query-chainer is deprecated and will be removed in version 2.2. Please use promises instead. [REMOVED] Events are no longer supported. [INTERNALS] Updated dependencies. bluebird@2.9.24","title":"2.1.0"},{"location":"changelog/#backwards-compatibility-changes_1","text":"Events support have been removed so using .on('success') or .success() is no longer supported. Try using .then() instead. Trying to apply a scope that does not exist will always throw an error","title":"Backwards compatibility changes"},{"location":"changelog/#206","text":"[BUG] Don't update virtual attributes in Model.update. Fixes #2860 [BUG] Fix for newlines in hstore #3383 [BUG] Fix unique key handling in Model.update #3474 [BUG] Fix issue with Model.create() using fields not specifying and non-incremental primary key #3458 [FEATURE] field support for Model.update #3498 [INTERNALS] Updated dependencies. Most notably we are moving up one major version on lodash. If you are using sequelize.Utils._ , notice that the semantics for many matching functions have changed to include a check for hasOwnProperty dottie@0.3.1 inflection@1.6.0 lodash@3.5.0 validator@3.34 generic-pool@2.2.0 [INTERNALS] Updated devDependencies. coffee-script@1.9.1 dox@0.7.1 mysql@2.6.2","title":"2.0.6"},{"location":"changelog/#205","text":"[FEATURE] Highly experimental support for nested creation #3386","title":"2.0.5"},{"location":"changelog/#204","text":"[BUG] Fixed support for 2 x belongsToMany without foreignKey defined and association getter/adder #3185 [BUG] No longer throws on Model.hasHook() if no hooks are defiend #3181 [BUG] Fixed issue with {$and: []} [BUG] Fixed issue with N:M relations with primary keys with field defined","title":"2.0.4"},{"location":"changelog/#203","text":"[BUG] Support for plain strings, ints and bools on JSON insert [BUG] Fixed regression where {$in: []} would result in IN () rather than IN (NULL) #3105 #3132 [BUG] Fixed bug where 2 x belongsToMany with foreignKey but no otherKey defined would result in 3 keys instead of 2. #2991 [BUG] Fixed regression with where: sequelize.json() #3138 [BUG] Fixed support for field with $or / $and #3153","title":"2.0.3"},{"location":"changelog/#202","text":"[BUG] Fixed regression with DataTypes.ARRAY(DataTypes.STRING(length)) #3106 [BUG] Fixed regression where .or([{key: value}, {key: value, key2: value}]) would result in 3 A OR B OR C rather than A OR (B AND C) #3107 [BUG] Fixed regression with DataTypes.DECIMAL(10) resulting in 10, undefined #3119 [BUG] Fixed issue with dangling WHERE query on Model.update(values, {where: {}}) #3113","title":"2.0.2"},{"location":"changelog/#201","text":"[BUG] Fixed issue with empty include.where [BUG] Fixed issue with otherKey generation for self-association N:M","title":"2.0.1"},{"location":"changelog/#200","text":"[BUG] Fixed field support for increment and decrement . [FEATURE/BUG] Raw queries always return all results (including affected rows etc). This means you should change all promise listeners on sequelize.query to use .spread instead of .then , unless you are passing a query type. [BUG] Support for composite primary keys in upsert #3065 [BUG] Support for field in upsert [FEATURE] Support for setting an initial autoincrement option in mysql #3076 [FEATURE] Test coverage for Node.js 0.12 and io.js 1.x","title":"2.0.0"},{"location":"changelog/#backwards-compatibility-changes_2","text":"The default query type for sequelize.query is now RAW - this means that two arguments (results and metadata) will be returned by default and you should use .spread The 4th argument to sequelize.query has been deprecated in favor of options.replacements","title":"Backwards compatibility changes"},{"location":"changelog/#200-rc8","text":"[FEATURE] CLS Support. CLS is also used to automatically pass the transaction to any calls within the callback chain when using sequelize.transaction(function() ... . [BUG] Fixed issue with paranoid deletes and deletedAt with a custom field. [BUG] No longer crahes on where: [] [FEATURE] Validations are now enabled by default for upsert. [FEATURE] Preliminary support for include.through.where [SECURITY/BUG] Fixed injection issue in direction param for order","title":"2.0.0-rc8"},{"location":"changelog/#200-rc7","text":"[FEATURE] Throw an error if no where clause is given to Model.destroy() . [BUG] Fixed issue with order: sequelize.literal('string') [FEATURE] add clone: true support to .get() . Is needed when using delete on values from a .get() ( toJSON() , this.values ). (.get() is just a reference to the values for performance reasons when there's no custom getters or includes) [FEATURE] add sequelize.escape(value) convenience method [BUG] Fixes crash with findAll({include: [Model], order: sequelize.literal()}) [FEATURE] Now possible to pass createdAt and updatedAt values to Model.create / Model.bulkCreate when using silent: true (when importing datasets with existing timestamps) [FEATURE] instance.update() using default fields will now automatically also save and validate values provided via beforeUpdate hooks [BUG] Fixed bad SQL when updating a JSON attribute with a different field [BUG] Fixed issue with creating and updating values of a DataTypes.ARRAY(DataTypes.JSON) attribute [BUG] Model.bulkCreate([{}], {returning: true}) will now correctly result in instances with primary key values. [BUG] instance.save() with fields: [] (as a result of .changed() being [] ) will no result in a noop instead of an empty update query. [BUG] Fixed case where findOrCreate could return [null, true] when given a defaults value that triggered a unique constraint error.","title":"2.0.0-rc7"},{"location":"changelog/#backwards-compatibility-changes_3","text":"instance.update() using default fields will now automatically also save and validate values provided via beforeUpdate hooks Sequelize no longer supports case insensitive mysql enums pg-hstore has been moved to a devDependency, Postgres users will have to install pg-hstore manually alongside pg : $ npm install pg pg-hstore","title":"Backwards compatibility changes"},{"location":"changelog/#200-rc6","text":"[BUG] Fixed issue with including by association reference and where","title":"2.0.0-rc6"},{"location":"changelog/#200-rc5","text":"[BUG] Fixed issue with subquery creating include.where and a paranoid main model.#2749/#2769 UniqueConstraintErrors will now extend from ValidationError making it possible to catch both with .catch(ValidationError) [FEATURE] Adds {save: false} for belongsTo relationship setters. user.setOrganization(organization, {save: false}) will then only set the foreign key value, but not trigger a save on user . [FEATURE] When updating an instance _previousDataValues will now be updated after afterUpdate hooks have been run rather than before allowing you to use changed in afterUpdate [BUG] Sequelize will no longer fail on a postgres constraint error not defined by Sequelize [FEATURE] It's now possible to pass an association reference to include. var Owner = Company.belongsTo(User, {as: 'owner'}; Company.findOne({include: [Owner]});","title":"2.0.0-rc5"},{"location":"changelog/#backwards-compatibility-changes_4","text":"When updating an instance _previousDataValues will now be updated after afterUpdate hooks have been run rather than before allowing you to use changed in afterUpdate","title":"Backwards compatibility changes"},{"location":"changelog/#200-rc4","text":"[INTERNALS] Update inflection dependency to v1.5.3 [FEATURE] Replaced string error messages for connection errors with error objects. #2576 [FEATURE] Support for updating fields on duplicate key in bulk update (mysql only) #2692 [FEATURE] Basic support for Microsoft SQL Server [INTERNALS] Deprecate migration logic. This is now implemented in umzug and the CLI . [BUG] Fixed various inconsistencies with Instance.update and how it behaves together with create , fields and more. [BUG] Fixed crash/bug when using include.where together with association.scope [BUG] Fixed support for Instance.destroy() and field for postgres.","title":"2.0.0-rc4"},{"location":"changelog/#backwards-compatibility-changes_5","text":"Some of the string error messages for connection errors have been replaced with actual error instances. Checking for connection errors should now be more consistent.","title":"Backwards compatibility changes"},{"location":"changelog/#200-rc3","text":"[FEATURE] Added the possibility of removing multiple associations in 1 call #2338 [FEATURE] Undestroy method for paranoid models #2540 [FEATURE] Support for UPSERT [BUG] Add support for field named the same as the attribute in reload , bulkCreate and save #2348 [BUG] Copy the options object in association getters. #2311 [BUG] Model#destroy() now supports field , this also fixes an issue with N:M#removeAssociation and field [BUG] Customized error message can now be set for unique constraint that was created manually (not with sync, but e.g. with migrations) or that has fields with underscore naming. This was problem at least with postgres before. [BUG] Fixed a bug where plain objects like { in: [...] } were not properly converted to SQL when combined with a sequelize method ( fn , where etc.). Closes #2077 [BUG] Made the default for array search in postgres exact comparison instead of overlap [BUG] Allow logging from individual functions even though the global logging setting is false. Closes #2571 [BUG] Allow increment/decrement operations when using schemata [BUG] Allow createTable with schema [BUG] Fix some issues with findAndCount and include [INTERNALS] Update inflection dependency to v1.5.2 [REMOVED] Remove query generation syntactic sugar provided by node-sql , as well as the dependency on that module","title":"2.0.0-rc3"},{"location":"changelog/#backwards-compatibility-changes_6","text":"When eager-loading a many-to-many association, the attributes of the through table are now accessible through an attribute named after the through model rather than the through table name singularized. i.e. Task.find({include: Worker}) where the table name for through model TaskWorker is TableTaskWorkers used to produce { Worker: { ..., TableTaskWorker: {...} } } . It now produces { Worker: { ..., TaskWorker: {...} } } . Does not affect models where table name is auto-defined by Sequelize, or where table name is model name pluralized. When using Model#find() with an order clause, the table name is prepended to the ORDER BY SQL. e.g. ORDER BY Task.id rather than ORDER BY id . The change is to avoid ambiguous column names where there are eager-loaded associations with the same column names. A side effect is that code like Task.findAll( { include: [ User ], order: [ [ 'Users.id', 'ASC' ] ] } ) will now throw an error. This should be achieved with Task.findAll( { include: [ User ], order: [ [ User, 'id', 'ASC' ] ] } ) instead. Nested HSTORE objects are no longer supported. Use DataTypes.JSON instead. In PG where: { arr: [1, 2] } where the arr column is an array will now use strict comparison ( = ) instead of the overlap operator ( && ). To obtain the old behaviour, use where: { arr: { overlap: [1, 2] }} The default fields for Instance#save (when not a new record) is now an intersection of the model attributes and the changed attributes making saves more atomic while still allowing only defined attributes. Syntactic sugar for query generation was removed. You will no longer be able to call Model.dataset() to generate raw sql queries","title":"Backwards compatibility changes"},{"location":"changelog/#200-rc2","text":"[FEATURE] Added to posibility of using a sequelize object as key in sequelize.where . Also added the option of specifying a comparator [FEATURE] Added countercache functionality to hasMany associations #2375 [FEATURE] Basic JSON support #2314 [BUG] Fixes regression bug with multiple hasMany between the same models with different join tables. Closes #2316 [BUG] Don't set autocommit in nested transactions #2418 [BUG] Improved field support","title":"2.0.0-rc2"},{"location":"changelog/#200-rc1","text":"[BUG] Fixed an issue with foreign key object syntax for hasOne and belongsTo [FEATURE] Added field and name to the object form of foreign key definitions [FEATURE] Added support for calling Promise.done , thus explicitly ending the promise chain by calling done with no arguments. Done with a function argument still continues the promise chain, to maintain BC. [FEATURE] Added scope to hasMany association definitions, provides default values to association setters/finders #2268 [FEATURE] We now support transactions that automatically commit/rollback based on the result of the promise chain returned to the callback. [BUG] Only try to create indexes which don't already exist. Closes #2162 [FEATURE] Hooks are passed options [FEATURE] Hooks need not return a result - undefined return is interpreted as a resolved promise [FEATURE] Added find() hooks","title":"2.0.0-rc1"},{"location":"changelog/#backwards-compatibility-changes_7","text":"The fieldName property, used in associations with a foreign key object (A.hasMany(B, { foreignKey: { ... }}) , has been renamed to name to avoid confusion with field . The naming of the join table entry for N:M association getters is now singular (like includes) Signature of hooks has changed to pass options to all hooks. Any hooks previously defined like Model.beforeCreate(values) now need to be Model.beforeCreate(values, options) etc. Results returned by hooks are ignored - changes to results by hooks should be made by reference Model.destroy() signature has been changed from (where, options) to (options) , options now take a where parameter. Model.update() signature has been changed from (values, where, options) to (values, options) , options now take a where parameter. The syntax for Model.findOrBuild has changed, to be more in line with the rest of the library. Model.findOrBuild(where, defaults); becomes Model.findOrBuild({ where: where, defaults: defaults }); .","title":"Backwards compatibility changes"},{"location":"changelog/#v200-dev13","text":"We are working our way to the first 2.0.0 release candidate. [FEATURE] Added to option of setting a timezone offset in the sequelize constructor ( timezone option). This timezone is used when initializing a connection (using SET TIME ZONE or equivalent), and when converting a timestamp string from the DB to a JS date with mysql (postgres stores the timezone, so for postgres we rely on what's in the DB). [FEATURE] Allow setting plural and singular name on the model ( options.name in sequelize.define ) and in associations ( options.as ) to circumvent issues with weird pluralization. [FEATURE] Added support for passing an indexes array in options to sequelize.define . #1485 . See API reference for details. [FEATURE/INTERNALS] Standardized the output from QueryInterface.showIndex . [FEATURE] Include deleted rows in find #2083 [FEATURE] Make addSingular and addPlural for n:m associations (fx addUser and addUsers now both accept an array or an instance. [BUG] Hid dottie.transform on raw queries behind a flag ( nest ) #2064 [BUG] Fixed problems with transaction parameter being removed / not passed on in associations #1789 and #1968 [BUG] Fix problem with minConnections. #2048 [BUG] Fix default scope being overwritten #2087 [BUG] Fixed updatedAt timestamp not being set in bulk create when validate = true. #1962 [INTERNALS] Replaced lingo with inflection [INTERNALS] Removed underscore.string dependency and moved a couple of helper functions from Utils._ to Utils [INTERNALS] Update dependencies validator 3.2.0 -> 3.16.1 moment 2.5.0 -> 2.7.0 generic-pool 2.0.4 -> 2.1.1 sql 0.35.0 -> 0.39.0 [INTERNALS] Use a transaction inside findOrCreate , and handle unique constraint errors if multiple calls are issues concurrently on the same transaction","title":"v2.0.0-dev13"},{"location":"changelog/#backwards-compatibility-changes_8","text":"We are using a new inflection library, which should make pluralization and singularization in general more robust. However, a couple of pluralizations have changed as a result: Person is now pluralized as people instead of persons Accesors for models with underscored names are no longer camel cased automatically. For example, if you have a model with name my_model , and my_other_model.hasMany(my_model) , the getter will now be instance_of_my_model.getMy_model instead of .getMyModel . Removed support for setting sequelize.language. If your model names are not in english, use the name option provided by sequelize.name to defined singular and plural forms for your model. Model names are now used more verbatim in associations. This means that if you have a model named Task (plural T), or an association specifying { as: 'Task' } , the tasks will be returned as relatedModel.Tasks instead of relatedModel.tasks . For more information and how to mitigate this, see https://github.com/sequelize/sequelize/wiki/Upgrading-to-2.0#inflection-replaces-lingo-and-changes-to-naming-conventions Removed the freezeAssociations option - use model and assocation names instead to provide the plural form yourself Removed sequelize.language option (not supported by inflection) Error handling has been refactored. Code that listens for : All Error classes properly inherit from Error and a common SequelizeBaseError base Instance Validator returns a single instance of a ValidationError which contains an errors array property. This property contains individual error items for each failed validation. ValidationError includes a get(path) method to find all broken validations for a path on an instance. To migrate existing error handling, switch from array indexing to using the get method: Old: err.validateCustom[0] New: err.get('validateCustom')[0] - The syntax for findOrCreate has changed, to be more in line with the rest of the library. Model.findOrCreate(where, defaults); becomes Model.findOrCreate({ where: where, defaults: defaults }); .","title":"Backwards compatibility changes"},{"location":"changelog/#v200-dev12","text":"[FEATURE] You can now return a promise to a hook rather than use a callback [FEATURE] There is now basic support for assigning a field name to an attribute name: {type: DataTypes.STRING, field: 'full_name'} [FEATURE] It's now possible to add multiple relations to a hasMany association, modelInstance.addRelations([otherInstanceA, otherInstanceB]) [FEATURE] define() stores models in sequelize.models Object e.g. sequelize.models.MyModel [FEATURE] The set / add / has methods for associations now allow you to pass the value of a primary key, instead of a full Instance object, like so: user.addTask(15); . [FEATURE] Support for FOR UPDATE and FOR SHARE statements #1777 [FEATURE] n:m createAssocation now returns the target model instance instead of the join model instance [FEATURE] Extend the foreignKey option for associations to support a full data type definition, and not just a string [FEATURE] Extract CLI into separate projects . [FEATURE] Sqlite now inserts dates with millisecond precision [FEATURE] Sequelize.VIRTUAL datatype which provides regular attribute functionality (set, get, etc) but never persists to database. [BUG] An error is now thrown if an association would create a naming conflict between the association and the foreign key when doing eager loading. Closes #1272 [BUG] Fix logging options for sequelize.sync [BUG] find no longer applies limit: 1 if querying on a primary key, should fix a lot of subquery issues. [BUG] Transactions now use the pool so you will never go over your pool defined connection limit [BUG] Fix use of Sequelize.literal in eager loading and when renaming attributes #1916 [BUG] Use the provided name for a unique index if one is given, instead of concating the column names together #1944 [BUG] Create a composite primary key for doubled linked self reference #1891 [INTERNALS] bulkDeleteQuery was removed from the MySQL / abstract query generator, since it was never used internally. Please use deleteQuery instead.","title":"v2.0.0-dev12"},{"location":"changelog/#backwards-compatibility-changes_9","text":"Sequelize now returns promises instead of its custom event emitter from most calls. This affects methods that return multiple values (like findOrCreate or findOrInitialize ). If your current callbacks do not accept the 2nd success parameter you might be seeing an array as the first param. Either use .spread() for these methods or add another argument to your callback: .success(instance) -> .success(instance, created) . .success() / .done() and any other non promise methods are now deprecated (we will keep the codebase around for a few versions though). on('sql') persists for debugging purposes. Model association calls (belongsTo/hasOne/hasMany) are no longer chainable. (this is to support being able to pass association references to include rather than model/as combinations) QueryInterface no longer emits global events. This means you can no longer do things like QueryInterface.on('showAllSchemas', function ... sequelize.showAllSchemas now returns an array of schemas, instead of an array containinig an array of schemas sequelize.transaction() now returns a promise rather than a instance of Sequelize.Transaction bulkCreate , bulkUpdate and bulkDestroy (and aliases) now take both a hooks and an individualHooks option, hooks defines whether or not to run the main hooks, and individualHooks defines whether to run hooks for each instance affected. It is no longer possible to disable pooling, disable pooling will just result in a 1/1 pool.","title":"Backwards compatibility changes"},{"location":"changelog/#v200-dev11","text":"","title":"v2.0.0-dev11"},{"location":"changelog/#caution-this-release-contains-many-changes-and-is-highly-experimental","text":"[PERFORMANCE] increased build performance when using include, which speeds up findAll etc. [BUG] Made it possible to use HSTORE both in attribute: HSTORE and attribute: { type: HSTORE } form. Thanks to @tomchentw #1458 [FEATURE] n:m now marks the columns of the through table as foreign keys and cascades them on delete and update by default. [FEATURE] 1:1 and 1:m marks columns as foreign keys, and sets them to cascade on update and set null on delete. If you are working with an existing DB which does not allow null values, be sure to override those options, or disable them completely by passing constraints: false to your assocation call ( M1.belongsTo(M2, { constraints: false}) ). [BUG] Removed the hard dependency on pg, allowing users to use pg.js [BUG] Fixed a bug with foreign keys pointing to attributes that were not integers. Now your primaryKey can be a string, and associations will still work. Thanks to @fixe #1544 [BUG] Fix a case where createdAt timestamp would not be set when updatedAt was disabled Thanks to @fixe #1543 [BUG] Fix a case where timestamps were not being write protected in set when underscored=true. janmeier #1523 [FEATURE/BUG] Prefetching/includes now fully support schemas [FEATURE] Centralize logging. #1566 [FEATURE/BUG] hstore values are now parsed on find/findAll. Thanks to @nunofgs #1560 [FEATURE] Read cli options from a file. Thanks to @codeinvain #1540","title":"Caution: This release contains many changes and is highly experimental"},{"location":"changelog/#backwards-compatibility-changes_10","text":"The notNull validator has been removed, use the Schema's allowNull property. All Validation errors now return a sequelize.ValidationError which inherits from Error. selectedValues has been removed for performance reasons, if you depend on this, please open an issue and we will help you work around it. foreign keys will now correctly be based on the alias of the model if you have any 1:1 relations where both sides use an alias, you'll need to set the foreign key, or they'll each use a different foreign key based on their alias. foreign keys for non-id primary keys will now be named for the foreign key, i.e. pub_name rather than pub_id if you have non-id primary keys you should go through your associations and set the foreignKey option if relying on a incorrect _id foreign key syncOnAssocation has been removed. It only worked for n:m, and having a synchronous function (hasMany) that invokes an asynchronous function (sync) without returning an emitter does not make a lot of sense. If you (implicitly) depended on this feature, sequelize.sync is your friend. If you do not want to do a full sync, use custom through models for n:m ( M1.hasMany(M2, { through: M3}) ) and sync the through model explicitly. Join tables will be no longer be paranoid (have a deletedAt timestamp added), even though other models are. All tables in select queries will now be aliased with the model names to be support schemas. This will affect people stuff like `where: {'table.attribute': value}","title":"Backwards compatibility changes"},{"location":"changelog/#v1710","text":"[FEATURE] ilike support for postgres #2122 [FEATURE] distinct option for count #2079 [BUG] various fixes","title":"v1.7.10"},{"location":"changelog/#v179","text":"[BUG] fixes issue with custom primary keys and N:M join tables #1929","title":"v1.7.9"},{"location":"changelog/#v178","text":"[FEATURE] adds rlike support for mysql","title":"v1.7.8"},{"location":"changelog/#v177","text":"[BUG] fixes issue where count/findAndCountAll would throw on empty rows #1849","title":"v1.7.7"},{"location":"changelog/#v176","text":"[BUG] fixes issue where primary key is also foreign key #1818","title":"v1.7.6"},{"location":"changelog/#v175","text":"[BUG] fixes bug with some methods relying on table information throwing strange errors #1686","title":"v1.7.5"},{"location":"changelog/#v173","text":"[BUG] fixes foreign key types for hasMany","title":"v1.7.3"},{"location":"changelog/#v172","text":"[BUG] fixes transactions support for 1-to-1 association setters.","title":"v1.7.2"},{"location":"changelog/#v171","text":"[BUG] fixes issue where relations would not use transactions probably in adders/setters.","title":"v1.7.1"},{"location":"changelog/#v170","text":"[FEATURE] covers more advanced include cases with limiting and filtering (specifically cases where a include would be in the subquery but its child include wouldnt be, for cases where a 1:1 association had a 1:M association as a nested include) [BUG] fixes issue where connection would timeout before calling COMMIT resulting in data never reaching the database #1429","title":"v1.7.0"},{"location":"changelog/#v170-rc9","text":"[PERFORMANCE] fixes performance regression introduced in rc7 [FEATURE] include all relations for a model #1421 [BUG] N:M adder/getter with through model and custom primary keys now work","title":"v1.7.0-rc9"},{"location":"changelog/#v170-rc8","text":"[BUG] fixes bug with required includes without wheres with subqueries","title":"v1.7.0-rc8"},{"location":"changelog/#v170-rc7","text":"[BUG] ORDER BY statements when using includes should now be places in the appropriate sub/main query more intelligently. [BUG] using include.attributes with primary key attributes specified should no longer result in multiple primary key attributes being selected #1410 [DEPENDENCIES] all dependencies, including Validator have been updated to the latest versions.","title":"v1.7.0-rc7"},{"location":"changelog/#backwards-compatability-changes","text":".set() will no longer set values that are not a dynamic setter or defined in the model. This only breaks BC since .set() was introduced but restores original .updateAttributes functionality where it was possible to 'trust' user input.","title":"Backwards compatability changes"},{"location":"changelog/#v170-rc6","text":"[BUG] Encode binary strings as bytea in postgres, and fix a case where using a binary as key in an association would produce an error 1364 . Thanks to @SohumB","title":"v1.7.0-rc6"},{"location":"changelog/#v170-rc5","text":"[FEATURE] sync() now correctly returns with an error when foreign key constraints reference unknown tables [BUG] sync() no longer fails with foreign key constraints references own table (toposort self-dependency error) [FEATURE] makes it possible to specify exactly what timestamp attributes you want to utilize #1334 [FEATURE] Support coffee script files in migrations. #1357 [FEATURE] include.where now supports Sequelize.and()/.or(). #1361","title":"v1.7.0-rc5"},{"location":"changelog/#v170-rc4","text":"[BUG] fixes issue with postgres sync and enums #1020 [BUG] fixes various issues with limit and includes #1322 [BUG] fixes issues with migrations/queryInterface createTable and enums [BUG] migration/queryInterface.addIndex() no longer fails on reserved keywords like 'from' [FEATURE] bulkCreate now supports a ignoreDuplicates option for MySQL, SQLite and MariaDB that will use INSERT IGNORE [BUG] fixes regression bug with 1:M self associations [FEATURE] significant performance improvements for 1:1 and single primary key includes for 500+ rows #1333","title":"v1.7.0-rc4"},{"location":"changelog/#backwards-compatability-changes_1","text":"find/findAll will now always return primary keys regardless of attributes settings. (Motivation was to fix various issues with eager loading)","title":"Backwards compatability changes"},{"location":"changelog/#v170-rc3","text":"[FEATURE] dropAllTables now takes an option parameter with skip as an option #1280 [FEATURE] implements .spread for eventemitters #1277 [BUG] fixes some of the mysql connection error bugs #1282 [Feature] Support for OR queries. [Feature] Support for HAVING queries. #1286 [FEATURE] bulkUpdate and bulkDestroy now returns affected rows. #1293 [BUG] fixes transaction memory leak issue [BUG] fixes security issue where it was possible to overwrite the id attribute when defined by sequelize (screwup - and fix - by mickhansen)","title":"v1.7.0-rc3"},{"location":"changelog/#v170-rc2","text":"[BUG] fixes unixSocket connections for mariadb #1248 [BUG] fixes a hangup issue for mysql #1244 [BUG] improves handling of uncaught errors in eventemitter #1245 [BUG] fixes bug with mysql replication and pool settings #1251 [BUG] fixes bug where through models created by N:M associations would inherit hooks #1263 [FEATURE] .col()/.literal()/etc now works with findAll #1249 [BUG] now currectly handles connection timeouts as errors #1207","title":"v1.7.0-rc2"},{"location":"changelog/#v200-alpha1","text":"[FEATURE] async validations. #580 . thanks to Interlock","title":"v2.0.0 (alpha1)"},{"location":"changelog/#v170-rc1","text":"[FEATURE] instance.createAssociationInstance functionality added #1213 [BUG] fixes a few bugs with transactions in regards to associations [FEATURE] add error handling for transaction creation [FEATURE] sequelize --undo will now actually undo migrations. Its basically an alias for sequelize --migrate --undo . #1059 [BUG] fix bug where {where: {ne: null}} would result in != NULL instead of IS NOT NULL #1231 [BUG] fixes a bug with validation skipping using the fields options. #1233 [BUG] fixes a bug with postgres and setters #1234 [BUG] fixes it so field: {type: Sequelize.ENUM(value1, value2)} works","title":"v1.7.0-rc1"},{"location":"changelog/#backwards-compatability-changes_2","text":"Hooks are no longer passing value hashes. Instead, they are now passing instances of the model. Hook callbacks no longer take two arguments (previously: err, newValues ). They only take the error argument since values can be changed directly on the model instance.","title":"Backwards compatability changes"},{"location":"changelog/#v170-beta8","text":"[FEATURE] max()/min() now supports dates #1200 [FEATURE] findAndCountAll now supports the include option","title":"v1.7.0-beta8"},{"location":"changelog/#backwards-compatibility-changes_11","text":"You will now need to include the relevant subtables to query on them in finders (find/findAll) Subquery logic no longer depends on where objects with keys containing '.', instead where options on the include options #1199","title":"Backwards compatibility changes"},{"location":"changelog/#v170-beta7","text":"[FEATURE] Nested eager loading / prefetching is now supported. Docs [FEATURE] Eager loading / prefetching now supports inner joins and extending the ON statement #1199 [FEATURE] Eager loading / prefetching now returns the attributes of through models aswell #1198 [FEATURE] New set/get/changed/previous feature #1182 Various bug fixes","title":"v1.7.0-beta7"},{"location":"changelog/#backwards-compatibility-changes_12","text":"None","title":"Backwards compatibility changes"},{"location":"changelog/#v170-beta1","text":"[DEPENDENCIES] Upgraded validator for IPv6 support. #603 . thanks to durango [DEPENDENCIES] replaced underscore by lodash. #954 . thanks to durango [DEPENDENCIES] Upgraded pg to 2.0.0. #711 . thanks to durango [DEPENDENCIES] Upgraded command to 2.0.0 and generic-pool to 2.0.4. thanks to durango [DEPENDENCIES] No longer require semver. thanks to durango [BUG] Fix string escape with postgresql on raw SQL queries. #586 . thanks to zanamixx [BUG] \"order by\" is now after \"group by\". #585 . thanks to mekanics [BUG] Added decimal support for min/max. #583 . thanks to durango [BUG] Null dates don't break SQLite anymore. #572 . thanks to mweibel [BUG] Correctly handle booleans in MySQL. #608 . Thanks to terraflubb [BUG] Fixed empty where conditions in MySQL. #619 . Thanks to terraflubb [BUG] Allow overriding of default columns. #635 . Thanks to sevastos [BUG] Fix where params for belongsTo #658 . Thanks to mweibel [BUG] Default ports are now declared in the connector manager, which means the default port for PG correctly becomes 5432. #633 . durango [BUG] Columns with type BOOLEAN were always added to toJSON output, even if they were not selected see . janmeier [BUG] Hstore is now fully supported #695 . thanks to tadman [BUG] Correct join table name for tables with custom names #698 . thanks to jjclark1982 [BUG] PostgreSQL should now be able to insert empty arrays with typecasting. #718 . thanks to durango [BUG] Fields should be escaped by quoteIdentifier for max/min functions which allows SQL reserved keywords to be used. #719 . thanks to durango [BUG] Fixed bug when trying to save objects with eagerly loaded attributes #716 . thanks to iamjochen [BUG] Strings for .find() should be fixed. Also added support for string primary keys to be found easily. #737 . thanks to durango [BUG] bulkCreate would have problems with a disparate field list #738 . thanks to durango [BUG] Fixed problems with quoteIdentifiers and {raw: false} option on raw queries #751 . thanks to janmeier [BUG] Fixed SQL escaping with sqlite and unified escaping #700 . thanks to PiPeep [BUG] Fixed Postgres' pools ff57af63 [BUG] Fixed BLOB/TEXT columns having a default value declared in MySQL #793 . thanks to durango [BUG] You can now use .find() on any single integer primary key when throwing just a number as an argument #796 . thanks to durango [BUG] Adding unique to a column for Postgres in the migrator should be fixed #795 . thanks to durango [BUG] For MySQL users, if their collation allows case insensitivity then allow enums to be case insensitive as well #794 . thanks to durango [BUG] Custom primary key (not keys, just singular) should no longer be a problem for models when using any of the data retrievals with just a number or through associations #771 . thanks to sdephold & durango [BUG] Default schemas should now be utilized when describing tables #812 . thanks to durango [BUG] Fixed eager loading for many-to-many associations. #834 . thanks to lemon-tree [BUG] allowNull: true enums can now be null #857 . thanks to durango [BUG] Fixes Postgres' ability to search within arrays. #879 . thanks to durango [BUG] Find and finAll would modify the options objects, now the objects are cloned at the start of the method #884 thanks to janmeier. Improved in #899 thanks to hackwaly [BUG] Add support for typed arrays in SqlString.escape and SqlString.arrayToList #891 . thanks to LJ1102 [BUG] Postgres requires empty array to be explicitly cast on update #890 . thanks to robraux [BUG] Added tests & bugfixes for DAO-Factory.update and array of values in where clause #880 . thanks to domasx2 [BUG] sqlite no longer leaks a global db variable #900 . thanks to xming [BUG] Fix for counts queries with no result #906 . thanks to iamjochem [BUG] Allow include when the same table is referenced multiple times using hasMany #913 . thanks to janmeier [BUG] Allow definition of defaultValue for the timestamp columns (createdAt, updatedAt, deletedAt) #930 . Thank to durango [BUG] Don't delete foreign keys of many-to-many associations, if still needed. #961 . thanks to sdepold [BUG] Update timestamps when incrementing and decrementing #1023 . durango [FEATURE] Validate a model before it gets saved. #601 . thanks to durango [FEATURE] Schematics. #564 . thanks to durango [FEATURE] Foreign key constraints. #595 . thanks to optilude [FEATURE] Support for bulk insert ( <DAOFactory>.bulkCreate() , update ( <DAOFactory>.update() ) and delete ( <DAOFactory>.destroy() ) #569 . thanks to optilude [FEATURE] Add an extra queryOptions parameter to DAOFactory.find and DAOFactory.findAll . This allows a user to specify { raw: true } , meaning that the raw result should be returned, instead of built DAOs. Usefull for queries returning large datasets, see #611 janmeier [FEATURE] Added convenient data types. #616 . Thanks to Costent [FEATURE] Binary is more verbose now. #612 . Thanks to terraflubb [FEATURE] Promises/A support. #626 . Thanks to kevinbeaty [FEATURE] Added Getters/Setters method for DAO. #538 . Thanks to iamjochem [FEATURE] Added model wide validations. #640 . Thanks to tremby [FEATURE] findOrCreate now returns an additional flag ( created ), that is true if a model was created, and false if it was found #648 . janmeier [FEATURE] Field and table comments for MySQL and PG. #523 . MySQL by iamjochen. PG by janmeier [FEATURE] BigInts can now be used for autoincrement/serial columns. #673 . thanks to sevastos [FEATURE] Use moment for better postgres timestamp strings. #710 . Thanks to seth-admittedly [FEATURE] Keep milliseconds in timestamps for postgres. #712 . Thanks to seth-admittedly [FEATURE] You can now set lingo's language through Sequelize. #713 . Thanks to durango [FEATURE] Added a findAndCountAll , useful for pagination. #533 . Thanks to iamjochen [FEATURE] Made explicit migrations possible. #728 . Thanks to freezy [FEATURE] Added support for where clauses containing !=, < etc. and support for date ranges #727 . Thanks to durango [FEATURE] Added support for model instances being referenced #761 thanks to sdepold [FEATURE] Added support for specifying the path to load a module for a dialect. #766 thanks to sonnym. [FEATURE] Drop index if exists has been added to sqlite #766 thanks to coderbuzz [FEATURE] bulkCreate() now has a third argument which gives you the ability to validate each row before attempting to bulkInsert #797 . thanks to durango [FEATURE] Added isDirty to model instances. #798 . Thanks to mstorgaard [FEATURE] Added possibility to use env variable for the database connection. #784 . Thanks to sykopomp. [FEATURE] Blob support. janmeier [FEATURE] We can now define our own custom timestamp columns #856 . thanks to durango [FEATURE] Scopes. #748 . durango [FEATURE] Model#find() / Model#findAll() is now working with strings. #855 . Thanks to whito. [FEATURE] Shortcut method for getting a defined model. #868 . Thanks to jwilm. [FEATURE] Added Sequelize.fn() and Sequelize.col() to properly call columns and functions within Sequelize. #882 . thanks to janmeier [FEATURE] Sequelize.import supports relative paths. #901 . thanks to accerqueira. [FEATURE] Sequelize.import can now handle functions. #911 . Thanks to davidrivera. [FEATURE] Uses sequelize.fn and sequelize.col functionality to allow you to use the value of another column or a function when updating. It also allows you to use a function as a default value when supported (in sqlite and postgres). #928 . thanks to janmeier [FEATURE] Added possibility to pass options to node-mysql. #929 . thanks to poying [FEATURE] Triggers for Postgres. #915 . Thanks to jonathana. [FEATURE] Support for join tables. #877 . Thanks to janmeier. [FEATURE] Support for hooks. #894 . Thanks to durango. [FEATURE] Support for literals and casts. #950 . Thanks to durango. [FEATURE] Model#findOrBuild. #960 . Thanks to durango. [FEATURE] Support for MariaDB. #948 . Thanks to reedog117 and janmeier. [FEATURE] Filter through associations. #991 . Thanks to snit-ram. [FEATURE] Possibility to disable loging for .sync #937 . Thanks to durango [FEATURE] Support for transactions. 1062 . [REFACTORING] hasMany now uses a single SQL statement when creating and destroying associations, instead of removing each association separately 690 . Inspired by #104 . janmeier [REFACTORING] Consistent handling of offset across dialects. Offset is now always applied, and limit is set to max table size of not limit is given #725 . janmeier [REFACTORING] Moved Jasmine to Buster and then Buster to Mocha + Chai. sdepold and durango","title":"v1.7.0-beta1"},{"location":"changelog/#v160","text":"[DEPENDENCIES] upgrade mysql to alpha7. You MUST use this version or newer for DATETIMEs to work [DEPENDENCIES] upgraded most dependencies. most important: mysql was upgraded to 2.0.0-alpha-3 [DEPENDENCIES] mysql is now an optional dependency. #355 (thanks to clkao) [REFACTORING] separated tests for dialects [REFACTORING] reduced number of sql queries used for adding an element to a N:M association. #449 (thanks to innofluence/janmeier) [REFACTORING] dropped support for synchronous migrations. added third parameter which needs to get called once the migration has been finished. also this adds support for asynchronous actions in migrations. [OTHERS] code was formatted to fit the latest code style guidelines (thanks to durango) [OTHERS] Explicitly target ./docs folder for generate-docs script. #444 (thanks to carsondarling) [OTHERS] Overwrite existing daoFactoryDefinition if there already has been one. (thanks to robraux) [BUG] fixed wrong version in sequelize binary [BUG] local options have higher priority than global options (thanks to guersam) [BUG] fixed where clause when passing an empty array (thanks to kbackowski) [BUG] fixed updateAttributes for models/tables without primary key (thanks to durango) [BUG] fixed the location of the foreign key when using belongsTo (thanks to ricardograca) [BUG] don't return timestamps if only specific attributes have been seleceted (thanks to ricardograca) [BUG] fixed removeColumn for sqlite [BUG] fixed date equality check for instances. (thanks to solotimes) [FEATURE] added association prefetching /eager loading for find and findAll. #465 [FEATURE] it's now possible to use callbacks of async functions inside migrations (thanks to mphilpot) [FEATURE] improved comfort of sequelize.query. just pass an sql string to it and wait for the result [FEATURE] Migrations now understand NODE_ENV (thanks to gavri) [FEATURE] Performance improvements (thanks to Mick-Hansen and janmeier from innofluence) [FEATURE] Model.find and Model.findAll can now take a String with an ID. (thanks to ghernandez345) [FEATURE] Compatibility for JSON-like strings in Postgres (thanks to aslakhellesoy) [FEATURE] honor maxConcurrentQueries option (thanks to dchester) [FEATURE] added support for stored procedures (inspired by wuyuntao) [FEATURE] added possibility to use pg lib's native api (thanks to denysonique) [FEATURE] added possibility to define the attributes of received associations (thanks to joshm) [FEATURE] added findOrCreate, which returns a the already existing instance or creates one (thanks to eveiga) [FEATURE] minConnections option for MySQL pooling (thanks to dominiklessel) [FEATURE] added BIGINT data type which is treated like a string (thanks to adamsch1) [FEATURE] experimental support for read replication for mysql (thanks to Janzeh) [FEATURE] allow definition of a models table name (thanks to slamkajs) [FEATURE] allow usage of enums. #440 (thanks to KevinMartin) [FEATURE] allows updateAttributes to target specific fields only (thanks to Pasvaz) [FEATURE] timestamps are now stored as UTC. #461 (thanks to innofluence/janmeier) [FEATURE] results of raw queries are parsed with dottie. #468 (thanks to kozze89) [FEATURE] support for array serialization. pg only. #443 (thanks to clkao) [FEATURE] add increment and decrement methods on dao. #408 (thanks to janmeier/innofluence) [FEATURE] unified the result of describeTable [FEATURE] add support for decimals (thanks to alexyoung) [FEATURE] added DAO.reload(), which updates the attributes of the DAO in-place (as opposed to doing having to do a find() and returning a new model)","title":"v1.6.0"},{"location":"changelog/#v150","text":"[REFACTORING] use underscore functions for Utils.isHash (thanks to Mick-Hansen/innofluence) [REFACTORING] removed the 'failure' event and replaced it with 'error' [BUG] fixed booleans for sqlite (thanks to vlmonk) [BUG] obsolete reference attribute for many-to-many associations are removed correctly [BUG] associations can be cleared via passing null to the set method [BUG] \"fixed\" quota handling (thanks to dgf) [BUG] fixed destroy in postgresql (thanks to robraux) [FEATURE] added possibility to set protocol and to remove port from postgresql connection uri (thanks to danielschwartz) [FEATURE] added possibility to not use a junction table for many-to-many associations on the same table (thanks to janmeier/innofluence) [FEATURE] results of the import method is now cached (thanks to janmeier/innofluence) [FEATURE] added possibility to check if a specific object or a whole bunch of objects is currently associated with another object (thanks to janmeier/innofluence) [FEATURE] added possibility to globally disable adding of NULL values to sql queries (thanks to janmeier/innofluence) [FEATURE] Model.create can now also be used to specify values for mass assignment (thanks to janmeier/innofluence) [FEATURE] QueryChainer will now provide the results of the added emitters in the order the emitters have been added (thanks to LaurentZuijdwijk and me ;)) [FEATURE] QueryChainer can now be initialized with serial items [FEATURE] node 0.8 compatibility [FEATURE] added options to hasMany getters (thanks to janmeier/innofluence) [FEATURE] pooling option is now correctly passed to postgres (thanks to megshark)","title":"v1.5.0"},{"location":"changelog/#v141","text":"[DEPRECATION] Added deprecation warning for node < v0.6. [FEATURE] added selective saving of instances (thanks to kioopi) [FEATURE] added command to binary for creating a migration skeleton with current timestamp [FEATURE] added complete function for each finder method (thanks to sstoiana) [BUG] fixed quotation for sqlite statements (thanks to vlmonk) [BUG] fixed timestamp parsing in migratios (thanks to grn) [FEATURE] added consistent logging behaviour to postgres (thanks to reacuna)","title":"v1.4.1"},{"location":"changelog/#v140","text":"[BUG] fixed booleans in sqlite (thanks to alexstrat) [BUG] fixed forced sync of many-to-many associations (thanks to SirUli) [FEATURE] objects are now compatible to JSON.stringify. (thanks to grayt0r) [FEATURE] When instantiating the sequelize object, you can now pass a function to logging. This allows you to customize the logging behavior. Default is now: console.log (thanks to kenperkins) [BUG] The default logging is still console.log but is wrapped after initialization as it crashes node < 0.6.x. [FEATURE] postgresql support. (thanks to swoodtke) [FEATURE] connection-pooling for mysql. (thanks to megshark) [FEATURE] added possibility to define NOW as default value for date data-types. Use Sequelize.NOW as defaultValue [BUG] Fixed date handling in sqlite (thanks to iizukanao)","title":"v1.4.0"},{"location":"changelog/#v137","text":"[BUG] fixed issue where multiple belongsTo or hasOne associations to the same table overwrite each other [BUG] fixed memory leaks (thanks to megshark)","title":"v1.3.7"},{"location":"changelog/#v136","text":"[BUG] don't update an existing updatedAt-attribute if timestamps option for a DAO is false","title":"v1.3.6"},{"location":"changelog/#v135","text":"[BUG] fixed missed DAO renaming in migrations (thanks to nov)","title":"v1.3.5"},{"location":"changelog/#v134","text":"[REFACTORING] renamed Model/ModelFactory/ModelFactoryManager to DAO/DAOFactory/DAOFactoryManager [IMPROVEMENT] npm test will run the test suite (thanks to gabrielfalcao) [IMPROVEMENT] documentation about setting up local development environment (thanks to gabrielfalcao) [REFACTORING] removed updatedAt + createdAt from SequelizeMeta","title":"v1.3.4"},{"location":"changelog/#v133","text":"[BUG] fixed sql-event emitter in all possible locations (thanks to megshark)","title":"v1.3.3"},{"location":"changelog/#v132","text":"[FEATURE] sqlite is now emitting the 'sql'-event as well (thanks to megshark)","title":"v1.3.2"},{"location":"changelog/#v131","text":"[REFACTORING] renamed ModelManager to ModelFactoryManager [IMPROVEMENT] decreased delay of CustomEventEmitter execution from 5ms to 1ms [IMPROVEMENT] improved performance of association handling (many-to-many) (thanks to magshark) [FEATURE] added possibility to specify name of the join table (thanks to magshark) [FEATURE] mysql is emitting a 'sql'-event when executing a query [BUG] correctly delete existing SequelizeMeta entry from database after undoing migration [BUG] fix path of migration files in executable (thanks to bcg)","title":"v1.3.1"},{"location":"changelog/#v130","text":"[REFACTORING] Model#all is now a function and not a getter. [REFACTORING] Renamed ModelDefinition to ModelFactory [REFACTORING] Private method scoping; Attributes are still public [REFACTORING] Use the new util module for node 0.6.2 [FEATURE] QueryChainer can now run serially [FEATURE] Association definition is chainable: Person.hasOne(House).hasMany(Address) [FEATURE] Validations (Thanks to hiddentao ) [FEATURE] jQuery-like event listeners: .success(callback) and .error(callback) [FEATURE] aliasing for select queries: Model.find({ where: 'id = 1', attributes: ['id', ['name', 'username']] }) ==> will return the user's name as username [FEATURE] cross-database support. currently supported: mysql, sqlite [FEATURE] migrations [TEST] removed all expresso tests and converted them to jasmine","title":"v1.3.0"},{"location":"changelog/#v121","text":"[REFACTORING] renamed the global options for sync, query and define on sequelize; before: options.queryOptions; now: options.query [FEATURE] allow definition of charset via global define option in sequelize or via charset option in sequelize.define [FEATURE] allow definition of mysql engine via global define option in sequelize or via engine option in sequelize.define; default is InnoDB now [FEATURE] find and findAll will now search in a list of values via: Model.findAll({where: { id: [1,2,3] }}); will return all models with id 1, 2 and 3 [TEST] force latin1 charset for travis","title":"v1.2.1"},{"location":"changelog/#v120","text":"[FEATURE] min/max function for models, which return the min/max value in a column [FEATURE] getModel for modelManager for getting a model without storing it in a variable; use it via sequelize.modelManager.getModel('User') [TEST] test suite refactoring for jasmine","title":"v1.2.0"},{"location":"changelog/#v114","text":"[BUG] tables with identical prefix (e.g. wp_) can now be used in many-to-many associations","title":"v1.1.4"},{"location":"changelog/#v113","text":"[BUG] scoped options in model => a model can now have the attribute options [FEATURE] added drop method for sequelize, that drops all currently registered tables","title":"v1.1.3"},{"location":"changelog/#v112","text":"[BUG] prevent malfunction after being idle","title":"v1.1.2"},{"location":"changelog/#v111","text":"[BUG] fixed memory leaks [FEATURE] added query queueing (adjustable via maxConcurrentQueries in config; default: 50)","title":"v1.1.1"},{"location":"changelog/#v110","text":"[BUG] defaultValue 0 is now working [REMOVED] mysql-pool usage (will give it a new try later) [CHORE] updated node-mysql to 0.9.4","title":"v1.1.0"},{"location":"changelog/#v102","text":"[BUG] Fixed where clause generation for models with explicit primary keys (allanca) [BUG] Set insertId for non-default auto increment fields (allanca)","title":"v1.0.2"},{"location":"changelog/#v101","text":"[FEATURE] Added Model.count(callback), which returns the number of elements saved in the database [BUG] Fixed self associations","title":"v1.0.1"},{"location":"changelog/#v100","text":"complete rewrite added new emitter syntax sql injection protection select now supports hash usage of where select now supports array usage of where added a lot of options to find/findAll Wrapped queries correctly using foo using expresso 0.7.2 moved config for test database into seperated config file Added method for adding and deleting single associations","title":"v1.0.0"},{"location":"changelog/#v043","text":"renamed loadAssociatedData to fetchAssociations renamed Model#associatedData to fetchedAssociations added fetchAssociations to finder methods store data found by finder method in the associatedData hash + grep them from there if reload is not forced added option to sequelize constructor for disabling the pluralization of tablenames: disableTableNameModification allow array as value for chainQueries => Sequelize.chainQueries([save: [a,b,c]], callback) remove the usage of an array => Sequelize.chainQueries({save: a}, {destroy: b}, callback)","title":"v0.4.3"},{"location":"changelog/#v042","text":"fixed bugs from 0.4.1 added the model instance method loadAssociatedData which adds the hash Model#associatedData to an instance which contains all associated data","title":"v0.4.2"},{"location":"changelog/#v041","text":"THIS UPDATE CHANGES TABLE STRUCTURES MASSIVELY! MAKE SURE TO DROP YOUR CURRENT TABLES AND LET THEM CREATE AGAIN! names of many-to-many-association-tables are chosen from passed association names foreign keys are chosen from passed association name added many-to-many association on the same model added hasManyAndBelongsTo added hasOneAndBelongsTo nodejs-mysql-native 0.4.2","title":"v0.4.1"},{"location":"changelog/#v040","text":"added error handling when defining invalid database credentials Sequelize#sync, Sequelize#drop, model#sync, model#drop returns errors via callback code is now located under lib/sequelize to use it with nDistro added possibility to use non default mysql database (host/port) added error handling when defining invalid database port/host schema definitions can now contain default values and null allowance database credentials can now also contain an empty / no password","title":"v0.4.0"},{"location":"changelog/#v030","text":"added possibility to define class and instance methods for models added import method for loading model definition from a file","title":"v0.3.0"},{"location":"changelog/#v026","text":"refactored Sequelize to fit CommonJS module conventions","title":"v0.2.6"},{"location":"changelog/#v025","text":"added BOOLEAN type added FLOAT type fixed DATE type issue fixed npm package","title":"v0.2.5"},{"location":"changelog/#v024","text":"fixed bug when using cross associated tables (many to many associations)","title":"v0.2.4"},{"location":"changelog/#v023","text":"added latest mysql connection library fixed id handling on save fixed text handling (varchar > 255; text) using the inflection library for naming tables more convenient Sequelize.TEXT is now using MySQL datatype TEXT instead of varchar(4000)","title":"v0.2.3"},{"location":"changelog/#v022","text":"released project as npm package","title":"v0.2.2"},{"location":"changelog/#v021","text":"fixed date bug","title":"v0.2.1"},{"location":"changelog/#v020","text":"added methods for setting associations added method for chaining an arbitraty amount of queries","title":"v0.2.0"},{"location":"changelog/#v010","text":"first stable version implemented all basic functions associations are working","title":"v0.1.0"},{"location":"imprint/","text":"Imprint - Boring legal stuff for the rest of us. As there are people who are suing for fun and glory, you can find the respective information about the author of the page right here. Have fun reading ... AUTHOR(S) Main author: Sascha Depold Uhlandstr. 122 10717 Berlin sascha [at] depold [dot] com [plus] 49 152 [slash] 03878582 INHALTLICHE VERANTWORTUNG Ich \u00fcbernehme keine Haftung f\u00fcr ausgehende Links. Daher musst du dich bei Problemen an deren Betreiber wenden!","title":"Imprint"},{"location":"imprint/#imprint-boring-legal-stuff-for-the-rest-of-us","text":"As there are people who are suing for fun and glory, you can find the respective information about the author of the page right here. Have fun reading ...","title":"Imprint - Boring legal stuff for the rest of us."},{"location":"imprint/#authors","text":"Main author: Sascha Depold Uhlandstr. 122 10717 Berlin sascha [at] depold [dot] com [plus] 49 152 [slash] 03878582","title":"AUTHOR(S)"},{"location":"imprint/#inhaltliche-verantwortung","text":"Ich \u00fcbernehme keine Haftung f\u00fcr ausgehende Links. Daher musst du dich bei Problemen an deren Betreiber wenden!","title":"INHALTLICHE VERANTWORTUNG"},{"location":"api/datatypes/","text":"Class DataTypes View code A convenience class holding commonly used data types. The datatypes are used when defining a new model using Sequelize.define , like this: sequelize.define('model', { column: DataTypes.INTEGER }) When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using DataTypes.BLOB , mean that that column will be returned as an instance of Buffer when being fetched by sequelize. Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do DataTypes.INTEGER.UNSIGNED.ZEROFILL . The order you access the properties in do not matter, so DataTypes.INTEGER.ZEROFILL.UNSIGNED is fine as well. The available properties are listed under each data type. To provide a length for the data type, you can invoke it like a function: INTEGER(2) Three of the values provided here ( NOW , UUIDV1 and UUIDV4 ) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard: sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV1, primaryKey: true } }) There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplised using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value from a function. sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: function() { return generateMyId() }, primaryKey: true } }) STRING() View code A variable length string. Default length 255 Available properties: BINARY CHAR() View code A fixed length string. Default length 255 Available properties: BINARY TEXT() View code An (un)limited length text column. Available lengths: tiny , medium , long INTEGER() View code A 32 bit integer. Available properties: UNSIGNED , ZEROFILL BIGINT() View code A 64 bit integer. Note: an attribute defined as BIGINT will be treated like a string due this feature from node-postgres to prevent precision loss. To have this attribute as a number , this is a possible workaround . Available properties: UNSIGNED , ZEROFILL FLOAT() View code Floating point number (4-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL REAL() View code Floating point number (4-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL DOUBLE() View code Floating point number (8-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL DECIMAL() View code Decimal number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL BOOLEAN() View code A boolean / tinyint column, depending on dialect TIME() View code A time column DATE() View code A datetime column DATEONLY() View code A date only column HSTORE() View code A key / value column. Only available in postgres. JSON() View code A JSON string column. Only available in postgres. JSONB() View code A pre-processed JSON data column. Only available in postgres. NOW() View code A default value of the current timestamp BLOB() View code Binary storage. Available lengths: tiny , medium , long RANGE() View code Range types are data types representing a range of values of some element type (called the range's subtype). Only available in postgres. See {@link http://www.postgresql.org/docs/9.4/static/rangetypes.html|Postgres documentation} for more details UUID() View code A column storing a unique universal identifier. Use with UUIDV1 or UUIDV4 for default values. UUIDV1() View code A default unique universal identifier generated following the UUID v1 standard UUIDV4() View code A default unique universal identifier generated following the UUID v4 standard VIRTUAL() View code A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB. You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example: sequelize.define('user', { password_hash: DataTypes.STRING, password: { type: DataTypes.VIRTUAL, set: function (val) { this.setDataValue('password', val); // Remember to set the data value, otherwise it won't be validated this.setDataValue('password_hash', this.salt + val); }, validate: { isLongEnough: function (val) { if (val.length < 7) { throw new Error(\"Please choose a longer password\") } } } } }) In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB. VIRTUAL also takes a return type and dependency fields as arguments If a virtual attribute is present in attributes it will automatically pull in the extra fields as well. Return type is mostly useful for setups that rely on types like GraphQL. { active: { type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']), get: function() { return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000) } } } Aliases: NONE ENUM() View code An enumeration. DataTypes.ENUM('value', 'another value') . ARRAY() View code An array of type , e.g. DataTypes.ARRAY(DataTypes.DECIMAL) . Only available in postgres. GEOMETRY() View code A column storing Geometry information. Only available in PostgreSQL (with PostGIS) or MySQL. In MySQL, allowable Geometry types are 'POINT', 'LINESTRING', 'POLYGON'. When using, GeoJSON is accepted as input and returned as output. In PostGIS, the GeoJSON is parsed using the PostGIS function ST_GeomFromGeoJSON . In MySQL it is parsed using the function GeomFromText . Therefore, one can just follow the GeoJSON spec for handling geometry objects. See the following examples: // Create a new point: var point = { type: 'Point', coordinates: [39.807222,-76.984722]}; User.create({username: 'username', geometry: point }).then(function(newUser) { ... }); // Create a new linestring: var line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] }; User.create({username: 'username', geometry: line }).then(function(newUser) { ... }); // Create a new polygon: var polygon = { type: 'Polygon', coordinates: [ [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ] ]}; User.create({username: 'username', geometry: polygon }).then(function(newUser) { ... }); // Create a new point with a custom SRID: var point = { type: 'Point', coordinates: [39.807222,-76.984722], crs: { type: 'name', properties: { name: 'EPSG:4326'} } }; User.create({username: 'username', geometry: point }).then(function(newUser) { ... }); GEOGRAPHY() View code A geography datatype represents two dimensional spacial objects in an elliptic coord system. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Datatypes"},{"location":"api/datatypes/#class-datatypes","text":"View code A convenience class holding commonly used data types. The datatypes are used when defining a new model using Sequelize.define , like this: sequelize.define('model', { column: DataTypes.INTEGER }) When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using DataTypes.BLOB , mean that that column will be returned as an instance of Buffer when being fetched by sequelize. Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do DataTypes.INTEGER.UNSIGNED.ZEROFILL . The order you access the properties in do not matter, so DataTypes.INTEGER.ZEROFILL.UNSIGNED is fine as well. The available properties are listed under each data type. To provide a length for the data type, you can invoke it like a function: INTEGER(2) Three of the values provided here ( NOW , UUIDV1 and UUIDV4 ) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard: sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV1, primaryKey: true } }) There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplised using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value from a function. sequelize.define('model', { uuid: { type: DataTypes.UUID, defaultValue: function() { return generateMyId() }, primaryKey: true } })","title":"Class DataTypes"},{"location":"api/datatypes/#string","text":"View code A variable length string. Default length 255 Available properties: BINARY","title":"STRING()"},{"location":"api/datatypes/#char","text":"View code A fixed length string. Default length 255 Available properties: BINARY","title":"CHAR()"},{"location":"api/datatypes/#text","text":"View code An (un)limited length text column. Available lengths: tiny , medium , long","title":"TEXT()"},{"location":"api/datatypes/#integer","text":"View code A 32 bit integer. Available properties: UNSIGNED , ZEROFILL","title":"INTEGER()"},{"location":"api/datatypes/#bigint","text":"View code A 64 bit integer. Note: an attribute defined as BIGINT will be treated like a string due this feature from node-postgres to prevent precision loss. To have this attribute as a number , this is a possible workaround . Available properties: UNSIGNED , ZEROFILL","title":"BIGINT()"},{"location":"api/datatypes/#float","text":"View code Floating point number (4-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"FLOAT()"},{"location":"api/datatypes/#real","text":"View code Floating point number (4-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"REAL()"},{"location":"api/datatypes/#double","text":"View code Floating point number (8-byte precision). Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"DOUBLE()"},{"location":"api/datatypes/#decimal","text":"View code Decimal number. Accepts one or two arguments for precision Available properties: UNSIGNED , ZEROFILL","title":"DECIMAL()"},{"location":"api/datatypes/#boolean","text":"View code A boolean / tinyint column, depending on dialect","title":"BOOLEAN()"},{"location":"api/datatypes/#time","text":"View code A time column","title":"TIME()"},{"location":"api/datatypes/#date","text":"View code A datetime column","title":"DATE()"},{"location":"api/datatypes/#dateonly","text":"View code A date only column","title":"DATEONLY()"},{"location":"api/datatypes/#hstore","text":"View code A key / value column. Only available in postgres.","title":"HSTORE()"},{"location":"api/datatypes/#json","text":"View code A JSON string column. Only available in postgres.","title":"JSON()"},{"location":"api/datatypes/#jsonb","text":"View code A pre-processed JSON data column. Only available in postgres.","title":"JSONB()"},{"location":"api/datatypes/#now","text":"View code A default value of the current timestamp","title":"NOW()"},{"location":"api/datatypes/#blob","text":"View code Binary storage. Available lengths: tiny , medium , long","title":"BLOB()"},{"location":"api/datatypes/#range","text":"View code Range types are data types representing a range of values of some element type (called the range's subtype). Only available in postgres. See {@link http://www.postgresql.org/docs/9.4/static/rangetypes.html|Postgres documentation} for more details","title":"RANGE()"},{"location":"api/datatypes/#uuid","text":"View code A column storing a unique universal identifier. Use with UUIDV1 or UUIDV4 for default values.","title":"UUID()"},{"location":"api/datatypes/#uuidv1","text":"View code A default unique universal identifier generated following the UUID v1 standard","title":"UUIDV1()"},{"location":"api/datatypes/#uuidv4","text":"View code A default unique universal identifier generated following the UUID v4 standard","title":"UUIDV4()"},{"location":"api/datatypes/#virtual","text":"View code A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB. You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example: sequelize.define('user', { password_hash: DataTypes.STRING, password: { type: DataTypes.VIRTUAL, set: function (val) { this.setDataValue('password', val); // Remember to set the data value, otherwise it won't be validated this.setDataValue('password_hash', this.salt + val); }, validate: { isLongEnough: function (val) { if (val.length < 7) { throw new Error(\"Please choose a longer password\") } } } } }) In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB. VIRTUAL also takes a return type and dependency fields as arguments If a virtual attribute is present in attributes it will automatically pull in the extra fields as well. Return type is mostly useful for setups that rely on types like GraphQL. { active: { type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']), get: function() { return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000) } } } Aliases: NONE","title":"VIRTUAL()"},{"location":"api/datatypes/#enum","text":"View code An enumeration. DataTypes.ENUM('value', 'another value') .","title":"ENUM()"},{"location":"api/datatypes/#array","text":"View code An array of type , e.g. DataTypes.ARRAY(DataTypes.DECIMAL) . Only available in postgres.","title":"ARRAY()"},{"location":"api/datatypes/#geometry","text":"View code A column storing Geometry information. Only available in PostgreSQL (with PostGIS) or MySQL. In MySQL, allowable Geometry types are 'POINT', 'LINESTRING', 'POLYGON'. When using, GeoJSON is accepted as input and returned as output. In PostGIS, the GeoJSON is parsed using the PostGIS function ST_GeomFromGeoJSON . In MySQL it is parsed using the function GeomFromText . Therefore, one can just follow the GeoJSON spec for handling geometry objects. See the following examples: // Create a new point: var point = { type: 'Point', coordinates: [39.807222,-76.984722]}; User.create({username: 'username', geometry: point }).then(function(newUser) { ... }); // Create a new linestring: var line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] }; User.create({username: 'username', geometry: line }).then(function(newUser) { ... }); // Create a new polygon: var polygon = { type: 'Polygon', coordinates: [ [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ] ]}; User.create({username: 'username', geometry: polygon }).then(function(newUser) { ... }); // Create a new point with a custom SRID: var point = { type: 'Point', coordinates: [39.807222,-76.984722], crs: { type: 'name', properties: { name: 'EPSG:4326'} } }; User.create({username: 'username', geometry: point }).then(function(newUser) { ... });","title":"GEOMETRY()"},{"location":"api/datatypes/#geography","text":"View code A geography datatype represents two dimensional spacial objects in an elliptic coord system. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"GEOGRAPHY()"},{"location":"api/deferrable/","text":"Deferrable() -> object View code A collection of properties related to deferrable constraints. It can be used to make foreign key constraints deferrable and to set the constraints within a transaction. This is only supported in PostgreSQL. The foreign keys can be configured like this. It will create a foreign key that will check the constraints immediately when the data was inserted. sequelize.define('Model', { foreign_id: { type: Sequelize.INTEGER, references: { model: OtherModel, key: 'id', deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }); The constraints can be configured in a transaction like this. It will trigger a query once the transaction has been started and set the constraints to be checked at the very end of the transaction. sequelize.transaction({ deferrable: Sequelize.Deferrable.SET_DEFERRED }); INITIALLY_DEFERRED() View code A property that will defer constraints checks to the end of transactions. INITIALLY_IMMEDIATE() View code A property that will trigger the constraint checks immediately NOT() View code A property that will set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction. SET_DEFERRED(constraints) View code A property that will trigger an additional query at the beginning of a transaction which sets the constraints to deferred. Params: Name Type Description constraints Array An array of constraint names. Will defer all constraints by default. SET_IMMEDIATE(constraints) View code A property that will trigger an additional query at the beginning of a transaction which sets the constraints to immediately. Params: Name Type Description constraints Array An array of constraint names. Will defer all constraints by default. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Deferrable"},{"location":"api/deferrable/#deferrable-object","text":"View code A collection of properties related to deferrable constraints. It can be used to make foreign key constraints deferrable and to set the constraints within a transaction. This is only supported in PostgreSQL. The foreign keys can be configured like this. It will create a foreign key that will check the constraints immediately when the data was inserted. sequelize.define('Model', { foreign_id: { type: Sequelize.INTEGER, references: { model: OtherModel, key: 'id', deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }); The constraints can be configured in a transaction like this. It will trigger a query once the transaction has been started and set the constraints to be checked at the very end of the transaction. sequelize.transaction({ deferrable: Sequelize.Deferrable.SET_DEFERRED });","title":"Deferrable() -&gt; object"},{"location":"api/deferrable/#initially_deferred","text":"View code A property that will defer constraints checks to the end of transactions.","title":"INITIALLY_DEFERRED()"},{"location":"api/deferrable/#initially_immediate","text":"View code A property that will trigger the constraint checks immediately","title":"INITIALLY_IMMEDIATE()"},{"location":"api/deferrable/#not","text":"View code A property that will set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction.","title":"NOT()"},{"location":"api/deferrable/#set_deferredconstraints","text":"View code A property that will trigger an additional query at the beginning of a transaction which sets the constraints to deferred. Params: Name Type Description constraints Array An array of constraint names. Will defer all constraints by default.","title":"SET_DEFERRED(constraints)"},{"location":"api/deferrable/#set_immediateconstraints","text":"View code A property that will trigger an additional query at the beginning of a transaction which sets the constraints to immediately. Params: Name Type Description constraints Array An array of constraint names. Will defer all constraints by default. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"SET_IMMEDIATE(constraints)"},{"location":"api/errors/","text":"Class Errors View code Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object. new BaseError() View code The Base Error all Sequelize Errors inherit from. Aliases: Error new ValidationError(message, [errors]) View code Validation Error. Thrown when the sequelize validation has failed. The error contains an errors property, which is an array with 1 or more ValidationErrorItems, one for each validation that failed. Params: Name Type Description message string Error message [errors] Array Array of ValidationErrorItem objects describing the validation errors Extends: BaseError errors View code An array of ValidationErrorItems get(path) View code Gets all validation error items for the path / field specified. Params: Name Type Description path string The path to be checked for error items new DatabaseError() View code A base class for all database related errors. Extends: BaseError parent View code The database specific error which triggered this one sql View code The SQL that triggered the error message() View code The message from the DB. fields() View code The fields of the unique constraint value() View code The value(s) which triggered the error index() View code The name of the index that triggered the error new TimeoutError() View code Thrown when a database query times out because of a deadlock Extends: DatabaseError new UniqueConstraintError() View code Thrown when a unique constraint is violated in the database Extends: DatabaseError new ForeignKeyConstraintError() View code Thrown when a foreign key constraint is violated in the database Extends: DatabaseError new ExclusionConstraintError() View code Thrown when an exclusion constraint is violated in the database Extends: DatabaseError new ValidationErrorItem(message, type, path, value) View code Validation Error Item Instances of this class are included in the ValidationError.errors property. Params: Name Type Description message string An error message type string The type of the validation error path string The field that triggered the validation error value string The value that generated the error new ConnectionError() View code A base class for all connection related errors. Extends: BaseError parent View code The connection specific error which triggered this one new ConnectionRefusedError() View code Thrown when a connection to a database is refused Extends: ConnectionError new AccessDeniedError() View code Thrown when a connection to a database is refused due to insufficient privileges Extends: ConnectionError new HostNotFoundError() View code Thrown when a connection to a database has a hostname that was not found Extends: ConnectionError new HostNotReachableError() View code Thrown when a connection to a database has a hostname that was not reachable Extends: ConnectionError new InvalidConnectionError() View code Thrown when a connection to a database has invalid values for any of the connection parameters Extends: ConnectionError new ConnectionTimedOutError() View code Thrown when a connection to a database times out Extends: ConnectionError new InstanceError() View code Thrown when a some problem occurred with Instance methods (see message for details) Extends: BaseError This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Errors"},{"location":"api/errors/#class-errors","text":"View code Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object.","title":"Class Errors"},{"location":"api/errors/#new-baseerror","text":"View code The Base Error all Sequelize Errors inherit from. Aliases: Error","title":"new BaseError()"},{"location":"api/errors/#new-validationerrormessage-errors","text":"View code Validation Error. Thrown when the sequelize validation has failed. The error contains an errors property, which is an array with 1 or more ValidationErrorItems, one for each validation that failed. Params: Name Type Description message string Error message [errors] Array Array of ValidationErrorItem objects describing the validation errors Extends: BaseError","title":"new ValidationError(message, [errors])"},{"location":"api/errors/#errors","text":"View code An array of ValidationErrorItems","title":"errors"},{"location":"api/errors/#getpath","text":"View code Gets all validation error items for the path / field specified. Params: Name Type Description path string The path to be checked for error items","title":"get(path)"},{"location":"api/errors/#new-databaseerror","text":"View code A base class for all database related errors. Extends: BaseError","title":"new DatabaseError()"},{"location":"api/errors/#parent","text":"View code The database specific error which triggered this one","title":"parent"},{"location":"api/errors/#sql","text":"View code The SQL that triggered the error","title":"sql"},{"location":"api/errors/#message","text":"View code The message from the DB.","title":"message()"},{"location":"api/errors/#fields","text":"View code The fields of the unique constraint","title":"fields()"},{"location":"api/errors/#value","text":"View code The value(s) which triggered the error","title":"value()"},{"location":"api/errors/#index","text":"View code The name of the index that triggered the error","title":"index()"},{"location":"api/errors/#new-timeouterror","text":"View code Thrown when a database query times out because of a deadlock Extends: DatabaseError","title":"new TimeoutError()"},{"location":"api/errors/#new-uniqueconstrainterror","text":"View code Thrown when a unique constraint is violated in the database Extends: DatabaseError","title":"new UniqueConstraintError()"},{"location":"api/errors/#new-foreignkeyconstrainterror","text":"View code Thrown when a foreign key constraint is violated in the database Extends: DatabaseError","title":"new ForeignKeyConstraintError()"},{"location":"api/errors/#new-exclusionconstrainterror","text":"View code Thrown when an exclusion constraint is violated in the database Extends: DatabaseError","title":"new ExclusionConstraintError()"},{"location":"api/errors/#new-validationerroritemmessage-type-path-value","text":"View code Validation Error Item Instances of this class are included in the ValidationError.errors property. Params: Name Type Description message string An error message type string The type of the validation error path string The field that triggered the validation error value string The value that generated the error","title":"new ValidationErrorItem(message, type, path, value)"},{"location":"api/errors/#new-connectionerror","text":"View code A base class for all connection related errors. Extends: BaseError","title":"new ConnectionError()"},{"location":"api/errors/#parent_1","text":"View code The connection specific error which triggered this one","title":"parent"},{"location":"api/errors/#new-connectionrefusederror","text":"View code Thrown when a connection to a database is refused Extends: ConnectionError","title":"new ConnectionRefusedError()"},{"location":"api/errors/#new-accessdeniederror","text":"View code Thrown when a connection to a database is refused due to insufficient privileges Extends: ConnectionError","title":"new AccessDeniedError()"},{"location":"api/errors/#new-hostnotfounderror","text":"View code Thrown when a connection to a database has a hostname that was not found Extends: ConnectionError","title":"new HostNotFoundError()"},{"location":"api/errors/#new-hostnotreachableerror","text":"View code Thrown when a connection to a database has a hostname that was not reachable Extends: ConnectionError","title":"new HostNotReachableError()"},{"location":"api/errors/#new-invalidconnectionerror","text":"View code Thrown when a connection to a database has invalid values for any of the connection parameters Extends: ConnectionError","title":"new InvalidConnectionError()"},{"location":"api/errors/#new-connectiontimedouterror","text":"View code Thrown when a connection to a database times out Extends: ConnectionError","title":"new ConnectionTimedOutError()"},{"location":"api/errors/#new-instanceerror","text":"View code Thrown when a some problem occurred with Instance methods (see message for details) Extends: BaseError This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"new InstanceError()"},{"location":"api/hooks/","text":"Mixin Hooks View code Hooks are function that are called before and after (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways: By specifying them as options in sequelize.define By calling hook() with a string and your hook handler function By calling the function with the same name as the hook you want // Method 1 sequelize.define(name, { attributes }, { hooks: { beforeBulkCreate: function () { // can be a single function }, beforeValidate: [ function () {}, function() {} // Or an array of several ] } }) // Method 2 Model.hook('afterDestroy', function () {}) // Method 3 Model.afterBulkUpdate(function () {}) See: Sequelize#define addHook(hooktype, [name], fn) View code Add a hook to the model Params: Name Type Description hooktype String [name] String Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future. fn Function The hook function Aliases: hook removeHook(hookType, name) View code Remove hook from the model Params: Name Type Description hookType String name String hasHook(hookType) View code Check whether the mode has any hooks of this type Params: Name Type Description hookType String Aliases: hasHooks beforeValidate(name, fn) View code A hook that is run before validation Params: Name Type Description name String fn Function A callback function that is called with instance, options afterValidate(name, fn) View code A hook that is run after validation Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeCreate(name, fn) View code A hook that is run before creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options afterCreate(name, fn) View code A hook that is run after creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options beforeDestroy(name, fn) View code A hook that is run before destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: beforeDelete afterDestroy(name, fn) View code A hook that is run after destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: afterDelete beforeRestore(name, fn) View code A hook that is run before restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options afterRestore(name, fn) View code A hook that is run after restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeUpdate(name, fn) View code A hook that is run before updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options afterUpdate(name, fn) View code A hook that is run after updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeBulkCreate(name, fn) View code A hook that is run before creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options afterBulkCreate(name, fn) View code A hook that is run after creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options beforeBulkDestroy(name, fn) View code A hook that is run before destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: beforeBulkDelete afterBulkDestroy(name, fn) View code A hook that is run after destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: afterBulkDelete beforeBulkRestore(name, fn) View code A hook that is run before restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options afterBulkRestore(name, fn) View code A hook that is run after restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options beforeBulkUpdate(name, fn) View code A hook that is run before updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options afterBulkUpdate(name, fn) View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options beforeFind(name, fn) View code A hook that is run before a find (select) query Params: Name Type Description name String fn Function A callback function that is called with options beforeFindAfterExpandIncludeAll(name, fn) View code A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded Params: Name Type Description name String fn Function A callback function that is called with options beforeFindAfterOptions(name, fn) View code A hook that is run before a find (select) query, after all option parsing is complete Params: Name Type Description name String fn Function A callback function that is called with options afterFind(name, fn) View code A hook that is run after a find (select) query Params: Name Type Description name String fn Function A callback function that is called with instance(s), options beforeDefine(name, fn) View code A hook that is run before a define call Params: Name Type Description name String fn Function A callback function that is called with attributes, options afterDefine(name, fn) View code A hook that is run after a define call Params: Name Type Description name String fn Function A callback function that is called with factory beforeInit(name, fn) View code A hook that is run before Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with config, options afterInit(name, fn) View code A hook that is run after Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with sequelize beforeSync(name, fn) View code A hook that is run before Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync afterSync(name, fn) View code A hook that is run after Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync beforeBulkSync(name, fn) View code A hook that is run before sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync afterBulkSync View code A hook that is run after sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Hooks"},{"location":"api/hooks/#mixin-hooks","text":"View code Hooks are function that are called before and after (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways: By specifying them as options in sequelize.define By calling hook() with a string and your hook handler function By calling the function with the same name as the hook you want // Method 1 sequelize.define(name, { attributes }, { hooks: { beforeBulkCreate: function () { // can be a single function }, beforeValidate: [ function () {}, function() {} // Or an array of several ] } }) // Method 2 Model.hook('afterDestroy', function () {}) // Method 3 Model.afterBulkUpdate(function () {}) See: Sequelize#define","title":"Mixin Hooks"},{"location":"api/hooks/#addhookhooktype-name-fn","text":"View code Add a hook to the model Params: Name Type Description hooktype String [name] String Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future. fn Function The hook function Aliases: hook","title":"addHook(hooktype, [name], fn)"},{"location":"api/hooks/#removehookhooktype-name","text":"View code Remove hook from the model Params: Name Type Description hookType String name String","title":"removeHook(hookType, name)"},{"location":"api/hooks/#hashookhooktype","text":"View code Check whether the mode has any hooks of this type Params: Name Type Description hookType String Aliases: hasHooks","title":"hasHook(hookType)"},{"location":"api/hooks/#beforevalidatename-fn","text":"View code A hook that is run before validation Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"beforeValidate(name, fn)"},{"location":"api/hooks/#aftervalidatename-fn","text":"View code A hook that is run after validation Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"afterValidate(name, fn)"},{"location":"api/hooks/#beforecreatename-fn","text":"View code A hook that is run before creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options","title":"beforeCreate(name, fn)"},{"location":"api/hooks/#aftercreatename-fn","text":"View code A hook that is run after creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options","title":"afterCreate(name, fn)"},{"location":"api/hooks/#beforedestroyname-fn","text":"View code A hook that is run before destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: beforeDelete","title":"beforeDestroy(name, fn)"},{"location":"api/hooks/#afterdestroyname-fn","text":"View code A hook that is run after destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: afterDelete","title":"afterDestroy(name, fn)"},{"location":"api/hooks/#beforerestorename-fn","text":"View code A hook that is run before restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"beforeRestore(name, fn)"},{"location":"api/hooks/#afterrestorename-fn","text":"View code A hook that is run after restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"afterRestore(name, fn)"},{"location":"api/hooks/#beforeupdatename-fn","text":"View code A hook that is run before updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"beforeUpdate(name, fn)"},{"location":"api/hooks/#afterupdatename-fn","text":"View code A hook that is run after updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options","title":"afterUpdate(name, fn)"},{"location":"api/hooks/#beforebulkcreatename-fn","text":"View code A hook that is run before creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options","title":"beforeBulkCreate(name, fn)"},{"location":"api/hooks/#afterbulkcreatename-fn","text":"View code A hook that is run after creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options","title":"afterBulkCreate(name, fn)"},{"location":"api/hooks/#beforebulkdestroyname-fn","text":"View code A hook that is run before destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: beforeBulkDelete","title":"beforeBulkDestroy(name, fn)"},{"location":"api/hooks/#afterbulkdestroyname-fn","text":"View code A hook that is run after destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: afterBulkDelete","title":"afterBulkDestroy(name, fn)"},{"location":"api/hooks/#beforebulkrestorename-fn","text":"View code A hook that is run before restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options","title":"beforeBulkRestore(name, fn)"},{"location":"api/hooks/#afterbulkrestorename-fn","text":"View code A hook that is run after restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options","title":"afterBulkRestore(name, fn)"},{"location":"api/hooks/#beforebulkupdatename-fn","text":"View code A hook that is run before updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options","title":"beforeBulkUpdate(name, fn)"},{"location":"api/hooks/#afterbulkupdatename-fn","text":"View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options","title":"afterBulkUpdate(name, fn)"},{"location":"api/hooks/#beforefindname-fn","text":"View code A hook that is run before a find (select) query Params: Name Type Description name String fn Function A callback function that is called with options","title":"beforeFind(name, fn)"},{"location":"api/hooks/#beforefindafterexpandincludeallname-fn","text":"View code A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded Params: Name Type Description name String fn Function A callback function that is called with options","title":"beforeFindAfterExpandIncludeAll(name, fn)"},{"location":"api/hooks/#beforefindafteroptionsname-fn","text":"View code A hook that is run before a find (select) query, after all option parsing is complete Params: Name Type Description name String fn Function A callback function that is called with options","title":"beforeFindAfterOptions(name, fn)"},{"location":"api/hooks/#afterfindname-fn","text":"View code A hook that is run after a find (select) query Params: Name Type Description name String fn Function A callback function that is called with instance(s), options","title":"afterFind(name, fn)"},{"location":"api/hooks/#beforedefinename-fn","text":"View code A hook that is run before a define call Params: Name Type Description name String fn Function A callback function that is called with attributes, options","title":"beforeDefine(name, fn)"},{"location":"api/hooks/#afterdefinename-fn","text":"View code A hook that is run after a define call Params: Name Type Description name String fn Function A callback function that is called with factory","title":"afterDefine(name, fn)"},{"location":"api/hooks/#beforeinitname-fn","text":"View code A hook that is run before Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with config, options","title":"beforeInit(name, fn)"},{"location":"api/hooks/#afterinitname-fn","text":"View code A hook that is run after Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with sequelize","title":"afterInit(name, fn)"},{"location":"api/hooks/#beforesyncname-fn","text":"View code A hook that is run before Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync","title":"beforeSync(name, fn)"},{"location":"api/hooks/#aftersyncname-fn","text":"View code A hook that is run after Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync","title":"afterSync(name, fn)"},{"location":"api/hooks/#beforebulksyncname-fn","text":"View code A hook that is run before sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync","title":"beforeBulkSync(name, fn)"},{"location":"api/hooks/#afterbulksync","text":"View code A hook that is run after sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"afterBulkSync"},{"location":"api/instance/","text":"Class Instance View code This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not instantiate the Instance class directly, instead you access it using the finder and creation methods on the model. Instance instances operate with the concept of a dataValues property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is: instance.field // is the same as instance.get('field') // is the same as instance.getDataValue('field') However, if getters and/or setters are defined for field they will be invoked, instead of returning the value from dataValues . Accessing properties directly or using get is preferred for regular use, getDataValue should only be used for custom getters. See: Sequelize#define isNewRecord -> Boolean View code Returns true if this instance has not yet been persisted to the database Model() -> Model View code Returns the Model the instance was created from. See: Model sequelize() -> Sequelize View code A reference to the sequelize instance See: Sequelize where() -> Object View code Get an object representing the query for this instance, use with options.where getDataValue(key) -> any View code Get the value of the underlying data value Params: Name Type Description key String setDataValue(key, value) View code Update the underlying data value Params: Name Type Description key String value any get([key], [options]) -> Object|any View code If no key is given, returns all values of the instance, also invoking virtual getters. If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key. Params: Name Type Description [key] String [options] Object [options.plain=false] Boolean If set to true, included instances will be returned as plain objects set(key, value, [options]) View code Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call save ). In its most basic form set will update a value stored in the underlying dataValues object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass raw: true in the options object. If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values. When set is called, the previous value of the field is stored and sets a changed flag(see changed ). Set can also be used to build instances for associations, if you have values for those. When using set with associations you need to make sure the property key matches the alias of the association while also making sure that the proper include options have been set (from .build() or .find()) If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed. See: Model#find Params: Name Type Description key String | Object value any [options] Object [options.raw=false] Boolean If set to true, field and virtual setters will be ignored [options.reset=false] Boolean Clear all previously set data values Aliases: setAttributes changed([key]) -> Boolean|Array View code If changed is called with a string it will return a boolean indicating whether the value of that key in dataValues is different from the value in _previousDataValues . If changed is called without an argument, it will return an array of keys that have changed. If changed is called without an argument and no keys have changed, it will return false . Params: Name Type Description [key] String previous([key]) -> any|Array.<any> View code Returns the previous value for key from _previousDataValues . If called without a key, returns the previous values for all values which have changed Params: Name Type Description [key] String save([options]) -> Promise.<this|Errors.ValidationError> View code Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed. On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of Sequelize.ValidationError . This error will have a property for each of the fields for which validation failed, with the error message for that field. Params: Name Type Description [options] Object [options.fields] Array.<string> An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved. [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. [options.validate=true] Boolean If false, validations won't be run. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) reload([options]) -> Promise.<this> View code Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a find(Instance.id) , because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created. See: Model#find Params: Name Type Description [options] Object Options that are passed on to Model.find [options.logging=false] Function A function that gets executed while running the query to log the sql. validate([options]) -> Promise.<Errors.ValidationError|undefined> View code Validate the attribute of this instance according to validation rules set in the model definition. Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries. See: InstanceValidator Params: Name Type Description [options] Object Options that are passed to the validator [options.skip] Array An array of strings. All properties that are in this array will not be validated update(updates, options) -> Promise.<this> View code This is the same as calling set and then calling save but it only saves the exact values passed to it, making it more atomic and safer. See: Instance#set Instance#save Params: Name Type Description updates Object See set options Object See save Aliases: updateAttributes destroy([options={}]) -> Promise.<undefined> View code Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time. Params: Name Type Description [options={}] Object [options.force=false] Boolean If set to true, paranoid models will actually be deleted [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) restore([options={}]) -> Promise.<undefined> View code Restore the row corresponding to this instance. Only available for paranoid models. Params: Name Type Description [options={}] Object [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction increment(fields, [options]) -> Promise.<this> View code Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a SET column = column + X query. To get the correct value after an increment into the Instance you should do a reload. instance.increment('number') // increment number by 1 instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2 instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is incremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given. [options] Object [options.by=1] Integer The number to increment by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) decrement(fields, [options]) -> Promise View code Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a SET column = column - X query. To get the correct value after an decrement into the Instance you should do a reload. instance.decrement('number') // decrement number by 1 instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2 instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is decremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given [options] Object [options.by=1] Integer The number to decrement by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) equals(other) -> Boolean View code Check whether all values of this and other Instance are the same Params: Name Type Description other Instance equalsOneOf(others) -> Boolean View code Check if this is equal to one of others by calling equals Params: Name Type Description others Array toJSON() -> object View code Convert the instance to a JSON representation. Proxies to calling get with no keys. This means get all values gotten from the DB, and apply all custom getters. See: Instance#get This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Instance"},{"location":"api/instance/#class-instance","text":"View code This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not instantiate the Instance class directly, instead you access it using the finder and creation methods on the model. Instance instances operate with the concept of a dataValues property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is: instance.field // is the same as instance.get('field') // is the same as instance.getDataValue('field') However, if getters and/or setters are defined for field they will be invoked, instead of returning the value from dataValues . Accessing properties directly or using get is preferred for regular use, getDataValue should only be used for custom getters. See: Sequelize#define","title":"Class Instance"},{"location":"api/instance/#isnewrecord-boolean","text":"View code Returns true if this instance has not yet been persisted to the database","title":"isNewRecord -&gt; Boolean"},{"location":"api/instance/#model-model","text":"View code Returns the Model the instance was created from. See: Model","title":"Model() -&gt; Model"},{"location":"api/instance/#sequelize-sequelize","text":"View code A reference to the sequelize instance See: Sequelize","title":"sequelize() -&gt; Sequelize"},{"location":"api/instance/#where-object","text":"View code Get an object representing the query for this instance, use with options.where","title":"where() -&gt; Object"},{"location":"api/instance/#getdatavaluekey-any","text":"View code Get the value of the underlying data value Params: Name Type Description key String","title":"getDataValue(key) -&gt; any"},{"location":"api/instance/#setdatavaluekey-value","text":"View code Update the underlying data value Params: Name Type Description key String value any","title":"setDataValue(key, value)"},{"location":"api/instance/#getkey-options-objectany","text":"View code If no key is given, returns all values of the instance, also invoking virtual getters. If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key. Params: Name Type Description [key] String [options] Object [options.plain=false] Boolean If set to true, included instances will be returned as plain objects","title":"get([key], [options]) -&gt; Object|any"},{"location":"api/instance/#setkey-value-options","text":"View code Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call save ). In its most basic form set will update a value stored in the underlying dataValues object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass raw: true in the options object. If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values. When set is called, the previous value of the field is stored and sets a changed flag(see changed ). Set can also be used to build instances for associations, if you have values for those. When using set with associations you need to make sure the property key matches the alias of the association while also making sure that the proper include options have been set (from .build() or .find()) If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed. See: Model#find Params: Name Type Description key String | Object value any [options] Object [options.raw=false] Boolean If set to true, field and virtual setters will be ignored [options.reset=false] Boolean Clear all previously set data values Aliases: setAttributes","title":"set(key, value, [options])"},{"location":"api/instance/#changedkey-booleanarray","text":"View code If changed is called with a string it will return a boolean indicating whether the value of that key in dataValues is different from the value in _previousDataValues . If changed is called without an argument, it will return an array of keys that have changed. If changed is called without an argument and no keys have changed, it will return false . Params: Name Type Description [key] String","title":"changed([key]) -&gt; Boolean|Array"},{"location":"api/instance/#previouskey-anyarrayany","text":"View code Returns the previous value for key from _previousDataValues . If called without a key, returns the previous values for all values which have changed Params: Name Type Description [key] String","title":"previous([key]) -&gt; any|Array.&lt;any&gt;"},{"location":"api/instance/#saveoptions-promisethiserrorsvalidationerror","text":"View code Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed. On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of Sequelize.ValidationError . This error will have a property for each of the fields for which validation failed, with the error message for that field. Params: Name Type Description [options] Object [options.fields] Array.<string> An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved. [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. [options.validate=true] Boolean If false, validations won't be run. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only)","title":"save([options]) -&gt; Promise.&lt;this|Errors.ValidationError&gt;"},{"location":"api/instance/#reloadoptions-promisethis","text":"View code Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a find(Instance.id) , because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created. See: Model#find Params: Name Type Description [options] Object Options that are passed on to Model.find [options.logging=false] Function A function that gets executed while running the query to log the sql.","title":"reload([options]) -&gt; Promise.&lt;this&gt;"},{"location":"api/instance/#validateoptions-promiseerrorsvalidationerrorundefined","text":"View code Validate the attribute of this instance according to validation rules set in the model definition. Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries. See: InstanceValidator Params: Name Type Description [options] Object Options that are passed to the validator [options.skip] Array An array of strings. All properties that are in this array will not be validated","title":"validate([options]) -&gt; Promise.&lt;Errors.ValidationError|undefined&gt;"},{"location":"api/instance/#updateupdates-options-promisethis","text":"View code This is the same as calling set and then calling save but it only saves the exact values passed to it, making it more atomic and safer. See: Instance#set Instance#save Params: Name Type Description updates Object See set options Object See save Aliases: updateAttributes","title":"update(updates, options) -&gt; Promise.&lt;this&gt;"},{"location":"api/instance/#destroyoptions-promiseundefined","text":"View code Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time. Params: Name Type Description [options={}] Object [options.force=false] Boolean If set to true, paranoid models will actually be deleted [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only)","title":"destroy([options={}]) -&gt; Promise.&lt;undefined&gt;"},{"location":"api/instance/#restoreoptions-promiseundefined","text":"View code Restore the row corresponding to this instance. Only available for paranoid models. Params: Name Type Description [options={}] Object [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction","title":"restore([options={}]) -&gt; Promise.&lt;undefined&gt;"},{"location":"api/instance/#incrementfields-options-promisethis","text":"View code Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a SET column = column + X query. To get the correct value after an increment into the Instance you should do a reload. instance.increment('number') // increment number by 1 instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2 instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is incremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given. [options] Object [options.by=1] Integer The number to increment by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only)","title":"increment(fields, [options]) -&gt; Promise.&lt;this&gt;"},{"location":"api/instance/#decrementfields-options-promise","text":"View code Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a SET column = column - X query. To get the correct value after an decrement into the Instance you should do a reload. instance.decrement('number') // decrement number by 1 instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2 instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is decremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given [options] Object [options.by=1] Integer The number to decrement by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only)","title":"decrement(fields, [options]) -&gt; Promise"},{"location":"api/instance/#equalsother-boolean","text":"View code Check whether all values of this and other Instance are the same Params: Name Type Description other Instance","title":"equals(other) -&gt; Boolean"},{"location":"api/instance/#equalsoneofothers-boolean","text":"View code Check if this is equal to one of others by calling equals Params: Name Type Description others Array","title":"equalsOneOf(others) -&gt; Boolean"},{"location":"api/instance/#tojson-object","text":"View code Convert the instance to a JSON representation. Proxies to calling get with no keys. This means get all values gotten from the DB, and apply all custom getters. See: Instance#get This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"toJSON() -&gt; object"},{"location":"api/model/","text":"Class Model View code A Model represents a table in the database. Sometimes you might also see it referred to as model, or simply as factory. This class should not be instantiated directly, it is created using sequelize.define , and already created models can be loaded using sequelize.import Mixes: Hooks Associations removeAttribute([attribute]) View code Remove attribute from model definition Params: Name Type Description [attribute] String sync() -> Promise.<this> View code Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this) See: Sequelize#sync drop([options]) -> Promise View code Drop the table represented by this Model Params: Name Type Description [options] Object [options.cascade=false] Boolean Also drop all objects depending on this table, such as views. Only works in postgres [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. schema(schema, [options]) -> this View code Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - \"schema\".\"tableName\" , while the schema will be prepended to the table name for mysql and sqlite - 'schema.tablename' . Params: Name Type Description schema String The name of the schema [options] Object [options.schemaDelimiter='.'] String The character(s) that separates the schema name from the table name [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. getTableName([options]) -> String|Object View code Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with tableName , schema and delimiter properties. Params: Name Type Description [options] Object The hash of options from any query. You can use one model to access tables with matching schemas by overriding getTableName and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. unscoped() -> Model View code addScope(name, scope, [options]) View code Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined. By default this will throw an error if a scope with that name already exists. Pass override: true in the options object to silence this error. Params: Name Type Description name String The name of the scope. Use defaultScope to override the default scope scope Object | Function [options] Object [options.override=false] Boolean scope(options*) -> Model View code Apply a scope created in define to the model. First let's look at how to create scopes: var Model = sequelize.define('model', attributes, { defaultScope: { where: { username: 'dan' }, limit: 12 }, scopes: { isALie: { where: { stuff: 'cake' } }, complexFunction: function(email, accessLevel) { return { where: { email: { $like: email }, accesss_level { $gte: accessLevel } } } } } }) Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples: Model.findAll() // WHERE username = 'dan' Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan' To invoke scope functions you can do: Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll() // WHERE email like 'dan@sequelize.com%' AND access_level >= 42 Params: Name Type Description options* Array | Object | String The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a method property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default. Returns: A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope. findAll([options]) -> Promise.<Array.<Instance>> View code Search for multiple instances. Simple search using AND and = Model.findAll({ where: { attr1: 42, attr2: 'cake' } }) WHERE attr1 = 42 AND attr2 = 'cake' Using greater than, less than etc. Model.findAll({ where: { attr1: { gt: 50 }, attr2: { lte: 45 }, attr3: { in: [1,2,3] }, attr4: { ne: 5 } } }) WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5 Possible options are: $ne, $in, $not, $notIn, $gte, $gt, $lte, $lt, $like, $ilike/$iLike, $notLike, $notILike, '..'/$between, '!..'/$notBetween, '&&'/$overlap, '@>'/$contains, '<@'/$contained Queries using OR Model.findAll({ where: { name: 'a project', $or: [ {id: [1, 2, 3]}, { $and: [ {id: {gt: 10}}, {id: {lt: 100}} ] } ] } }); WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100)); The success listener is called with an array of instances if the query succeeds. See: Sequelize#query Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.where] Object A hash of attributes to describe your search. See above for examples. [options.attributes] Array.<String> | Object A list of the attributes that you want to select, or an object with include and exclude keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as Sequelize.literal , Sequelize.fn and so on), and the second is the name you want the attribute to have in the returned instance [options.attributes.include] Array.<String> Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. { attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] } [options.attributes.exclude] Array.<String> Select all the attributes of the model, except some few. Useful for security purposes e.g. { attributes: { exclude: ['password'] } } [options.paranoid=true] Boolean If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if options.paranoid is true for the model. [options.include] Array.<Object | Model> A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, ...]} or { include: [{ model: Model1, as: 'Alias' }]} . If your association are set up with an as (eg. X.hasMany(Y, { as: 'Z } , you need to specify Z in the as attribute when eager loading Y). [options.include[].model] Model The model you want to eagerly load [options.include[].as] String The alias of the relation, in case the model you want to eagerly load is aliased. For hasOne / belongsTo , this should be the singular name, and for hasMany , it should be the plural [options.include[].association] Association The association you want to eagerly load. (This can be used instead of providing a model/as pair) [options.include[].where] Object Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set required: false [options.include[].or=false] Boolean Whether to bind the ON and WHERE clause together by OR instead of AND. [options.include[].on] Object Supply your own ON condition for the join. [options.include[].attributes] Array.<String> A list of attributes to select from the child model [options.include[].required] Boolean If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if include.where is set, false otherwise. [options.include[].separate] Boolean If true, runs a separate query to fetch the associated instances, only supported for hasMany associations [options.include[].limit] Number Limit the joined rows, only supported with include.separate=true [options.include[].through.where] Object Filter on the join model for belongsToMany relations [options.include[].through.attributes] Array A list of attributes to select from the join model for belongsToMany relations [options.include[].include] Array.<Object | Model> Load further nested related models [options.order] String | Array | Sequelize.fn Specifies an ordering. If a string is provided, it will be escaped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: order: [['name', 'DESC']] . In this way the column will be escaped, but the direction will not. [options.limit] Number [options.offset] Number [options.transaction] Transaction Transaction to run query under [options.lock] String | Object Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See transaction.LOCK for an example [options.raw] Boolean Return raw result. See sequelize.query for more information. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.having] Object [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: all findById(id, [options]) -> Promise.<Instance> View code Search for a single instance by its primary key. See: Model#findAll Params: Name Type Description id Number | String | Buffer The value of the desired instance's primary key. [options] Object [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: findByPrimary findOne([options]) -> Promise.<Instance> View code Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance. See: Model#findAll Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: find aggregate(field, aggregateFunction, [options]) -> Promise.<options.dataType|object> View code Run an aggregation method on the specified field Params: Name Type Description field String The field to aggregate over. Can be a field name or * aggregateFunction String The function to use for aggregation, e.g. sum, max etc. [options] Object Query options. See sequelize.query for full options [options.where] Object A hash of search attributes. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.dataType] DataType | String The type of the result. If field is a field in this Model, the default will be the type of that field, otherwise defaults to float. [options.distinct] boolean Applies DISTINCT to the field being aggregated over [options.transaction] Transaction Transaction to run query under [options.plain] Boolean When true , the first returned value of aggregateFunction is cast to dataType and returned. If additional attributes are specified, along with group clauses, set plain to false to return all values of all returned rows. Defaults to true [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns the aggregate result cast to options.dataType , unless options.plain is false, in which case the complete data result is returned. count([options]) -> Promise.<Integer> View code Count the number of records matching the provided where clause. If you provide an include option, the number of matching associations will be counted instead. Params: Name Type Description [options] Object [options.where] Object A hash of search attributes. [options.include] Object Include options. See find for details [options.distinct] boolean Apply COUNT(DISTINCT(col)) on primary key, Model.aggregate should be used for other columns [options.attributes] Object Used in conjunction with group [options.group] Object For creating complex counts. Will return multiple rows as needed. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. findAndCount([findOptions]) -> Promise.<Object> View code Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging Model.findAndCountAll({ where: ..., limit: 12, offset: 12 }).then(function (result) { ... }) In the above example, result.rows will contain rows 13 through 24, while result.count will return the total number of rows that matched your query. When you add includes, only those which are required (either because they have a where clause, or because required is explicitly set to true on the include) will be added to the count part. Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted See: Model#findAll Params: Name Type Description [findOptions] Object See findAll Aliases: findAndCountAll max(field, [options]) -> Promise.<Any> View code Find the maximum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate min(field, [options]) -> Promise.<Any> View code Find the minimum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate sum(field, [options]) -> Promise.<Number> View code Find the sum of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate build(values, [options]) -> Instance View code Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty. Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.include] Array an array of include options - Used to build prefetched/included model instances. See set create(values, [options]) -> Promise.<Instance> View code Builds a new model instance and calls save on it. See: Instance#build Instance#save Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.fields] Array If set, only columns matching those in fields will be saved [options.include] Array an array of include options - Used to build prefetched/included model instances [options.onDuplicate] String [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. findOrInitialize -> Promise.<Instance, initialized> View code Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, initialized) - Make sure to use .spread() Params: Name Type Description options Object options.where Object A hash of search attributes. [options.defaults] Object Default values to use if building a new instance [options.transaction] Object Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: findOrBuild findOrCreate(options) -> Promise.<Instance, created> View code Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created) - Make sure to use .spread() If no transaction is passed in the options object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize.TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally. See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance [options.transaction] Transaction Transaction to run query under findCreateFind(options) -> Promise.<Instance, created> View code A more performant findOrCreate that will not work under a transaction (at least not in postgres) Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance upsert(values, [options]) -> Promise.<created> View code Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated. Implementation details: MySQL - Implemented as a single query INSERT values ON DUPLICATE KEY UPDATE values PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE SQLite - Implemented as two queries INSERT; UPDATE . This means that the update is executed regardless of whether the row already existed or not Note that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not. Params: Name Type Description values Object [options] Object [options.validate=true] Boolean Run validations before the row is inserted [options.fields=Object.keys(this.attributes)] Array The fields to insert / update. Defaults to all fields [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns a boolean indicating whether the row was created or updated. Aliases: insertOrUpdate bulkCreate(records, [options]) -> Promise.<Array.<Instance>> View code Create and insert multiple instances in bulk. The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again. Params: Name Type Description records Array List of objects (key/value pairs) to create instances from [options] Object [options.fields] Array Fields to insert (defaults to all fields) [options.validate=false] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk create hooks? [options.individualHooks=false] Boolean Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true. [options.ignoreDuplicates=false] Boolean Ignore duplicate values for primary keys? (not supported by postgres) [options.updateOnDuplicate] Array Fields to update if row key already exists (on duplicate key update)? (only supported by mysql & mariadb). By default, all fields are updated. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.returning=false] Boolean Append RETURNING * to get back auto generated values (Postgres only) [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. truncate([options]) -> Promise View code Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }). See: Model#destroy Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function Transaction to run query under [options.cascade Boolean | function = false] Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.transaction] Transaction Transaction to run query under [options.logging] Boolean | function A function that logs sql queries, or false for no logging [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. destroy(options) -> Promise.<Integer> View code Delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the destroy [options.hooks=true] Boolean Run before / after bulk destroy hooks? [options.individualHooks=false] Boolean If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row [options.limit] Number How many rows to delete [options.force=false] Boolean Delete instead of setting deletedAt to current timestamp (only applicable if paranoid is enabled) [options.truncate=false] Boolean If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored [options.cascade=false] Boolean Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.restartIdentity=false] Boolean Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table. Postgres only. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: The number of destroyed rows restore(options) -> Promise.<undefined> View code Restore multiple instances if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the restore [options.hooks=true] Boolean Run before / after bulk restore hooks? [options.individualHooks=false] Boolean If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row [options.limit] Number How many rows to undelete [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under update(values, options) -> Promise.<Array.<affectedCount, affectedRows>> View code Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with options.returning true.) Params: Name Type Description values Object options Object options.where Object Options to describe the scope of the search. [options.fields] Array Fields to update (defaults to all fields) [options.validate=true] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk update hooks? [options.sideEffects=true] Boolean Whether or not to update the side effects of any virtual setters. [options.individualHooks=false] Boolean Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks [options.returning=false] Boolean Return the affected rows (only for postgres) [options.limit] Number How many rows to update (only for mysql and mariadb) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. describe() -> Promise View code Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Model"},{"location":"api/model/#class-model","text":"View code A Model represents a table in the database. Sometimes you might also see it referred to as model, or simply as factory. This class should not be instantiated directly, it is created using sequelize.define , and already created models can be loaded using sequelize.import","title":"Class Model"},{"location":"api/model/#mixes","text":"Hooks Associations","title":"Mixes:"},{"location":"api/model/#removeattributeattribute","text":"View code Remove attribute from model definition Params: Name Type Description [attribute] String","title":"removeAttribute([attribute])"},{"location":"api/model/#sync-promisethis","text":"View code Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this) See: Sequelize#sync","title":"sync() -&gt; Promise.&lt;this&gt;"},{"location":"api/model/#dropoptions-promise","text":"View code Drop the table represented by this Model Params: Name Type Description [options] Object [options.cascade=false] Boolean Also drop all objects depending on this table, such as views. Only works in postgres [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"drop([options]) -&gt; Promise"},{"location":"api/model/#schemaschema-options-this","text":"View code Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - \"schema\".\"tableName\" , while the schema will be prepended to the table name for mysql and sqlite - 'schema.tablename' . Params: Name Type Description schema String The name of the schema [options] Object [options.schemaDelimiter='.'] String The character(s) that separates the schema name from the table name [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"schema(schema, [options]) -&gt; this"},{"location":"api/model/#gettablenameoptions-stringobject","text":"View code Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with tableName , schema and delimiter properties. Params: Name Type Description [options] Object The hash of options from any query. You can use one model to access tables with matching schemas by overriding getTableName and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"getTableName([options]) -&gt; String|Object"},{"location":"api/model/#unscoped-model","text":"View code","title":"unscoped() -&gt; Model"},{"location":"api/model/#addscopename-scope-options","text":"View code Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined. By default this will throw an error if a scope with that name already exists. Pass override: true in the options object to silence this error. Params: Name Type Description name String The name of the scope. Use defaultScope to override the default scope scope Object | Function [options] Object [options.override=false] Boolean","title":"addScope(name, scope, [options])"},{"location":"api/model/#scopeoptions-model","text":"View code Apply a scope created in define to the model. First let's look at how to create scopes: var Model = sequelize.define('model', attributes, { defaultScope: { where: { username: 'dan' }, limit: 12 }, scopes: { isALie: { where: { stuff: 'cake' } }, complexFunction: function(email, accessLevel) { return { where: { email: { $like: email }, accesss_level { $gte: accessLevel } } } } } }) Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples: Model.findAll() // WHERE username = 'dan' Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan' To invoke scope functions you can do: Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll() // WHERE email like 'dan@sequelize.com%' AND access_level >= 42 Params: Name Type Description options* Array | Object | String The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a method property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default. Returns: A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.","title":"scope(options*) -&gt; Model"},{"location":"api/model/#findalloptions-promisearrayinstance","text":"View code Search for multiple instances. Simple search using AND and = Model.findAll({ where: { attr1: 42, attr2: 'cake' } }) WHERE attr1 = 42 AND attr2 = 'cake' Using greater than, less than etc. Model.findAll({ where: { attr1: { gt: 50 }, attr2: { lte: 45 }, attr3: { in: [1,2,3] }, attr4: { ne: 5 } } }) WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5 Possible options are: $ne, $in, $not, $notIn, $gte, $gt, $lte, $lt, $like, $ilike/$iLike, $notLike, $notILike, '..'/$between, '!..'/$notBetween, '&&'/$overlap, '@>'/$contains, '<@'/$contained Queries using OR Model.findAll({ where: { name: 'a project', $or: [ {id: [1, 2, 3]}, { $and: [ {id: {gt: 10}}, {id: {lt: 100}} ] } ] } }); WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100)); The success listener is called with an array of instances if the query succeeds. See: Sequelize#query Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.where] Object A hash of attributes to describe your search. See above for examples. [options.attributes] Array.<String> | Object A list of the attributes that you want to select, or an object with include and exclude keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as Sequelize.literal , Sequelize.fn and so on), and the second is the name you want the attribute to have in the returned instance [options.attributes.include] Array.<String> Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. { attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] } [options.attributes.exclude] Array.<String> Select all the attributes of the model, except some few. Useful for security purposes e.g. { attributes: { exclude: ['password'] } } [options.paranoid=true] Boolean If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if options.paranoid is true for the model. [options.include] Array.<Object | Model> A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, ...]} or { include: [{ model: Model1, as: 'Alias' }]} . If your association are set up with an as (eg. X.hasMany(Y, { as: 'Z } , you need to specify Z in the as attribute when eager loading Y). [options.include[].model] Model The model you want to eagerly load [options.include[].as] String The alias of the relation, in case the model you want to eagerly load is aliased. For hasOne / belongsTo , this should be the singular name, and for hasMany , it should be the plural [options.include[].association] Association The association you want to eagerly load. (This can be used instead of providing a model/as pair) [options.include[].where] Object Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set required: false [options.include[].or=false] Boolean Whether to bind the ON and WHERE clause together by OR instead of AND. [options.include[].on] Object Supply your own ON condition for the join. [options.include[].attributes] Array.<String> A list of attributes to select from the child model [options.include[].required] Boolean If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if include.where is set, false otherwise. [options.include[].separate] Boolean If true, runs a separate query to fetch the associated instances, only supported for hasMany associations [options.include[].limit] Number Limit the joined rows, only supported with include.separate=true [options.include[].through.where] Object Filter on the join model for belongsToMany relations [options.include[].through.attributes] Array A list of attributes to select from the join model for belongsToMany relations [options.include[].include] Array.<Object | Model> Load further nested related models [options.order] String | Array | Sequelize.fn Specifies an ordering. If a string is provided, it will be escaped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: order: [['name', 'DESC']] . In this way the column will be escaped, but the direction will not. [options.limit] Number [options.offset] Number [options.transaction] Transaction Transaction to run query under [options.lock] String | Object Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See transaction.LOCK for an example [options.raw] Boolean Return raw result. See sequelize.query for more information. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.having] Object [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: all","title":"findAll([options]) -&gt; Promise.&lt;Array.&lt;Instance&gt;&gt;"},{"location":"api/model/#findbyidid-options-promiseinstance","text":"View code Search for a single instance by its primary key. See: Model#findAll Params: Name Type Description id Number | String | Buffer The value of the desired instance's primary key. [options] Object [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: findByPrimary","title":"findById(id, [options]) -&gt; Promise.&lt;Instance&gt;"},{"location":"api/model/#findoneoptions-promiseinstance","text":"View code Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance. See: Model#findAll Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: find","title":"findOne([options]) -&gt; Promise.&lt;Instance&gt;"},{"location":"api/model/#aggregatefield-aggregatefunction-options-promiseoptionsdatatypeobject","text":"View code Run an aggregation method on the specified field Params: Name Type Description field String The field to aggregate over. Can be a field name or * aggregateFunction String The function to use for aggregation, e.g. sum, max etc. [options] Object Query options. See sequelize.query for full options [options.where] Object A hash of search attributes. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.dataType] DataType | String The type of the result. If field is a field in this Model, the default will be the type of that field, otherwise defaults to float. [options.distinct] boolean Applies DISTINCT to the field being aggregated over [options.transaction] Transaction Transaction to run query under [options.plain] Boolean When true , the first returned value of aggregateFunction is cast to dataType and returned. If additional attributes are specified, along with group clauses, set plain to false to return all values of all returned rows. Defaults to true [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns the aggregate result cast to options.dataType , unless options.plain is false, in which case the complete data result is returned.","title":"aggregate(field, aggregateFunction, [options]) -&gt; Promise.&lt;options.dataType|object&gt;"},{"location":"api/model/#countoptions-promiseinteger","text":"View code Count the number of records matching the provided where clause. If you provide an include option, the number of matching associations will be counted instead. Params: Name Type Description [options] Object [options.where] Object A hash of search attributes. [options.include] Object Include options. See find for details [options.distinct] boolean Apply COUNT(DISTINCT(col)) on primary key, Model.aggregate should be used for other columns [options.attributes] Object Used in conjunction with group [options.group] Object For creating complex counts. Will return multiple rows as needed. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"count([options]) -&gt; Promise.&lt;Integer&gt;"},{"location":"api/model/#findandcountfindoptions-promiseobject","text":"View code Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging Model.findAndCountAll({ where: ..., limit: 12, offset: 12 }).then(function (result) { ... }) In the above example, result.rows will contain rows 13 through 24, while result.count will return the total number of rows that matched your query. When you add includes, only those which are required (either because they have a where clause, or because required is explicitly set to true on the include) will be added to the count part. Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted See: Model#findAll Params: Name Type Description [findOptions] Object See findAll Aliases: findAndCountAll","title":"findAndCount([findOptions]) -&gt; Promise.&lt;Object&gt;"},{"location":"api/model/#maxfield-options-promiseany","text":"View code Find the maximum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"max(field, [options]) -&gt; Promise.&lt;Any&gt;"},{"location":"api/model/#minfield-options-promiseany","text":"View code Find the minimum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"min(field, [options]) -&gt; Promise.&lt;Any&gt;"},{"location":"api/model/#sumfield-options-promisenumber","text":"View code Find the sum of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate","title":"sum(field, [options]) -&gt; Promise.&lt;Number&gt;"},{"location":"api/model/#buildvalues-options-instance","text":"View code Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty. Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.include] Array an array of include options - Used to build prefetched/included model instances. See set","title":"build(values, [options]) -&gt; Instance"},{"location":"api/model/#createvalues-options-promiseinstance","text":"View code Builds a new model instance and calls save on it. See: Instance#build Instance#save Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.fields] Array If set, only columns matching those in fields will be saved [options.include] Array an array of include options - Used to build prefetched/included model instances [options.onDuplicate] String [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"create(values, [options]) -&gt; Promise.&lt;Instance&gt;"},{"location":"api/model/#findorinitialize-promiseinstance-initialized","text":"View code Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, initialized) - Make sure to use .spread() Params: Name Type Description options Object options.where Object A hash of search attributes. [options.defaults] Object Default values to use if building a new instance [options.transaction] Object Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: findOrBuild","title":"findOrInitialize -&gt; Promise.&lt;Instance, initialized&gt;"},{"location":"api/model/#findorcreateoptions-promiseinstance-created","text":"View code Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created) - Make sure to use .spread() If no transaction is passed in the options object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize.TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally. See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance [options.transaction] Transaction Transaction to run query under","title":"findOrCreate(options) -&gt; Promise.&lt;Instance, created&gt;"},{"location":"api/model/#findcreatefindoptions-promiseinstance-created","text":"View code A more performant findOrCreate that will not work under a transaction (at least not in postgres) Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance","title":"findCreateFind(options) -&gt; Promise.&lt;Instance, created&gt;"},{"location":"api/model/#upsertvalues-options-promisecreated","text":"View code Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated. Implementation details: MySQL - Implemented as a single query INSERT values ON DUPLICATE KEY UPDATE values PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE SQLite - Implemented as two queries INSERT; UPDATE . This means that the update is executed regardless of whether the row already existed or not Note that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not. Params: Name Type Description values Object [options] Object [options.validate=true] Boolean Run validations before the row is inserted [options.fields=Object.keys(this.attributes)] Array The fields to insert / update. Defaults to all fields [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns a boolean indicating whether the row was created or updated. Aliases: insertOrUpdate","title":"upsert(values, [options]) -&gt; Promise.&lt;created&gt;"},{"location":"api/model/#bulkcreaterecords-options-promisearrayinstance","text":"View code Create and insert multiple instances in bulk. The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again. Params: Name Type Description records Array List of objects (key/value pairs) to create instances from [options] Object [options.fields] Array Fields to insert (defaults to all fields) [options.validate=false] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk create hooks? [options.individualHooks=false] Boolean Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true. [options.ignoreDuplicates=false] Boolean Ignore duplicate values for primary keys? (not supported by postgres) [options.updateOnDuplicate] Array Fields to update if row key already exists (on duplicate key update)? (only supported by mysql & mariadb). By default, all fields are updated. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.returning=false] Boolean Append RETURNING * to get back auto generated values (Postgres only) [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"bulkCreate(records, [options]) -&gt; Promise.&lt;Array.&lt;Instance&gt;&gt;"},{"location":"api/model/#truncateoptions-promise","text":"View code Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }). See: Model#destroy Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function Transaction to run query under [options.cascade Boolean | function = false] Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.transaction] Transaction Transaction to run query under [options.logging] Boolean | function A function that logs sql queries, or false for no logging [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"truncate([options]) -&gt; Promise"},{"location":"api/model/#destroyoptions-promiseinteger","text":"View code Delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the destroy [options.hooks=true] Boolean Run before / after bulk destroy hooks? [options.individualHooks=false] Boolean If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row [options.limit] Number How many rows to delete [options.force=false] Boolean Delete instead of setting deletedAt to current timestamp (only applicable if paranoid is enabled) [options.truncate=false] Boolean If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored [options.cascade=false] Boolean Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.restartIdentity=false] Boolean Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table. Postgres only. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: The number of destroyed rows","title":"destroy(options) -&gt; Promise.&lt;Integer&gt;"},{"location":"api/model/#restoreoptions-promiseundefined","text":"View code Restore multiple instances if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the restore [options.hooks=true] Boolean Run before / after bulk restore hooks? [options.individualHooks=false] Boolean If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row [options.limit] Number How many rows to undelete [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under","title":"restore(options) -&gt; Promise.&lt;undefined&gt;"},{"location":"api/model/#updatevalues-options-promisearrayaffectedcount-affectedrows","text":"View code Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with options.returning true.) Params: Name Type Description values Object options Object options.where Object Options to describe the scope of the search. [options.fields] Array Fields to update (defaults to all fields) [options.validate=true] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk update hooks? [options.sideEffects=true] Boolean Whether or not to update the side effects of any virtual setters. [options.individualHooks=false] Boolean Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks [options.returning=false] Boolean Return the affected rows (only for postgres) [options.limit] Number How many rows to update (only for mysql and mariadb) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated.","title":"update(values, options) -&gt; Promise.&lt;Array.&lt;affectedCount, affectedRows&gt;&gt;"},{"location":"api/model/#describe-promise","text":"View code Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"describe() -&gt; Promise"},{"location":"api/sequelize/","text":"Class Sequelize View code This is the main class, the entry point to sequelize. To use it, you just need to import sequelize: var Sequelize = require('sequelize'); In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that. new Sequelize(database, [username=null], [password=null], [options={}]) View code Instantiate sequelize with name of database, username and password Example usage // without password and options var sequelize = new Sequelize('database', 'username') // without options var sequelize = new Sequelize('database', 'username', 'password') // without password / with blank password var sequelize = new Sequelize('database', 'username', null, {}) // with password and options var sequelize = new Sequelize('my_database', 'john', 'doe', {}) // with uri (see below) var sequelize = new Sequelize('mysql://localhost:3306/database', {}) Params: Name Type Description database String The name of the database [username=null] String The username which is used to authenticate against the database. [password=null] String The password which is used to authenticate against the database. [options={}] Object An object with options. [options.dialect='mysql'] String The dialect of the database you are connecting to. One of mysql, postgres, sqlite, mariadb and mssql. [options.dialectModulePath=null] String If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here [options.dialectOptions] Object An object of additional options, which are passed directly to the connection library [options.storage] String Only used by sqlite. Defaults to ':memory:' [options.host='localhost'] String The host of the relational database. [options.port=] Integer The port of the relational database. [options.protocol='tcp'] String The protocol of the relational database. [options.define={}] Object Default options for model definitions. See sequelize.define for options [options.query={}] Object Default options for sequelize.query [options.set={}] Object Default options for sequelize.set [options.sync={}] Object Default options for sequelize.sync [options.timezone='+00:00'] String The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes. [options.logging=console.log] Function A function that gets executed every time Sequelize would log something. [options.omitNull=false] Boolean A flag that defines if null values should be passed to SQL queries or not. [options.native=false] Boolean A flag that defines if native library shall be used or not. Currently only has an effect for postgres [options.replication=false] Boolean Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: host , port , username , password , database [options.pool={}] Object Should sequelize use a connection pool. Default is true [options.pool.maxConnections] Integer [options.pool.minConnections] Integer [options.pool.maxIdleTime] Integer The maximum time, in milliseconds, that a connection can be idle before being released [options.pool.validateConnection] Function A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected [options.quoteIdentifiers=true] Boolean Set to false to make table names and attributes case-insensitive on Postgres and skip double quoting of them. [options.transactionType='DEFERRED'] String Set the default transaction type. See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String Set the default transaction isolation level. See Sequelize.Transaction.ISOLATION_LEVELS for possible options. [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error. [options.typeValidation=false] Boolean Run built in type validators on insert and update, e.g. validate that arguments passed to integer fields are integer-like. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. new Sequelize(uri, [options={}]) View code Instantiate sequelize with an URI Params: Name Type Description uri String A full database URI [options={}] object See above for possible options models View code Models are stored here under the name given to sequelize.define version View code Sequelize version number. Sequelize View code A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc. See: Sequelize Utils View code A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use Sequelize.Utils._ , which is a reference to the lodash library, if you don't already have it imported in your project. Promise View code A handy reference to the bluebird Promise class QueryTypes View code Available query types for use with sequelize.query Validator View code Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor. See: Transaction View code A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction See: Transaction Sequelize#transaction Deferrable View code A reference to the deferrable collection. Use this to access the different deferrable options. See: Deferrable Sequelize#transaction Instance View code A reference to the sequelize instance class. See: Instance Association View code A reference to the sequelize association class. See: Association Error View code A general error class See: Errors#BaseError ValidationError View code Emitted when a validation fails See: Errors#ValidationError ValidationErrorItem View code Describes a validation error on an instance path See: Errors#ValidationErrorItem DatabaseError View code A base class for all database related errors. See: Errors#DatabaseError TimeoutError View code Thrown when a database query times out because of a deadlock See: Errors#TimeoutError UniqueConstraintError View code Thrown when a unique constraint is violated in the database See: Errors#UniqueConstraintError ExclusionConstraintError View code Thrown when an exclusion constraint is violated in the database See: Errors#ExclusionConstraintError ForeignKeyConstraintError View code Thrown when a foreign key constraint is violated in the database See: Errors#ForeignKeyConstraintError ConnectionError View code A base class for all connection related errors. See: Errors#ConnectionError ConnectionRefusedError View code Thrown when a connection to a database is refused See: Errors#ConnectionRefusedError AccessDeniedError View code Thrown when a connection to a database is refused due to insufficient access See: Errors#AccessDeniedError HostNotFoundError View code Thrown when a connection to a database has a hostname that was not found See: Errors#HostNotFoundError HostNotReachableError View code Thrown when a connection to a database has a hostname that was not reachable See: Errors#HostNotReachableError InvalidConnectionError View code Thrown when a connection to a database has invalid values for any of the connection parameters See: Errors#InvalidConnectionError ConnectionTimedOutError View code Thrown when a connection to a database times out See: Errors#ConnectionTimedOutError InstanceError View code Thrown when a some problem occurred with Instance methods (see message for details) See: Errors#InstanceError getDialect() -> String View code Returns the specified dialect. Returns: The specified dialect. getQueryInterface() -> QueryInterface View code Returns an instance of QueryInterface. See: QueryInterface Returns: An instance (singleton) of QueryInterface. define(modelName, attributes, [options]) -> Model View code Define a new model, representing a table in the DB. The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this: sequelize.define('modelName', { columnA: { type: Sequelize.BOOLEAN, validate: { is: [\"[a-z]\",'i'], // will only allow letters max: 23, // only allow values <= 23 isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } }, field: 'column_a' // Other attributes here }, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE' }) sequelize.models.modelName // The model will now be available in models under the name given to define As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters. For a list of possible data types, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#data-types For more about getters and setters, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#getters-setters For more about instance and class methods, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#expansion-of-models For more about validation, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#validations See: DataTypes Hooks Params: Name Type Description modelName String The name of the model. The model will be stored in sequelize.models under this name attributes Object An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below: attributes.column String | DataType | Object The description of a database column attributes.column.type String | DataType A string or a data type [attributes.column.allowNull=true] Boolean If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved. [attributes.column.defaultValue=null] Any A literal default value, a JavaScript function, or an SQL function (see sequelize.fn ) [attributes.column.unique=false] String | Boolean If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index [attributes.column.primaryKey=false] Boolean [attributes.column.field=null] String If set, sequelize will map the attribute name to a different name in the database [attributes.column.autoIncrement=false] Boolean [attributes.column.comment=null] String [attributes.column.references=null] String | Model An object with reference configurations [attributes.column.references.model] String | Model If this column references another table, provide it here as a Model, or a string [attributes.column.references.key='id'] String The column of the foreign table that this column references [attributes.column.onUpdate] String What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.onDelete] String What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.get] Function Provide a custom getter for this column. Use this.getDataValue(String) to manipulate the underlying values. [attributes.column.set] Function Provide a custom setter for this column. Use this.setDataValue(String, Value) to manipulate the underlying values. [attributes.validate] Object An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the DAOValidator property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text. [options] Object These options are merged with the default define options provided to the Sequelize constructor [options.defaultScope={}] Object Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll [options.scopes] Object More scopes, defined in the same way as defaultScope above. See Model.scope for more information about how scopes are defined, and what you can do with them [options.omitNull] Boolean Don't persist null values. This means that all columns with null values will not be saved [options.timestamps=true] Boolean Adds createdAt and updatedAt timestamps to the model. [options.paranoid=false] Boolean Calling destroy will not delete the model, but instead set a deletedAt timestamp if this is true. Needs timestamps=true to work [options.underscored=false] Boolean Converts all camelCased columns to underscored if true [options.underscoredAll=false] Boolean Converts camelCased model names to underscored table names if true [options.freezeTableName=false] Boolean If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the model name will be pluralized [options.name] Object An object with two attributes, singular and plural , which are used when this model is associated to others. [options.name.singular=inflection.singularize(modelName)] String [options.name.plural=inflection.pluralize(modelName)] String [options.indexes] Array.<Object> [options.indexes[].name] String The name of the index. Defaults to model name + _ + fields concatenated [options.indexes[].type] String Index type. Only used by mysql. One of UNIQUE , FULLTEXT and SPATIAL [options.indexes[].method] String The method to create the index by ( USING statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN. [options.indexes[].unique=false] Boolean Should the index by unique? Can also be triggered by setting type to UNIQUE [options.indexes[].concurrently=false] Boolean PostgreSQL will build the index without taking any write locks. Postgres only [options.indexes[].fields] Array.<String | Object> An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g sequelize.fn ), or an object with the following attributes: attribute (field name), length (create a prefix index of length chars), order (the direction the column should be sorted in), collate (the collation (sort order) for the column) [options.createdAt] String | Boolean Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.updatedAt] String | Boolean Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.deletedAt] String | Boolean Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.tableName] String Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim [options.getterMethods] Object Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values [options.setterMethods] Object Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted [options.instanceMethods] Object Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using this.constructor.super_.prototype , e.g. this.constructor.super_.prototype.toJSON.apply(this, arguments) [options.classMethods] Object Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using this.constructor.prototype , e.g. this.constructor.prototype.find.apply(this, arguments) [options.schema='public'] String [options.engine] String [options.charset] String [options.comment] String [options.collate] String [options.initialAutoIncrement] String Set the initial AUTO_INCREMENT value for the table in MySQL. [options.hooks] Object An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions. [options.validate] Object An object of model wide validations. Validations have access to all model values via this . If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error. model(modelName) -> Model View code Fetch a Model which is already defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define isDefined(modelName) -> Boolean View code Checks whether a model with the given name is defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define import(path) -> Model View code Imports a model defined in another file Imported models are cached, so multiple calls to import with the same path will not load the file multiple times See https://github.com/sequelize/express-example for a short example of how to define your models in separate files so that they can be imported by sequelize.import Params: Name Type Description path String The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file query(sql, [options={}]) -> Promise View code Execute a query on the DB, with the possibility to bypass all the sequelize goodness. By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc. Use .spread to access the results. If you are running a type of query where you don't need the metadata, for example a SELECT query, you can pass in a query type to make sequelize format the results: sequelize.query('SELECT...').spread(function (results, metadata) { // Raw query - use spread }); sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(function (results) { // SELECT query - use then }) See: Model#build Params: Name Type Description sql String [options={}] Object Query options. [options.raw] Boolean If true, sequelize will not try to format the results of the query, or build an instance of a model from the result [options.transaction=null] Transaction The transaction that the query should be executed under [options.type='RAW'] String The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but Sequelize.QueryTypes is provided as convenience shortcuts. [options.nest=false] Boolean If true, transforms objects with . separated property names into nested objects using dottie.js . For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When nest is true, the query type is assumed to be 'SELECT' , unless otherwise specified [options.plain=false] Boolean Sets the query type to SELECT and return a single row [options.replacements] Object | Array Either an object of named parameter replacements in the format :param or an array of unnamed replacements to replace ? in your SQL. [options.bind] Object | Array Either an object of named bind parameter in the format $param or an array of unnamed bind parameter to replace $1, $2, ... in your SQL. [options.useMaster=false] Boolean Force the query to use the write pool, regardless of the query type. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.instance] Instance A sequelize instance used to build the return instance [options.model] Model A sequelize model used to build the returned model instances (used to be called callee) [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.supportsSearchPath] Boolean If false do not prepend the query with the search_path (Postgres only) [options.mapToModel=false] Object Map returned fields to model's fields if options.model or options.instance is present. Mapping will occur before building the model instance. [options.fieldMap] Object Map returned fields to arbitrary names for SELECT query type. set(variables, options) -> Promise View code Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL. Params: Name Type Description variables Object Object with multiple variables. options Object Query options. options.transaction Transaction The transaction that the query should be executed under escape(value) -> String View code Escape value. Params: Name Type Description value String createSchema(schema, options={}) -> Promise View code Create a new database schema. Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this command will do nothing. See: Model#schema Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging showAllSchemas(options={}) -> Promise View code Show all defined schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this will show all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging dropSchema(schema, options={}) -> Promise View code Drop a single schema Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this drop a table matching the schema name Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging dropAllSchemas(options={}) -> Promise View code Drop all schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this is the equivalent of drop all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging sync([options={}]) -> Promise View code Sync all defined models to the DB. Params: Name Type Description [options={}] Object [options.force=false] Boolean If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table [options.match] RegEx Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code [options.logging=console.log] Boolean | function A function that logs sql queries, or false for no logging [options.schema='public'] String The schema that the tables should be created in. This can be overriden for each table in sequelize.define [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.hooks=true] Boolean If hooks is true then beforeSync, afterSync, beforBulkSync, afterBulkSync hooks will be called truncate([options]) -> Promise View code Truncate all tables defined through the sequelize models. This is done by calling Model.truncate() on each model. See: Model#truncate Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function [options.logging] Boolean | function A function that logs sql queries, or false for no logging drop(options) -> Promise View code Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model See: Model#drop Params: Name Type Description options object The options passed to each call to Model.drop options.logging Boolean | function A function that logs sql queries, or false for no logging authenticate() -> Promise View code Test the connection by trying to authenticate Aliases: validate fn(fn, args) -> Sequelize.fn View code Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use sequelize.col , so that the columns are properly interpreted as columns and not a strings. Convert a user's username to upper case instance.updateAttributes({ username: self.sequelize.fn('upper', self.sequelize.col('username')) }) Alternatively, a condition object can be used as an argument e.g. to get the count of rows for which the predicate evaluates to true. Works on mysql and sqlite. sequelize.fn('sum', { age: { $gt: 25 }, name: 'Joe' }) An explicit cast is required on postgres. sequelize.fn('sum', sequelize.cast({ age: { $gt: 25 }, name: 'Joe' }, 'int')) See: Model#find Model#findAll Model#define Sequelize#col Params: Name Type Description fn String The function you want to call args any All further arguments will be passed as arguments to the function. An argument may be a condition object. col(col) -> Sequelize.col View code Creates a object representing a column in the DB. This is often useful in conjunction with sequelize.fn , since raw string arguments to fn will be escaped. See: Sequelize#fn Params: Name Type Description col String The name of the column cast(val, type) -> Sequelize.cast View code Creates a object representing a call to the cast function. Params: Name Type Description val any The value to cast type String The type to cast it to literal(val) -> Sequelize.literal View code Creates a object representing a literal, i.e. something that will not be escaped. Params: Name Type Description val any Aliases: asIs and(args) -> Sequelize.and View code An AND query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by AND or(args) -> Sequelize.or View code An OR query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by OR json(conditions, [value]) -> Sequelize.json View code Creates an object representing nested where conditions for postgres's json data-type. See: Model#find Params: Name Type Description conditions String | Object A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax. [value] String | Number | Boolean An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\". where(attr, [comparator='='], logic) -> Sequelize.where View code A way of specifying attr = condition. The attr can either be an object taken from Model.rawAttributes (for example Model.rawAttributes.id or Model.rawAttributes.name ). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions ( sequelize.fn , sequelize.col etc.) For string attributes, use the regular { where: { attr: something }} syntax. If you don't want your string to be escaped, use sequelize.literal . See: Model#find Params: Name Type Description attr Object The attribute, which can be either an attribute object from Model.rawAttributes or a sequelize object, for example an instance of sequelize.fn . For simple string attributes, use the POJO syntax [comparator='='] string logic String | Object The condition. Can be both a simply type, or a further condition ( $or , $and , .literal etc.) Aliases: condition transaction([options={}]) -> Promise View code Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction sequelize.transaction().then(function (t) { return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }) .then(t.commit.bind(t)) .catch(t.rollback.bind(t)); }) A syntax for automatically committing or rolling back based on the promise chain resolution is also supported: sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then() return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }); }).then(function () { // Committed }).catch(function (err) { // Rolled back console.error(err); }); If you have CLS enabled, the transaction will automatically be passed to any query that runs within the callback. To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor: var cls = require('continuation-local-storage'), ns = cls.createNamespace('....'); var Sequelize = require('sequelize'); Sequelize.cls = ns; Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace See: Transaction Params: Name Type Description [options={}] Object [options.autocommit=true] Boolean [options.type='DEFERRED'] String See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String See Sequelize.Transaction.ISOLATION_LEVELS for possible options [options.logging=false] Function A function that gets executed while running the query to log the sql. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Sequelize"},{"location":"api/sequelize/#class-sequelize","text":"View code This is the main class, the entry point to sequelize. To use it, you just need to import sequelize: var Sequelize = require('sequelize'); In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that.","title":"Class Sequelize"},{"location":"api/sequelize/#new-sequelizedatabase-usernamenull-passwordnull-options","text":"View code Instantiate sequelize with name of database, username and password","title":"new Sequelize(database, [username=null], [password=null], [options={}])"},{"location":"api/sequelize/#example-usage","text":"// without password and options var sequelize = new Sequelize('database', 'username') // without options var sequelize = new Sequelize('database', 'username', 'password') // without password / with blank password var sequelize = new Sequelize('database', 'username', null, {}) // with password and options var sequelize = new Sequelize('my_database', 'john', 'doe', {}) // with uri (see below) var sequelize = new Sequelize('mysql://localhost:3306/database', {}) Params: Name Type Description database String The name of the database [username=null] String The username which is used to authenticate against the database. [password=null] String The password which is used to authenticate against the database. [options={}] Object An object with options. [options.dialect='mysql'] String The dialect of the database you are connecting to. One of mysql, postgres, sqlite, mariadb and mssql. [options.dialectModulePath=null] String If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here [options.dialectOptions] Object An object of additional options, which are passed directly to the connection library [options.storage] String Only used by sqlite. Defaults to ':memory:' [options.host='localhost'] String The host of the relational database. [options.port=] Integer The port of the relational database. [options.protocol='tcp'] String The protocol of the relational database. [options.define={}] Object Default options for model definitions. See sequelize.define for options [options.query={}] Object Default options for sequelize.query [options.set={}] Object Default options for sequelize.set [options.sync={}] Object Default options for sequelize.sync [options.timezone='+00:00'] String The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes. [options.logging=console.log] Function A function that gets executed every time Sequelize would log something. [options.omitNull=false] Boolean A flag that defines if null values should be passed to SQL queries or not. [options.native=false] Boolean A flag that defines if native library shall be used or not. Currently only has an effect for postgres [options.replication=false] Boolean Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: host , port , username , password , database [options.pool={}] Object Should sequelize use a connection pool. Default is true [options.pool.maxConnections] Integer [options.pool.minConnections] Integer [options.pool.maxIdleTime] Integer The maximum time, in milliseconds, that a connection can be idle before being released [options.pool.validateConnection] Function A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected [options.quoteIdentifiers=true] Boolean Set to false to make table names and attributes case-insensitive on Postgres and skip double quoting of them. [options.transactionType='DEFERRED'] String Set the default transaction type. See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String Set the default transaction isolation level. See Sequelize.Transaction.ISOLATION_LEVELS for possible options. [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error. [options.typeValidation=false] Boolean Run built in type validators on insert and update, e.g. validate that arguments passed to integer fields are integer-like. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL.","title":"Example usage"},{"location":"api/sequelize/#new-sequelizeuri-options","text":"View code Instantiate sequelize with an URI Params: Name Type Description uri String A full database URI [options={}] object See above for possible options","title":"new Sequelize(uri, [options={}])"},{"location":"api/sequelize/#models","text":"View code Models are stored here under the name given to sequelize.define","title":"models"},{"location":"api/sequelize/#version","text":"View code Sequelize version number.","title":"version"},{"location":"api/sequelize/#sequelize","text":"View code A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc. See: Sequelize","title":"Sequelize"},{"location":"api/sequelize/#utils","text":"View code A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use Sequelize.Utils._ , which is a reference to the lodash library, if you don't already have it imported in your project.","title":"Utils"},{"location":"api/sequelize/#promise","text":"View code A handy reference to the bluebird Promise class","title":"Promise"},{"location":"api/sequelize/#querytypes","text":"View code Available query types for use with sequelize.query","title":"QueryTypes"},{"location":"api/sequelize/#validator","text":"View code Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor. See:","title":"Validator"},{"location":"api/sequelize/#transaction","text":"View code A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction See: Transaction Sequelize#transaction","title":"Transaction"},{"location":"api/sequelize/#deferrable","text":"View code A reference to the deferrable collection. Use this to access the different deferrable options. See: Deferrable Sequelize#transaction","title":"Deferrable"},{"location":"api/sequelize/#instance","text":"View code A reference to the sequelize instance class. See: Instance","title":"Instance"},{"location":"api/sequelize/#association","text":"View code A reference to the sequelize association class. See: Association","title":"Association"},{"location":"api/sequelize/#error","text":"View code A general error class See: Errors#BaseError","title":"Error"},{"location":"api/sequelize/#validationerror","text":"View code Emitted when a validation fails See: Errors#ValidationError","title":"ValidationError"},{"location":"api/sequelize/#validationerroritem","text":"View code Describes a validation error on an instance path See: Errors#ValidationErrorItem","title":"ValidationErrorItem"},{"location":"api/sequelize/#databaseerror","text":"View code A base class for all database related errors. See: Errors#DatabaseError","title":"DatabaseError"},{"location":"api/sequelize/#timeouterror","text":"View code Thrown when a database query times out because of a deadlock See: Errors#TimeoutError","title":"TimeoutError"},{"location":"api/sequelize/#uniqueconstrainterror","text":"View code Thrown when a unique constraint is violated in the database See: Errors#UniqueConstraintError","title":"UniqueConstraintError"},{"location":"api/sequelize/#exclusionconstrainterror","text":"View code Thrown when an exclusion constraint is violated in the database See: Errors#ExclusionConstraintError","title":"ExclusionConstraintError"},{"location":"api/sequelize/#foreignkeyconstrainterror","text":"View code Thrown when a foreign key constraint is violated in the database See: Errors#ForeignKeyConstraintError","title":"ForeignKeyConstraintError"},{"location":"api/sequelize/#connectionerror","text":"View code A base class for all connection related errors. See: Errors#ConnectionError","title":"ConnectionError"},{"location":"api/sequelize/#connectionrefusederror","text":"View code Thrown when a connection to a database is refused See: Errors#ConnectionRefusedError","title":"ConnectionRefusedError"},{"location":"api/sequelize/#accessdeniederror","text":"View code Thrown when a connection to a database is refused due to insufficient access See: Errors#AccessDeniedError","title":"AccessDeniedError"},{"location":"api/sequelize/#hostnotfounderror","text":"View code Thrown when a connection to a database has a hostname that was not found See: Errors#HostNotFoundError","title":"HostNotFoundError"},{"location":"api/sequelize/#hostnotreachableerror","text":"View code Thrown when a connection to a database has a hostname that was not reachable See: Errors#HostNotReachableError","title":"HostNotReachableError"},{"location":"api/sequelize/#invalidconnectionerror","text":"View code Thrown when a connection to a database has invalid values for any of the connection parameters See: Errors#InvalidConnectionError","title":"InvalidConnectionError"},{"location":"api/sequelize/#connectiontimedouterror","text":"View code Thrown when a connection to a database times out See: Errors#ConnectionTimedOutError","title":"ConnectionTimedOutError"},{"location":"api/sequelize/#instanceerror","text":"View code Thrown when a some problem occurred with Instance methods (see message for details) See: Errors#InstanceError","title":"InstanceError"},{"location":"api/sequelize/#getdialect-string","text":"View code Returns the specified dialect. Returns: The specified dialect.","title":"getDialect() -&gt; String"},{"location":"api/sequelize/#getqueryinterface-queryinterface","text":"View code Returns an instance of QueryInterface. See: QueryInterface Returns: An instance (singleton) of QueryInterface.","title":"getQueryInterface() -&gt; QueryInterface"},{"location":"api/sequelize/#definemodelname-attributes-options-model","text":"View code Define a new model, representing a table in the DB. The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this: sequelize.define('modelName', { columnA: { type: Sequelize.BOOLEAN, validate: { is: [\"[a-z]\",'i'], // will only allow letters max: 23, // only allow values <= 23 isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } }, field: 'column_a' // Other attributes here }, columnB: Sequelize.STRING, columnC: 'MY VERY OWN COLUMN TYPE' }) sequelize.models.modelName // The model will now be available in models under the name given to define As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters. For a list of possible data types, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#data-types For more about getters and setters, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#getters-setters For more about instance and class methods, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#expansion-of-models For more about validation, see https://sequelize.org/v3/docs/en/latest/docs/models-definition/#validations See: DataTypes Hooks Params: Name Type Description modelName String The name of the model. The model will be stored in sequelize.models under this name attributes Object An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below: attributes.column String | DataType | Object The description of a database column attributes.column.type String | DataType A string or a data type [attributes.column.allowNull=true] Boolean If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved. [attributes.column.defaultValue=null] Any A literal default value, a JavaScript function, or an SQL function (see sequelize.fn ) [attributes.column.unique=false] String | Boolean If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index [attributes.column.primaryKey=false] Boolean [attributes.column.field=null] String If set, sequelize will map the attribute name to a different name in the database [attributes.column.autoIncrement=false] Boolean [attributes.column.comment=null] String [attributes.column.references=null] String | Model An object with reference configurations [attributes.column.references.model] String | Model If this column references another table, provide it here as a Model, or a string [attributes.column.references.key='id'] String The column of the foreign table that this column references [attributes.column.onUpdate] String What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.onDelete] String What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.get] Function Provide a custom getter for this column. Use this.getDataValue(String) to manipulate the underlying values. [attributes.column.set] Function Provide a custom setter for this column. Use this.setDataValue(String, Value) to manipulate the underlying values. [attributes.validate] Object An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the DAOValidator property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text. [options] Object These options are merged with the default define options provided to the Sequelize constructor [options.defaultScope={}] Object Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll [options.scopes] Object More scopes, defined in the same way as defaultScope above. See Model.scope for more information about how scopes are defined, and what you can do with them [options.omitNull] Boolean Don't persist null values. This means that all columns with null values will not be saved [options.timestamps=true] Boolean Adds createdAt and updatedAt timestamps to the model. [options.paranoid=false] Boolean Calling destroy will not delete the model, but instead set a deletedAt timestamp if this is true. Needs timestamps=true to work [options.underscored=false] Boolean Converts all camelCased columns to underscored if true [options.underscoredAll=false] Boolean Converts camelCased model names to underscored table names if true [options.freezeTableName=false] Boolean If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the model name will be pluralized [options.name] Object An object with two attributes, singular and plural , which are used when this model is associated to others. [options.name.singular=inflection.singularize(modelName)] String [options.name.plural=inflection.pluralize(modelName)] String [options.indexes] Array.<Object> [options.indexes[].name] String The name of the index. Defaults to model name + _ + fields concatenated [options.indexes[].type] String Index type. Only used by mysql. One of UNIQUE , FULLTEXT and SPATIAL [options.indexes[].method] String The method to create the index by ( USING statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN. [options.indexes[].unique=false] Boolean Should the index by unique? Can also be triggered by setting type to UNIQUE [options.indexes[].concurrently=false] Boolean PostgreSQL will build the index without taking any write locks. Postgres only [options.indexes[].fields] Array.<String | Object> An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g sequelize.fn ), or an object with the following attributes: attribute (field name), length (create a prefix index of length chars), order (the direction the column should be sorted in), collate (the collation (sort order) for the column) [options.createdAt] String | Boolean Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.updatedAt] String | Boolean Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.deletedAt] String | Boolean Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.tableName] String Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim [options.getterMethods] Object Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values [options.setterMethods] Object Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted [options.instanceMethods] Object Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using this.constructor.super_.prototype , e.g. this.constructor.super_.prototype.toJSON.apply(this, arguments) [options.classMethods] Object Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using this.constructor.prototype , e.g. this.constructor.prototype.find.apply(this, arguments) [options.schema='public'] String [options.engine] String [options.charset] String [options.comment] String [options.collate] String [options.initialAutoIncrement] String Set the initial AUTO_INCREMENT value for the table in MySQL. [options.hooks] Object An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions. [options.validate] Object An object of model wide validations. Validations have access to all model values via this . If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.","title":"define(modelName, attributes, [options]) -&gt; Model"},{"location":"api/sequelize/#modelmodelname-model","text":"View code Fetch a Model which is already defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define","title":"model(modelName) -&gt; Model"},{"location":"api/sequelize/#isdefinedmodelname-boolean","text":"View code Checks whether a model with the given name is defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define","title":"isDefined(modelName) -&gt; Boolean"},{"location":"api/sequelize/#importpath-model","text":"View code Imports a model defined in another file Imported models are cached, so multiple calls to import with the same path will not load the file multiple times See https://github.com/sequelize/express-example for a short example of how to define your models in separate files so that they can be imported by sequelize.import Params: Name Type Description path String The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file","title":"import(path) -&gt; Model"},{"location":"api/sequelize/#querysql-options-promise","text":"View code Execute a query on the DB, with the possibility to bypass all the sequelize goodness. By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc. Use .spread to access the results. If you are running a type of query where you don't need the metadata, for example a SELECT query, you can pass in a query type to make sequelize format the results: sequelize.query('SELECT...').spread(function (results, metadata) { // Raw query - use spread }); sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(function (results) { // SELECT query - use then }) See: Model#build Params: Name Type Description sql String [options={}] Object Query options. [options.raw] Boolean If true, sequelize will not try to format the results of the query, or build an instance of a model from the result [options.transaction=null] Transaction The transaction that the query should be executed under [options.type='RAW'] String The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but Sequelize.QueryTypes is provided as convenience shortcuts. [options.nest=false] Boolean If true, transforms objects with . separated property names into nested objects using dottie.js . For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When nest is true, the query type is assumed to be 'SELECT' , unless otherwise specified [options.plain=false] Boolean Sets the query type to SELECT and return a single row [options.replacements] Object | Array Either an object of named parameter replacements in the format :param or an array of unnamed replacements to replace ? in your SQL. [options.bind] Object | Array Either an object of named bind parameter in the format $param or an array of unnamed bind parameter to replace $1, $2, ... in your SQL. [options.useMaster=false] Boolean Force the query to use the write pool, regardless of the query type. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.instance] Instance A sequelize instance used to build the return instance [options.model] Model A sequelize model used to build the returned model instances (used to be called callee) [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.supportsSearchPath] Boolean If false do not prepend the query with the search_path (Postgres only) [options.mapToModel=false] Object Map returned fields to model's fields if options.model or options.instance is present. Mapping will occur before building the model instance. [options.fieldMap] Object Map returned fields to arbitrary names for SELECT query type.","title":"query(sql, [options={}]) -&gt; Promise"},{"location":"api/sequelize/#setvariables-options-promise","text":"View code Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL. Params: Name Type Description variables Object Object with multiple variables. options Object Query options. options.transaction Transaction The transaction that the query should be executed under","title":"set(variables, options) -&gt; Promise"},{"location":"api/sequelize/#escapevalue-string","text":"View code Escape value. Params: Name Type Description value String","title":"escape(value) -&gt; String"},{"location":"api/sequelize/#createschemaschema-options-promise","text":"View code Create a new database schema. Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this command will do nothing. See: Model#schema Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging","title":"createSchema(schema, options={}) -&gt; Promise"},{"location":"api/sequelize/#showallschemasoptions-promise","text":"View code Show all defined schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this will show all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging","title":"showAllSchemas(options={}) -&gt; Promise"},{"location":"api/sequelize/#dropschemaschema-options-promise","text":"View code Drop a single schema Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this drop a table matching the schema name Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging","title":"dropSchema(schema, options={}) -&gt; Promise"},{"location":"api/sequelize/#dropallschemasoptions-promise","text":"View code Drop all schemas Note,that this is a schema in the postgres sense of the word , not a database table. In mysql and sqlite, this is the equivalent of drop all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging","title":"dropAllSchemas(options={}) -&gt; Promise"},{"location":"api/sequelize/#syncoptions-promise","text":"View code Sync all defined models to the DB. Params: Name Type Description [options={}] Object [options.force=false] Boolean If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table [options.match] RegEx Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code [options.logging=console.log] Boolean | function A function that logs sql queries, or false for no logging [options.schema='public'] String The schema that the tables should be created in. This can be overriden for each table in sequelize.define [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.hooks=true] Boolean If hooks is true then beforeSync, afterSync, beforBulkSync, afterBulkSync hooks will be called","title":"sync([options={}]) -&gt; Promise"},{"location":"api/sequelize/#truncateoptions-promise","text":"View code Truncate all tables defined through the sequelize models. This is done by calling Model.truncate() on each model. See: Model#truncate Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function [options.logging] Boolean | function A function that logs sql queries, or false for no logging","title":"truncate([options]) -&gt; Promise"},{"location":"api/sequelize/#dropoptions-promise","text":"View code Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model See: Model#drop Params: Name Type Description options object The options passed to each call to Model.drop options.logging Boolean | function A function that logs sql queries, or false for no logging","title":"drop(options) -&gt; Promise"},{"location":"api/sequelize/#authenticate-promise","text":"View code Test the connection by trying to authenticate Aliases: validate","title":"authenticate() -&gt; Promise"},{"location":"api/sequelize/#fnfn-args-sequelizefn","text":"View code Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use sequelize.col , so that the columns are properly interpreted as columns and not a strings. Convert a user's username to upper case instance.updateAttributes({ username: self.sequelize.fn('upper', self.sequelize.col('username')) }) Alternatively, a condition object can be used as an argument e.g. to get the count of rows for which the predicate evaluates to true. Works on mysql and sqlite. sequelize.fn('sum', { age: { $gt: 25 }, name: 'Joe' }) An explicit cast is required on postgres. sequelize.fn('sum', sequelize.cast({ age: { $gt: 25 }, name: 'Joe' }, 'int')) See: Model#find Model#findAll Model#define Sequelize#col Params: Name Type Description fn String The function you want to call args any All further arguments will be passed as arguments to the function. An argument may be a condition object.","title":"fn(fn, args) -&gt; Sequelize.fn"},{"location":"api/sequelize/#colcol-sequelizecol","text":"View code Creates a object representing a column in the DB. This is often useful in conjunction with sequelize.fn , since raw string arguments to fn will be escaped. See: Sequelize#fn Params: Name Type Description col String The name of the column","title":"col(col) -&gt; Sequelize.col"},{"location":"api/sequelize/#castval-type-sequelizecast","text":"View code Creates a object representing a call to the cast function. Params: Name Type Description val any The value to cast type String The type to cast it to","title":"cast(val, type) -&gt; Sequelize.cast"},{"location":"api/sequelize/#literalval-sequelizeliteral","text":"View code Creates a object representing a literal, i.e. something that will not be escaped. Params: Name Type Description val any Aliases: asIs","title":"literal(val) -&gt; Sequelize.literal"},{"location":"api/sequelize/#andargs-sequelizeand","text":"View code An AND query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by AND","title":"and(args) -&gt; Sequelize.and"},{"location":"api/sequelize/#orargs-sequelizeor","text":"View code An OR query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by OR","title":"or(args) -&gt; Sequelize.or"},{"location":"api/sequelize/#jsonconditions-value-sequelizejson","text":"View code Creates an object representing nested where conditions for postgres's json data-type. See: Model#find Params: Name Type Description conditions String | Object A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax. [value] String | Number | Boolean An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\".","title":"json(conditions, [value]) -&gt; Sequelize.json"},{"location":"api/sequelize/#whereattr-comparator-logic-sequelizewhere","text":"View code A way of specifying attr = condition. The attr can either be an object taken from Model.rawAttributes (for example Model.rawAttributes.id or Model.rawAttributes.name ). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions ( sequelize.fn , sequelize.col etc.) For string attributes, use the regular { where: { attr: something }} syntax. If you don't want your string to be escaped, use sequelize.literal . See: Model#find Params: Name Type Description attr Object The attribute, which can be either an attribute object from Model.rawAttributes or a sequelize object, for example an instance of sequelize.fn . For simple string attributes, use the POJO syntax [comparator='='] string logic String | Object The condition. Can be both a simply type, or a further condition ( $or , $and , .literal etc.) Aliases: condition","title":"where(attr, [comparator='='], logic) -&gt; Sequelize.where"},{"location":"api/sequelize/#transactionoptions-promise","text":"View code Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction sequelize.transaction().then(function (t) { return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }) .then(t.commit.bind(t)) .catch(t.rollback.bind(t)); }) A syntax for automatically committing or rolling back based on the promise chain resolution is also supported: sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then() return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }); }).then(function () { // Committed }).catch(function (err) { // Rolled back console.error(err); }); If you have CLS enabled, the transaction will automatically be passed to any query that runs within the callback. To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor: var cls = require('continuation-local-storage'), ns = cls.createNamespace('....'); var Sequelize = require('sequelize'); Sequelize.cls = ns; Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace See: Transaction Params: Name Type Description [options={}] Object [options.autocommit=true] Boolean [options.type='DEFERRED'] String See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String See Sequelize.Transaction.ISOLATION_LEVELS for possible options [options.logging=false] Function A function that gets executed while running the query to log the sql. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"transaction([options={}]) -&gt; Promise"},{"location":"api/transaction/","text":"Class Transaction View code The transaction object is used to identify a running transaction. It is created by calling Sequelize.transaction() . To run a query under a transaction, you should pass the transaction in the options object. Params: Name Type Description sequelize Sequelize A configured sequelize Instance options Object An object with options options.autocommit=true Boolean Sets the autocommit property of the transaction. options.type=true String Sets the type of the transaction. options.isolationLevel=true String Sets the isolation level of the transaction. options.deferrable String Sets the constraints to be deferred or immediately checked. TYPES View code Types can be set per-transaction by passing options.type to sequelize.transaction . Default to DEFERRED but you can override the default type by passing options.transactionType in new Sequelize . Sqlite only. The possible types to use when starting a transaction: { DEFERRED: \"DEFERRED\", IMMEDIATE: \"IMMEDIATE\", EXCLUSIVE: \"EXCLUSIVE\" } Pass in the desired level as the first argument: return sequelize.transaction({ type: Sequelize.Transaction.EXCLUSIVE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. }); ISOLATION_LEVELS View code Isolations levels can be set per-transaction by passing options.isolationLevel to sequelize.transaction . Default to REPEATABLE_READ but you can override the default isolation level by passing options.isolationLevel in new Sequelize . The possible isolations levels to use when starting a transaction: { READ_UNCOMMITTED: \"READ UNCOMMITTED\", READ_COMMITTED: \"READ COMMITTED\", REPEATABLE_READ: \"REPEATABLE READ\", SERIALIZABLE: \"SERIALIZABLE\" } Pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.SERIALIZABLE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. }); LOCK View code Possible options for row locking. Used in conjunction with find calls: t1 // is a transaction t1.LOCK.UPDATE, t1.LOCK.SHARE, t1.LOCK.KEY_SHARE, // Postgres 9.3+ only t1.LOCK.NO_KEY_UPDATE // Postgres 9.3+ only Usage: t1 // is a transaction Model.findAll({ where: ..., transaction: t1, lock: t1.LOCK... }); Postgres also supports specific locks while eager loading by using OF: UserModel.findAll({ where: ..., include: [TaskModel, ...], transaction: t1, lock: { level: t1.LOCK..., of: UserModel } }); UserModel will be locked but TaskModel won't! commit() -> Promise View code Commit the transaction rollback() -> Promise View code Rollback (abort) the transaction This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Transaction"},{"location":"api/transaction/#class-transaction","text":"View code The transaction object is used to identify a running transaction. It is created by calling Sequelize.transaction() . To run a query under a transaction, you should pass the transaction in the options object. Params: Name Type Description sequelize Sequelize A configured sequelize Instance options Object An object with options options.autocommit=true Boolean Sets the autocommit property of the transaction. options.type=true String Sets the type of the transaction. options.isolationLevel=true String Sets the isolation level of the transaction. options.deferrable String Sets the constraints to be deferred or immediately checked.","title":"Class Transaction"},{"location":"api/transaction/#types","text":"View code Types can be set per-transaction by passing options.type to sequelize.transaction . Default to DEFERRED but you can override the default type by passing options.transactionType in new Sequelize . Sqlite only. The possible types to use when starting a transaction: { DEFERRED: \"DEFERRED\", IMMEDIATE: \"IMMEDIATE\", EXCLUSIVE: \"EXCLUSIVE\" } Pass in the desired level as the first argument: return sequelize.transaction({ type: Sequelize.Transaction.EXCLUSIVE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. });","title":"TYPES"},{"location":"api/transaction/#isolation_levels","text":"View code Isolations levels can be set per-transaction by passing options.isolationLevel to sequelize.transaction . Default to REPEATABLE_READ but you can override the default isolation level by passing options.isolationLevel in new Sequelize . The possible isolations levels to use when starting a transaction: { READ_UNCOMMITTED: \"READ UNCOMMITTED\", READ_COMMITTED: \"READ COMMITTED\", REPEATABLE_READ: \"REPEATABLE READ\", SERIALIZABLE: \"SERIALIZABLE\" } Pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.SERIALIZABLE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. });","title":"ISOLATION_LEVELS"},{"location":"api/transaction/#lock","text":"View code Possible options for row locking. Used in conjunction with find calls: t1 // is a transaction t1.LOCK.UPDATE, t1.LOCK.SHARE, t1.LOCK.KEY_SHARE, // Postgres 9.3+ only t1.LOCK.NO_KEY_UPDATE // Postgres 9.3+ only Usage: t1 // is a transaction Model.findAll({ where: ..., transaction: t1, lock: t1.LOCK... }); Postgres also supports specific locks while eager loading by using OF: UserModel.findAll({ where: ..., include: [TaskModel, ...], transaction: t1, lock: { level: t1.LOCK..., of: UserModel } }); UserModel will be locked but TaskModel won't!","title":"LOCK"},{"location":"api/transaction/#commit-promise","text":"View code Commit the transaction","title":"commit() -&gt; Promise"},{"location":"api/transaction/#rollback-promise","text":"View code Rollback (abort) the transaction This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"rollback() -&gt; Promise"},{"location":"api/associations/","text":"Mixin Associations View code Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target). hasOne - adds a foreign key to the target and singular association mixins to the source. belongsTo - add a foreign key and singular association mixins to the source. hasMany - adds a foreign key to target and plural association mixins to the source. belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId. Creating an association will add a foreign key constraint to the attributes. All associations use CASCADE on update and SET NULL on delete, except for n:m, which also uses CASCADE on delete. When creating associations, you can provide an alias, via the as option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model. As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a userId , but in addition the user model also has a profilePictureId , to be able to easily load the user's profile picture. User.hasMany(Picture) User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false }) user.getPictures() // gets you all pictures user.getProfilePicture() // gets you only the profile picture User.findAll({ where: ..., include: [ { model: Picture }, // load all pictures { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association ] }) To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define . User.hasMany(Picture, { foreignKey: 'uid' }) The foreign key column in Picture will now be called uid instead of the default userId . User.hasMany(Picture, { foreignKey: { name: 'uid', allowNull: false } }) This specifies that the uid column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see constraints: false below). When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to find / findAll . To only get pictures in JPG, you can do: user.getPictures({ where: { format: 'jpg' } }) There are several ways to update and add new associations. Continuing with our example of users and pictures: user.addPicture(p) // Add a single picture user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations You don't have to pass in a complete object to the association functions, if your associated model has a single primary key: user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it. Note how we also specified constraints: false for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of Error: Cyclic dependency found. 'users' is dependent of itself . If you encounter this, you should either disable some constraints, or rethink your associations completely. hasOne(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasOne(Profile) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.onDelete='SET NULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. belongsTo(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the source. Example: Profile.belongsTo(User) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the source table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.targetKey] string The name of the field to use as the key for the association in the target table. Defaults to the primary key of the target table [options.onDelete='SET NULL | NO ACTION'] string SET NULL if foreignKey allows nulls, NO ACTION if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. hasMany(target, [options]) View code Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasMany(Profile) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string | object The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.onDelete='SET NULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. belongsToMany(target, [options]) View code Create an N:M association with a join table. User.belongsToMany(Project, { through: 'UserProjects' }) Project.belongsToMany(User, { through: 'UserProjects' }) Defining through is required. Sequelize would previously attempt to auto generate names but that would not always lead to the most logical setups. If you define a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet: var UserProjects = sequelize.define('UserProjects', { started: Sequelize.BOOLEAN }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) jan.addProject(homework, { started: false }) // The homework project is not started yet jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model: p1.UserProjects = { started: true } user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that. Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model. user.getProjects().then(function (projects) { var p1 = projects[0] p1.UserProjects.started // Is this project started yet? }) Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.through] Model | string | object The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it. [options.through.model] Model The model used to join both sides of the N:M association. [options.through.scope] object A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model) [options.through.unique=true] boolean If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes) [options.as] string | object The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.otherKey] string | object The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.timestamps=sequelize.options.timestamps] boolean Should the join model have timestamps [options.onDelete='SET NULL | CASCADE'] string Cascade if this is a n:m, and set null if it is a 1:m [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"Overview"},{"location":"api/associations/#mixin-associations","text":"View code Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target). hasOne - adds a foreign key to the target and singular association mixins to the source. belongsTo - add a foreign key and singular association mixins to the source. hasMany - adds a foreign key to target and plural association mixins to the source. belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId. Creating an association will add a foreign key constraint to the attributes. All associations use CASCADE on update and SET NULL on delete, except for n:m, which also uses CASCADE on delete. When creating associations, you can provide an alias, via the as option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model. As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a userId , but in addition the user model also has a profilePictureId , to be able to easily load the user's profile picture. User.hasMany(Picture) User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false }) user.getPictures() // gets you all pictures user.getProfilePicture() // gets you only the profile picture User.findAll({ where: ..., include: [ { model: Picture }, // load all pictures { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association ] }) To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define . User.hasMany(Picture, { foreignKey: 'uid' }) The foreign key column in Picture will now be called uid instead of the default userId . User.hasMany(Picture, { foreignKey: { name: 'uid', allowNull: false } }) This specifies that the uid column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see constraints: false below). When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to find / findAll . To only get pictures in JPG, you can do: user.getPictures({ where: { format: 'jpg' } }) There are several ways to update and add new associations. Continuing with our example of users and pictures: user.addPicture(p) // Add a single picture user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations You don't have to pass in a complete object to the association functions, if your associated model has a single primary key: user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it. Note how we also specified constraints: false for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of Error: Cyclic dependency found. 'users' is dependent of itself . If you encounter this, you should either disable some constraints, or rethink your associations completely.","title":"Mixin Associations"},{"location":"api/associations/#hasonetarget-options","text":"View code Creates an association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasOne(Profile) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.onDelete='SET NULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key.","title":"hasOne(target, [options])"},{"location":"api/associations/#belongstotarget-options","text":"View code Creates an association between this (the source) and the provided target. The foreign key is added on the source. Example: Profile.belongsTo(User) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the source table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.targetKey] string The name of the field to use as the key for the association in the target table. Defaults to the primary key of the target table [options.onDelete='SET NULL | NO ACTION'] string SET NULL if foreignKey allows nulls, NO ACTION if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key.","title":"belongsTo(target, [options])"},{"location":"api/associations/#hasmanytarget-options","text":"View code Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasMany(Profile) . This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string | object The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.onDelete='SET NULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key.","title":"hasMany(target, [options])"},{"location":"api/associations/#belongstomanytarget-options","text":"View code Create an N:M association with a join table. User.belongsToMany(Project, { through: 'UserProjects' }) Project.belongsToMany(User, { through: 'UserProjects' }) Defining through is required. Sequelize would previously attempt to auto generate names but that would not always lead to the most logical setups. If you define a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet: var UserProjects = sequelize.define('UserProjects', { started: Sequelize.BOOLEAN }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) jan.addProject(homework, { started: false }) // The homework project is not started yet jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model: p1.UserProjects = { started: true } user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that. Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model. user.getProjects().then(function (projects) { var p1 = projects[0] p1.UserProjects.started // Is this project started yet? }) Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}) , the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.through] Model | string | object The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it. [options.through.model] Model The model used to join both sides of the N:M association. [options.through.scope] object A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model) [options.through.unique=true] boolean If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes) [options.as] string | object The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define . If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.otherKey] string | object The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.timestamps=sequelize.options.timestamps] boolean Should the join model have timestamps [options.onDelete='SET NULL | CASCADE'] string Cascade if this is a n:m, and set null if it is a 1:m [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"belongsToMany(target, [options])"},{"location":"api/associations/belongs-to-many/","text":"Mixin BelongsToMany View code Many-to-many association with a join table. When the join table has additional attributes, these can be passed in the options object: UserProject = sequelize.define('user_project', { role: Sequelize.STRING }); User.belongsToMany(Project, { through: UserProject }); Project.belongsToMany(User, { through: UserProject }); // through is required! user.addProject(project, { role: 'manager', transaction: t }); All methods allow you to pass either a persisted instance, its primary key, or a mixture: Project.create({ id: 11 }).then(function (project) { user.addProjects([project, 12]); }); In the API reference below, replace Assocation(s) with the actual name of your association, e.g. for User.belongsToMany(Project) the getter will be user.getProjects() . getAssociations([options]) -> Promise.<Array.<Instance>> View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociations([newAssociations], [options]) -> Promise View code Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to through.findAll , bulkCreate , update and destroy . Can also hold additional attributes for the join table [options.validate] Object Run validation for the join model addAssociations([newAssociations], [options]) -> Promise View code Associate several instances with this. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. [options] Object Options passed to through.findAll , bulkCreate and update . Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model. addAssociation([newAssociation], [options]) -> Promise View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to through.findAll , bulkCreate and update . Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to create and add. Can also hold additional attributes for the join table removeAssociation([oldAssociated], [options]) -> Promise View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to through.destroy removeAssociations([oldAssociated], [options]) -> Promise View code Un-associate several instances. Params: Name Type Description [oldAssociated] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to through.destroy hasAssociation([instance], [options]) -> Promise View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations hasAssociations([instances], [options]) -> Promise View code Check if all instances are associated with this. Params: Name Type Description [instances] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to getAssociations countAssociations([options]) -> Promise.<Int> View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"BelongsToMany (n:m)"},{"location":"api/associations/belongs-to-many/#mixin-belongstomany","text":"View code Many-to-many association with a join table. When the join table has additional attributes, these can be passed in the options object: UserProject = sequelize.define('user_project', { role: Sequelize.STRING }); User.belongsToMany(Project, { through: UserProject }); Project.belongsToMany(User, { through: UserProject }); // through is required! user.addProject(project, { role: 'manager', transaction: t }); All methods allow you to pass either a persisted instance, its primary key, or a mixture: Project.create({ id: 11 }).then(function (project) { user.addProjects([project, 12]); }); In the API reference below, replace Assocation(s) with the actual name of your association, e.g. for User.belongsToMany(Project) the getter will be user.getProjects() .","title":"Mixin BelongsToMany"},{"location":"api/associations/belongs-to-many/#getassociationsoptions-promisearrayinstance","text":"View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model","title":"getAssociations([options]) -&gt; Promise.&lt;Array.&lt;Instance&gt;&gt;"},{"location":"api/associations/belongs-to-many/#setassociationsnewassociations-options-promise","text":"View code Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to through.findAll , bulkCreate , update and destroy . Can also hold additional attributes for the join table [options.validate] Object Run validation for the join model","title":"setAssociations([newAssociations], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#addassociationsnewassociations-options-promise","text":"View code Associate several instances with this. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. [options] Object Options passed to through.findAll , bulkCreate and update . Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model.","title":"addAssociations([newAssociations], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#addassociationnewassociation-options-promise","text":"View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to through.findAll , bulkCreate and update . Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model.","title":"addAssociation([newAssociation], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#createassociationvalues-options-promise","text":"View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to create and add. Can also hold additional attributes for the join table","title":"createAssociation([values], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#removeassociationoldassociated-options-promise","text":"View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to through.destroy","title":"removeAssociation([oldAssociated], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#removeassociationsoldassociated-options-promise","text":"View code Un-associate several instances. Params: Name Type Description [oldAssociated] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to through.destroy","title":"removeAssociations([oldAssociated], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#hasassociationinstance-options-promise","text":"View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations","title":"hasAssociation([instance], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#hasassociationsinstances-options-promise","text":"View code Check if all instances are associated with this. Params: Name Type Description [instances] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to getAssociations","title":"hasAssociations([instances], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to-many/#countassociationsoptions-promiseint","text":"View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"countAssociations([options]) -&gt; Promise.&lt;Int&gt;"},{"location":"api/associations/belongs-to/","text":"Mixin BelongsTo View code One-to-one association In the API reference below, replace Assocation with the actual name of your association, e.g. for User.belongsTo(Project) the getter will be user.getProject() . getAssociation([options]) -> Promise.<Instance> View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false. [options.schema] String Apply a schema on the related model setAssociation([newAssociation], [options]) -> Promise View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to this.save [options.save=true] Boolean Skip saving this after setting the foreign key if false. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"BelongsTo (1:1)"},{"location":"api/associations/belongs-to/#mixin-belongsto","text":"View code One-to-one association In the API reference below, replace Assocation with the actual name of your association, e.g. for User.belongsTo(Project) the getter will be user.getProject() .","title":"Mixin BelongsTo"},{"location":"api/associations/belongs-to/#getassociationoptions-promiseinstance","text":"View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false. [options.schema] String Apply a schema on the related model","title":"getAssociation([options]) -&gt; Promise.&lt;Instance&gt;"},{"location":"api/associations/belongs-to/#setassociationnewassociation-options-promise","text":"View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to this.save [options.save=true] Boolean Skip saving this after setting the foreign key if false.","title":"setAssociation([newAssociation], [options]) -&gt; Promise"},{"location":"api/associations/belongs-to/#createassociationvalues-options-promise","text":"View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"createAssociation([values], [options]) -&gt; Promise"},{"location":"api/associations/has-many/","text":"Mixin HasMany View code One-to-many association In the API reference below, replace Association(s) with the actual name of your association, e.g. for User.hasMany(Project) the getter will be user.getProjects() . getAssociations([options]) -> Promise.<Array.<Instance>> View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociations([newAssociations], [options]) -> Promise View code Set the associated models by passing an array of instances or their primary keys. Everything that is not in the passed array will be un-associated Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to target.findAll and update . [options.validate] Object Run validation for the join model addAssociations([newAssociations], [options]) -> Promise View code Associate several instances with this. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. [options] Object Options passed to target.update . [options.validate] Object Run validation for the join model. addAssociation([newAssociation], [options]) -> Promise View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to target.update . [options.validate] Object Run validation for the join model. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create . removeAssociation([oldAssociated], [options]) -> Promise View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to target.update removeAssociations([oldAssociatedArray], [options]) -> Promise View code Un-associate several instances. Params: Name Type Description [oldAssociatedArray] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to through.destroy hasAssociation([instance], [options]) -> Promise View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations hasAssociations([instances], [options]) -> Promise View code Check if all instances are associated with this. Params: Name Type Description [instances] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to getAssociations countAssociations([options]) -> Promise.<Int> View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"HasMany (1:m)"},{"location":"api/associations/has-many/#mixin-hasmany","text":"View code One-to-many association In the API reference below, replace Association(s) with the actual name of your association, e.g. for User.hasMany(Project) the getter will be user.getProjects() .","title":"Mixin HasMany"},{"location":"api/associations/has-many/#getassociationsoptions-promisearrayinstance","text":"View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model","title":"getAssociations([options]) -&gt; Promise.&lt;Array.&lt;Instance&gt;&gt;"},{"location":"api/associations/has-many/#setassociationsnewassociations-options-promise","text":"View code Set the associated models by passing an array of instances or their primary keys. Everything that is not in the passed array will be un-associated Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to target.findAll and update . [options.validate] Object Run validation for the join model","title":"setAssociations([newAssociations], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#addassociationsnewassociations-options-promise","text":"View code Associate several instances with this. Params: Name Type Description [newAssociations] Array.<Instance | String | Number> An array of instances or primary key of instances to associate with this. [options] Object Options passed to target.update . [options.validate] Object Run validation for the join model.","title":"addAssociations([newAssociations], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#addassociationnewassociation-options-promise","text":"View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to target.update . [options.validate] Object Run validation for the join model.","title":"addAssociation([newAssociation], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#createassociationvalues-options-promise","text":"View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create .","title":"createAssociation([values], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#removeassociationoldassociated-options-promise","text":"View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to target.update","title":"removeAssociation([oldAssociated], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#removeassociationsoldassociatedarray-options-promise","text":"View code Un-associate several instances. Params: Name Type Description [oldAssociatedArray] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to through.destroy","title":"removeAssociations([oldAssociatedArray], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#hasassociationinstance-options-promise","text":"View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations","title":"hasAssociation([instance], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#hasassociationsinstances-options-promise","text":"View code Check if all instances are associated with this. Params: Name Type Description [instances] Array.<Instance | String | Number> Can be an array of instances or their primary keys [options] Object Options passed to getAssociations","title":"hasAssociations([instances], [options]) -&gt; Promise"},{"location":"api/associations/has-many/#countassociationsoptions-promiseint","text":"View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"countAssociations([options]) -&gt; Promise.&lt;Int&gt;"},{"location":"api/associations/has-one/","text":"Mixin HasOne View code One-to-one association In the API reference below, replace Association with the actual name of your association, e.g. for User.hasOne(Project) the getter will be user.getProject() . This is almost the same as belongsTo with one exception. The foreign key will be defined on the target model. getAssociation([options]) -> Promise.<Instance> View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociation([newAssociation], [options]) -> Promise View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to getAssociation and target.save createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"HasOne (1:1)"},{"location":"api/associations/has-one/#mixin-hasone","text":"View code One-to-one association In the API reference below, replace Association with the actual name of your association, e.g. for User.hasOne(Project) the getter will be user.getProject() . This is almost the same as belongsTo with one exception. The foreign key will be defined on the target model.","title":"Mixin HasOne"},{"location":"api/associations/has-one/#getassociationoptions-promiseinstance","text":"View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model","title":"getAssociation([options]) -&gt; Promise.&lt;Instance&gt;"},{"location":"api/associations/has-one/#setassociationnewassociation-options-promise","text":"View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to getAssociation and target.save","title":"setAssociation([newAssociation], [options]) -&gt; Promise"},{"location":"api/associations/has-one/#createassociationvalues-options-promise","text":"View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC , open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox","title":"createAssociation([values], [options]) -&gt; Promise"},{"location":"articles/express/","text":"fromGithub = function (partialId, ext) { ext = ext || ''; var $partial = $(\"#\" + partialId) $.get(\"https://cdn.rawgit.com/sequelize/express-example/master/\" + partialId.replace(\"_\", \"/\") + ext, function (code) { if (ext === '.js') { code = hljs.highlight('js', code).value; } code = '<div class=\"highlight\"><pre>' + code + '</pre></div>'; $partial.replaceWith(code); }, 'html'); } Introduction This article explains the usage of Sequelize with the MVC framework Express.You will learn how and where to define models and how to load them when needed. A minimal express application In order to create a minimal express application, we need to install express first and scaffold a project. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express express-generator $ node_modules/.bin/express . -f $ npm install $ ./bin/www You should now be able to see a tiny welcome page on http://localhost:3000 Adding Sequelize to the application Now that we have the express application in place, we can start adding Sequelize to it. What we need for that are the following packages: sequelize, sequelize-cli, sqlite3. Please note, that for the sake of simplicity this tutorial will use SQLite. $ npm install --save sequelize@2.0.0-rc1 sequelize-cli sqlite3 This will install the respective packages and uses the upcoming major release of sequelize. We can now let the sequelize CLI initialize the project's directory: $ node_modules/.bin/sequelize init Running this command will create the folders config , migrations and models . Implementing a todo app As an example application we will create a very basic and simple todo tool, which allows the creation of users and the management of their tasks. bin/www In order to create a maintainable application, we will put all the database logic into the models folder. When the application gets fired up, sequelize will sync the models with the database and afterwards start the server. This way we don't clutter the application while making use of sequelize's features. $(function () { fromGithub(\"bin_www\") }) models/index.js This file has been generated with the sequelize CLI and collects all the models from the models directory and associates them if needed. $(function () { fromGithub(\"models_index\", '.js') }) models/user.js All models of our application are located as separate files in the models folder. If you want to add a new model, just add it to this folder and everything will work automagically. Also you can use the sequelize CLI's sequelize model:create . Notice that the associate method receives a parameter models , which contains every declared model within the models directory. $(function () { fromGithub(\"models_user\", '.js') }) models/task.js The other needed model is Task . It relates to the User . $(function () { fromGithub(\"models_task\", '.js') }) routes/index.js The file routes/index.js contains the logic for a request against the main homepage. It loads the models module and uses it to load all the users and tasks from the database. $(function () { fromGithub(\"routes_index\", '.js') }) This will allow us to iterate over the users in the view file. We will skip the rest of the route files for this article. views/index.jade As we passed the users to the view and include the tasks for each user, we can access the data in the view's template file. Besides listing the users and tasks, there are also forms for creating new instances. $(function () { fromGithub(\"views_index\", '.jade') }) What's next? This article shows a basic approach of how to integrate Sequelize into an ExpressJS application. It allows the very easy management of models by adding new files to a specific folder. Starting the application will automatically sync the schema with the database. If you don't want to have automatic schema synchronization and instead want migrations, just add a respective step to your deployment script. When you use the CLI for the model generation, you will gain the migration scripts for free as well. You can find the complete application code on Github . Feel free to add pull requests to it. Besides the use of Sequelize as model backend in your ExpressJS application, you might also want to turn your server into a restful API. If that is the case, check out the repository on Github","title":"Express"},{"location":"articles/express/#introduction","text":"This article explains the usage of Sequelize with the MVC framework Express.You will learn how and where to define models and how to load them when needed.","title":"Introduction"},{"location":"articles/express/#a-minimal-express-application","text":"In order to create a minimal express application, we need to install express first and scaffold a project. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express express-generator $ node_modules/.bin/express . -f $ npm install $ ./bin/www You should now be able to see a tiny welcome page on http://localhost:3000","title":"A minimal express application"},{"location":"articles/express/#adding-sequelize-to-the-application","text":"Now that we have the express application in place, we can start adding Sequelize to it. What we need for that are the following packages: sequelize, sequelize-cli, sqlite3. Please note, that for the sake of simplicity this tutorial will use SQLite. $ npm install --save sequelize@2.0.0-rc1 sequelize-cli sqlite3 This will install the respective packages and uses the upcoming major release of sequelize. We can now let the sequelize CLI initialize the project's directory: $ node_modules/.bin/sequelize init Running this command will create the folders config , migrations and models .","title":"Adding Sequelize to the application"},{"location":"articles/express/#implementing-a-todo-app","text":"As an example application we will create a very basic and simple todo tool, which allows the creation of users and the management of their tasks.","title":"Implementing a todo app"},{"location":"articles/express/#binwww","text":"In order to create a maintainable application, we will put all the database logic into the models folder. When the application gets fired up, sequelize will sync the models with the database and afterwards start the server. This way we don't clutter the application while making use of sequelize's features. $(function () { fromGithub(\"bin_www\") })","title":"bin/www"},{"location":"articles/express/#modelsindexjs","text":"This file has been generated with the sequelize CLI and collects all the models from the models directory and associates them if needed. $(function () { fromGithub(\"models_index\", '.js') })","title":"models/index.js"},{"location":"articles/express/#modelsuserjs","text":"All models of our application are located as separate files in the models folder. If you want to add a new model, just add it to this folder and everything will work automagically. Also you can use the sequelize CLI's sequelize model:create . Notice that the associate method receives a parameter models , which contains every declared model within the models directory. $(function () { fromGithub(\"models_user\", '.js') })","title":"models/user.js"},{"location":"articles/express/#modelstaskjs","text":"The other needed model is Task . It relates to the User . $(function () { fromGithub(\"models_task\", '.js') })","title":"models/task.js"},{"location":"articles/express/#routesindexjs","text":"The file routes/index.js contains the logic for a request against the main homepage. It loads the models module and uses it to load all the users and tasks from the database. $(function () { fromGithub(\"routes_index\", '.js') }) This will allow us to iterate over the users in the view file. We will skip the rest of the route files for this article.","title":"routes/index.js"},{"location":"articles/express/#viewsindexjade","text":"As we passed the users to the view and include the tasks for each user, we can access the data in the view's template file. Besides listing the users and tasks, there are also forms for creating new instances. $(function () { fromGithub(\"views_index\", '.jade') })","title":"views/index.jade"},{"location":"articles/express/#whats-next","text":"This article shows a basic approach of how to integrate Sequelize into an ExpressJS application. It allows the very easy management of models by adding new files to a specific folder. Starting the application will automatically sync the schema with the database. If you don't want to have automatic schema synchronization and instead want migrations, just add a respective step to your deployment script. When you use the CLI for the model generation, you will gain the migration scripts for free as well. You can find the complete application code on Github . Feel free to add pull requests to it. Besides the use of Sequelize as model backend in your ExpressJS application, you might also want to turn your server into a restful API. If that is the case, check out the repository on Github","title":"What's next?"},{"location":"articles/getting-started/","text":"Introduction This article explains the basic concepts of Sequelize. You will learn how to use the supported dialects, which types of database setup approaches are available, and how common scenarios can be achieved. Premise We will skip the very basic things and directly dive into the Sequelize related stuff. Here is a list of things that have to be in place before you can start: Node.JS at v0.8 or higher One of the supported databases / SQLite bindings The credentials for the respective database A basic understanding of how databases are working Optional but recommended: Coffee :) A word about promises Read about promises here . Setting up a project Now that your computer is prepared and your coffee sits next to your keyboard, we can finally get started. First things first: create a directory and initialize it with NPM! $ mkdir my-project $ cd my-project $ npm init NPM will ask you a couple of questions. Answer them or just hit the return key until it's satisfied. Once done, you can install Sequelize and the connector for your database of choice. $ npm install --save sequelize $ npm install --save pg # for postgres $ npm install --save mysql # for mysql $ npm install --save sqlite3 # for sqlite $ npm install --save mariasql # for mariasql Connecting to the database Open the created directory in your favorite text editor and add a new file called app.js with the following content: var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password', { dialect: \"mysql\", // or 'sqlite', 'postgres', 'mariadb', 'mssql' port: 3306 // or 5432 (for postgres) }); sequelize .authenticate() .then(function(err) { console.log('Connection has been established successfully.'); }) .catch(function (err) { console.log('Unable to connect to the database:', err); }); Managing the schema of your database Sequelize supports two types of schema management. You can either define so-called migrations, which are programmatically changing your database's structure, or you can let Sequelize create the tables for you. While the first possibility of using migrations takes more time to setup, it's most likely the way to go if you want to deploy your application on many different server environments. This is because migrations are consistently changing your database according to the current state of the schema. However, the automated way of using Sequelize's function sequelize.sync will probably be a good choice on your local machine or if you just want to quickly spin up a prototype. As this article is for beginners, we will skip migrations for now and take a closer look at the automated way. Defining a model In order to let Sequelize create schemas in the database, you need to describe what kind of data you want to store. This can be done with sequelize.define : var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }); This will define a user model that has a username and password. Furthermore, Sequelize will automatically add the columns id , createdAt and updatedAt . createdAt and updatedAt are controlled by Sequelize - when you create a model through Sequelize, createdAt will be set, and whenever you call updateAttributes / save on a model, updatedAt will be set. Synchronizing the schema As we want to store data in the database, we need to create a representation of the model: sequelize .sync({ force: true }) .then(function(err) { console.log('It worked!'); }, function (err) { console.log('An error occurred while creating the table:', err); }); Once executed, the database will contain a table Users (note the plural) with the columns: id - INT(11) username - VARCHAR(255) password - VARCHAR(255) createdAt - DATETIME updatedAt - DATETIME Please note, that { force: true } will drop the Users table and re-create it. Configuration You might not need the timestamps or you might not want the plural of the model's name as table name, right? Luckily there are configuration possibilities for that: var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { tableName: 'my_user_table', // this will define the table's name timestamps: false // this will deactivate the timestamp columns }) And just in case you want to customize the timestamp field names, you can do it like this: var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { updatedAt: 'last_update', createdAt: 'date_of_creation' }) Furthermore you can introduce a deletedAt timestamp so models are not actually deleted when you call destroy . Adding a deletedAt timestamp is called making the model 'paranoid': var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { paranoid: true }); Creating and persisting instances Sequelize allows the creation of instances in two ways. You can either build an object and save it afterwards. Or you can directly create an instance in the database: var user = User.build({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }) user.save().then(function() { /* ... */ }) This persists the instance in a two step way. If you want to do everything at once, use the following approach: User.create({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }).then(function(user) { /* ... */ }) Reading data from the database Every defined model has finder methods, with which you can read the database. Searching for a single item can be done with Model.find . Retrieval of multiple items needs the use of Model.findAll . User .find({ where: { username: 'john-doe' } }) .then(function(err, johnDoe) { if (!johnDoe) { console.log('No user with the username \"john-doe\" has been found.'); } else { console.log('Hello ' + johnDoe.username + '!'); console.log('All attributes of john:', johnDoe.get()); } }); Please note that, if no user with the name \"john-doe\" has been found, there won't be any errors. This is intended, as there are no internal or authentication errors. Defining associations A very common use case is the definition of associations between two or even more models. Once declared, Sequelize will know how to query the database to get or set associated data. Furthermore it will be able to automatically create the respective foreign key columns for you. Before taking a closer look at the code, it is critical to understand some details about the three different association types. One to one An association between one source and one target is called \"one to one\" or 1:1 association. It consists of a source that has one target and a target that belongs to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasOne(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! }); One to many An association between one source and many target is called \"one to many\" or 1:N association. It consists of a source that has many targets and some targets which belong to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasMany(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! }) Many to many An association between many sources and many targets is called \"many to many\" or N:M association. It consists of sources which have many targets and some targets which have many sources. Sequelize expects a junction table which contains a foreign key to the source table and a foreign key to the target table. A row in the table connects a source with a target. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasMany(Target) Target.hasMany(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // Sequelize will create a table SourcesTargets. }) Getting/Setting associations Defining associations is nice, but won't give you any advantage if you cannot read or set associations. Of course Sequelize will add respective functions to your models. Depending on the type of association you will find different methods: var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}); Source.hasOne(Target); Target.belongsTo(Source); sequelize.Promise.all([ Source.create({}), Target.create({}) ]).spread(function (source, target) { // Set the association return source.setTarget(target).return(source); }).then(function(source) { // Get the association return source.getTarget(); }).then(function(_target) { console.log(_target.get({ plain: true })) /* { id: 1, createdAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), updatedAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), SourceId: 1 } */ }); Clearing associations Assuming we already defined the models (as in the previous code example) and synced the schema with the database, we can clear the associations like this: source.setTarget(null).then(function() { return source.getTarget(); }).then(function(target) { console.log(target); }); Adding / removing associations For 1:N and N:M associations it makes sense to not only set the associations, but also to add or remove associations. Furthermore checking for an association can be handy. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}); Source.hasMany(Target); Target.belongsTo(Source); return sequelize.Promise.all([ Source.create({}), Target.create({}); Target.create({}), ]).bind({}).spread(function (source, target1, target2) { // Set the association this.source = source; this.target1 = target1; this.target2 = target2; return source.setTargets([target1, target2]); }).then(function() { // Get the association return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 // Remove an association return this.source.removeTarget(this.target1); }).then(function() { return source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 1 // Check for an association return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // false // Adding an association return this.source.addTarget(this.target1); }).then(function() { return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // true }); A combined example Now that you know the basics of Sequelize, you might want to see everything in a single program: var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password') , User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }); sequelize.sync({ force: true }).then(function() { return User.create({ username: 'john', password: '1111' }); }).then(function(user1) { return User.find({ username: 'john' }) }).then(function(user2) { console.log(user2.get()); // Get returns a JSON representation of the user }); What's next? As there are some more advanced features in Sequelize which are a bit inappropriate for this article, you can check the following resources for further advice: Migrations Data types Configuration of the model Validations Finders Associations","title":"Getting started"},{"location":"articles/getting-started/#introduction","text":"This article explains the basic concepts of Sequelize. You will learn how to use the supported dialects, which types of database setup approaches are available, and how common scenarios can be achieved.","title":"Introduction"},{"location":"articles/getting-started/#premise","text":"We will skip the very basic things and directly dive into the Sequelize related stuff. Here is a list of things that have to be in place before you can start: Node.JS at v0.8 or higher One of the supported databases / SQLite bindings The credentials for the respective database A basic understanding of how databases are working Optional but recommended: Coffee :)","title":"Premise"},{"location":"articles/getting-started/#a-word-about-promises","text":"Read about promises here .","title":"A word about promises"},{"location":"articles/getting-started/#setting-up-a-project","text":"Now that your computer is prepared and your coffee sits next to your keyboard, we can finally get started. First things first: create a directory and initialize it with NPM! $ mkdir my-project $ cd my-project $ npm init NPM will ask you a couple of questions. Answer them or just hit the return key until it's satisfied. Once done, you can install Sequelize and the connector for your database of choice. $ npm install --save sequelize $ npm install --save pg # for postgres $ npm install --save mysql # for mysql $ npm install --save sqlite3 # for sqlite $ npm install --save mariasql # for mariasql","title":"Setting up a project"},{"location":"articles/getting-started/#connecting-to-the-database","text":"Open the created directory in your favorite text editor and add a new file called app.js with the following content: var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password', { dialect: \"mysql\", // or 'sqlite', 'postgres', 'mariadb', 'mssql' port: 3306 // or 5432 (for postgres) }); sequelize .authenticate() .then(function(err) { console.log('Connection has been established successfully.'); }) .catch(function (err) { console.log('Unable to connect to the database:', err); });","title":"Connecting to the database"},{"location":"articles/getting-started/#managing-the-schema-of-your-database","text":"Sequelize supports two types of schema management. You can either define so-called migrations, which are programmatically changing your database's structure, or you can let Sequelize create the tables for you. While the first possibility of using migrations takes more time to setup, it's most likely the way to go if you want to deploy your application on many different server environments. This is because migrations are consistently changing your database according to the current state of the schema. However, the automated way of using Sequelize's function sequelize.sync will probably be a good choice on your local machine or if you just want to quickly spin up a prototype. As this article is for beginners, we will skip migrations for now and take a closer look at the automated way.","title":"Managing the schema of your database"},{"location":"articles/getting-started/#defining-a-model","text":"In order to let Sequelize create schemas in the database, you need to describe what kind of data you want to store. This can be done with sequelize.define : var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }); This will define a user model that has a username and password. Furthermore, Sequelize will automatically add the columns id , createdAt and updatedAt . createdAt and updatedAt are controlled by Sequelize - when you create a model through Sequelize, createdAt will be set, and whenever you call updateAttributes / save on a model, updatedAt will be set.","title":"Defining a model"},{"location":"articles/getting-started/#synchronizing-the-schema","text":"As we want to store data in the database, we need to create a representation of the model: sequelize .sync({ force: true }) .then(function(err) { console.log('It worked!'); }, function (err) { console.log('An error occurred while creating the table:', err); }); Once executed, the database will contain a table Users (note the plural) with the columns: id - INT(11) username - VARCHAR(255) password - VARCHAR(255) createdAt - DATETIME updatedAt - DATETIME Please note, that { force: true } will drop the Users table and re-create it.","title":"Synchronizing the schema"},{"location":"articles/getting-started/#configuration","text":"You might not need the timestamps or you might not want the plural of the model's name as table name, right? Luckily there are configuration possibilities for that: var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { tableName: 'my_user_table', // this will define the table's name timestamps: false // this will deactivate the timestamp columns }) And just in case you want to customize the timestamp field names, you can do it like this: var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { updatedAt: 'last_update', createdAt: 'date_of_creation' }) Furthermore you can introduce a deletedAt timestamp so models are not actually deleted when you call destroy . Adding a deletedAt timestamp is called making the model 'paranoid': var User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }, { paranoid: true });","title":"Configuration"},{"location":"articles/getting-started/#creating-and-persisting-instances","text":"Sequelize allows the creation of instances in two ways. You can either build an object and save it afterwards. Or you can directly create an instance in the database: var user = User.build({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }) user.save().then(function() { /* ... */ }) This persists the instance in a two step way. If you want to do everything at once, use the following approach: User.create({ username: 'john-doe', password: generatePasswordHash('i-am-so-great') }).then(function(user) { /* ... */ })","title":"Creating and persisting instances"},{"location":"articles/getting-started/#reading-data-from-the-database","text":"Every defined model has finder methods, with which you can read the database. Searching for a single item can be done with Model.find . Retrieval of multiple items needs the use of Model.findAll . User .find({ where: { username: 'john-doe' } }) .then(function(err, johnDoe) { if (!johnDoe) { console.log('No user with the username \"john-doe\" has been found.'); } else { console.log('Hello ' + johnDoe.username + '!'); console.log('All attributes of john:', johnDoe.get()); } }); Please note that, if no user with the name \"john-doe\" has been found, there won't be any errors. This is intended, as there are no internal or authentication errors.","title":"Reading data from the database"},{"location":"articles/getting-started/#defining-associations","text":"A very common use case is the definition of associations between two or even more models. Once declared, Sequelize will know how to query the database to get or set associated data. Furthermore it will be able to automatically create the respective foreign key columns for you. Before taking a closer look at the code, it is critical to understand some details about the three different association types.","title":"Defining associations"},{"location":"articles/getting-started/#one-to-one","text":"An association between one source and one target is called \"one to one\" or 1:1 association. It consists of a source that has one target and a target that belongs to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasOne(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! });","title":"One to one"},{"location":"articles/getting-started/#one-to-many","text":"An association between one source and many target is called \"one to many\" or 1:N association. It consists of a source that has many targets and some targets which belong to a source. Sequelize expects a foreign key in the target's schema. That means that there has to be an attribute respectively a column in the target's table. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasMany(Target) Target.belongsTo(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // instances of Target will have a column SourceId! })","title":"One to many"},{"location":"articles/getting-started/#many-to-many","text":"An association between many sources and many targets is called \"many to many\" or N:M association. It consists of sources which have many targets and some targets which have many sources. Sequelize expects a junction table which contains a foreign key to the source table and a foreign key to the target table. A row in the table connects a source with a target. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}) Source.hasMany(Target) Target.hasMany(Source) sequelize .sync({ force: true }) .then(function() { // Even if we didn't define any foreign key or something else, // Sequelize will create a table SourcesTargets. })","title":"Many to many"},{"location":"articles/getting-started/#gettingsetting-associations","text":"Defining associations is nice, but won't give you any advantage if you cannot read or set associations. Of course Sequelize will add respective functions to your models. Depending on the type of association you will find different methods: var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}); Source.hasOne(Target); Target.belongsTo(Source); sequelize.Promise.all([ Source.create({}), Target.create({}) ]).spread(function (source, target) { // Set the association return source.setTarget(target).return(source); }).then(function(source) { // Get the association return source.getTarget(); }).then(function(_target) { console.log(_target.get({ plain: true })) /* { id: 1, createdAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), updatedAt: Sun Dec 08 2013 11:46:42 GMT+0100 (CET), SourceId: 1 } */ });","title":"Getting/Setting associations"},{"location":"articles/getting-started/#clearing-associations","text":"Assuming we already defined the models (as in the previous code example) and synced the schema with the database, we can clear the associations like this: source.setTarget(null).then(function() { return source.getTarget(); }).then(function(target) { console.log(target); });","title":"Clearing associations"},{"location":"articles/getting-started/#adding-removing-associations","text":"For 1:N and N:M associations it makes sense to not only set the associations, but also to add or remove associations. Furthermore checking for an association can be handy. var Source = sequelize.define('source', {}) , Target = sequelize.define('target', {}); Source.hasMany(Target); Target.belongsTo(Source); return sequelize.Promise.all([ Source.create({}), Target.create({}); Target.create({}), ]).bind({}).spread(function (source, target1, target2) { // Set the association this.source = source; this.target1 = target1; this.target2 = target2; return source.setTargets([target1, target2]); }).then(function() { // Get the association return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 // Remove an association return this.source.removeTarget(this.target1); }).then(function() { return source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 1 // Check for an association return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // false // Adding an association return this.source.addTarget(this.target1); }).then(function() { return this.source.getTargets(); }).then(function(targets) { console.log(targets.length) // = 2 return this.source.hasTarget(this.target1); }).then(function(hasTarget) { console.log(hasTarget) // true });","title":"Adding / removing associations"},{"location":"articles/getting-started/#a-combined-example","text":"Now that you know the basics of Sequelize, you might want to see everything in a single program: var Sequelize = require('sequelize') , sequelize = new Sequelize('database_name', 'username', 'password') , User = sequelize.define('user', { username: Sequelize.STRING, password: Sequelize.STRING }); sequelize.sync({ force: true }).then(function() { return User.create({ username: 'john', password: '1111' }); }).then(function(user1) { return User.find({ username: 'john' }) }).then(function(user2) { console.log(user2.get()); // Get returns a JSON representation of the user });","title":"A combined example"},{"location":"articles/getting-started/#whats-next","text":"As there are some more advanced features in Sequelize which are a bit inappropriate for this article, you can check the following resources for further advice: Migrations Data types Configuration of the model Validations Finders Associations","title":"What's next?"},{"location":"articles/heroku/","text":"Introduction This section covers the use of Sequelize on Heroku. It will explain how to get started with Heroku and what is necessary to setup a proper environment. We will use MySQL on the development machine and PostgreSQL on the remote servers. Getting started with Heroku Before we can roll out any software on the Heroku cluster, we need to sign up and have to connect our development environment. Here are the most basic steps: Sign up for a Heroku account. Install the Heroku Toolbelt. This tool will let you create applications and is a handy way to configure them on the command line. Use the new binary to login. Run the following command on command line: heroku login And that's it. You should now be able to do things like heroku apps . This should list all applications you've currently created on the Heroku cluster. If you've just created a new account, this should show you an empty list. You can get further information about the registration process here . A minimal express application In order to create a minimal express application, we need to install express first. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ node app.js So now we have a default express application. If you point your browser to http://localhost:8080 , you will see a tiny page welcoming you. Next step: Deploy the application to Heroku. Deployment to Heroku First of all, we need to add the right version of Node.JS and NPM to the package.json . The file should look similar to this: { \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node app.js\" }, \"dependencies\": { \"express\": \"3.1.1\", \"jade\": \"*\" }, \"engines\": { \"node\": \"0.8.x\", \"npm\": \"1.1.x\" } } Now we can create a Heroku application and deploy to it: $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku open You should now see a browser with the same application as on your local machine. Spawning a database on Heroku In order to get a database on Heroku we can use their CLI. Just run the following command and take a closer look at it's output: $ heroku addons:add heroku-postgresql:dev This will result in something like this: Adding heroku-postgresql:dev on fast-dusk-7858... done, v5 (free) Attached as HEROKU_POSTGRESQL_BRONZE_URL Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore. Use `heroku addons:docs heroku-postgresql:dev` to view documentation. What we will need is the color (sounds strange right?) of the database. In this case we just created a bronze one. That means, that we will have an environment variable HEROKU_POSTGRESQL_BRONZE_URL containing the URI of the database. If you are interested in the URI, you can just run this command: $ heroku config:get HEROKU_POSTGRESQL_BRONZE_URL $ # => postgres://pfforbjhkrletg:aic5oO6Cran1g3hk6mJa5QqNZB@ec2-23-21-91-97.compute-1.amazonaws.com:5432/dek11b2j1g3mfb Adding Sequelize to the application The following commands will install sequelize , the needed PostgreSQL library as well as the MySQL bindings. Also we will create a folder models , that will contain the model definitions. $ npm install --save sequelize pg mysql $ mkdir models app.js In order to create a maintainable application, we will put all the database logic into the models folder. The application's main file will then just sync the models with the database and run the server. This way we don't clutter the application. var express = require('express') , routes = require('./routes') , user = require('./routes/user') , http = require('http') , path = require('path') , db = require('./models'); var app = express(); // all environments app.set('port', process.env.PORT || 3000); app.set('views', __dirname + '/views'); app.set('view engine', 'jade'); app.use(express.favicon()); app.use(express.logger('dev')); app.use(express.bodyParser()); app.use(express.methodOverride()); app.use(app.router); app.use(express.static(path.join(__dirname, 'public'))); // development only if ('development' === app.get('env')) { app.use(express.errorHandler()); } app.get('/', routes.index); app.get('/users', user.list); db.sequelize.sync().then(function() { http.createServer(app).listen(app.get('port'), function(){ console.log('Express server listening on port ' + app.get('port')); }); }); models/index.js The idea of this file is to configure a connection to the database and to collect all model definitions. Once everything is in place we will store the stuff in a singleton. This will make it possible to load the file whenever we need database access without running into issues with duplicated database access. This file will also differ between the local machine and the Heroku server. if (!global.hasOwnProperty('db')) { var Sequelize = require('sequelize') , sequelize = null if (process.env.HEROKU_POSTGRESQL_BRONZE_URL) { // the application is executed on Heroku ... use the postgres database sequelize = new Sequelize(process.env.HEROKU_POSTGRESQL_BRONZE_URL, { dialect: 'postgres', protocol: 'postgres', port: match[4], host: match[3], logging: true //false }) } else { // the application is executed on the local machine ... use mysql sequelize = new Sequelize('example-app-db', 'root', null) } global.db = { Sequelize: Sequelize, sequelize: sequelize, User: sequelize.import(__dirname + '/user') // add your other models here } /* Associations can be defined here. E.g. like this: global.db.User.hasMany(global.db.SomethingElse) */ } module.exports = global.db models/user.js All the other models of our application will be located as separate files in the models folder. We will use the import -method of Sequelize to load those files. module.exports = function(sequelize, DataTypes) { return sequelize.define(\"User\", { username: DataTypes.STRING }) } Running Migrations To run migrations on Heroku you must have the following entry in your config/config.json file: \"production\": { \"use_env_variable\": \"DATABASE_URL\" } Which also means you must make sure your Heroku environment has a promoted database. Then from the command line run $ heroku run bash $ sequelize -m tl;dr This article explains a straight-forward but maintainable approach for hosting an express application on Heroku. If you don't want to read all the stuff mentioned, just execute the following stuff and have fun. $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/459c923dd0a14841c932bb95ff3be8a8170bd563/package.json > package.json $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ npm install --save sequelize pg mysql $ mkdir models $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku addons:add heroku-postgresql:dev $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/6db41e130a8b901cd0843bf52390b7cb11db5f15/app.js > app.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/26c5a94d74db4a242464b02aa8e0ae4b3bac6880/models-index.js > models/index.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/3b37b0e5d459b2e4b3833a63a018b600a1001795/models-user.js > models/user.js $ clear $ # Now run the following command and change HEROKU_POSTGRESQL_BRONZE_URL in $ # the file \"models/index.js\" to its result: $ heroku config|grep HEROKU_POSTGRESQL|cut -d : -f 1 $ git add . $ git commit -m \"sequelize application\" $ git push heroku master $ heroku open","title":"Heroku"},{"location":"articles/heroku/#introduction","text":"This section covers the use of Sequelize on Heroku. It will explain how to get started with Heroku and what is necessary to setup a proper environment. We will use MySQL on the development machine and PostgreSQL on the remote servers.","title":"Introduction"},{"location":"articles/heroku/#getting-started-with-heroku","text":"Before we can roll out any software on the Heroku cluster, we need to sign up and have to connect our development environment. Here are the most basic steps: Sign up for a Heroku account. Install the Heroku Toolbelt. This tool will let you create applications and is a handy way to configure them on the command line. Use the new binary to login. Run the following command on command line: heroku login And that's it. You should now be able to do things like heroku apps . This should list all applications you've currently created on the Heroku cluster. If you've just created a new account, this should show you an empty list. You can get further information about the registration process here .","title":"Getting started with Heroku"},{"location":"articles/heroku/#a-minimal-express-application","text":"In order to create a minimal express application, we need to install express first. We can do this via the following commands: $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ node app.js So now we have a default express application. If you point your browser to http://localhost:8080 , you will see a tiny page welcoming you. Next step: Deploy the application to Heroku.","title":"A minimal express application"},{"location":"articles/heroku/#deployment-to-heroku","text":"First of all, we need to add the right version of Node.JS and NPM to the package.json . The file should look similar to this: { \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node app.js\" }, \"dependencies\": { \"express\": \"3.1.1\", \"jade\": \"*\" }, \"engines\": { \"node\": \"0.8.x\", \"npm\": \"1.1.x\" } } Now we can create a Heroku application and deploy to it: $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku open You should now see a browser with the same application as on your local machine.","title":"Deployment to Heroku"},{"location":"articles/heroku/#spawning-a-database-on-heroku","text":"In order to get a database on Heroku we can use their CLI. Just run the following command and take a closer look at it's output: $ heroku addons:add heroku-postgresql:dev This will result in something like this: Adding heroku-postgresql:dev on fast-dusk-7858... done, v5 (free) Attached as HEROKU_POSTGRESQL_BRONZE_URL Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore. Use `heroku addons:docs heroku-postgresql:dev` to view documentation. What we will need is the color (sounds strange right?) of the database. In this case we just created a bronze one. That means, that we will have an environment variable HEROKU_POSTGRESQL_BRONZE_URL containing the URI of the database. If you are interested in the URI, you can just run this command: $ heroku config:get HEROKU_POSTGRESQL_BRONZE_URL $ # => postgres://pfforbjhkrletg:aic5oO6Cran1g3hk6mJa5QqNZB@ec2-23-21-91-97.compute-1.amazonaws.com:5432/dek11b2j1g3mfb","title":"Spawning a database on Heroku"},{"location":"articles/heroku/#adding-sequelize-to-the-application","text":"The following commands will install sequelize , the needed PostgreSQL library as well as the MySQL bindings. Also we will create a folder models , that will contain the model definitions. $ npm install --save sequelize pg mysql $ mkdir models","title":"Adding Sequelize to the application"},{"location":"articles/heroku/#appjs","text":"In order to create a maintainable application, we will put all the database logic into the models folder. The application's main file will then just sync the models with the database and run the server. This way we don't clutter the application. var express = require('express') , routes = require('./routes') , user = require('./routes/user') , http = require('http') , path = require('path') , db = require('./models'); var app = express(); // all environments app.set('port', process.env.PORT || 3000); app.set('views', __dirname + '/views'); app.set('view engine', 'jade'); app.use(express.favicon()); app.use(express.logger('dev')); app.use(express.bodyParser()); app.use(express.methodOverride()); app.use(app.router); app.use(express.static(path.join(__dirname, 'public'))); // development only if ('development' === app.get('env')) { app.use(express.errorHandler()); } app.get('/', routes.index); app.get('/users', user.list); db.sequelize.sync().then(function() { http.createServer(app).listen(app.get('port'), function(){ console.log('Express server listening on port ' + app.get('port')); }); });","title":"app.js"},{"location":"articles/heroku/#modelsindexjs","text":"The idea of this file is to configure a connection to the database and to collect all model definitions. Once everything is in place we will store the stuff in a singleton. This will make it possible to load the file whenever we need database access without running into issues with duplicated database access. This file will also differ between the local machine and the Heroku server. if (!global.hasOwnProperty('db')) { var Sequelize = require('sequelize') , sequelize = null if (process.env.HEROKU_POSTGRESQL_BRONZE_URL) { // the application is executed on Heroku ... use the postgres database sequelize = new Sequelize(process.env.HEROKU_POSTGRESQL_BRONZE_URL, { dialect: 'postgres', protocol: 'postgres', port: match[4], host: match[3], logging: true //false }) } else { // the application is executed on the local machine ... use mysql sequelize = new Sequelize('example-app-db', 'root', null) } global.db = { Sequelize: Sequelize, sequelize: sequelize, User: sequelize.import(__dirname + '/user') // add your other models here } /* Associations can be defined here. E.g. like this: global.db.User.hasMany(global.db.SomethingElse) */ } module.exports = global.db","title":"models/index.js"},{"location":"articles/heroku/#modelsuserjs","text":"All the other models of our application will be located as separate files in the models folder. We will use the import -method of Sequelize to load those files. module.exports = function(sequelize, DataTypes) { return sequelize.define(\"User\", { username: DataTypes.STRING }) }","title":"models/user.js"},{"location":"articles/heroku/#running-migrations","text":"To run migrations on Heroku you must have the following entry in your config/config.json file: \"production\": { \"use_env_variable\": \"DATABASE_URL\" } Which also means you must make sure your Heroku environment has a promoted database. Then from the command line run $ heroku run bash $ sequelize -m","title":"Running Migrations"},{"location":"articles/heroku/#tldr","text":"This article explains a straight-forward but maintainable approach for hosting an express application on Heroku. If you don't want to read all the stuff mentioned, just execute the following stuff and have fun. $ mkdir example-app $ cd example-app $ npm install express $ node_modules/.bin/express . -f $ npm install $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/459c923dd0a14841c932bb95ff3be8a8170bd563/package.json > package.json $ echo \"web: node app.js\" > Procfile $ echo \"node_modules\" > .gitignore $ npm install --save sequelize pg mysql $ mkdir models $ git init $ git add . $ git commit -m \"initial commit\" $ heroku create $ git push heroku master $ heroku ps:scale web=1 $ heroku addons:add heroku-postgresql:dev $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/6db41e130a8b901cd0843bf52390b7cb11db5f15/app.js > app.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/26c5a94d74db4a242464b02aa8e0ae4b3bac6880/models-index.js > models/index.js $ curl -s https://gist.github.com/sdepold/ced7d2a4a847f38901ef/raw/3b37b0e5d459b2e4b3833a63a018b600a1001795/models-user.js > models/user.js $ clear $ # Now run the following command and change HEROKU_POSTGRESQL_BRONZE_URL in $ # the file \"models/index.js\" to its result: $ heroku config|grep HEROKU_POSTGRESQL|cut -d : -f 1 $ git add . $ git commit -m \"sequelize application\" $ git push heroku master $ heroku open","title":"tl;dr"},{"location":"docs/associations/","text":"This section describes the various association types in sequelize. When calling a method such as User.hasOne(Project) , we say that the User model (the model that the function is being invoked on) is the source and the Project model (the model being passed as an argument) is the target . One-To-One associations One-To-One associations are associations between exactly two models connected by a single foreign key. BelongsTo BelongsTo associations are associations where the foreign key for the one-to-one relation exists on the source model . A simple example would be a Player being part of a Team with the foreign key on the player. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Player.belongsTo(Team); // Will add a teamId attribute to Player to hold the primary key value for Team Foreign keys By default the foreign key for a belongsTo relation will be generated from the target model name and the target primary key name. The default casing is camelCase however if the source model is configured with underscored: true the foreignKey will be snake_case . var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company); // Will add companyId to user var User = this.sequelize.define('user', {/* attributes */}, {underscored: true}) , Company = this.sequelize.define('company', { uuid: { type: Sequelize.UUID, primaryKey: true } }); User.belongsTo(Company); // Will add company_uuid to user In cases where as has been defined it will be used in place of the target model name. var User = this.sequelize.define('user', {/* attributes */}) , UserRole = this.sequelize.define('userRole', {/* attributes */}); User.belongsTo(UserRole, {as: 'role'}); // Adds roleId to user rather than userRoleId In all cases the default foreign key can be overwritten with the foreignKey option. When the foreign key option is used, Sequelize will use it as-is: var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_company'}); // Adds fk_company to User Target keys The target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the targetKey option. var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_companyname', targetKey: 'name'}); // Adds fk_companyname to User HasOne HasOne associations are associations where the foreign key for the one-to-one relation exists on the target model . var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // One-way associations Project.hasOne(User) /* In this example hasOne will add an attribute projectId to the User model! Furthermore, Project.prototype will gain the methods getUser and setUser according to the first parameter passed to define. If you have underscore style enabled, the added attribute will be project_id instead of projectId. The foreign key will be placed on the users table. You can also define the foreign key, e.g. if you already have an existing database and want to work on it: */ Project.hasOne(User, { foreignKey: 'initiator_id' }) /* Because Sequelize will use the model's name (first parameter of define) for the accessor methods, it is also possible to pass a special option to hasOne: */ Project.hasOne(User, { as: 'Initiator' }) // Now you will get Project#getInitiator and Project#setInitiator // Or let's define some self references var Person = sequelize.define('person', { /* ... */}) Person.hasOne(Person, {as: 'Father'}) // this will add the attribute FatherId to Person // also possible: Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) // this will add the attribute DadId to Person // In both cases you will be able to do: Person#setFather Person#getFather // If you need to join a table twice you can double join the same table Team.hasOne(Game, {as: 'HomeTeam', foreignKey : 'homeTeamId'}); Team.hasOne(Game, {as: 'AwayTeam', foreignKey : 'awayTeamId'}); Game.belongsTo(Team); Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target. Difference between HasOne and BelongsTo In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example. Suppose we have two tables to link Player and Team . Lets define their models. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); When we link two model in Sequelize we can refer them as pairs of source and target models. Like this Having Player as the source and Team as the target Player.belongsTo(Team); //Or Player.hasOne(Team); Having Team as the source and Player as the target Team.belongsTo(Player); //Or Team.hasOne(Player); HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in target model whereas BelongsTo inserts the association key in the source model. Here is an example demonstrating use cases of BelongsTo and HasOne. var Player = this.sequelize.define('player', {/* attributes */}) , Coach = this.sequelize.define('coach', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Suppose our Player model has information about its team as teamId column. Information about each Team's Coach is stored in the Team model as coachId column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time. When information about association is present in source model we can use belongsTo . In this case Player is suitable for belongsTo because it has teamId column. Player.belongsTo(Team) // `teamId` will be added on Player / Source model When information about association is present in target model we can use hasOne . In this case Coach is suitable for hasOne because Team model store information about its Coach as coachId field. Coach.hasOne(Team) // `coachId` will be added on Team / Target model One-To-Many associations One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source. var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // OK. Now things get more complicated (not really visible to the user :)). // First let's define a hasMany association Project.hasMany(User, {as: 'Workers'}) This will add the attribute projectId or project_id to User. Instances of Project will get the accessors getWorkers and setWorkers. We could just leave it the way it is and let it be a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section: Sometimes you may need to associate records on different columns, you may use sourceKey option: var City = sequelize.define('city', { countryCode: Sequelize.STRING }); var Country = sequelize.define('country', { isoCode: Sequelize.STRING }); // Here we can connect countries and cities base on country code Country.hasMany(City, {foreignKey: 'countryCode', sourceKey: 'isoCode'}); City.belongsTo(Country, {foreignKey: 'countryCode', targetKey: 'isoCode'}); Belongs-To-Many associations Belongs-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources. Project.belongsToMany(User, {through: 'UserProject'}); User.belongsToMany(Project, {through: 'UserProject'}); This will create a new model called UserProject with the equivalent foreign keys projectId and userId . Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project). Defining through is required. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups. This will add methods getUsers , setUsers , addUser , addUsers to Project , and getProjects , setProjects , addProject , and addProjects to User . Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias ( as ) option. We will also manually define the foreign keys to use: User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId' }) Project.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' }) foreignKey will allow you to set source model key in the through relation. otherKey will allow you to set target model key in the through relation. User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'}) Of course you can also define self references with belongsToMany: Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' }) // This will create the table PersonChildren which stores the ids of the objects. If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one: User = sequelize.define('user', {}) Project = sequelize.define('project', {}) UserProjects = sequelize.define('userProjects', { status: DataTypes.STRING }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) To add a new project to a user and set its status, you pass an extra object to the setter, which contains the attributes for the join table user.addProject(project, { status: 'started' }) By default the code above will add projectId and userId to the UserProjects table, and remove any previously defined primary key attribute - the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the UserProjects model you can add it manually. UserProjects = sequelize.define('userProjects', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, status: DataTypes.STRING }) With Belongs-To-Many you can query based on through relation and select specific attributes. For example using findAll with through User.findAll({ include: [{ model: Project, through: { attributes: ['createdAt', 'startedAt', 'finishedAt'], where: {completed: true} } }] }); Scopes This section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see Scopes . Association scopes allow you to place a scope (a set of default attributes for get and create ) on the association. Scopes can be placed both on the associated model (the target of the association), and on the through table for n:m relations. 1:m Assume we have tables Comment, Post and Image. A comment can be associated to either an image or a post via commentable_id and commentable - we say that Post and Image are Commentable this.Comment = this.sequelize.define('comment', { title: Sequelize.STRING, commentable: Sequelize.STRING, commentable_id: Sequelize.INTEGER }, { instanceMethods: { getItem: function() { return this['get' + this.get('commentable').substr(0, 1).toUpperCase() + this.get('commentable').substr(1)](); } } }); this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'post' } }); this.Comment.belongsTo(this.Post, { foreignKey: 'commentable_id', constraints: false, as: 'post' }); this.Image.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'image' } }); this.Comment.belongsTo(this.Image, { foreignKey: 'commentable_id', constraints: false, as: 'image' }); constraints: false, disables references constraints - since the commentable_id column references several tables, we cannot add a REFERENCES constraint to it. Note that the Image -> Comment and Post -> Comment relations define a scope, commentable: 'image' and commentable: 'post' respectively. This scope is automatically applied when using the association functions: image.getComments() SELECT * FROM comments WHERE commentable_id = 42 AND commentable = 'image'; image.createComment({ title: 'Awesome!' }) INSERT INTO comments (title, commentable_id, commentable) VALUES ('Awesome!', 42, 'image'); image.addComment(comment); UPDATE comments SET commentable_id = 42, commentable = 'image' The getItem utility function on Comment completes the picture - it simply converts the commentable string into a call to either getImage or getPost , providing an abstraction over whether a comment belongs to a post or an image. n:m Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items. For brevity, the example only shows a Post model, but in reality Tag would be related to several other models. ItemTag = sequelize.define('item_tag', { tag_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable' }, taggable: { type: DataTypes.STRING, unique: 'item_tag_taggable' }, taggable_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable', references: null } }); Tag = sequelize.define('tag', { name: DataTypes.STRING }); Post.belongsToMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, foreignKey: 'taggable_id', constraints: false }); Tag.belongsToMany(Post, { through: { model: ItemTag, unique: false }, foreignKey: 'tag_id' }); Notice that the scoped column ( taggable ) is now on the through model ( ItemTag ). We could also define a more restrictive association, for example to get all pending tags for a post by applying a scope of both the through model ( ItemTag ) and the target model ( Tag ): Post.hasMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, scope: { status: 'pending' }, as: 'pendingTags', foreignKey: 'taggable_id', constraints: false }); Post.getPendingTags(); SELECT `tag`.* INNER JOIN `item_tags` AS `item_tag` ON `tag`.`id` = `item_tag`.`tagId` AND `item_tag`.`taggable_id` = 42 AND `item_tag`.`taggable` = 'post' WHERE (`tag`.`status` = 'pending'); constraints: false disables references constraints on the taggable_id column. Because the column is polymorphic, we cannot say that it REFERENCES a specific table. Naming strategy By default sequelize will use the model name (the name passed to sequelize.define ) to figure out the name of the model when used in associations. For example, a model named user will add the functions get/set/add User to instances of the associated model, and a property named .user in eager loading, while a model named User will add the same functions, but a property named .User (notice the upper case U) in eager loading. As we've already seen, you can alias models in associations using as . In single associations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the inflection library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias: User.belongsToMany(Project, { as: { singular: 'task', plural: 'tasks' }}) // Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes. If you know that a model will always use the same alias in associations, you can provide it when creating the model var Project = sequelize.define('project', attributes, { name: { singular: 'task', plural: 'tasks', } }) User.belongsToMany(Project); This will add the functions add/set/get Tasks to user instances. Remember, that using as to change the name of the association will also change the name of the foreign key. When using as , it is safest to also specify the foreign key. Invoice.belongsTo(Subscription) Subscription.hasMany(Invoice) Without as , this adds subscriptionId as expected. However, if you were to say Invoice.belongsTo(Subscription, { as: 'TheSubscription' }) , you will have both subscriptionId and theSubscriptionId , because sequelize is not smart enough to figure that the calls are two sides of the same relation. 'foreignKey' fixes this problem; Invoice.belongsTo(Subscription, , { as: 'TheSubscription', foreignKey: 'subscription_id' }) Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' ) Associating objects Because Sequelize is doing a lot of magic, you have to call Sequelize.sync after setting the associations! Doing so will allow you the following: Project.belongsToMany(Task) Task.belongsToMany(Project) Project.create()... Task.create()... Task.create()... // save them... and then: project.setTasks([task1, task2]).then(function() { // saved! }) // ok, now they are saved... how do I get them later on? project.getTasks().then(function(associatedTasks) { // associatedTasks is an array of tasks }) // You can also pass filters to the getter method. // They are equal to the options you can pass to a usual finder method. project.getTasks({ where: 'id > 10' }).then(function(tasks) { // tasks with an id greater than 10 :) }) // You can also only retrieve certain fields of a associated object. project.getTasks({attributes: ['title']}).then(function(tasks) { // retrieve tasks with the attributes \"title\" and \"id\" }) To remove created associations you can just call the set method without a specific id: // remove the association with task1 project.setTasks([task2]).then(function(associatedTasks) { // you will get task2 only }) // remove 'em all project.setTasks([]).then(function(associatedTasks) { // you will get an empty array }) // or remove 'em more directly project.removeTask(task1).then(function() { // it's gone }) // and add 'em again project.addTask(task1).then(function() { // it's back again }) You can of course also do it vice versa: // project is associated with task1 and task2 task2.setProject(null).then(function() { // and it's gone }) For hasOne/belongsTo its basically the same: Task.hasOne(User, {as: \"Author\"}) Task#setAuthor(anAuthor) Adding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter): // Either by adding a property with the name of the join table model to the object, before creating the association project.UserProjects = { status: 'active' } u.addProject(project) // Or by providing a second argument when adding the association, containing the data that should go in the join table u.addProject(project, { status: 'active' }) // When associating multiple objects, you can combine the two options above. In this case the second argument // will be treated as a defaults object, that will be used if no data is provided project1.UserProjects = { status: 'inactive' } u.setProjects([project1, project2], { status: 'active' }) // The code above will record inactive for project one, and active for project two in the join table When getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance: u.getProjects().then(function(projects) { var project = projects[0] if (project.UserProjects.status === 'active') { // .. do magic // since this is a real DAO instance, you can save it directly after you are done doing magic return project.UserProjects.save() } }) If you only need some of the attributes from the join table, you can provide an array with the attributes you want: // This will select only name from the Projects table, and only status from the UserProjects table user.getProjects({ attributes: ['name'], joinTableAttributes: ['status']}) Check associations You can also check if an object is already associated with another one (N:M only). Here is how you'd do it: // check if an object is one of associated ones: Project.create({ /* */ }).then(function(project) { return User.create({ /* */ }).then(function(user) { return project.hasUser(user).then(function(result) { // result would be false return project.addUser(user).then(function() { return project.hasUser(user).then(function(result) { // result would be true }) }) }) }) }) // check if all associated objects are as expected: // let's assume we have already a project and two users project.setUsers([user1, user2]).then(function() { return project.hasUsers([user1]); }).then(function(result) { // result would be false return project.hasUsers([user1, user2]); }).then(function(result) { // result would be true }) Foreign Keys When you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below: var Task = this.sequelize.define('task', { title: Sequelize.STRING }) , User = this.sequelize.define('user', { username: Sequelize.STRING }) User.hasMany(Task) Task.belongsTo(User) Will generate the following SQL: CREATE TABLE IF NOT EXISTS `User` ( `id` INTEGER PRIMARY KEY, `username` VARCHAR(255) ); CREATE TABLE IF NOT EXISTS `Task` ( `id` INTEGER PRIMARY KEY, `title` VARCHAR(255), `user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); The relation between task and user injects the user_id foreign key on tasks, and marks it as a reference to the User table. By default user_id will be set to NULL if the referenced user is deleted, and updated if the id of the user id updated. These options can be overridden by passing onUpdate and onDelete options to the association calls. The validation options are RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL . For 1:1 and 1:m associations the default option is SET NULL for deletion, and CASCADE for updates. For n:m, the default for both is CASCADE . This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated. Adding constraints between tables means that tables must be created in the database in a certain order, when using sequelize.sync . If Task has a reference to User, the User table must be created before the Task table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has an reference to it's current version. var Document = this.sequelize.define('document', { author: Sequelize.STRING }) , Version = this.sequelize.define('version', { timestamp: Sequelize.DATE }) Document.hasMany(Version) // This adds document_id to version Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id'}) // This adds current_version_id to document However, the code above will result in the following error: Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document . In order to alleviate that, we can pass constraints: false to one of the associations: Document.hasMany(Version) Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false}) Which will allow us to sync the tables correctly: CREATE TABLE IF NOT EXISTS `Document` ( `id` INTEGER PRIMARY KEY, `author` VARCHAR(255), `current_version_id` INTEGER ); CREATE TABLE IF NOT EXISTS `Version` ( `id` INTEGER PRIMARY KEY, `timestamp` DATETIME, `document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); Enforcing a foreign key reference without constraints Some times you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them. var Series, Trainer, Video // Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series) Series = sequelize.define('series', { title: DataTypes.STRING, sub_title: DataTypes.STRING, description: DataTypes.TEXT, // Set FK relationship (hasMany) with `Trainer` trainer_id: { type: DataTypes.INTEGER, references: { model: \"trainers\", key: \"id\" } } }) Trainer = sequelize.define('trainer', { first_name: DataTypes.STRING, last_name: DataTypes.STRING }); // Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)... Video = sequelize.define('video', { title: DataTypes.STRING, sequence: DataTypes.INTEGER, description: DataTypes.TEXT, // set relationship (hasOne) with `Series` series_id: { type: DataTypes.INTEGER, references: { model: Series, // Can be both a string representing the table name, or a reference to the model key: \"id\" } } }); Series.hasOne(Video); Trainer.hasMany(Series); Creating with associations An instance can be created with nested association in one step, provided all elements are new. Creating elements of a \"BelongsTo\" or \"HasOne\" association Consider the following models: var Product = this.sequelize.define('product', { title: Sequelize.STRING }); var User = this.sequelize.define('user', { first_name: Sequelize.STRING, last_name: Sequelize.STRING }); Product.belongsTo(User); // Also works for `hasOne` A new Product and User can be created in one step in the following way: return Product.create({ title: 'Chair', user: { first_name: 'Mick', last_name: 'Broadstone' } }, { include: [ User ] }); Creating elements of a \"BelongsTo\" association with an alias The previous example can be extended to support an association alias. var Creator = Product.belongsTo(User, {as: 'creator'}); return Product.create({ title: 'Chair', creator: { first_name: 'Matt', last_name: 'Hansen' } }, { include: [ Creator ] }); Creating elements of a \"HasMany\" or \"BelongsToMany\" association Let's introduce the ability to associate a project with many tags. Setting up the models could look like: var Tag = this.sequelize.define('tag', { name: Sequelize.STRING }); Product.hasMany(Tag); // Also works for `belongsToMany`. Now we can create a project with multiple tags in the following way: Product.create({ id: 1, title: 'Chair', tags: [ { name: 'Alpha'}, { name: 'Beta'} ] }, { include: [ Tag ] }) And, we can modify this example to support an alias as well: var Categories = Product.hasMany(Tag, {as: 'categories'}); Product.create({ id: 1, title: 'Chair', categories: [ {id: 1, name: 'Alpha'}, {id: 2, name: 'Beta'} ] }, { include: [{ model: Categories, as: 'categories' }] })","title":"Relations / Associations"},{"location":"docs/associations/#one-to-one-associations","text":"One-To-One associations are associations between exactly two models connected by a single foreign key.","title":"One-To-One associations"},{"location":"docs/associations/#belongsto","text":"BelongsTo associations are associations where the foreign key for the one-to-one relation exists on the source model . A simple example would be a Player being part of a Team with the foreign key on the player. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Player.belongsTo(Team); // Will add a teamId attribute to Player to hold the primary key value for Team","title":"BelongsTo"},{"location":"docs/associations/#foreign-keys","text":"By default the foreign key for a belongsTo relation will be generated from the target model name and the target primary key name. The default casing is camelCase however if the source model is configured with underscored: true the foreignKey will be snake_case . var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company); // Will add companyId to user var User = this.sequelize.define('user', {/* attributes */}, {underscored: true}) , Company = this.sequelize.define('company', { uuid: { type: Sequelize.UUID, primaryKey: true } }); User.belongsTo(Company); // Will add company_uuid to user In cases where as has been defined it will be used in place of the target model name. var User = this.sequelize.define('user', {/* attributes */}) , UserRole = this.sequelize.define('userRole', {/* attributes */}); User.belongsTo(UserRole, {as: 'role'}); // Adds roleId to user rather than userRoleId In all cases the default foreign key can be overwritten with the foreignKey option. When the foreign key option is used, Sequelize will use it as-is: var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_company'}); // Adds fk_company to User","title":"Foreign keys"},{"location":"docs/associations/#target-keys","text":"The target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the targetKey option. var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_companyname', targetKey: 'name'}); // Adds fk_companyname to User","title":"Target keys"},{"location":"docs/associations/#hasone","text":"HasOne associations are associations where the foreign key for the one-to-one relation exists on the target model . var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // One-way associations Project.hasOne(User) /* In this example hasOne will add an attribute projectId to the User model! Furthermore, Project.prototype will gain the methods getUser and setUser according to the first parameter passed to define. If you have underscore style enabled, the added attribute will be project_id instead of projectId. The foreign key will be placed on the users table. You can also define the foreign key, e.g. if you already have an existing database and want to work on it: */ Project.hasOne(User, { foreignKey: 'initiator_id' }) /* Because Sequelize will use the model's name (first parameter of define) for the accessor methods, it is also possible to pass a special option to hasOne: */ Project.hasOne(User, { as: 'Initiator' }) // Now you will get Project#getInitiator and Project#setInitiator // Or let's define some self references var Person = sequelize.define('person', { /* ... */}) Person.hasOne(Person, {as: 'Father'}) // this will add the attribute FatherId to Person // also possible: Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) // this will add the attribute DadId to Person // In both cases you will be able to do: Person#setFather Person#getFather // If you need to join a table twice you can double join the same table Team.hasOne(Game, {as: 'HomeTeam', foreignKey : 'homeTeamId'}); Team.hasOne(Game, {as: 'AwayTeam', foreignKey : 'awayTeamId'}); Game.belongsTo(Team); Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target.","title":"HasOne"},{"location":"docs/associations/#difference-between-hasone-and-belongsto","text":"In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example. Suppose we have two tables to link Player and Team . Lets define their models. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); When we link two model in Sequelize we can refer them as pairs of source and target models. Like this Having Player as the source and Team as the target Player.belongsTo(Team); //Or Player.hasOne(Team); Having Team as the source and Player as the target Team.belongsTo(Player); //Or Team.hasOne(Player); HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in target model whereas BelongsTo inserts the association key in the source model. Here is an example demonstrating use cases of BelongsTo and HasOne. var Player = this.sequelize.define('player', {/* attributes */}) , Coach = this.sequelize.define('coach', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Suppose our Player model has information about its team as teamId column. Information about each Team's Coach is stored in the Team model as coachId column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time. When information about association is present in source model we can use belongsTo . In this case Player is suitable for belongsTo because it has teamId column. Player.belongsTo(Team) // `teamId` will be added on Player / Source model When information about association is present in target model we can use hasOne . In this case Coach is suitable for hasOne because Team model store information about its Coach as coachId field. Coach.hasOne(Team) // `coachId` will be added on Team / Target model","title":"Difference between HasOne and BelongsTo"},{"location":"docs/associations/#one-to-many-associations","text":"One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source. var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // OK. Now things get more complicated (not really visible to the user :)). // First let's define a hasMany association Project.hasMany(User, {as: 'Workers'}) This will add the attribute projectId or project_id to User. Instances of Project will get the accessors getWorkers and setWorkers. We could just leave it the way it is and let it be a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section: Sometimes you may need to associate records on different columns, you may use sourceKey option: var City = sequelize.define('city', { countryCode: Sequelize.STRING }); var Country = sequelize.define('country', { isoCode: Sequelize.STRING }); // Here we can connect countries and cities base on country code Country.hasMany(City, {foreignKey: 'countryCode', sourceKey: 'isoCode'}); City.belongsTo(Country, {foreignKey: 'countryCode', targetKey: 'isoCode'});","title":"One-To-Many associations"},{"location":"docs/associations/#belongs-to-many-associations","text":"Belongs-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources. Project.belongsToMany(User, {through: 'UserProject'}); User.belongsToMany(Project, {through: 'UserProject'}); This will create a new model called UserProject with the equivalent foreign keys projectId and userId . Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project). Defining through is required. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups. This will add methods getUsers , setUsers , addUser , addUsers to Project , and getProjects , setProjects , addProject , and addProjects to User . Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias ( as ) option. We will also manually define the foreign keys to use: User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId' }) Project.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' }) foreignKey will allow you to set source model key in the through relation. otherKey will allow you to set target model key in the through relation. User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'}) Of course you can also define self references with belongsToMany: Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' }) // This will create the table PersonChildren which stores the ids of the objects. If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one: User = sequelize.define('user', {}) Project = sequelize.define('project', {}) UserProjects = sequelize.define('userProjects', { status: DataTypes.STRING }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) To add a new project to a user and set its status, you pass an extra object to the setter, which contains the attributes for the join table user.addProject(project, { status: 'started' }) By default the code above will add projectId and userId to the UserProjects table, and remove any previously defined primary key attribute - the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the UserProjects model you can add it manually. UserProjects = sequelize.define('userProjects', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, status: DataTypes.STRING }) With Belongs-To-Many you can query based on through relation and select specific attributes. For example using findAll with through User.findAll({ include: [{ model: Project, through: { attributes: ['createdAt', 'startedAt', 'finishedAt'], where: {completed: true} } }] });","title":"Belongs-To-Many associations"},{"location":"docs/associations/#scopes","text":"This section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see Scopes . Association scopes allow you to place a scope (a set of default attributes for get and create ) on the association. Scopes can be placed both on the associated model (the target of the association), and on the through table for n:m relations.","title":"Scopes"},{"location":"docs/associations/#1m","text":"Assume we have tables Comment, Post and Image. A comment can be associated to either an image or a post via commentable_id and commentable - we say that Post and Image are Commentable this.Comment = this.sequelize.define('comment', { title: Sequelize.STRING, commentable: Sequelize.STRING, commentable_id: Sequelize.INTEGER }, { instanceMethods: { getItem: function() { return this['get' + this.get('commentable').substr(0, 1).toUpperCase() + this.get('commentable').substr(1)](); } } }); this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'post' } }); this.Comment.belongsTo(this.Post, { foreignKey: 'commentable_id', constraints: false, as: 'post' }); this.Image.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'image' } }); this.Comment.belongsTo(this.Image, { foreignKey: 'commentable_id', constraints: false, as: 'image' }); constraints: false, disables references constraints - since the commentable_id column references several tables, we cannot add a REFERENCES constraint to it. Note that the Image -> Comment and Post -> Comment relations define a scope, commentable: 'image' and commentable: 'post' respectively. This scope is automatically applied when using the association functions: image.getComments() SELECT * FROM comments WHERE commentable_id = 42 AND commentable = 'image'; image.createComment({ title: 'Awesome!' }) INSERT INTO comments (title, commentable_id, commentable) VALUES ('Awesome!', 42, 'image'); image.addComment(comment); UPDATE comments SET commentable_id = 42, commentable = 'image' The getItem utility function on Comment completes the picture - it simply converts the commentable string into a call to either getImage or getPost , providing an abstraction over whether a comment belongs to a post or an image.","title":"1:m"},{"location":"docs/associations/#nm","text":"Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items. For brevity, the example only shows a Post model, but in reality Tag would be related to several other models. ItemTag = sequelize.define('item_tag', { tag_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable' }, taggable: { type: DataTypes.STRING, unique: 'item_tag_taggable' }, taggable_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable', references: null } }); Tag = sequelize.define('tag', { name: DataTypes.STRING }); Post.belongsToMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, foreignKey: 'taggable_id', constraints: false }); Tag.belongsToMany(Post, { through: { model: ItemTag, unique: false }, foreignKey: 'tag_id' }); Notice that the scoped column ( taggable ) is now on the through model ( ItemTag ). We could also define a more restrictive association, for example to get all pending tags for a post by applying a scope of both the through model ( ItemTag ) and the target model ( Tag ): Post.hasMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, scope: { status: 'pending' }, as: 'pendingTags', foreignKey: 'taggable_id', constraints: false }); Post.getPendingTags(); SELECT `tag`.* INNER JOIN `item_tags` AS `item_tag` ON `tag`.`id` = `item_tag`.`tagId` AND `item_tag`.`taggable_id` = 42 AND `item_tag`.`taggable` = 'post' WHERE (`tag`.`status` = 'pending'); constraints: false disables references constraints on the taggable_id column. Because the column is polymorphic, we cannot say that it REFERENCES a specific table.","title":"n:m"},{"location":"docs/associations/#naming-strategy","text":"By default sequelize will use the model name (the name passed to sequelize.define ) to figure out the name of the model when used in associations. For example, a model named user will add the functions get/set/add User to instances of the associated model, and a property named .user in eager loading, while a model named User will add the same functions, but a property named .User (notice the upper case U) in eager loading. As we've already seen, you can alias models in associations using as . In single associations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the inflection library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias: User.belongsToMany(Project, { as: { singular: 'task', plural: 'tasks' }}) // Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes. If you know that a model will always use the same alias in associations, you can provide it when creating the model var Project = sequelize.define('project', attributes, { name: { singular: 'task', plural: 'tasks', } }) User.belongsToMany(Project); This will add the functions add/set/get Tasks to user instances. Remember, that using as to change the name of the association will also change the name of the foreign key. When using as , it is safest to also specify the foreign key. Invoice.belongsTo(Subscription) Subscription.hasMany(Invoice) Without as , this adds subscriptionId as expected. However, if you were to say Invoice.belongsTo(Subscription, { as: 'TheSubscription' }) , you will have both subscriptionId and theSubscriptionId , because sequelize is not smart enough to figure that the calls are two sides of the same relation. 'foreignKey' fixes this problem; Invoice.belongsTo(Subscription, , { as: 'TheSubscription', foreignKey: 'subscription_id' }) Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' )","title":"Naming strategy"},{"location":"docs/associations/#associating-objects","text":"Because Sequelize is doing a lot of magic, you have to call Sequelize.sync after setting the associations! Doing so will allow you the following: Project.belongsToMany(Task) Task.belongsToMany(Project) Project.create()... Task.create()... Task.create()... // save them... and then: project.setTasks([task1, task2]).then(function() { // saved! }) // ok, now they are saved... how do I get them later on? project.getTasks().then(function(associatedTasks) { // associatedTasks is an array of tasks }) // You can also pass filters to the getter method. // They are equal to the options you can pass to a usual finder method. project.getTasks({ where: 'id > 10' }).then(function(tasks) { // tasks with an id greater than 10 :) }) // You can also only retrieve certain fields of a associated object. project.getTasks({attributes: ['title']}).then(function(tasks) { // retrieve tasks with the attributes \"title\" and \"id\" }) To remove created associations you can just call the set method without a specific id: // remove the association with task1 project.setTasks([task2]).then(function(associatedTasks) { // you will get task2 only }) // remove 'em all project.setTasks([]).then(function(associatedTasks) { // you will get an empty array }) // or remove 'em more directly project.removeTask(task1).then(function() { // it's gone }) // and add 'em again project.addTask(task1).then(function() { // it's back again }) You can of course also do it vice versa: // project is associated with task1 and task2 task2.setProject(null).then(function() { // and it's gone }) For hasOne/belongsTo its basically the same: Task.hasOne(User, {as: \"Author\"}) Task#setAuthor(anAuthor) Adding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter): // Either by adding a property with the name of the join table model to the object, before creating the association project.UserProjects = { status: 'active' } u.addProject(project) // Or by providing a second argument when adding the association, containing the data that should go in the join table u.addProject(project, { status: 'active' }) // When associating multiple objects, you can combine the two options above. In this case the second argument // will be treated as a defaults object, that will be used if no data is provided project1.UserProjects = { status: 'inactive' } u.setProjects([project1, project2], { status: 'active' }) // The code above will record inactive for project one, and active for project two in the join table When getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance: u.getProjects().then(function(projects) { var project = projects[0] if (project.UserProjects.status === 'active') { // .. do magic // since this is a real DAO instance, you can save it directly after you are done doing magic return project.UserProjects.save() } }) If you only need some of the attributes from the join table, you can provide an array with the attributes you want: // This will select only name from the Projects table, and only status from the UserProjects table user.getProjects({ attributes: ['name'], joinTableAttributes: ['status']})","title":"Associating objects"},{"location":"docs/associations/#check-associations","text":"You can also check if an object is already associated with another one (N:M only). Here is how you'd do it: // check if an object is one of associated ones: Project.create({ /* */ }).then(function(project) { return User.create({ /* */ }).then(function(user) { return project.hasUser(user).then(function(result) { // result would be false return project.addUser(user).then(function() { return project.hasUser(user).then(function(result) { // result would be true }) }) }) }) }) // check if all associated objects are as expected: // let's assume we have already a project and two users project.setUsers([user1, user2]).then(function() { return project.hasUsers([user1]); }).then(function(result) { // result would be false return project.hasUsers([user1, user2]); }).then(function(result) { // result would be true })","title":"Check associations"},{"location":"docs/associations/#foreign-keys_1","text":"When you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below: var Task = this.sequelize.define('task', { title: Sequelize.STRING }) , User = this.sequelize.define('user', { username: Sequelize.STRING }) User.hasMany(Task) Task.belongsTo(User) Will generate the following SQL: CREATE TABLE IF NOT EXISTS `User` ( `id` INTEGER PRIMARY KEY, `username` VARCHAR(255) ); CREATE TABLE IF NOT EXISTS `Task` ( `id` INTEGER PRIMARY KEY, `title` VARCHAR(255), `user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); The relation between task and user injects the user_id foreign key on tasks, and marks it as a reference to the User table. By default user_id will be set to NULL if the referenced user is deleted, and updated if the id of the user id updated. These options can be overridden by passing onUpdate and onDelete options to the association calls. The validation options are RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL . For 1:1 and 1:m associations the default option is SET NULL for deletion, and CASCADE for updates. For n:m, the default for both is CASCADE . This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated. Adding constraints between tables means that tables must be created in the database in a certain order, when using sequelize.sync . If Task has a reference to User, the User table must be created before the Task table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has an reference to it's current version. var Document = this.sequelize.define('document', { author: Sequelize.STRING }) , Version = this.sequelize.define('version', { timestamp: Sequelize.DATE }) Document.hasMany(Version) // This adds document_id to version Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id'}) // This adds current_version_id to document However, the code above will result in the following error: Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document . In order to alleviate that, we can pass constraints: false to one of the associations: Document.hasMany(Version) Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false}) Which will allow us to sync the tables correctly: CREATE TABLE IF NOT EXISTS `Document` ( `id` INTEGER PRIMARY KEY, `author` VARCHAR(255), `current_version_id` INTEGER ); CREATE TABLE IF NOT EXISTS `Version` ( `id` INTEGER PRIMARY KEY, `timestamp` DATETIME, `document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE );","title":"Foreign Keys"},{"location":"docs/associations/#enforcing-a-foreign-key-reference-without-constraints","text":"Some times you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them. var Series, Trainer, Video // Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series) Series = sequelize.define('series', { title: DataTypes.STRING, sub_title: DataTypes.STRING, description: DataTypes.TEXT, // Set FK relationship (hasMany) with `Trainer` trainer_id: { type: DataTypes.INTEGER, references: { model: \"trainers\", key: \"id\" } } }) Trainer = sequelize.define('trainer', { first_name: DataTypes.STRING, last_name: DataTypes.STRING }); // Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)... Video = sequelize.define('video', { title: DataTypes.STRING, sequence: DataTypes.INTEGER, description: DataTypes.TEXT, // set relationship (hasOne) with `Series` series_id: { type: DataTypes.INTEGER, references: { model: Series, // Can be both a string representing the table name, or a reference to the model key: \"id\" } } }); Series.hasOne(Video); Trainer.hasMany(Series);","title":"Enforcing a foreign key reference without constraints"},{"location":"docs/associations/#creating-with-associations","text":"An instance can be created with nested association in one step, provided all elements are new.","title":"Creating with associations"},{"location":"docs/associations/#creating-elements-of-a-belongsto-or-hasone-association","text":"Consider the following models: var Product = this.sequelize.define('product', { title: Sequelize.STRING }); var User = this.sequelize.define('user', { first_name: Sequelize.STRING, last_name: Sequelize.STRING }); Product.belongsTo(User); // Also works for `hasOne` A new Product and User can be created in one step in the following way: return Product.create({ title: 'Chair', user: { first_name: 'Mick', last_name: 'Broadstone' } }, { include: [ User ] });","title":"Creating elements of a \"BelongsTo\" or \"HasOne\" association"},{"location":"docs/associations/#creating-elements-of-a-belongsto-association-with-an-alias","text":"The previous example can be extended to support an association alias. var Creator = Product.belongsTo(User, {as: 'creator'}); return Product.create({ title: 'Chair', creator: { first_name: 'Matt', last_name: 'Hansen' } }, { include: [ Creator ] });","title":"Creating elements of a \"BelongsTo\" association with an alias"},{"location":"docs/associations/#creating-elements-of-a-hasmany-or-belongstomany-association","text":"Let's introduce the ability to associate a project with many tags. Setting up the models could look like: var Tag = this.sequelize.define('tag', { name: Sequelize.STRING }); Product.hasMany(Tag); // Also works for `belongsToMany`. Now we can create a project with multiple tags in the following way: Product.create({ id: 1, title: 'Chair', tags: [ { name: 'Alpha'}, { name: 'Beta'} ] }, { include: [ Tag ] }) And, we can modify this example to support an alias as well: var Categories = Product.hasMany(Tag, {as: 'categories'}); Product.create({ id: 1, title: 'Chair', categories: [ {id: 1, name: 'Alpha'}, {id: 2, name: 'Beta'} ] }, { include: [{ model: Categories, as: 'categories' }] })","title":"Creating elements of a \"HasMany\" or \"BelongsToMany\" association"},{"location":"docs/getting-started/","text":"Installation Sequelize is available via NPM. $ npm install --save sequelize # And one of the following: $ npm install --save pg pg-hstore $ npm install --save mysql // For both mysql and mariadb dialects $ npm install --save sqlite3 $ npm install --save tedious // MSSQL Setting up a connection Sequelize will setup a connection pool on initialization so you should ideally only ever create one instance per database. var sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: 'mysql'|'mariadb'|'sqlite'|'postgres'|'mssql', pool: { max: 5, min: 0, idle: 10000 }, // SQLite only storage: 'path/to/database.sqlite' }); // Or you can simply use a connection uri var sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname'); The Sequelize constructor takes a whole slew of options that are available via the API reference . Your first model Models are defined with sequelize.define('name', {attributes}, {options}) . var User = sequelize.define('user', { firstName: { type: Sequelize.STRING, field: 'first_name' // Will result in an attribute that is firstName when user facing but first_name in the database }, lastName: { type: Sequelize.STRING } }, { freezeTableName: true // Model tableName will be the same as the model name }); User.sync({force: true}).then(function () { // Table created return User.create({ firstName: 'John', lastName: 'Hancock' }); }); Many more options can be found in the Model API reference Application wide model options The Sequelize constructor takes a define option which will be used as the default options for all defined models. var sequelize = new Sequelize('connectionUri', { define: { timestamps: false // true by default } }); var User = sequelize.define('user', {}); // timestamps is false by default var Post = sequelize.define('post', {}, { timestamps: true // timestamps will now be true }); Promises Sequelize uses promises to control async control-flow. If you are unfamiliar with how promises work, now might be a good time to brush up on them, here and here Basically a promise represents a value which will be present at some point - \"I promise you I will give you a result or an error at some point\". This means that // DON'T DO THIS user = User.findOne() console.log(user.get('firstName')); will never work! This is because user is a promise object, not a data row from the DB. The right way to do it is: User.findOne().then(function (user) { console.log(user.get('firstName')); }); Once you've got the hang of what promises are and how they work, use the bluebird API reference as your go to tool. In particular, you'll probably be using .all a lot.","title":"Getting Started"},{"location":"docs/getting-started/#installation","text":"Sequelize is available via NPM. $ npm install --save sequelize # And one of the following: $ npm install --save pg pg-hstore $ npm install --save mysql // For both mysql and mariadb dialects $ npm install --save sqlite3 $ npm install --save tedious // MSSQL","title":"Installation"},{"location":"docs/getting-started/#setting-up-a-connection","text":"Sequelize will setup a connection pool on initialization so you should ideally only ever create one instance per database. var sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: 'mysql'|'mariadb'|'sqlite'|'postgres'|'mssql', pool: { max: 5, min: 0, idle: 10000 }, // SQLite only storage: 'path/to/database.sqlite' }); // Or you can simply use a connection uri var sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname'); The Sequelize constructor takes a whole slew of options that are available via the API reference .","title":"Setting up a connection"},{"location":"docs/getting-started/#your-first-model","text":"Models are defined with sequelize.define('name', {attributes}, {options}) . var User = sequelize.define('user', { firstName: { type: Sequelize.STRING, field: 'first_name' // Will result in an attribute that is firstName when user facing but first_name in the database }, lastName: { type: Sequelize.STRING } }, { freezeTableName: true // Model tableName will be the same as the model name }); User.sync({force: true}).then(function () { // Table created return User.create({ firstName: 'John', lastName: 'Hancock' }); }); Many more options can be found in the Model API reference","title":"Your first model"},{"location":"docs/getting-started/#application-wide-model-options","text":"The Sequelize constructor takes a define option which will be used as the default options for all defined models. var sequelize = new Sequelize('connectionUri', { define: { timestamps: false // true by default } }); var User = sequelize.define('user', {}); // timestamps is false by default var Post = sequelize.define('post', {}, { timestamps: true // timestamps will now be true });","title":"Application wide model options"},{"location":"docs/getting-started/#promises","text":"Sequelize uses promises to control async control-flow. If you are unfamiliar with how promises work, now might be a good time to brush up on them, here and here Basically a promise represents a value which will be present at some point - \"I promise you I will give you a result or an error at some point\". This means that // DON'T DO THIS user = User.findOne() console.log(user.get('firstName')); will never work! This is because user is a promise object, not a data row from the DB. The right way to do it is: User.findOne().then(function (user) { console.log(user.get('firstName')); }); Once you've got the hang of what promises are and how they work, use the bluebird API reference as your go to tool. In particular, you'll probably be using .all a lot.","title":"Promises"},{"location":"docs/hooks/","text":"Hooks (also known as callbacks or lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a beforeUpdate hook. For a full list of hooks, see Hooks API . Order of Operations (1) beforeBulkCreate(instances, options, fn) beforeBulkDestroy(options, fn) beforeBulkUpdate(options, fn) (2) beforeValidate(instance, options, fn) (-) validate (3) afterValidate(instance, options, fn) - or - validationFailed(instance, options, error, fn) (4) beforeCreate(instance, options, fn) beforeDestroy(instance, options, fn) beforeUpdate(instance, options, fn) (-) create destroy update (5) afterCreate(instance, options, fn) afterDestroy(instance, options, fn) afterUpdate(instance, options, fn) (6) afterBulkCreate(instances, options, fn) afterBulkDestroy(options, fn) afterBulkUpdate(options, fn) Declaring Hooks Arguments to hooks are passed by reference. This means, that you can change the values, and this will be reflected in the insert / update statement. A hook may contain async actions - in this case the hook function should return a promise. There are currently three ways to programmatically add hooks: // Method 1 via the .define() method var User = sequelize.define('user', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: function(user, options) { user.mood = 'happy' }, afterValidate: function(user, options) { user.username = 'Toni' } } }) // Method 2 via the .hook() method User.hook('beforeValidate', function(user, options) { user.mood = 'happy' }) User.hook('afterValidate', function(user, options) { return sequelize.Promise.reject(\"I'm afraid I can't let you do that!\") }) // Method 3 via the direct method User.beforeCreate(function(user, options) { return hashPassword(user.password).then(function (hashedPw) { user.password = hashedPw; }); }) User.afterValidate('myHookAfter', function(user, options, fn) { user.username = 'Toni' }) Removing hooks Only a hook with name param can be removed. var Book = sequelize.define('book', { title: DataTypes.STRING }) Book.addHook('afterCreate', 'notifyUsers', function(book, options) { // ... }) Book.removeHook('afterCreate', 'notifyUsers') Global / universal hooks Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics: Sequelize.options.define (default hook) var sequelize = new Sequelize(..., { define: { hooks: { beforeCreate: function () { // Do stuff } } } }); This adds a default hook to all models, which is run if the model does not define its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook (because the global hook is overwritten) Sequelize.addHook (permanent hook) sequelize.addHook('beforeCreate', function () { // Do stuff }); This hooks is always run before create, regardless of whether the model specifies its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook, followed by the global hook Local hooks are always run before global hooks. Instance hooks The following hooks will emit whenever you're editing a single object beforeValidate afterValidate or validationFailed beforeCreate / beforeUpdate / beforeDestroy afterCreate / afterUpdate / afterDestroy // ...define ... User.beforeCreate(function(user) { if (user.accessLevel > 10 && user.username !== \"Boss\") { throw new Error(\"You can't grant this user an access level above 10!\") } }) This example will return an error: User.create({username: 'Not a Boss', accessLevel: 20}).catch(function(err) { console.log(err) // You can't grant this user an access level above 10! }) The following example would return successful: User.create({username: 'Boss', accessLevel: 20}).then(function(user) { console.log(user) // user object with username as Boss and accessLevel of 20 }) Model hooks Sometimes you'll be editing more than one record at a time by utilizing the bulkCreate, update, destroy methods on the model. The following will emit whenever you're using one of those methods. beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy afterBulkCreate / afterBulkUpdate / afterBulkDestroy If you want to emit hooks for each individual record, along with the bulk hooks you can pass individualHooks: true to the call. Model.destroy({ where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Destroy on each instance Model.update({username: 'Toni'}, { where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be updated and emit before- + after- Update on each instance Some model hooks have two or three parameters sent to each hook depending on it's type. Model.beforeBulkCreate(function(records, fields) { // records = the first argument sent to .bulkCreate // fields = the second argument sent to .bulkCreate }) Model.bulkCreate([ {username: 'Toni'}, // part of records argument {username: 'Tobi'} // part of records argument ], ['username'] /* part of fields argument */) Model.beforeBulkUpdate(function(attributes, where) { // attributes = first argument sent to Model.update // where = second argument sent to Model.update }) Model.update({gender: 'Male'} /*attributes argument*/, { where: {username: 'Tom'}} /*where argument*/) Model.beforeBulkDestroy(function(whereClause) { // whereClause = first argument sent to Model.destroy }) Model.destroy({ where: {username: 'Tom'}} /*whereClause argument*/) If you use Model.bulkCreate(...) with the updatesOnDuplicate option, changes made in the hook to fields that aren't given in the updatesOnDuplicate array will not be persisted to the database. However it is possible to change the updatesOnDuplicate option inside the hook if this is what you want. // Bulk updating existing users with updatesOnDuplicate option Users.bulkCreate([{ id: 1, isMemeber: true}, { id: 2, isMember: false}], { updatesOnDuplicate: ['isMember']}) User.beforeBulkCreate(function (users, options) { users.forEach(function (user) { if (user.isMember) { user.memberSince = new Date() } }) // Add memberSince to updatesOnDuplicate otherwise the memberSince date wont be // saved to the database options.updatesOnDuplicate.push('memberSince') }) Associations For the most part hooks will work the same for instances when being associated except a few things When using add/set functions the beforeUpdate/afterUpdate hooks will run. The only way to call beforeDestroy/afterDestroy hooks are on associations with onDelete: 'cascade' and the option hooks: true . For instance: var Projects = sequelize.define('projects', { title: DataTypes.STRING }) var Tasks = sequelize.define('tasks', { title: DataTypes.STRING }) Projects.hasMany(Tasks, { onDelete: 'cascade', hooks: true }) Tasks.belongsTo(Projects) This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey However, adding hooks: true explicitly tells Sequelize that optimization is not of your concern and will perform a SELECT on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters. If your association is of type n:m , you may be interested in firing hooks on the through model when using the remove call. Internally, sequelize is using Model.destroy resulting in calling the bulkDestroy instead of the before/afterDestroy hooks on each through instance. This can be simply solved by passing {individualHooks: true} to the remove call, resulting on each hook to be called on each removed through instance object. A Note About Transactions Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction is specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet: // Here we use the promise-style of async hooks rather than // the callback. User.hook('afterCreate', function(user, options) { // 'transaction' will be available in options.transaction // This operation will be part of the same transaction as the // original User.create call. return User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); sequelize.transaction(function(t) { User.create({ username: 'someguy', mood: 'happy', transaction: t }); }); If we had not included the transaction option in our call to User.update in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed. Internal Transactions It is very important to recognize that sequelize may make use of transactions internally for certain operations such as Model.findOrCreate . If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify { transaction: options.transaction } . If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified { transaction: null } and can expect the default behaviour.","title":"Hooks"},{"location":"docs/hooks/#order-of-operations","text":"(1) beforeBulkCreate(instances, options, fn) beforeBulkDestroy(options, fn) beforeBulkUpdate(options, fn) (2) beforeValidate(instance, options, fn) (-) validate (3) afterValidate(instance, options, fn) - or - validationFailed(instance, options, error, fn) (4) beforeCreate(instance, options, fn) beforeDestroy(instance, options, fn) beforeUpdate(instance, options, fn) (-) create destroy update (5) afterCreate(instance, options, fn) afterDestroy(instance, options, fn) afterUpdate(instance, options, fn) (6) afterBulkCreate(instances, options, fn) afterBulkDestroy(options, fn) afterBulkUpdate(options, fn)","title":"Order of Operations"},{"location":"docs/hooks/#declaring-hooks","text":"Arguments to hooks are passed by reference. This means, that you can change the values, and this will be reflected in the insert / update statement. A hook may contain async actions - in this case the hook function should return a promise. There are currently three ways to programmatically add hooks: // Method 1 via the .define() method var User = sequelize.define('user', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: function(user, options) { user.mood = 'happy' }, afterValidate: function(user, options) { user.username = 'Toni' } } }) // Method 2 via the .hook() method User.hook('beforeValidate', function(user, options) { user.mood = 'happy' }) User.hook('afterValidate', function(user, options) { return sequelize.Promise.reject(\"I'm afraid I can't let you do that!\") }) // Method 3 via the direct method User.beforeCreate(function(user, options) { return hashPassword(user.password).then(function (hashedPw) { user.password = hashedPw; }); }) User.afterValidate('myHookAfter', function(user, options, fn) { user.username = 'Toni' })","title":"Declaring Hooks"},{"location":"docs/hooks/#removing-hooks","text":"Only a hook with name param can be removed. var Book = sequelize.define('book', { title: DataTypes.STRING }) Book.addHook('afterCreate', 'notifyUsers', function(book, options) { // ... }) Book.removeHook('afterCreate', 'notifyUsers')","title":"Removing hooks"},{"location":"docs/hooks/#global-universal-hooks","text":"Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics:","title":"Global / universal hooks"},{"location":"docs/hooks/#sequelizeoptionsdefine-default-hook","text":"var sequelize = new Sequelize(..., { define: { hooks: { beforeCreate: function () { // Do stuff } } } }); This adds a default hook to all models, which is run if the model does not define its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook (because the global hook is overwritten)","title":"Sequelize.options.define (default hook)"},{"location":"docs/hooks/#sequelizeaddhook-permanent-hook","text":"sequelize.addHook('beforeCreate', function () { // Do stuff }); This hooks is always run before create, regardless of whether the model specifies its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook, followed by the global hook Local hooks are always run before global hooks.","title":"Sequelize.addHook (permanent hook)"},{"location":"docs/hooks/#instance-hooks","text":"The following hooks will emit whenever you're editing a single object beforeValidate afterValidate or validationFailed beforeCreate / beforeUpdate / beforeDestroy afterCreate / afterUpdate / afterDestroy // ...define ... User.beforeCreate(function(user) { if (user.accessLevel > 10 && user.username !== \"Boss\") { throw new Error(\"You can't grant this user an access level above 10!\") } }) This example will return an error: User.create({username: 'Not a Boss', accessLevel: 20}).catch(function(err) { console.log(err) // You can't grant this user an access level above 10! }) The following example would return successful: User.create({username: 'Boss', accessLevel: 20}).then(function(user) { console.log(user) // user object with username as Boss and accessLevel of 20 })","title":"Instance hooks"},{"location":"docs/hooks/#model-hooks","text":"Sometimes you'll be editing more than one record at a time by utilizing the bulkCreate, update, destroy methods on the model. The following will emit whenever you're using one of those methods. beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy afterBulkCreate / afterBulkUpdate / afterBulkDestroy If you want to emit hooks for each individual record, along with the bulk hooks you can pass individualHooks: true to the call. Model.destroy({ where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Destroy on each instance Model.update({username: 'Toni'}, { where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be updated and emit before- + after- Update on each instance Some model hooks have two or three parameters sent to each hook depending on it's type. Model.beforeBulkCreate(function(records, fields) { // records = the first argument sent to .bulkCreate // fields = the second argument sent to .bulkCreate }) Model.bulkCreate([ {username: 'Toni'}, // part of records argument {username: 'Tobi'} // part of records argument ], ['username'] /* part of fields argument */) Model.beforeBulkUpdate(function(attributes, where) { // attributes = first argument sent to Model.update // where = second argument sent to Model.update }) Model.update({gender: 'Male'} /*attributes argument*/, { where: {username: 'Tom'}} /*where argument*/) Model.beforeBulkDestroy(function(whereClause) { // whereClause = first argument sent to Model.destroy }) Model.destroy({ where: {username: 'Tom'}} /*whereClause argument*/) If you use Model.bulkCreate(...) with the updatesOnDuplicate option, changes made in the hook to fields that aren't given in the updatesOnDuplicate array will not be persisted to the database. However it is possible to change the updatesOnDuplicate option inside the hook if this is what you want. // Bulk updating existing users with updatesOnDuplicate option Users.bulkCreate([{ id: 1, isMemeber: true}, { id: 2, isMember: false}], { updatesOnDuplicate: ['isMember']}) User.beforeBulkCreate(function (users, options) { users.forEach(function (user) { if (user.isMember) { user.memberSince = new Date() } }) // Add memberSince to updatesOnDuplicate otherwise the memberSince date wont be // saved to the database options.updatesOnDuplicate.push('memberSince') })","title":"Model hooks"},{"location":"docs/hooks/#associations","text":"For the most part hooks will work the same for instances when being associated except a few things When using add/set functions the beforeUpdate/afterUpdate hooks will run. The only way to call beforeDestroy/afterDestroy hooks are on associations with onDelete: 'cascade' and the option hooks: true . For instance: var Projects = sequelize.define('projects', { title: DataTypes.STRING }) var Tasks = sequelize.define('tasks', { title: DataTypes.STRING }) Projects.hasMany(Tasks, { onDelete: 'cascade', hooks: true }) Tasks.belongsTo(Projects) This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey However, adding hooks: true explicitly tells Sequelize that optimization is not of your concern and will perform a SELECT on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters. If your association is of type n:m , you may be interested in firing hooks on the through model when using the remove call. Internally, sequelize is using Model.destroy resulting in calling the bulkDestroy instead of the before/afterDestroy hooks on each through instance. This can be simply solved by passing {individualHooks: true} to the remove call, resulting on each hook to be called on each removed through instance object.","title":"Associations"},{"location":"docs/hooks/#a-note-about-transactions","text":"Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction is specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet: // Here we use the promise-style of async hooks rather than // the callback. User.hook('afterCreate', function(user, options) { // 'transaction' will be available in options.transaction // This operation will be part of the same transaction as the // original User.create call. return User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); sequelize.transaction(function(t) { User.create({ username: 'someguy', mood: 'happy', transaction: t }); }); If we had not included the transaction option in our call to User.update in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.","title":"A Note About Transactions"},{"location":"docs/hooks/#internal-transactions","text":"It is very important to recognize that sequelize may make use of transactions internally for certain operations such as Model.findOrCreate . If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify { transaction: options.transaction } . If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified { transaction: null } and can expect the default behaviour.","title":"Internal Transactions"},{"location":"docs/instances/","text":"Building a non-persistent instance In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the build -method will return an unsaved object, which you explicitly have to save. var project = Project.build({ title: 'my awesome project', description: 'woot woot. this will make me a rich man' }) var task = Task.build({ title: 'specify the project idea', description: 'bla', deadline: new Date() }) Built instances will automatically get default values when they were defined: // first define the model var Task = sequelize.define('task', { title: Sequelize.STRING, rating: { type: Sequelize.STRING, defaultValue: 3 } }) // now instantiate an object var task = Task.build({title: 'very important task'}) task.title // ==> 'very important task' task.rating // ==> 3 To get it stored in the database, use the save -method and catch the events ... if needed: project.save().then(function() { // my nice callback stuff }) task.save().catch(function(error) { // mhhh, wth! }) // you can also build, save and access the object with chaining: Task .build({ title: 'foo', description: 'bar', deadline: new Date() }) .save() .then(function(anotherTask) { // you can now access the currently saved task with the variable anotherTask... nice! }).catch(function(error) { // Ooops, do some error-handling }) Creating persistent instances Besides constructing objects, that needs an explicit save call to get stored in the database, there is also the possibility to do all those steps with one single command. It's called create . Task.create({ title: 'foo', description: 'bar', deadline: new Date() }).then(function(task) { // you can now access the newly created task via the variable task }) It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the User model to set only a username and an address but not an admin flag: User.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(function(user) { // let's assume the default of isAdmin is false: console.log(user.get({ plain: true })) // => { username: 'barfooz', isAdmin: false } }) Updating / Saving / Persisting an instance Now lets change some values and save changes to the database... There are two ways to do that: // way 1 task.title = 'a very different title now' task.save().then(function() {}) // way 2 task.update({ title: 'a very different title now' }).then(function() {}) It's also possible to define which attributes should be saved when calling save , by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for update . This is how it looks like: task.title = 'foooo' task.description = 'baaaaaar' task.save({fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) // The equivalent call using update looks like this: task.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) When you call save without changing any attribute, this method will execute nothing; Destroying / Deleting persistent instances Once you created an object and got a reference to it, you can delete it from the database. The relevant method is destroy : Task.create({ title: 'a task' }).then(function(task) { // now you see me... return task.destroy(); }).then(function() { // now i'm gone :) }) If the paranoid options is true, the object will not be deleted, instead the deletedAt column will be set to the current timestamp. To force the deletion, you can pass force: true to the destroy call: task.destroy({ force: true }) Working in bulk (creating, updating and destroying multiple rows at once) In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called Model.bulkCreate Model.update Model.destroy Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike create , not have the resulting values of autoIncrement attributes. update and destroy will return the number of affected rows. First lets look at bulkCreate User.bulkCreate([ { username: 'barfooz', isAdmin: true }, { username: 'foo', isAdmin: true }, { username: 'bar', isAdmin: false } ]).then(function() { // Notice: There are no arguments here, as of right now you'll have to... return User.findAll(); }).then(function(users) { console.log(users) // ... in order to get the array of user objects }) To update several rows at once: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.update( { status: 'inactive' }, /* set attributes' value */, { where: { subject: 'programming' }} /* where criteria */ ); }).spread(function(affectedCount, affectedRows) { // .update returns two values in an array, therefore we use .spread // Notice that affectedRows will only be defined in dialects which support returning: true // affectedCount will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // the 'programming' tasks will both have a status of 'inactive' }) And delete them: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.destroy({ where: { subject: 'programming' }, truncate: true /* this will ignore where and truncate the table instead */ }); }).then(function(affectedRows) { // affectedRows will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // no programming, just reading :( }) If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. bulkCreate() accepts an options object as the second parameter. The object can have a fields parameter, (an array) to let it know which fields you want to build explicitly User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true} ], { fields: ['username'] }).then(function() { // nope bar, you can't be admin! }) bulkCreate was originally made to be a mainstream/fast way of inserting records, however, sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through. You can do by adding a validate: true property to the options object. var Tasks = sequelize.define('task', { name: { type: Sequelize.STRING, validate: { notNull: { args: true, msg: 'name cannot be null' } } }, code: { type: Sequelize.STRING, validate: { len: [3, 10] } } }) Tasks.bulkCreate([ {name: 'foo', code: '123'}, {code: '1234'}, {name: 'bar', code: '1'} ], { validate: true }).catch(function(errors) { /* console.log(errors) would look like: [ { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } }, { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } } ] */ }) Values of an instance If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the get -attribute. Calling it with the option plain = true will only return the values of an instance. Person.create({ name: 'Rambow', firstname: 'John' }).then(function(john) { console.log(john.get({ plain: true })) }) // result: // { name: 'Rambow', // firstname: 'John', // id: 1, // createdAt: Tue, 01 May 2012 19:12:16 GMT, // updatedAt: Tue, 01 May 2012 19:12:16 GMT // } Hint: You can also transform an instance into JSON by using JSON.stringify(instance) . This will basically return the very same as values . Reloading instances If you need to get your instance in sync, you can use the method reload . It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on. Person.findOne({ where: { name: 'john' } }).then(function(person) { person.name = 'jane' console.log(person.name) // 'jane' person.reload().then(function() { console.log(person.name) // 'john' }) }) Incrementing certain values of an instance In order to increment values of an instance without running into concurrency issues, you may use increment . First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.increment('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.increment([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its increment values. User.findById(1).then(function(user) { return user.increment({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */) Decrementing certain values of an instance In order to decrement values of an instance without running into concurrency issues, you may use decrement . First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.decrement('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.decrement([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its decrement values. User.findById(1).then(function(user) { return user.decrement({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */)","title":"Instances"},{"location":"docs/instances/#building-a-non-persistent-instance","text":"In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the build -method will return an unsaved object, which you explicitly have to save. var project = Project.build({ title: 'my awesome project', description: 'woot woot. this will make me a rich man' }) var task = Task.build({ title: 'specify the project idea', description: 'bla', deadline: new Date() }) Built instances will automatically get default values when they were defined: // first define the model var Task = sequelize.define('task', { title: Sequelize.STRING, rating: { type: Sequelize.STRING, defaultValue: 3 } }) // now instantiate an object var task = Task.build({title: 'very important task'}) task.title // ==> 'very important task' task.rating // ==> 3 To get it stored in the database, use the save -method and catch the events ... if needed: project.save().then(function() { // my nice callback stuff }) task.save().catch(function(error) { // mhhh, wth! }) // you can also build, save and access the object with chaining: Task .build({ title: 'foo', description: 'bar', deadline: new Date() }) .save() .then(function(anotherTask) { // you can now access the currently saved task with the variable anotherTask... nice! }).catch(function(error) { // Ooops, do some error-handling })","title":"Building a non-persistent instance"},{"location":"docs/instances/#creating-persistent-instances","text":"Besides constructing objects, that needs an explicit save call to get stored in the database, there is also the possibility to do all those steps with one single command. It's called create . Task.create({ title: 'foo', description: 'bar', deadline: new Date() }).then(function(task) { // you can now access the newly created task via the variable task }) It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the User model to set only a username and an address but not an admin flag: User.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(function(user) { // let's assume the default of isAdmin is false: console.log(user.get({ plain: true })) // => { username: 'barfooz', isAdmin: false } })","title":"Creating persistent instances"},{"location":"docs/instances/#updating-saving-persisting-an-instance","text":"Now lets change some values and save changes to the database... There are two ways to do that: // way 1 task.title = 'a very different title now' task.save().then(function() {}) // way 2 task.update({ title: 'a very different title now' }).then(function() {}) It's also possible to define which attributes should be saved when calling save , by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for update . This is how it looks like: task.title = 'foooo' task.description = 'baaaaaar' task.save({fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) // The equivalent call using update looks like this: task.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) When you call save without changing any attribute, this method will execute nothing;","title":"Updating / Saving / Persisting an instance"},{"location":"docs/instances/#destroying-deleting-persistent-instances","text":"Once you created an object and got a reference to it, you can delete it from the database. The relevant method is destroy : Task.create({ title: 'a task' }).then(function(task) { // now you see me... return task.destroy(); }).then(function() { // now i'm gone :) }) If the paranoid options is true, the object will not be deleted, instead the deletedAt column will be set to the current timestamp. To force the deletion, you can pass force: true to the destroy call: task.destroy({ force: true })","title":"Destroying / Deleting persistent instances"},{"location":"docs/instances/#working-in-bulk-creating-updating-and-destroying-multiple-rows-at-once","text":"In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called Model.bulkCreate Model.update Model.destroy Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike create , not have the resulting values of autoIncrement attributes. update and destroy will return the number of affected rows. First lets look at bulkCreate User.bulkCreate([ { username: 'barfooz', isAdmin: true }, { username: 'foo', isAdmin: true }, { username: 'bar', isAdmin: false } ]).then(function() { // Notice: There are no arguments here, as of right now you'll have to... return User.findAll(); }).then(function(users) { console.log(users) // ... in order to get the array of user objects }) To update several rows at once: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.update( { status: 'inactive' }, /* set attributes' value */, { where: { subject: 'programming' }} /* where criteria */ ); }).spread(function(affectedCount, affectedRows) { // .update returns two values in an array, therefore we use .spread // Notice that affectedRows will only be defined in dialects which support returning: true // affectedCount will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // the 'programming' tasks will both have a status of 'inactive' }) And delete them: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.destroy({ where: { subject: 'programming' }, truncate: true /* this will ignore where and truncate the table instead */ }); }).then(function(affectedRows) { // affectedRows will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // no programming, just reading :( }) If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. bulkCreate() accepts an options object as the second parameter. The object can have a fields parameter, (an array) to let it know which fields you want to build explicitly User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true} ], { fields: ['username'] }).then(function() { // nope bar, you can't be admin! }) bulkCreate was originally made to be a mainstream/fast way of inserting records, however, sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through. You can do by adding a validate: true property to the options object. var Tasks = sequelize.define('task', { name: { type: Sequelize.STRING, validate: { notNull: { args: true, msg: 'name cannot be null' } } }, code: { type: Sequelize.STRING, validate: { len: [3, 10] } } }) Tasks.bulkCreate([ {name: 'foo', code: '123'}, {code: '1234'}, {name: 'bar', code: '1'} ], { validate: true }).catch(function(errors) { /* console.log(errors) would look like: [ { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } }, { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } } ] */ })","title":"Working in bulk (creating, updating and destroying multiple rows at once)"},{"location":"docs/instances/#values-of-an-instance","text":"If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the get -attribute. Calling it with the option plain = true will only return the values of an instance. Person.create({ name: 'Rambow', firstname: 'John' }).then(function(john) { console.log(john.get({ plain: true })) }) // result: // { name: 'Rambow', // firstname: 'John', // id: 1, // createdAt: Tue, 01 May 2012 19:12:16 GMT, // updatedAt: Tue, 01 May 2012 19:12:16 GMT // } Hint: You can also transform an instance into JSON by using JSON.stringify(instance) . This will basically return the very same as values .","title":"Values of an instance"},{"location":"docs/instances/#reloading-instances","text":"If you need to get your instance in sync, you can use the method reload . It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on. Person.findOne({ where: { name: 'john' } }).then(function(person) { person.name = 'jane' console.log(person.name) // 'jane' person.reload().then(function() { console.log(person.name) // 'john' }) })","title":"Reloading instances"},{"location":"docs/instances/#incrementing-certain-values-of-an-instance","text":"In order to increment values of an instance without running into concurrency issues, you may use increment . First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.increment('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.increment([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its increment values. User.findById(1).then(function(user) { return user.increment({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */)","title":"Incrementing certain values of an instance"},{"location":"docs/instances/#decrementing-certain-values-of-an-instance","text":"In order to decrement values of an instance without running into concurrency issues, you may use decrement . First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.decrement('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.decrement([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its decrement values. User.findById(1).then(function(user) { return user.decrement({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */)","title":"Decrementing certain values of an instance"},{"location":"docs/legacy/","text":"While out of the box Sequelize will seem a bit opinionated it's trivial to both legacy and forward proof your application by defining (otherwise generated) table and field names. Tables sequelize.define('user', { }, { tableName: 'users' }); Fields sequelize.define('modelName', { userId: { type: Sequelize.INTEGER, field: 'user_id' } }); Primary keys Sequelize will assume your table has a id primary key property by default. To define your own primary key: sequelize.define('collection', { uid: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true // Automatically gets converted to SERIAL for postgres } }); sequelize.define('collection', { uuid: { type: Sequelize.UUID, primaryKey: true } }); And if your model has no primary key at all you can use Model.removeAttribute('id'); Foreign keys // 1:1 Organization.belongsTo(User, {foreignKey: 'owner_id'}); User.hasOne(Organization, {foreignKey: 'owner_id'}); // 1:M Project.hasMany(Task, {foreignkey: 'tasks_pk'}); Task.belongsTo(Project, {foreignKey: 'tasks_pk'}); // N:M User.hasMany(Role, {through: 'user_has_roles', foreignKey: 'user_role_user_id'}); Role.hasMany(User, {through: 'user_has_roles', foreignKey: 'roles_identifier'});","title":"Working with legacy tables"},{"location":"docs/legacy/#tables","text":"sequelize.define('user', { }, { tableName: 'users' });","title":"Tables"},{"location":"docs/legacy/#fields","text":"sequelize.define('modelName', { userId: { type: Sequelize.INTEGER, field: 'user_id' } });","title":"Fields"},{"location":"docs/legacy/#primary-keys","text":"Sequelize will assume your table has a id primary key property by default. To define your own primary key: sequelize.define('collection', { uid: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true // Automatically gets converted to SERIAL for postgres } }); sequelize.define('collection', { uuid: { type: Sequelize.UUID, primaryKey: true } }); And if your model has no primary key at all you can use Model.removeAttribute('id');","title":"Primary keys"},{"location":"docs/legacy/#foreign-keys","text":"// 1:1 Organization.belongsTo(User, {foreignKey: 'owner_id'}); User.hasOne(Organization, {foreignKey: 'owner_id'}); // 1:M Project.hasMany(Task, {foreignkey: 'tasks_pk'}); Task.belongsTo(Project, {foreignKey: 'tasks_pk'}); // N:M User.hasMany(Role, {through: 'user_has_roles', foreignKey: 'user_role_user_id'}); Role.hasMany(User, {through: 'user_has_roles', foreignKey: 'roles_identifier'});","title":"Foreign keys"},{"location":"docs/migrations/","text":"Sequelize 2.0.0 introduces a new CLI which is based on gulp and combines sequelize-cli and gulp-sequelize . The CLI ships support for migrations and project bootstrapping. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe the way how to get to the new state and how to revert the changes in order to get back to the old state. The CLI In order to use the CLI you need to install the respective package: $ npm install --save sequelize-cli As with any npm package, you can use the global flag ( -g ) to install the CLI globally. If you have installed the CLI without the global flag, use node_modules/.bin/sequelize [command] instead of sequelize [command] . The CLI currently supports the following commands: $ sequelize db:migrate # Run pending migrations. $ sequelize db:migrate:undo # Revert the last migration run. $ sequelize help # Display this help text. $ sequelize init # Initializes the project. $ sequelize migration:create # Generates a new migration file. $ sequelize version # Prints the version number. Further and more detailed information about the available commands can be obtained via the help command: $ sequelize help:init $ sequelize help:db:migrate $ sequelize help:db:migrate:undo # etc The latter one for example will print out the following output: Sequelize [CLI: v0.0.2, ORM: v1.7.5] COMMANDS sequelize db:migrate:undo -- Revert the last migration run. DESCRIPTION Revert the last migration run. OPTIONS --env The environment to run the command in. Default: development --options-path The path to a JSON file with additional options. Default: none --coffee Enables coffee script support. Default: false --config The path to the config file. Default: config/config.json Skeleton The following skeleton shows a typical migration file. All migrations are expected to be located in a folder called migrations at the very top of the project. The sequelize binary can generate a migration skeleton. See the above section for more details. module.exports = { up: function(queryInterface, Sequelize) { // logic for transforming into the new state }, down: function(queryInterface, Sequelize) { // logic for reverting the changes } } The passed queryInterface object can be used to modify the database. The Sequelize object stores the available data types such as STRING or INTEGER . Function up or down should return a Promise . Here is some code: module.exports = { up: function(queryInterface, Sequelize) { return queryInterface.dropAllTables(); } } The available methods of the queryInterface object are the following. Functions Using the queryInterface object describe before, you will have access to most of already introduced functions. Furthermore there are some other methods, which are designed to actually change the database schema. createTable(tableName, attributes, options) This method allows creation of new tables. It is allowed to pass simple or complex attribute definitions. You can define the encoding of the table and the table's engine via options queryInterface.createTable( 'nameOfTheNewTable', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, createdAt: { type: Sequelize.DATE }, updatedAt: { type: Sequelize.DATE }, attr1: Sequelize.STRING, attr2: Sequelize.INTEGER, attr3: { type: Sequelize.BOOLEAN, defaultValue: false, allowNull: false }, //foreign key usage attr4: { type: Sequelize.INTEGER, references: { model: 'another_table_name', key: 'id' }, onUpdate: 'cascade', onDelete: 'cascade' } }, { engine: 'MYISAM', // default: 'InnoDB' charset: 'latin1' // default: null } ) dropTable(tableName, options) This method allows deletion of an existing table. queryInterface.dropTable('nameOfTheExistingTable') dropAllTables(options) This method allows deletion of all existing tables in the database. queryInterface.dropAllTables() renameTable(before, after, options) This method allows renaming of an existing table. queryInterface.renameTable('Person', 'User') showAllTables(options) This method returns the name of all existing tables in the database. queryInterface.showAllTables().then(function(tableNames) {}) describeTable(tableName, options) This method returns an array of hashes containing information about all attributes in the table. queryInterface.describeTable('Person').then(function(attributes) { /* attributes will be something like: { name: { type: 'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg! allowNull: true, defaultValue: null }, isBetaMember: { type: 'TINYINT(1)', // this will be 'BOOLEAN' for pg! allowNull: false, defaultValue: false } } */ }) addColumn(tableName, attributeName, dataTypeOrOptions, options) This method allows adding columns to an existing table. The data type can be simple or complex. queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', Sequelize.STRING ) // or queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', { type: Sequelize.STRING, allowNull: false } ) removeColumn(tableName, attributeName, options) This method allows deletion of a specific column of an existing table. queryInterface.removeColumn('Person', 'signature') changeColumn(tableName, attributeName, dataTypeOrOptions, options) This method changes the meta data of an attribute. It is possible to change the default value, allowance of null or the data type. Please make sure, that you are completely describing the new data type. queryInterface.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', { type: Sequelize.FLOAT, allowNull: false, defaultValue: 0.0 } ) renameColumn(tableName, attrNameBefore, attrNameAfter, options) This methods allows renaming attributes. queryInterface.renameColumn('Person', 'signature', 'sig') addIndex(tableName, attributes, options) This methods creates indexes for specific attributes of a table. The index name will be automatically generated if it is not passed via in the options (see below). // This example will create the index person_firstname_lastname queryInterface.addIndex('Person', ['firstname', 'lastname']) // This example will create a unique index with the name SuperDuperIndex using the optional 'options' field. // Possible options: // - indicesType: UNIQUE|FULLTEXT|SPATIAL // - indexName: The name of the index. Default is __ // - parser: For FULLTEXT columns set your parser // - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect // - logging: A function that receives the sql query, e.g. console.log queryInterface.addIndex( 'Person', ['firstname', 'lastname'], { indexName: 'SuperDuperIndex', indicesType: 'UNIQUE' } ) removeIndex(tableName, indexNameOrAttributes, options) This method deletes an existing index of a table. queryInterface.removeIndex('Person', 'SuperDuperIndex') // or queryInterface.removeIndex('Person', ['firstname', 'lastname']) Programmatic use Sequelize has a sister library for programmatically handling execution and logging of migration tasks.","title":"Migrations"},{"location":"docs/migrations/#the-cli","text":"In order to use the CLI you need to install the respective package: $ npm install --save sequelize-cli As with any npm package, you can use the global flag ( -g ) to install the CLI globally. If you have installed the CLI without the global flag, use node_modules/.bin/sequelize [command] instead of sequelize [command] . The CLI currently supports the following commands: $ sequelize db:migrate # Run pending migrations. $ sequelize db:migrate:undo # Revert the last migration run. $ sequelize help # Display this help text. $ sequelize init # Initializes the project. $ sequelize migration:create # Generates a new migration file. $ sequelize version # Prints the version number. Further and more detailed information about the available commands can be obtained via the help command: $ sequelize help:init $ sequelize help:db:migrate $ sequelize help:db:migrate:undo # etc The latter one for example will print out the following output: Sequelize [CLI: v0.0.2, ORM: v1.7.5] COMMANDS sequelize db:migrate:undo -- Revert the last migration run. DESCRIPTION Revert the last migration run. OPTIONS --env The environment to run the command in. Default: development --options-path The path to a JSON file with additional options. Default: none --coffee Enables coffee script support. Default: false --config The path to the config file. Default: config/config.json","title":"The CLI"},{"location":"docs/migrations/#skeleton","text":"The following skeleton shows a typical migration file. All migrations are expected to be located in a folder called migrations at the very top of the project. The sequelize binary can generate a migration skeleton. See the above section for more details. module.exports = { up: function(queryInterface, Sequelize) { // logic for transforming into the new state }, down: function(queryInterface, Sequelize) { // logic for reverting the changes } } The passed queryInterface object can be used to modify the database. The Sequelize object stores the available data types such as STRING or INTEGER . Function up or down should return a Promise . Here is some code: module.exports = { up: function(queryInterface, Sequelize) { return queryInterface.dropAllTables(); } } The available methods of the queryInterface object are the following.","title":"Skeleton"},{"location":"docs/migrations/#functions","text":"Using the queryInterface object describe before, you will have access to most of already introduced functions. Furthermore there are some other methods, which are designed to actually change the database schema.","title":"Functions"},{"location":"docs/migrations/#createtabletablename-attributes-options","text":"This method allows creation of new tables. It is allowed to pass simple or complex attribute definitions. You can define the encoding of the table and the table's engine via options queryInterface.createTable( 'nameOfTheNewTable', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, createdAt: { type: Sequelize.DATE }, updatedAt: { type: Sequelize.DATE }, attr1: Sequelize.STRING, attr2: Sequelize.INTEGER, attr3: { type: Sequelize.BOOLEAN, defaultValue: false, allowNull: false }, //foreign key usage attr4: { type: Sequelize.INTEGER, references: { model: 'another_table_name', key: 'id' }, onUpdate: 'cascade', onDelete: 'cascade' } }, { engine: 'MYISAM', // default: 'InnoDB' charset: 'latin1' // default: null } )","title":"createTable(tableName, attributes, options)"},{"location":"docs/migrations/#droptabletablename-options","text":"This method allows deletion of an existing table. queryInterface.dropTable('nameOfTheExistingTable')","title":"dropTable(tableName, options)"},{"location":"docs/migrations/#dropalltablesoptions","text":"This method allows deletion of all existing tables in the database. queryInterface.dropAllTables()","title":"dropAllTables(options)"},{"location":"docs/migrations/#renametablebefore-after-options","text":"This method allows renaming of an existing table. queryInterface.renameTable('Person', 'User')","title":"renameTable(before, after, options)"},{"location":"docs/migrations/#showalltablesoptions","text":"This method returns the name of all existing tables in the database. queryInterface.showAllTables().then(function(tableNames) {})","title":"showAllTables(options)"},{"location":"docs/migrations/#describetabletablename-options","text":"This method returns an array of hashes containing information about all attributes in the table. queryInterface.describeTable('Person').then(function(attributes) { /* attributes will be something like: { name: { type: 'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg! allowNull: true, defaultValue: null }, isBetaMember: { type: 'TINYINT(1)', // this will be 'BOOLEAN' for pg! allowNull: false, defaultValue: false } } */ })","title":"describeTable(tableName, options)"},{"location":"docs/migrations/#addcolumntablename-attributename-datatypeoroptions-options","text":"This method allows adding columns to an existing table. The data type can be simple or complex. queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', Sequelize.STRING ) // or queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', { type: Sequelize.STRING, allowNull: false } )","title":"addColumn(tableName, attributeName, dataTypeOrOptions, options)"},{"location":"docs/migrations/#removecolumntablename-attributename-options","text":"This method allows deletion of a specific column of an existing table. queryInterface.removeColumn('Person', 'signature')","title":"removeColumn(tableName, attributeName, options)"},{"location":"docs/migrations/#changecolumntablename-attributename-datatypeoroptions-options","text":"This method changes the meta data of an attribute. It is possible to change the default value, allowance of null or the data type. Please make sure, that you are completely describing the new data type. queryInterface.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', { type: Sequelize.FLOAT, allowNull: false, defaultValue: 0.0 } )","title":"changeColumn(tableName, attributeName, dataTypeOrOptions, options)"},{"location":"docs/migrations/#renamecolumntablename-attrnamebefore-attrnameafter-options","text":"This methods allows renaming attributes. queryInterface.renameColumn('Person', 'signature', 'sig')","title":"renameColumn(tableName, attrNameBefore, attrNameAfter, options)"},{"location":"docs/migrations/#addindextablename-attributes-options","text":"This methods creates indexes for specific attributes of a table. The index name will be automatically generated if it is not passed via in the options (see below). // This example will create the index person_firstname_lastname queryInterface.addIndex('Person', ['firstname', 'lastname']) // This example will create a unique index with the name SuperDuperIndex using the optional 'options' field. // Possible options: // - indicesType: UNIQUE|FULLTEXT|SPATIAL // - indexName: The name of the index. Default is __ // - parser: For FULLTEXT columns set your parser // - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect // - logging: A function that receives the sql query, e.g. console.log queryInterface.addIndex( 'Person', ['firstname', 'lastname'], { indexName: 'SuperDuperIndex', indicesType: 'UNIQUE' } )","title":"addIndex(tableName, attributes, options)"},{"location":"docs/migrations/#removeindextablename-indexnameorattributes-options","text":"This method deletes an existing index of a table. queryInterface.removeIndex('Person', 'SuperDuperIndex') // or queryInterface.removeIndex('Person', ['firstname', 'lastname'])","title":"removeIndex(tableName, indexNameOrAttributes, options)"},{"location":"docs/migrations/#programmatic-use","text":"Sequelize has a sister library for programmatically handling execution and logging of migration tasks.","title":"Programmatic use"},{"location":"docs/models-definition/","text":"Definition To define mappings between a model and a table, use the define method. Sequelize will then automatically add the attributes createdAt and updatedAt to it. So you will be able to know when the database entry went into the db and when it was updated the last time. If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to configuration to see how to do that. var Project = sequelize.define('project', { title: Sequelize.STRING, description: Sequelize.TEXT }) var Task = sequelize.define('task', { title: Sequelize.STRING, description: Sequelize.TEXT, deadline: Sequelize.DATE }) You can also set some options on each column: var Foo = sequelize.define('foo', { // instantiating will automatically set the flag to true if not set flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // default values for dates => current time myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // setting allowNull to false will add NOT NULL to the column, which means an error will be // thrown from the DB when the query is executed if the column is null. If you want to check that a value // is not null before querying the DB, look at the validations section below. title: { type: Sequelize.STRING, allowNull: false}, // Creating two objects with the same value will throw an error. The unique property can be either a // boolean, or a string. If you provide the same string for multiple columns, they will form a // composite unique key. someUnique: {type: Sequelize.STRING, unique: true}, uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // The unique property is simply a shorthand to create a unique index. someUnique: {type: Sequelize.STRING, unique: true} // It's exactly the same as creating the index in the model's options. {someUnique: {type: Sequelize.STRING}}, {indexes: [{unique: true, fields: ['someUnique']}]} // Go on reading for further information about primary keys identifier: { type: Sequelize.STRING, primaryKey: true}, // autoIncrement can be used to create auto_incrementing integer columns incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, // Comments can be specified for each field for MySQL and PG hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // You can specify a custom field name via the \"field\" attribute: fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" }, // It is possible to create foreign keys: bar_id: { type: Sequelize.INTEGER, references: { // This is a reference to another model model: Bar, // This is the column name of the referenced model key: 'id', // This declares when to check the foreign key constraint. PostgreSQL only. deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }) The comment option can also be used on a table, see model configuration Data types Below are some of the datatypes supported by sequelize. For a full and updated list, see DataTypes . Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT('tiny') // TINYTEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.REAL // REAL PostgreSQL only. Sequelize.REAL(11) // REAL(11) PostgreSQL only. Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only. Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.DATE(6) // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision Sequelize.DATEONLY // DATE without time. Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.ARRAY(Sequelize.ENUM) // Defines an array of enum. PostgreSQL only. Sequelize.JSON // JSON column. PostgreSQL only. Sequelize.JSONB // JSONB column. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically) Sequelize.RANGE(Sequelize.INTEGER) // Defines int4range range. PostgreSQL only. Sequelize.RANGE(Sequelize.BIGINT) // Defined int8range range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATE) // Defines tstzrange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATEONLY) // Defines daterange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DECIMAL) // Defines numrange range. PostgreSQL only. Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only. Sequelize.GEOMETRY // Spatial column. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT') // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT', 4326) // Spatial column with geometry type and SRID. PostgreSQL (with PostGIS) or MySQL only. The BLOB data type allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column. that data will always be returned as a buffer. If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser: require('pg').types.setTypeParser(1114, function(stringValue) { return new Date(stringValue + \"+0000\"); // e.g., UTC offset. Use any offset that you would like. }); In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL! Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL The examples above only show integer, but the same can be done with bigint and float Usage in object notation: // for enums: sequelize.define('model', { states: { type: Sequelize.ENUM, values: ['active', 'pending', 'deleted'] } }) Deferrable When you specify a foreign key column it is optionally possible to declare the deferrable type in PostgreSQL. The following options are available: // Defer all foreign key constraint check to the end of a transaction Sequelize.Deferrable.INITIALLY_DEFERRED // Immediately check the foreign key constraints Sequelize.Deferrable.INITIALLY_IMMEDIATE // Don't defer the checks at all Sequelize.Deferrable.NOT The last option is the default in PostgreSQL and won't allow you to dynamically change the rule in a transaction. See the transaction section for further information. Getters & setters It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties. Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches): as part of a single property definition as part of a model options N.B: If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence. Defining as part of a property var Employee = sequelize.define('employee', { name: { type : Sequelize.STRING, allowNull: false, get : function() { var title = this.getDataValue('title'); // 'this' allows you to access attributes of the instance return this.getDataValue('name') + ' (' + title + ')'; }, }, title: { type : Sequelize.STRING, allowNull: false, set : function(val) { this.setDataValue('title', val.toUpperCase()); } } }); Employee .create({ name: 'John Doe', title: 'senior engineer' }) .then(function(employee) { console.log(employee.get('name')); // John Doe (SENIOR ENGINEER) console.log(employee.get('title')); // SENIOR ENGINEER }) Defining as part of the model options Below is an example of defining the getters and setters in the model options. The fullName getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the VIRTUAL datatype . Virtual datatypes can have validations, while getters for virtual attributes cannot. Note that the this.firstname and this.lastname references in the fullName getter function will trigger a call to the respective getter functions. If you do not want that then use the getDataValue() method to access the raw value (see below). var Foo = sequelize.define('foo', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { getterMethods : { fullName : function() { return this.firstname + ' ' + this.lastname } }, setterMethods : { fullName : function(value) { var names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); }, } }); Helper functions for use inside getter and setter definitions retrieving an underlying property value - always use this.getDataValue() /* a getter for 'title' property */ function() { return this.getDataValue('title'); } setting an underlying property value - always use this.setDataValue() /* a setter for 'title' property */ function(title) { return this.setDataValue('title', title.toString().toLowerCase()); } N.B: It is important to stick to using the setDataValue() and getDataValue() functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations. Validations Model validations, allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on create , update and save . You can also call validate() to manually validate an instance. The validations are implemented by validator.js . var ValidateMe = sequelize.define('foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: [\"[a-z]\",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true, // will only allow alphanumeric characters, so \"_abc\" will fail isNumeric: true, // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: \"2011-11-05\", // only allow date strings after a specific date isBefore: \"2011-11-05\", // only allow date strings before a specific date max: 23, // only allow values min: 23, // only allow values >= 23 isArray: true, // only allow arrays isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }); Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for isIn , this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as [['one', 'two']] as shown above. To use a custom error message instead of that provided by validator.js, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with isInt: { msg: \"Must be an integer number of pennies\" } or if arguments need to also be passed add an args property: isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } When using custom validator functions the error message will be whatever message the thrown Error object holds. See the validator.js project for more details on the built in validation methods. Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged. Validators and allowNull If a particular field of a model is set to allow null (with allowNull: true ) and that value has been set to null , its validators do not run. This means you can, for instance, have a string field which validates its length to be at least 5 characters, but which also allows null . Model validations Validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of latitude and longitude are set or both, and fail if one but not the other is set. Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators. Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the validate option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors. An example: var Pub = Sequelize.define('pub', { name: { type: Sequelize.STRING }, address: { type: Sequelize.STRING }, latitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -90, max: 90 } }, longitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -180, max: 180 } }, }, { validate: { bothCoordsOrNone: function() { if ((this.latitude === null) !== (this.longitude === null)) { throw new Error('Require either both latitude and longitude or neither') } } } }) In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, raging_bullock_arms.validate() might return { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither'] } Configuration You can also influence the way Sequelize handles your column names: var Bar = sequelize.define('bar', { /* bla */ }, { // don't add the timestamp attributes (updatedAt, createdAt) timestamps: false, // don't delete database entries but set the newly added attribute deletedAt // to the current date (when deletion was done). paranoid will only work if // timestamps are enabled paranoid: true, // don't use camelcase for automatically added attributes but underscore style // so updatedAt will be updated_at underscored: true, // disable the modification of table names; By default, sequelize will automatically // transform all passed model names (first parameter of define) into plural. // if you don't want that, set the following freezeTableName: true, // define the table's name tableName: 'my_very_custom_table_name' }) If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually: var Foo = sequelize.define('foo', { /* bla */ }, { // don't forget to enable timestamps! timestamps: true, // I don't want createdAt createdAt: false, // I want updatedAt to actually be called updateTimestamp updatedAt: 'updateTimestamp' // And deletedAt to be called destroyTime (remember to enable paranoid for this to work) deletedAt: 'destroyTime', paranoid: true }) You can also change the database engine, e.g. to MyISAM. InnoDB is the default. var Person = sequelize.define('person', { /* attributes */ }, { engine: 'MYISAM' }) // or globally var sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) Finally you can specify a comment for the table in MySQL and PG var Person = sequelize.define('person', { /* attributes */ }, { comment: \"I'm a table comment!\" }) Import You can also store your model definitions in a single file using the import method. The returned object is exactly the same as defined in the imported file's function. Since v1:5.0 of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often. // in your server file - e.g. app.js var Project = sequelize.import(__dirname + \"/path/to/models/project\") // The model definition is done in /path/to/models/project.js // As you might notice, the DataTypes are the very same as explained above module.exports = function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) } The import method can also accept a callback as an argument. sequelize.import('project', function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) }) Database synchronization When starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables: // Create the tables: Project.sync() Task.sync() // Force the creation! Project.sync({force: true}) // this will drop the table first and re-create it afterwards // drop the tables: Project.drop() Task.drop() // event handling: Project.[sync|drop]().then(function() { // ok ... everything is nice! }).catch(function(error) { // oooh, did you enter wrong database credentials? }) Because synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you: // Sync all models that aren't already in the database sequelize.sync() // Force sync all models sequelize.sync({force: true}) // Drop all tables sequelize.drop() // emit handling: sequelize.[sync|drop]().then(function() { // woot woot }).catch(function(error) { // whooops }) Because .sync({ force: true }) is destructive operation, you can use match option as an additional safety check. match option tells sequelize to match a regex against the database name before syncing - a safety check for cases where force: true is used in tests but not live code. // This will run .sync() only if database name ends with '_test' sequelize.sync({ force: true, match: /_test$/ }); Expansion of models Sequelize allows you to pass custom methods to a model and its instances. Just do the following: var Foo = sequelize.define('foo', { /* attributes */}, { classMethods: { method1: function(){ return 'smth' } }, instanceMethods: { method2: function() { return 'foo' } } }) // Example: Foo.method1() Foo.build().method2() Of course you can also access the instance's data and generate virtual getters: var User = sequelize.define('user', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { instanceMethods: { getFullname: function() { return [this.firstname, this.lastname].join(' ') } } }) // Example: User.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar' You can also set custom methods to all of your models during the instantiation: var sequelize = new Sequelize('database', 'username', 'password', { // Other options during the initialization could be here define: { classMethods: { method1: function() {}, method2: function() {} }, instanceMethods: { method3: function() {} } } }) // Example: var Foo = sequelize.define('foo', { /* attributes */}); Foo.method1() Foo.method2() Foo.build().method3() Indexes Sequelize supports adding indexes to the model definition which will be created during Model.sync() or sequelize.sync . sequelize.define('user', {}, { indexes: [ // Create a unique index on email { unique: true, fields: ['email'] }, // Creates a gin index on data with the jsonb_path_ops operator { fields: ['data'], using: 'gin', operator: 'jsonb_path_ops' }, // By default index name will be [table]_[fields] // Creates a multi column partial index { name: 'public_by_author', fields: ['author', 'status'], where: { status: 'public' } }, // A BTREE index with a ordered field { name: 'title_index', method: 'BTREE', fields: ['author', {attribute: 'title', collate: 'en_US', order: 'DESC', length: 5}] } ] })","title":"Definition"},{"location":"docs/models-definition/#definition","text":"To define mappings between a model and a table, use the define method. Sequelize will then automatically add the attributes createdAt and updatedAt to it. So you will be able to know when the database entry went into the db and when it was updated the last time. If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to configuration to see how to do that. var Project = sequelize.define('project', { title: Sequelize.STRING, description: Sequelize.TEXT }) var Task = sequelize.define('task', { title: Sequelize.STRING, description: Sequelize.TEXT, deadline: Sequelize.DATE }) You can also set some options on each column: var Foo = sequelize.define('foo', { // instantiating will automatically set the flag to true if not set flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // default values for dates => current time myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // setting allowNull to false will add NOT NULL to the column, which means an error will be // thrown from the DB when the query is executed if the column is null. If you want to check that a value // is not null before querying the DB, look at the validations section below. title: { type: Sequelize.STRING, allowNull: false}, // Creating two objects with the same value will throw an error. The unique property can be either a // boolean, or a string. If you provide the same string for multiple columns, they will form a // composite unique key. someUnique: {type: Sequelize.STRING, unique: true}, uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // The unique property is simply a shorthand to create a unique index. someUnique: {type: Sequelize.STRING, unique: true} // It's exactly the same as creating the index in the model's options. {someUnique: {type: Sequelize.STRING}}, {indexes: [{unique: true, fields: ['someUnique']}]} // Go on reading for further information about primary keys identifier: { type: Sequelize.STRING, primaryKey: true}, // autoIncrement can be used to create auto_incrementing integer columns incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, // Comments can be specified for each field for MySQL and PG hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // You can specify a custom field name via the \"field\" attribute: fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" }, // It is possible to create foreign keys: bar_id: { type: Sequelize.INTEGER, references: { // This is a reference to another model model: Bar, // This is the column name of the referenced model key: 'id', // This declares when to check the foreign key constraint. PostgreSQL only. deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }) The comment option can also be used on a table, see model configuration","title":"Definition"},{"location":"docs/models-definition/#data-types","text":"Below are some of the datatypes supported by sequelize. For a full and updated list, see DataTypes . Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT('tiny') // TINYTEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.REAL // REAL PostgreSQL only. Sequelize.REAL(11) // REAL(11) PostgreSQL only. Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only. Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.DATE(6) // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision Sequelize.DATEONLY // DATE without time. Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.ARRAY(Sequelize.ENUM) // Defines an array of enum. PostgreSQL only. Sequelize.JSON // JSON column. PostgreSQL only. Sequelize.JSONB // JSONB column. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically) Sequelize.RANGE(Sequelize.INTEGER) // Defines int4range range. PostgreSQL only. Sequelize.RANGE(Sequelize.BIGINT) // Defined int8range range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATE) // Defines tstzrange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATEONLY) // Defines daterange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DECIMAL) // Defines numrange range. PostgreSQL only. Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only. Sequelize.GEOMETRY // Spatial column. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT') // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT', 4326) // Spatial column with geometry type and SRID. PostgreSQL (with PostGIS) or MySQL only. The BLOB data type allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column. that data will always be returned as a buffer. If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser: require('pg').types.setTypeParser(1114, function(stringValue) { return new Date(stringValue + \"+0000\"); // e.g., UTC offset. Use any offset that you would like. }); In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL! Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL The examples above only show integer, but the same can be done with bigint and float Usage in object notation: // for enums: sequelize.define('model', { states: { type: Sequelize.ENUM, values: ['active', 'pending', 'deleted'] } })","title":"Data types"},{"location":"docs/models-definition/#deferrable","text":"When you specify a foreign key column it is optionally possible to declare the deferrable type in PostgreSQL. The following options are available: // Defer all foreign key constraint check to the end of a transaction Sequelize.Deferrable.INITIALLY_DEFERRED // Immediately check the foreign key constraints Sequelize.Deferrable.INITIALLY_IMMEDIATE // Don't defer the checks at all Sequelize.Deferrable.NOT The last option is the default in PostgreSQL and won't allow you to dynamically change the rule in a transaction. See the transaction section for further information.","title":"Deferrable"},{"location":"docs/models-definition/#getters-setters","text":"It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties. Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches): as part of a single property definition as part of a model options N.B: If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence.","title":"Getters &amp; setters"},{"location":"docs/models-definition/#defining-as-part-of-a-property","text":"var Employee = sequelize.define('employee', { name: { type : Sequelize.STRING, allowNull: false, get : function() { var title = this.getDataValue('title'); // 'this' allows you to access attributes of the instance return this.getDataValue('name') + ' (' + title + ')'; }, }, title: { type : Sequelize.STRING, allowNull: false, set : function(val) { this.setDataValue('title', val.toUpperCase()); } } }); Employee .create({ name: 'John Doe', title: 'senior engineer' }) .then(function(employee) { console.log(employee.get('name')); // John Doe (SENIOR ENGINEER) console.log(employee.get('title')); // SENIOR ENGINEER })","title":"Defining as part of a property"},{"location":"docs/models-definition/#defining-as-part-of-the-model-options","text":"Below is an example of defining the getters and setters in the model options. The fullName getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the VIRTUAL datatype . Virtual datatypes can have validations, while getters for virtual attributes cannot. Note that the this.firstname and this.lastname references in the fullName getter function will trigger a call to the respective getter functions. If you do not want that then use the getDataValue() method to access the raw value (see below). var Foo = sequelize.define('foo', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { getterMethods : { fullName : function() { return this.firstname + ' ' + this.lastname } }, setterMethods : { fullName : function(value) { var names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); }, } });","title":"Defining as part of the model options"},{"location":"docs/models-definition/#helper-functions-for-use-inside-getter-and-setter-definitions","text":"retrieving an underlying property value - always use this.getDataValue() /* a getter for 'title' property */ function() { return this.getDataValue('title'); } setting an underlying property value - always use this.setDataValue() /* a setter for 'title' property */ function(title) { return this.setDataValue('title', title.toString().toLowerCase()); } N.B: It is important to stick to using the setDataValue() and getDataValue() functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations.","title":"Helper functions for use inside getter and setter definitions"},{"location":"docs/models-definition/#validations","text":"Model validations, allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on create , update and save . You can also call validate() to manually validate an instance. The validations are implemented by validator.js . var ValidateMe = sequelize.define('foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: [\"[a-z]\",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true, // will only allow alphanumeric characters, so \"_abc\" will fail isNumeric: true, // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: \"2011-11-05\", // only allow date strings after a specific date isBefore: \"2011-11-05\", // only allow date strings before a specific date max: 23, // only allow values min: 23, // only allow values >= 23 isArray: true, // only allow arrays isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }); Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for isIn , this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as [['one', 'two']] as shown above. To use a custom error message instead of that provided by validator.js, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with isInt: { msg: \"Must be an integer number of pennies\" } or if arguments need to also be passed add an args property: isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } When using custom validator functions the error message will be whatever message the thrown Error object holds. See the validator.js project for more details on the built in validation methods. Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.","title":"Validations"},{"location":"docs/models-definition/#validators-and-allownull","text":"If a particular field of a model is set to allow null (with allowNull: true ) and that value has been set to null , its validators do not run. This means you can, for instance, have a string field which validates its length to be at least 5 characters, but which also allows null .","title":"Validators and allowNull"},{"location":"docs/models-definition/#model-validations","text":"Validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of latitude and longitude are set or both, and fail if one but not the other is set. Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators. Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the validate option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors. An example: var Pub = Sequelize.define('pub', { name: { type: Sequelize.STRING }, address: { type: Sequelize.STRING }, latitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -90, max: 90 } }, longitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -180, max: 180 } }, }, { validate: { bothCoordsOrNone: function() { if ((this.latitude === null) !== (this.longitude === null)) { throw new Error('Require either both latitude and longitude or neither') } } } }) In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, raging_bullock_arms.validate() might return { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither'] }","title":"Model validations"},{"location":"docs/models-definition/#configuration","text":"You can also influence the way Sequelize handles your column names: var Bar = sequelize.define('bar', { /* bla */ }, { // don't add the timestamp attributes (updatedAt, createdAt) timestamps: false, // don't delete database entries but set the newly added attribute deletedAt // to the current date (when deletion was done). paranoid will only work if // timestamps are enabled paranoid: true, // don't use camelcase for automatically added attributes but underscore style // so updatedAt will be updated_at underscored: true, // disable the modification of table names; By default, sequelize will automatically // transform all passed model names (first parameter of define) into plural. // if you don't want that, set the following freezeTableName: true, // define the table's name tableName: 'my_very_custom_table_name' }) If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually: var Foo = sequelize.define('foo', { /* bla */ }, { // don't forget to enable timestamps! timestamps: true, // I don't want createdAt createdAt: false, // I want updatedAt to actually be called updateTimestamp updatedAt: 'updateTimestamp' // And deletedAt to be called destroyTime (remember to enable paranoid for this to work) deletedAt: 'destroyTime', paranoid: true }) You can also change the database engine, e.g. to MyISAM. InnoDB is the default. var Person = sequelize.define('person', { /* attributes */ }, { engine: 'MYISAM' }) // or globally var sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) Finally you can specify a comment for the table in MySQL and PG var Person = sequelize.define('person', { /* attributes */ }, { comment: \"I'm a table comment!\" })","title":"Configuration"},{"location":"docs/models-definition/#import","text":"You can also store your model definitions in a single file using the import method. The returned object is exactly the same as defined in the imported file's function. Since v1:5.0 of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often. // in your server file - e.g. app.js var Project = sequelize.import(__dirname + \"/path/to/models/project\") // The model definition is done in /path/to/models/project.js // As you might notice, the DataTypes are the very same as explained above module.exports = function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) } The import method can also accept a callback as an argument. sequelize.import('project', function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) })","title":"Import"},{"location":"docs/models-definition/#database-synchronization","text":"When starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables: // Create the tables: Project.sync() Task.sync() // Force the creation! Project.sync({force: true}) // this will drop the table first and re-create it afterwards // drop the tables: Project.drop() Task.drop() // event handling: Project.[sync|drop]().then(function() { // ok ... everything is nice! }).catch(function(error) { // oooh, did you enter wrong database credentials? }) Because synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you: // Sync all models that aren't already in the database sequelize.sync() // Force sync all models sequelize.sync({force: true}) // Drop all tables sequelize.drop() // emit handling: sequelize.[sync|drop]().then(function() { // woot woot }).catch(function(error) { // whooops }) Because .sync({ force: true }) is destructive operation, you can use match option as an additional safety check. match option tells sequelize to match a regex against the database name before syncing - a safety check for cases where force: true is used in tests but not live code. // This will run .sync() only if database name ends with '_test' sequelize.sync({ force: true, match: /_test$/ });","title":"Database synchronization"},{"location":"docs/models-definition/#expansion-of-models","text":"Sequelize allows you to pass custom methods to a model and its instances. Just do the following: var Foo = sequelize.define('foo', { /* attributes */}, { classMethods: { method1: function(){ return 'smth' } }, instanceMethods: { method2: function() { return 'foo' } } }) // Example: Foo.method1() Foo.build().method2() Of course you can also access the instance's data and generate virtual getters: var User = sequelize.define('user', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { instanceMethods: { getFullname: function() { return [this.firstname, this.lastname].join(' ') } } }) // Example: User.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar' You can also set custom methods to all of your models during the instantiation: var sequelize = new Sequelize('database', 'username', 'password', { // Other options during the initialization could be here define: { classMethods: { method1: function() {}, method2: function() {} }, instanceMethods: { method3: function() {} } } }) // Example: var Foo = sequelize.define('foo', { /* attributes */}); Foo.method1() Foo.method2() Foo.build().method3()","title":"Expansion of models"},{"location":"docs/models-definition/#indexes","text":"Sequelize supports adding indexes to the model definition which will be created during Model.sync() or sequelize.sync . sequelize.define('user', {}, { indexes: [ // Create a unique index on email { unique: true, fields: ['email'] }, // Creates a gin index on data with the jsonb_path_ops operator { fields: ['data'], using: 'gin', operator: 'jsonb_path_ops' }, // By default index name will be [table]_[fields] // Creates a multi column partial index { name: 'public_by_author', fields: ['author', 'status'], where: { status: 'public' } }, // A BTREE index with a ordered field { name: 'title_index', method: 'BTREE', fields: ['author', {attribute: 'title', collate: 'en_US', order: 'DESC', length: 5}] } ] })","title":"Indexes"},{"location":"docs/models-usage/","text":"Data retrieval / Finders Finder methods are intended to query data from the database. They do not return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for instances . In this document we'll explore what finder methods can do: find - Search for one specific element in the database // search for known ids Project.findById(123).then(function(project) { // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null }) // search for attributes Project.findOne({ where: {title: 'aProject'} }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null }) Project.findOne({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null // project.title will contain the name of the project }) findOrCreate - Search for a specific element or create it if not available The method findOrCreate can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created. Let's assume we have an empty database with a User model which has a username and a job . User .findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: true */ }) The code created a new instance. So when we already have an instance ... User .create({ username: 'fnord', job: 'omnomnom' }) .then(function() { User .findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: false */ }) }) ... the existing entry will not be changed. See the job of the second user, and the fact that created was false. findAndCountAll - Search for multiple elements in the database, returns both data and total count This is a convenience method that combines findAll and count (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a limit and offset but also need to know the total number of records that match the query: The success handler will always receive an object with two properties: count - an integer, total number records matching the where clause rows - an array of objects, the records matching the where clause, within the limit and offset range Project .findAndCountAll({ where: { title: { $like: 'foo%' } }, offset: 10, limit: 2 }) .then(function(result) { console.log(result.count); console.log(result.rows); }); findAndCountAll also supports includes. Only the includes that are marked as required will be added to the count part: Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit: 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted. Adding a where clause to the include automatically makes it required: User.findAndCountAll({ include: [ { model: Profile, where: { active: true }} ], limit: 3 }); The query above will only count users who have an active profile, because required is implicitly set to true when you add a where clause to the include. The options object that you pass to findAndCountAll is the same as for findAll (described below). findAll - Search for multiple elements in the database // find multiple entries Project.findAll().then(function(projects) { // projects will be an array of all Project instances }) // also possible: Project.all().then(function(projects) { // projects will be an array of all Project instances }) // search for specific attributes - hash usage Project.findAll({ where: { name: 'A Project' } }).then(function(projects) { // projects will be an array of Project instances with the specified name }) // search with string replacements Project.findAll({ where: [\"id > ?\", 25] }).then(function(projects) { // projects will be an array of Projects having a greater id than 25 }) // search within a specific range Project.findAll({ where: { id: [1,2,3] } }).then(function(projects) { // projects will be an array of Projects having the id 1, 2 or 3 // this is actually doing an IN query }) Project.findAll({ where: { id: { $and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // id > 6 $gte: 6, // id >= 6 $lt: 10, // id < 10 $lte: 10, // id <= 10 $ne: 20, // id != 20 $between: [6, 10], // BETWEEN 6 AND 10 $notBetween: [11, 15], // NOT BETWEEN 11 AND 15 $in: [1, 2], // IN [1, 2] $notIn: [1, 2], // NOT IN [1, 2] $like: '%hat', // LIKE '%hat' $notLike: '%hat' // NOT LIKE '%hat' $iLike: '%hat' // ILIKE '%hat' (case insensitive) (PG only) $notILike: '%hat' // NOT ILIKE '%hat' (PG only) $overlap: [1, 2] // && [1, 2] (PG array overlap operator) $contains: [1, 2] // @> [1, 2] (PG array contains operator) $contained: [1, 2] // <@ [1, 2] (PG array contained by operator) $any: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only) }, status: { $not: false, // status NOT FALSE } } }) Complex filtering / OR / NOT queries It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use $or , $and or $not : Project.findOne({ where: { name: 'a project', $or: [ { id: [1,2,3] }, { id: { $gt: 10 } } ] } }) Project.findOne({ where: { name: 'a project', id: { $or: [ [1,2,3], { $gt: 10 } ] } } }) Both pieces of code code will generate the following: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` > 10) ) LIMIT 1; $not example: Project.findOne({ where: { name: 'a project', $not: [ { id: [1,2,3] }, { array: { $contains: [3,4,5] } } ] } }); Will generate: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND NOT (`Projects`.`id` IN (1,2,3) OR `Projects`.`array` @> ARRAY[1,2,3]::INTEGER[]) ) LIMIT 1; Manipulating the dataset with limit, offset, order and group To get more relevant data, you can use limit, offset, order and grouping: // limit the results of the query Project.findAll({ limit: 10 }) // step over the first 10 elements Project.findAll({ offset: 10 }) // step over the first 10 elements, and take 2 Project.findAll({ offset: 10, limit: 2 }) The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group Project.findAll({order: 'title DESC'}) // yields ORDER BY title DESC Project.findAll({group: 'name'}) // yields GROUP BY name Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column something.findOne({ order: [ 'name', // will return `name` 'username DESC', // will return `username DESC` -- i.e. don't do it! ['username', 'DESC'], // will return `username` DESC sequelize.fn('max', sequelize.col('age')), // will return max(`age`) [sequelize.fn('max', sequelize.col('age')), 'DESC'], // will return max(`age`) DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // will return otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite! [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC'] // This won't be quoted, but direction will be added ] }) To recap, the elements of the order/group array can be the following: String - will be quoted Array - first element will be quoted, second will be appended verbatim Object - Raw will be added verbatim without quoting Everything else is ignored, and if raw is not set, the query will fail Sequelize.fn and Sequelize.col returns functions and quoted cools Raw queries Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data. // Are you expecting a massive dataset from the DB, // and don't want to spend the time building DAOs for each entry? // You can pass an extra query option to get the raw data instead: Project.findAll({ where: { ... }, raw: true }) count - Count the occurrences of elements in the database There is also a method for counting database objects: Project.count().then(function(c) { console.log(\"There are \" + c + \" projects!\") }) Project.count({ where: [\"id > ?\", 25] }).then(function(c) { console.log(\"There are \" + c + \" projects with an id greater than 25.\") }) max - Get the greatest value of a specific attribute within a specific table And here is a method for getting the max value of an attribute:f /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.max('age').then(function(max) { // this will return 40 }) Project.max('age', { where: { age: { lt: 20 } } }).then(function(max) { // will be 10 }) min - Get the least value of a specific attribute within a specific table And here is a method for getting the min value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.min('age').then(function(min) { // this will return 5 }) Project.min('age', { where: { age: { $gt: 5 } } }).then(function(min) { // will be 10 }) sum - Sum the value of specific attributes In order to calculate the sum over a specific column of a table, you can use the sum method. /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.sum('age').then(function(sum) { // this will return 55 }) Project.sum('age', { where: { age: { $gt: 5 } } }).then(function(sum) { // will be 50 }) Eager loading When you are retrieving data from the database there is a fair chance that you also want to get associations with the same query - this is called eager loading. The basic idea behind that, is the use of the attribute include when you are calling find or findAll . Lets assume the following setup: var User = sequelize.define('user', { name: Sequelize.STRING }) , Task = sequelize.define('task', { name: Sequelize.STRING }) , Tool = sequelize.define('tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().then(function() { // this is where we continue ... }) OK. So, first of all, let's load all tasks with their associated user. Task.findAll({ include: [ User ] }).then(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) Notice that the accessor (the User property in the resulting instance) is singular because the association is one-to-something. Next thing: Loading of data with many-to-something associations! User.findAll({ include: [ Task ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1 }] }] */ }) Notice that the accessor (the Tasks property in the resulting instance) is plural because the association is many-to-something. If an association is aliased (using the as option), you must specify this alias when including the model. Notice how the user's Tool s are aliased as Instruments above. In order to get that right you have to specify the model you want to load, as well as the alias: User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }] */ }) When eager loading we can also filter the associated model using where . This will return all User s in which the where clause of Tool model matches rows. User.findAll({ include: [{ model: Tool, as: 'Instruments', where: { name: { $like: '%ooth%' } } }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], [{ \"name\": \"John Smith\", \"id\": 2, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], */ }) When an eager loaded model is filtered using include.where then include.required is implicitly set to true . This means that an inner join is done returning parent models with any matching children. Including everything To include all attributes, you can pass a single object with all: true : User.findAll({ include: [{ all: true }]}); Including soft deleted records In case you want to eager load soft deleted records you can do that by setting include.paranoid to true User.findAll({ include: [{ model: Tool, where: { name: { $like: '%ooth%' } }, paranoid: true // query and loads the soft deleted records }] }); Ordering Eager Loaded Associations In the case of a one-to-many relationship. Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, 'name' ] ] }); In the case of many-to-many joins, you are also able to sort by attributes in the through table. Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, 'name' ] ] }); Nested eager loading You can use nested eager loading to load all related models of a related model: User.findAll({ include: [ {model: Tool, as: 'Instruments', include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ // 1:M and N:M association \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1, \"Teacher\": { // 1:1 association \"name\": \"Jimi Hendrix\" } }] }] */ }) This will produce an outer join. However, a where clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add required: false . User.findAll({ include: [{ model: Tool, as: 'Instruments', include: [{ model: Teacher, where: { school: \"Woodstock Music School\" }, required: false }] }] }).then(function(users) { /* ... */ }) The query above will return all users, and all their instruments, but only those teachers associated with Woodstock Music School . Include all also supports nested loading: User.findAll({ include: [{ all: true, nested: true }]});","title":"Usage"},{"location":"docs/models-usage/#data-retrieval-finders","text":"Finder methods are intended to query data from the database. They do not return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for instances . In this document we'll explore what finder methods can do:","title":"Data retrieval / Finders"},{"location":"docs/models-usage/#find-search-for-one-specific-element-in-the-database","text":"// search for known ids Project.findById(123).then(function(project) { // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null }) // search for attributes Project.findOne({ where: {title: 'aProject'} }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null }) Project.findOne({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null // project.title will contain the name of the project })","title":"find - Search for one specific element in the database"},{"location":"docs/models-usage/#findorcreate-search-for-a-specific-element-or-create-it-if-not-available","text":"The method findOrCreate can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created. Let's assume we have an empty database with a User model which has a username and a job . User .findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: true */ }) The code created a new instance. So when we already have an instance ... User .create({ username: 'fnord', job: 'omnomnom' }) .then(function() { User .findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: false */ }) }) ... the existing entry will not be changed. See the job of the second user, and the fact that created was false.","title":"findOrCreate - Search for a specific element or create it if not available"},{"location":"docs/models-usage/#findandcountall-search-for-multiple-elements-in-the-database-returns-both-data-and-total-count","text":"This is a convenience method that combines findAll and count (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a limit and offset but also need to know the total number of records that match the query: The success handler will always receive an object with two properties: count - an integer, total number records matching the where clause rows - an array of objects, the records matching the where clause, within the limit and offset range Project .findAndCountAll({ where: { title: { $like: 'foo%' } }, offset: 10, limit: 2 }) .then(function(result) { console.log(result.count); console.log(result.rows); }); findAndCountAll also supports includes. Only the includes that are marked as required will be added to the count part: Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit: 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted. Adding a where clause to the include automatically makes it required: User.findAndCountAll({ include: [ { model: Profile, where: { active: true }} ], limit: 3 }); The query above will only count users who have an active profile, because required is implicitly set to true when you add a where clause to the include. The options object that you pass to findAndCountAll is the same as for findAll (described below).","title":"findAndCountAll - Search for multiple elements in the database, returns both data and total count"},{"location":"docs/models-usage/#findall-search-for-multiple-elements-in-the-database","text":"// find multiple entries Project.findAll().then(function(projects) { // projects will be an array of all Project instances }) // also possible: Project.all().then(function(projects) { // projects will be an array of all Project instances }) // search for specific attributes - hash usage Project.findAll({ where: { name: 'A Project' } }).then(function(projects) { // projects will be an array of Project instances with the specified name }) // search with string replacements Project.findAll({ where: [\"id > ?\", 25] }).then(function(projects) { // projects will be an array of Projects having a greater id than 25 }) // search within a specific range Project.findAll({ where: { id: [1,2,3] } }).then(function(projects) { // projects will be an array of Projects having the id 1, 2 or 3 // this is actually doing an IN query }) Project.findAll({ where: { id: { $and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // id > 6 $gte: 6, // id >= 6 $lt: 10, // id < 10 $lte: 10, // id <= 10 $ne: 20, // id != 20 $between: [6, 10], // BETWEEN 6 AND 10 $notBetween: [11, 15], // NOT BETWEEN 11 AND 15 $in: [1, 2], // IN [1, 2] $notIn: [1, 2], // NOT IN [1, 2] $like: '%hat', // LIKE '%hat' $notLike: '%hat' // NOT LIKE '%hat' $iLike: '%hat' // ILIKE '%hat' (case insensitive) (PG only) $notILike: '%hat' // NOT ILIKE '%hat' (PG only) $overlap: [1, 2] // && [1, 2] (PG array overlap operator) $contains: [1, 2] // @> [1, 2] (PG array contains operator) $contained: [1, 2] // <@ [1, 2] (PG array contained by operator) $any: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only) }, status: { $not: false, // status NOT FALSE } } })","title":"findAll - Search for multiple elements in the database"},{"location":"docs/models-usage/#complex-filtering-or-not-queries","text":"It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use $or , $and or $not : Project.findOne({ where: { name: 'a project', $or: [ { id: [1,2,3] }, { id: { $gt: 10 } } ] } }) Project.findOne({ where: { name: 'a project', id: { $or: [ [1,2,3], { $gt: 10 } ] } } }) Both pieces of code code will generate the following: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` > 10) ) LIMIT 1; $not example: Project.findOne({ where: { name: 'a project', $not: [ { id: [1,2,3] }, { array: { $contains: [3,4,5] } } ] } }); Will generate: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND NOT (`Projects`.`id` IN (1,2,3) OR `Projects`.`array` @> ARRAY[1,2,3]::INTEGER[]) ) LIMIT 1;","title":"Complex filtering / OR / NOT queries"},{"location":"docs/models-usage/#manipulating-the-dataset-with-limit-offset-order-and-group","text":"To get more relevant data, you can use limit, offset, order and grouping: // limit the results of the query Project.findAll({ limit: 10 }) // step over the first 10 elements Project.findAll({ offset: 10 }) // step over the first 10 elements, and take 2 Project.findAll({ offset: 10, limit: 2 }) The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group Project.findAll({order: 'title DESC'}) // yields ORDER BY title DESC Project.findAll({group: 'name'}) // yields GROUP BY name Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column something.findOne({ order: [ 'name', // will return `name` 'username DESC', // will return `username DESC` -- i.e. don't do it! ['username', 'DESC'], // will return `username` DESC sequelize.fn('max', sequelize.col('age')), // will return max(`age`) [sequelize.fn('max', sequelize.col('age')), 'DESC'], // will return max(`age`) DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // will return otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite! [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC'] // This won't be quoted, but direction will be added ] }) To recap, the elements of the order/group array can be the following: String - will be quoted Array - first element will be quoted, second will be appended verbatim Object - Raw will be added verbatim without quoting Everything else is ignored, and if raw is not set, the query will fail Sequelize.fn and Sequelize.col returns functions and quoted cools","title":"Manipulating the dataset with limit, offset, order and group"},{"location":"docs/models-usage/#raw-queries","text":"Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data. // Are you expecting a massive dataset from the DB, // and don't want to spend the time building DAOs for each entry? // You can pass an extra query option to get the raw data instead: Project.findAll({ where: { ... }, raw: true })","title":"Raw queries"},{"location":"docs/models-usage/#count-count-the-occurrences-of-elements-in-the-database","text":"There is also a method for counting database objects: Project.count().then(function(c) { console.log(\"There are \" + c + \" projects!\") }) Project.count({ where: [\"id > ?\", 25] }).then(function(c) { console.log(\"There are \" + c + \" projects with an id greater than 25.\") })","title":"count - Count the occurrences of elements in the database"},{"location":"docs/models-usage/#max-get-the-greatest-value-of-a-specific-attribute-within-a-specific-table","text":"And here is a method for getting the max value of an attribute:f /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.max('age').then(function(max) { // this will return 40 }) Project.max('age', { where: { age: { lt: 20 } } }).then(function(max) { // will be 10 })","title":"max - Get the greatest value of a specific attribute within a specific table"},{"location":"docs/models-usage/#min-get-the-least-value-of-a-specific-attribute-within-a-specific-table","text":"And here is a method for getting the min value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.min('age').then(function(min) { // this will return 5 }) Project.min('age', { where: { age: { $gt: 5 } } }).then(function(min) { // will be 10 })","title":"min - Get the least value of a specific attribute within a specific table"},{"location":"docs/models-usage/#sum-sum-the-value-of-specific-attributes","text":"In order to calculate the sum over a specific column of a table, you can use the sum method. /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.sum('age').then(function(sum) { // this will return 55 }) Project.sum('age', { where: { age: { $gt: 5 } } }).then(function(sum) { // will be 50 })","title":"sum - Sum the value of specific attributes"},{"location":"docs/models-usage/#eager-loading","text":"When you are retrieving data from the database there is a fair chance that you also want to get associations with the same query - this is called eager loading. The basic idea behind that, is the use of the attribute include when you are calling find or findAll . Lets assume the following setup: var User = sequelize.define('user', { name: Sequelize.STRING }) , Task = sequelize.define('task', { name: Sequelize.STRING }) , Tool = sequelize.define('tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().then(function() { // this is where we continue ... }) OK. So, first of all, let's load all tasks with their associated user. Task.findAll({ include: [ User ] }).then(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) Notice that the accessor (the User property in the resulting instance) is singular because the association is one-to-something. Next thing: Loading of data with many-to-something associations! User.findAll({ include: [ Task ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1 }] }] */ }) Notice that the accessor (the Tasks property in the resulting instance) is plural because the association is many-to-something. If an association is aliased (using the as option), you must specify this alias when including the model. Notice how the user's Tool s are aliased as Instruments above. In order to get that right you have to specify the model you want to load, as well as the alias: User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }] */ }) When eager loading we can also filter the associated model using where . This will return all User s in which the where clause of Tool model matches rows. User.findAll({ include: [{ model: Tool, as: 'Instruments', where: { name: { $like: '%ooth%' } } }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], [{ \"name\": \"John Smith\", \"id\": 2, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], */ }) When an eager loaded model is filtered using include.where then include.required is implicitly set to true . This means that an inner join is done returning parent models with any matching children.","title":"Eager loading"},{"location":"docs/models-usage/#including-everything","text":"To include all attributes, you can pass a single object with all: true : User.findAll({ include: [{ all: true }]});","title":"Including everything"},{"location":"docs/models-usage/#including-soft-deleted-records","text":"In case you want to eager load soft deleted records you can do that by setting include.paranoid to true User.findAll({ include: [{ model: Tool, where: { name: { $like: '%ooth%' } }, paranoid: true // query and loads the soft deleted records }] });","title":"Including soft deleted records"},{"location":"docs/models-usage/#ordering-eager-loaded-associations","text":"In the case of a one-to-many relationship. Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, 'name' ] ] }); In the case of many-to-many joins, you are also able to sort by attributes in the through table. Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, 'name' ] ] });","title":"Ordering Eager Loaded Associations"},{"location":"docs/models-usage/#nested-eager-loading","text":"You can use nested eager loading to load all related models of a related model: User.findAll({ include: [ {model: Tool, as: 'Instruments', include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ // 1:M and N:M association \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1, \"Teacher\": { // 1:1 association \"name\": \"Jimi Hendrix\" } }] }] */ }) This will produce an outer join. However, a where clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add required: false . User.findAll({ include: [{ model: Tool, as: 'Instruments', include: [{ model: Teacher, where: { school: \"Woodstock Music School\" }, required: false }] }] }).then(function(users) { /* ... */ }) The query above will return all users, and all their instruments, but only those teachers associated with Woodstock Music School . Include all also supports nested loading: User.findAll({ include: [{ all: true, nested: true }]});","title":"Nested eager loading"},{"location":"docs/querying/","text":"Attributes To select only some attributes, you can use the attributes option. Most often, you pass an array: Model.findAll({ attributes: ['foo', 'bar'] }); SELECT foo, bar ... Attributes can be renamed using a nested array: Model.findAll({ attributes: ['foo', ['bar', 'baz']] }); SELECT foo, bar AS baz ... You can use sequelize.fn to do aggregations: Model.findAll({ attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); SELECT COUNT(hats) AS no_hats ... When using aggregation function, you must give it an alias to be able to access it from the model. In the example above you can get the number of hats with instance.get('no_hats') . Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation: // This is a tiresome way of getting the number of hats... Model.findAll({ attributes: ['id', 'foo', 'bar', 'baz', 'quz', [sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); // This is shorter, and less error prone because it still works if you add / remove attributes Model.findAll({ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] } }); SELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ... Similarly, its also possible to remove a selected few attributes: Model.findAll({ attributes: { exclude: ['baz'] } }); SELECT id, foo, bar, quz ... Where Whether you are querying with findAll/find or doing bulk updates/destroys you can pass a where object to filter the query. where generally takes an object from attribute:value pairs, where value can be primitives for equality matches or keyed objects for other operators. It's also possible to generate complex AND/OR conditions by nesting sets of $or and $and . Basics Post.findAll({ where: { authorId: 2 } }); // SELECT * FROM post WHERE authorId = 2 Post.findAll({ where: { authorId: 12, status: 'active' } }); // SELECT * FROM post WHERE authorId = 12 AND status = 'active'; Post.destroy({ where: { status: 'inactive' } }); // DELETE FROM post WHERE status = 'inactive'; Post.update({ updatedAt: null, }, { where: { deletedAt: { $ne: null } } }); // UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL; Post.findAll({ where: sequelize.where(sequelize.fn('char_length', sequelize.col('status')), 6) }); // SELECT * FROM post WHERE char_length(status) = 6; Operators $and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // > 6 $gte: 6, // >= 6 $lt: 10, // < 10 $lte: 10, // <= 10 $ne: 20, // != 20 $not: true, // IS NOT TRUE $between: [6, 10], // BETWEEN 6 AND 10 $notBetween: [11, 15], // NOT BETWEEN 11 AND 15 $in: [1, 2], // IN [1, 2] $notIn: [1, 2], // NOT IN [1, 2] $like: '%hat', // LIKE '%hat' $notLike: '%hat' // NOT LIKE '%hat' $iLike: '%hat' // ILIKE '%hat' (case insensitive) (PG only) $notILike: '%hat' // NOT ILIKE '%hat' (PG only) $like: { $any: ['cat', 'hat']} // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike $overlap: [1, 2] // && [1, 2] (PG array overlap operator) $contains: [1, 2] // @> [1, 2] (PG array contains operator) $contained: [1, 2] // <@ [1, 2] (PG array contained by operator) $any: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only) $col: 'user.organization_id' // = \"user\".\"organization_id\", with dialect specific column identifiers, PG in this example Combinations { rank: { $or: { $lt: 1000, $eq: null } } } // rank < 1000 OR rank IS NULL { createdAt: { $lt: new Date(), $gt: new Date(new Date() - 24 * 60 * 60 * 1000) } } // createdAt < [timestamp] AND createdAt > [timestamp] { $or: [ { title: { $like: 'Boat%' } }, { description: { $like: '%boat%' } } ] } // title LIKE 'Boat%' OR description LIKE '%boat%' JSONB JSONB can be queried in three different ways. Nested object { meta: { video: { url: { $ne: null } } } } Nested key { \"meta.audio.length\": { $gt: 20 } } Containment { \"meta\": { $contains: { site: { url: 'http://google.com' } } } } Relations / Associations // Find all projects with a least one task where task.state === project.task Project.findAll({ include: [{ model: Task, where: { state: Sequelize.col('project.state') } }] }) Pagination / Limiting // Fetch 10 instances/rows Project.findAll({ limit: 10 }) // Skip 8 instances/rows Project.findAll({ offset: 8 }) // Skip 5 instances and fetch the 5 after that Project.findAll({ offset: 5, limit: 5 }) Ordering order takes an array of items to order the query by. Generally you will want to use a tuple/array of either attribute, direction or just direction to ensure proper escaping. something.findOne({ order: [ // Will escape username and validate DESC against a list of valid direction parameters ['username', 'DESC'], // Will order by max(age) sequelize.fn('max', sequelize.col('age')), // Will order by max(age) DESC [sequelize.fn('max', sequelize.col('age')), 'DESC'], // Will order by otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // Will order by name on an associated User [User, 'name', 'DESC'], // Will order by name on an associated User aliased as Friend [{model: User, as: 'Friend'}, 'name', 'DESC'], // Will order by name on a nested associated Company of an associated User [User, Company, 'name', 'DESC'], ] // All the following statements will be treated literally so should be treated with care order: 'convert(user_name using gbk)' order: 'username DESC' order: sequelize.literal('convert(user_name using gbk)') })","title":"Querying"},{"location":"docs/querying/#attributes","text":"To select only some attributes, you can use the attributes option. Most often, you pass an array: Model.findAll({ attributes: ['foo', 'bar'] }); SELECT foo, bar ... Attributes can be renamed using a nested array: Model.findAll({ attributes: ['foo', ['bar', 'baz']] }); SELECT foo, bar AS baz ... You can use sequelize.fn to do aggregations: Model.findAll({ attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); SELECT COUNT(hats) AS no_hats ... When using aggregation function, you must give it an alias to be able to access it from the model. In the example above you can get the number of hats with instance.get('no_hats') . Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation: // This is a tiresome way of getting the number of hats... Model.findAll({ attributes: ['id', 'foo', 'bar', 'baz', 'quz', [sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); // This is shorter, and less error prone because it still works if you add / remove attributes Model.findAll({ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] } }); SELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ... Similarly, its also possible to remove a selected few attributes: Model.findAll({ attributes: { exclude: ['baz'] } }); SELECT id, foo, bar, quz ...","title":"Attributes"},{"location":"docs/querying/#where","text":"Whether you are querying with findAll/find or doing bulk updates/destroys you can pass a where object to filter the query. where generally takes an object from attribute:value pairs, where value can be primitives for equality matches or keyed objects for other operators. It's also possible to generate complex AND/OR conditions by nesting sets of $or and $and .","title":"Where"},{"location":"docs/querying/#basics","text":"Post.findAll({ where: { authorId: 2 } }); // SELECT * FROM post WHERE authorId = 2 Post.findAll({ where: { authorId: 12, status: 'active' } }); // SELECT * FROM post WHERE authorId = 12 AND status = 'active'; Post.destroy({ where: { status: 'inactive' } }); // DELETE FROM post WHERE status = 'inactive'; Post.update({ updatedAt: null, }, { where: { deletedAt: { $ne: null } } }); // UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL; Post.findAll({ where: sequelize.where(sequelize.fn('char_length', sequelize.col('status')), 6) }); // SELECT * FROM post WHERE char_length(status) = 6;","title":"Basics"},{"location":"docs/querying/#operators","text":"$and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // > 6 $gte: 6, // >= 6 $lt: 10, // < 10 $lte: 10, // <= 10 $ne: 20, // != 20 $not: true, // IS NOT TRUE $between: [6, 10], // BETWEEN 6 AND 10 $notBetween: [11, 15], // NOT BETWEEN 11 AND 15 $in: [1, 2], // IN [1, 2] $notIn: [1, 2], // NOT IN [1, 2] $like: '%hat', // LIKE '%hat' $notLike: '%hat' // NOT LIKE '%hat' $iLike: '%hat' // ILIKE '%hat' (case insensitive) (PG only) $notILike: '%hat' // NOT ILIKE '%hat' (PG only) $like: { $any: ['cat', 'hat']} // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike $overlap: [1, 2] // && [1, 2] (PG array overlap operator) $contains: [1, 2] // @> [1, 2] (PG array contains operator) $contained: [1, 2] // <@ [1, 2] (PG array contained by operator) $any: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only) $col: 'user.organization_id' // = \"user\".\"organization_id\", with dialect specific column identifiers, PG in this example","title":"Operators"},{"location":"docs/querying/#combinations","text":"{ rank: { $or: { $lt: 1000, $eq: null } } } // rank < 1000 OR rank IS NULL { createdAt: { $lt: new Date(), $gt: new Date(new Date() - 24 * 60 * 60 * 1000) } } // createdAt < [timestamp] AND createdAt > [timestamp] { $or: [ { title: { $like: 'Boat%' } }, { description: { $like: '%boat%' } } ] } // title LIKE 'Boat%' OR description LIKE '%boat%'","title":"Combinations"},{"location":"docs/querying/#jsonb","text":"JSONB can be queried in three different ways.","title":"JSONB"},{"location":"docs/querying/#nested-object","text":"{ meta: { video: { url: { $ne: null } } } }","title":"Nested object"},{"location":"docs/querying/#nested-key","text":"{ \"meta.audio.length\": { $gt: 20 } }","title":"Nested key"},{"location":"docs/querying/#containment","text":"{ \"meta\": { $contains: { site: { url: 'http://google.com' } } } }","title":"Containment"},{"location":"docs/querying/#relations-associations","text":"// Find all projects with a least one task where task.state === project.task Project.findAll({ include: [{ model: Task, where: { state: Sequelize.col('project.state') } }] })","title":"Relations / Associations"},{"location":"docs/querying/#pagination-limiting","text":"// Fetch 10 instances/rows Project.findAll({ limit: 10 }) // Skip 8 instances/rows Project.findAll({ offset: 8 }) // Skip 5 instances and fetch the 5 after that Project.findAll({ offset: 5, limit: 5 })","title":"Pagination / Limiting"},{"location":"docs/querying/#ordering","text":"order takes an array of items to order the query by. Generally you will want to use a tuple/array of either attribute, direction or just direction to ensure proper escaping. something.findOne({ order: [ // Will escape username and validate DESC against a list of valid direction parameters ['username', 'DESC'], // Will order by max(age) sequelize.fn('max', sequelize.col('age')), // Will order by max(age) DESC [sequelize.fn('max', sequelize.col('age')), 'DESC'], // Will order by otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // Will order by name on an associated User [User, 'name', 'DESC'], // Will order by name on an associated User aliased as Friend [{model: User, as: 'Friend'}, 'name', 'DESC'], // Will order by name on a nested associated Company of an associated User [User, Company, 'name', 'DESC'], ] // All the following statements will be treated literally so should be treated with care order: 'convert(user_name using gbk)' order: 'username DESC' order: sequelize.literal('convert(user_name using gbk)') })","title":"Ordering"},{"location":"docs/raw-queries/","text":"As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize.query . By default the function will return two arguments - a results array, and an object containing metadata (affected rows etc.). Note that since this is a raw query, the metadata (property names etc.) is dialect specific. Some dialects return the metadata \"within\" the results object (as properties on an array). However, two arguments will always be returned, but for MSSQL and MySQL it will be two references to the same object. sequelize.query(\"UPDATE users SET y = 42 WHERE x = 12\").spread(function(results, metadata) { // Results will be an empty array and metadata will contain the number of affected rows. }) In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do: sequelize.query(\"SELECT * FROM `users`\", { type: sequelize.QueryTypes.SELECT}) .then(function(users) { // We don't need spread here, since only the results will be returned for select queries }) Several other query types are available. Peek into the source for details A second option is the model. If you pass a model the returned data will be instances of that model. // Callee is the model definition. This allows you to easily map a query to a predefined model sequelize.query('SELECT * FROM projects', { model: Projects }).then(function(projects){ // Each record will now be a instance of Project }) Replacements Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? . Replacements are passed in the options object. If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown. sequelize.query('SELECT * FROM projects WHERE status = ?', { replacements: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT * FROM projects WHERE status = :status ', { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) Bind Parameter Bind parameters are like replacements. Except replacements are escaped and inserted into the query by sequelize before the query is sent to the database, while bind parameters are sent to the database outside the SQL query text. A query can have either bind parameters or replacements. Only SQLite and PostgreSQL support bind parameters. Other dialects will insert them into the SQL query in the same way it is done for replacements. Bind parameters are referred to by either $1, $2, ... (numeric) or $key (alpha-numeric). This is independent of the dialect. If an array is passed, $1 is bound to the 1st element in the array ( bind[0] ) If an object is passed, $key is bound to object['key'] . Each key must begin with a non-numeric char. $1 is not a valid key, even if object['1'] exists. In either case $$ can be used to escape a literal $ sign. The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter. The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context $1::varchar . sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1', { bind: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status', { bind: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) })","title":"Raw queries"},{"location":"docs/raw-queries/#replacements","text":"Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? . Replacements are passed in the options object. If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown. sequelize.query('SELECT * FROM projects WHERE status = ?', { replacements: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT * FROM projects WHERE status = :status ', { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) })","title":"Replacements"},{"location":"docs/raw-queries/#bind-parameter","text":"Bind parameters are like replacements. Except replacements are escaped and inserted into the query by sequelize before the query is sent to the database, while bind parameters are sent to the database outside the SQL query text. A query can have either bind parameters or replacements. Only SQLite and PostgreSQL support bind parameters. Other dialects will insert them into the SQL query in the same way it is done for replacements. Bind parameters are referred to by either $1, $2, ... (numeric) or $key (alpha-numeric). This is independent of the dialect. If an array is passed, $1 is bound to the 1st element in the array ( bind[0] ) If an object is passed, $key is bound to object['key'] . Each key must begin with a non-numeric char. $1 is not a valid key, even if object['1'] exists. In either case $$ can be used to escape a literal $ sign. The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter. The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context $1::varchar . sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1', { bind: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status', { bind: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) })","title":"Bind Parameter"},{"location":"docs/schema/","text":"Syncing sequelize.sync() will, based on your model definitions, create any missing tables. If force: true it will first drop tables before recreating them. Migrations / Manual schema changes Sequelize has a sister library for handling execution and logging of migration tasks. Sequelize provides a list of ways to programmatically create or change a table schema. createTable addColumn changeColumn removeColumn addIndex removeIndex addConstraint removeConstraint","title":"Working with table schemas"},{"location":"docs/schema/#syncing","text":"sequelize.sync() will, based on your model definitions, create any missing tables. If force: true it will first drop tables before recreating them.","title":"Syncing"},{"location":"docs/schema/#migrations-manual-schema-changes","text":"Sequelize has a sister library for handling execution and logging of migration tasks. Sequelize provides a list of ways to programmatically create or change a table schema.","title":"Migrations / Manual schema changes"},{"location":"docs/schema/#createtable","text":"","title":"createTable"},{"location":"docs/schema/#addcolumn","text":"","title":"addColumn"},{"location":"docs/schema/#changecolumn","text":"","title":"changeColumn"},{"location":"docs/schema/#removecolumn","text":"","title":"removeColumn"},{"location":"docs/schema/#addindex","text":"","title":"addIndex"},{"location":"docs/schema/#removeindex","text":"","title":"removeIndex"},{"location":"docs/schema/#addconstraint","text":"","title":"addConstraint"},{"location":"docs/schema/#removeconstraint","text":"","title":"removeConstraint"},{"location":"docs/scopes/","text":"Definition Scoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, where , include , limit etc. Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object: var Project = sequelize.define('project', { // Attributes }, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } }, activeUsers: { include: [ { model: User, where: { active: true }} ] } random: function () { return { where: { someNumber: Math.random() } } }, accessLevel: function (value) { return { where: { accessLevel: { $gte: value } } } } } }); You can also add scopes after a model has been defined by calling addScope . This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined. The default scope is always applied. This means, that with the model definition above, Project.findAll() will create the following query: SELECT * FROM projects WHERE active = true The default scope can be removed by calling .unscoped() , .scope(null) , or by invoking another scope: Project.scope('deleted').findAll(); // Removes the default scope SELECT * FROM projects WHERE deleted = true Usage Scopes are applied by calling .scope on the model definition, passing the name of one or more scopes. .scope returns a fully functional model instance with all the regular methods: .findAll , .update , .count , .destroy etc. You can save this model instance and reuse it later: var DeletedProjects = Project.scope('deleted'); DeletedProjects.findAll(); // some time passes // let's look for deleted projects again! DeletedProjects.findAll(); Scopes apply to .find , .findAll , .count , .update and .destroy . Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object: Project.scope('random', { method: ['accessLevel', 19]}).findAll(); SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19 Merging Several scopes can be applied simultaneously by passing an array of scopes to .scope , or by passing the scopes as consecutive arguments. // These two are equivalent Project.scope('deleted', 'activeUsers').findAll(); Project.scope(['deleted', 'activeUsers']).findAll(); SELECT * FROM projects INNER JOIN users ON projects.userId = users.id AND users.active = true If you want to apply another scope alongside the default scope, pass the key defaultScope to .scope : Project.scope('defaultScope', 'deleted').findAll(); SELECT * FROM projects WHERE active = true AND deleted = true When invoking several scopes, keys from subsequent scopes will overwrite previous ones (similar to _.assign ). Consider two scopes: { scope1: { where: { firstName: 'bob', age: { $gt: 20 } }, limit: 2 }, scope2: { where: { age: { $gt: 30 } }, limit: 10 } } Calling .scope('scope1', 'scope2') will yield the following query WHERE firstName = 'bob' AND age > 30 LIMIT 10 Note how limit and age are overwritten by scope2 , while firstName is preserved. limit , offset , order , paranoid , lock and raw are overwritten, while where and include are shallowly merged. This means that identical keys in the where objects, and subsequent includes of the same model will both overwrite each other. The same merge logic applies when passing a find object directly to findAll on a scoped model: Project.scope('deleted').findAll({ where: { firstName: 'john' } }) WHERE deleted = true AND firstName = 'john' Here the deleted scope is merged with the finder. If we were to pass where: { firstName: 'john', deleted: false } to the finder, the deleted scope would be overwritten. Associations Sequelize has two different but related scope concepts in relation to associations. The difference is subtle but important: Association scopes Allow you to specify default attributes when getting and setting associations - useful when implementing polymorphic associations. This scope is only invoked on the association between the two models, when using the get , set , add and create associated model functions Scopes on associated models Allows you to apply default and other scopes when fetching associations, and allows you to pass a scoped model when creating associations. These scopes both apply to regular finds on the model and to find through the association. As an example, consider the models Post and Comment. Comment is associated to several other models (Image, Video etc.) and the association between Comment and other models is polymorphic, which means that Comment stores a commentable column, in addition to the foreign key commentable_id . The polymorphic association can be implemented with an association scope : this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', scope: { commentable: 'post' } }); When calling post.getComments() , this will automatically add WHERE commentable = 'post' . Similarly, when adding new comments to a post, commentable will automagically be set to 'post' . The association scope is meant to live in the background without the programmer having to worry about it - it cannot be disabled. For a more complete polymorphic example, see Association scopes Consider then, that Post has a default scope which only shows active posts: where: { active: true } . This scope lives on the associated model (Post), and not on the association like the commentable scope did. Just like the default scope is applied when calling Post.findAll() , it is also applied when calling User.getPosts() - this will only return the active posts for that user. To disable the default scope, pass scope: null to the getter: User.getPosts({ scope: null }) . Similarly, if you want to apply other scopes, pass an array like you would to .scope : User.getPosts({ scope: ['scope1', 'scope2']}); If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user: var Post = sequelize.define('post', attributes, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } } } }); User.hasMany(Post); // regular getPosts association User.hasMany(Post.scope('deleted'), { as: 'deletedPosts' }); User.getPosts(); // WHERE active = true User.getDeletedPosts(); // WHERE deleted = true","title":"Scopes"},{"location":"docs/scopes/#definition","text":"Scoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, where , include , limit etc. Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object: var Project = sequelize.define('project', { // Attributes }, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } }, activeUsers: { include: [ { model: User, where: { active: true }} ] } random: function () { return { where: { someNumber: Math.random() } } }, accessLevel: function (value) { return { where: { accessLevel: { $gte: value } } } } } }); You can also add scopes after a model has been defined by calling addScope . This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined. The default scope is always applied. This means, that with the model definition above, Project.findAll() will create the following query: SELECT * FROM projects WHERE active = true The default scope can be removed by calling .unscoped() , .scope(null) , or by invoking another scope: Project.scope('deleted').findAll(); // Removes the default scope SELECT * FROM projects WHERE deleted = true","title":"Definition"},{"location":"docs/scopes/#usage","text":"Scopes are applied by calling .scope on the model definition, passing the name of one or more scopes. .scope returns a fully functional model instance with all the regular methods: .findAll , .update , .count , .destroy etc. You can save this model instance and reuse it later: var DeletedProjects = Project.scope('deleted'); DeletedProjects.findAll(); // some time passes // let's look for deleted projects again! DeletedProjects.findAll(); Scopes apply to .find , .findAll , .count , .update and .destroy . Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object: Project.scope('random', { method: ['accessLevel', 19]}).findAll(); SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19","title":"Usage"},{"location":"docs/scopes/#merging","text":"Several scopes can be applied simultaneously by passing an array of scopes to .scope , or by passing the scopes as consecutive arguments. // These two are equivalent Project.scope('deleted', 'activeUsers').findAll(); Project.scope(['deleted', 'activeUsers']).findAll(); SELECT * FROM projects INNER JOIN users ON projects.userId = users.id AND users.active = true If you want to apply another scope alongside the default scope, pass the key defaultScope to .scope : Project.scope('defaultScope', 'deleted').findAll(); SELECT * FROM projects WHERE active = true AND deleted = true When invoking several scopes, keys from subsequent scopes will overwrite previous ones (similar to _.assign ). Consider two scopes: { scope1: { where: { firstName: 'bob', age: { $gt: 20 } }, limit: 2 }, scope2: { where: { age: { $gt: 30 } }, limit: 10 } } Calling .scope('scope1', 'scope2') will yield the following query WHERE firstName = 'bob' AND age > 30 LIMIT 10 Note how limit and age are overwritten by scope2 , while firstName is preserved. limit , offset , order , paranoid , lock and raw are overwritten, while where and include are shallowly merged. This means that identical keys in the where objects, and subsequent includes of the same model will both overwrite each other. The same merge logic applies when passing a find object directly to findAll on a scoped model: Project.scope('deleted').findAll({ where: { firstName: 'john' } }) WHERE deleted = true AND firstName = 'john' Here the deleted scope is merged with the finder. If we were to pass where: { firstName: 'john', deleted: false } to the finder, the deleted scope would be overwritten.","title":"Merging"},{"location":"docs/scopes/#associations","text":"Sequelize has two different but related scope concepts in relation to associations. The difference is subtle but important: Association scopes Allow you to specify default attributes when getting and setting associations - useful when implementing polymorphic associations. This scope is only invoked on the association between the two models, when using the get , set , add and create associated model functions Scopes on associated models Allows you to apply default and other scopes when fetching associations, and allows you to pass a scoped model when creating associations. These scopes both apply to regular finds on the model and to find through the association. As an example, consider the models Post and Comment. Comment is associated to several other models (Image, Video etc.) and the association between Comment and other models is polymorphic, which means that Comment stores a commentable column, in addition to the foreign key commentable_id . The polymorphic association can be implemented with an association scope : this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', scope: { commentable: 'post' } }); When calling post.getComments() , this will automatically add WHERE commentable = 'post' . Similarly, when adding new comments to a post, commentable will automagically be set to 'post' . The association scope is meant to live in the background without the programmer having to worry about it - it cannot be disabled. For a more complete polymorphic example, see Association scopes Consider then, that Post has a default scope which only shows active posts: where: { active: true } . This scope lives on the associated model (Post), and not on the association like the commentable scope did. Just like the default scope is applied when calling Post.findAll() , it is also applied when calling User.getPosts() - this will only return the active posts for that user. To disable the default scope, pass scope: null to the getter: User.getPosts({ scope: null }) . Similarly, if you want to apply other scopes, pass an array like you would to .scope : User.getPosts({ scope: ['scope1', 'scope2']}); If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user: var Post = sequelize.define('post', attributes, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } } } }); User.hasMany(Post); // regular getPosts association User.hasMany(Post.scope('deleted'), { as: 'deletedPosts' }); User.getPosts(); // WHERE active = true User.getDeletedPosts(); // WHERE deleted = true","title":"Associations"},{"location":"docs/transactions/","text":"Sequelize supports two ways of using transactions: One which will automatically commit or rollback the transaction based on the result of a promise chain and, (if enabled) pass the transaction to all calls within the callback And one which leaves committing, rolling back and passing the transaction to the user. The key difference is that the managed transaction uses a callback that expects a promise to be returned to it while the unmanaged transaction returns a promise. Managed transaction (auto-callback) Managed transactions handle committing or rolling back the transaction automagically. You start a managed transaction by passing a callback to sequelize.transaction . Notice how the callback passed to transaction returns a promise chain, and does not explicitly call t.commit() nor t.rollback() . If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back. return sequelize.transaction(function (t) { // chain all your queries here. make sure you return them. return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { return user.setShooter({ firstName: 'John', lastName: 'Boothe' }, {transaction: t}); }); }).then(function (result) { // Transaction has been committed // result is whatever the result of the promise chain returned to the transaction callback }).catch(function (err) { // Transaction has been rolled back // err is whatever rejected the promise chain returned to the transaction callback }); Throw errors to rollback When using the managed transaction you should never commit or rollback the transaction manually. If all queries are successful, but you still want to rollback the transaction (for example because of a validation failure) you should throw an error to break and reject the chain: return sequelize.transaction(function (t) { return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { // Woops, the query was successful but we still want to roll back! throw new Error(); }); }); Automatically pass transactions to all queries In the examples above, the transaction is still manually passed, by passing { transaction: t } as the second argument. To automatically pass the transaction to all queries you must install the continuation local storage (CLS) module and instantiate a namespace in your own code: var cls = require('continuation-local-storage'), namespace = cls.createNamespace('my-very-own-namespace'); To enable CLS you must tell sequelize which namespace to use by setting it as a property on the sequelize constructor: var Sequelize = require('sequelize'); Sequelize.cls = namespace; new Sequelize(....); Notice, that the cls property must be set on the constructor , not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances. CLS works like a thread-local storage for callbacks. What this means in practice is, that different callback chains can access local variables by using the CLS namespace. When CLS is enabled sequelize will set the transaction property on the namespace when a new transaction is created. Since variables set within a callback chain are private to that chain several concurrent transactions can exist at the same time: sequelize.transaction(function (t1) { namespace.get('transaction') === t1; // true }); sequelize.transaction(function (t2) { namespace.get('transaction') === t2; // true }); In most case you won't need to access namespace.get('transaction') directly, since all queries will automatically look for a transaction on the namespace: sequelize.transaction(function (t1) { // With CLS enabled, the user will be created inside the transaction return User.create({ name: 'Alice' }); }); Concurrent/Partial transactions You can have concurrent transactions within a sequence of queries or have some of them excluded from any transactions. Use the {transaction: } option to control which transaction a query belong to: Without CLS enabled sequelize.transaction(function (t1) { return sequelize.transaction(function (t2) { // With CLS enable, queries here will by default use t2 // Pass in the `transaction` option to define/alter the transaction they belong to. return Promise.all([ User.create({ name: 'Bob' }, { transaction: null }), User.create({ name: 'Mallory' }, { transaction: t1 }), User.create({ name: 'John' }) // this would default to t2 ]); }); }); Isolation levels The possible isolations levels to use when starting a transaction: Sequelize.Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // \"READ UNCOMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED // \"READ COMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.REPEATABLE_READ // \"REPEATABLE READ\" Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE // \"SERIALIZABLE\" By default, sequelize uses \"REPEATABLE READ\". If you want to use a different isolation level, pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }, function (t) { // your transactions }); Unmanaged transaction (then-callback) Unmanaged transactions force you to manually rollback or commit the transaction. If you don't do that, the transaction will hang until it times out. To start an unmanaged transaction, call sequelize.transaction() without a callback (you can still pass an options object) and call then on the returned promise. Notice that commit() and rollback() returns a promise. return sequelize.transaction().then(function (t) { return User.create({ firstName: 'Homer', lastName: 'Simpson' }, {transaction: t}).then(function (user) { return user.addSibling({ firstName: 'Lisa', lastName: 'Simpson' }, {transaction: t}); }).then(function () { return t.commit(); }).catch(function (err) { return t.rollback(); }); }); Options The transaction method can be called with an options object as the first argument, that allows the configuration of the transaction. return sequelize.transaction({ /* options */ }); The following options (with it's default values) are available: { autocommit: true, isolationLevel: 'REPEATABLE_READ', deferrable: 'NOT DEFERRABLE' // implicit default of postgres } The isolationLevel can either be set globally when initializing the Sequelize instance or locally for every transaction: // globally new Sequelize('db', 'user', 'pw', { isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); // locally sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); The deferrable option triggers an additional query after the transaction start that optionally set the constraint checks to be deferred or immediate. Please note that this is only supported in PostgreSQL. sequelize.transaction({ // to defer all constraints: deferrable: Sequelize.Deferrable.SET_DEFERRED, // to defer a specific constraint: deferrable: Sequelize.Deferrable.SET_DEFERRED(['some_constraint']), // to not defer constraints: deferrable: Sequelize.Deferrable.SET_IMMEDIATE }) Usage with other sequelize methods The transaction option goes with most other options, which are usually the first argument of a method. For methods that take values, like .create , .update() , .updateAttributes() etc. transaction should be passed to the option in the second argument. If unsure, refer to the API documentation for the method you are using to be sure of the signature.","title":"Transactions"},{"location":"docs/transactions/#managed-transaction-auto-callback","text":"Managed transactions handle committing or rolling back the transaction automagically. You start a managed transaction by passing a callback to sequelize.transaction . Notice how the callback passed to transaction returns a promise chain, and does not explicitly call t.commit() nor t.rollback() . If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back. return sequelize.transaction(function (t) { // chain all your queries here. make sure you return them. return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { return user.setShooter({ firstName: 'John', lastName: 'Boothe' }, {transaction: t}); }); }).then(function (result) { // Transaction has been committed // result is whatever the result of the promise chain returned to the transaction callback }).catch(function (err) { // Transaction has been rolled back // err is whatever rejected the promise chain returned to the transaction callback });","title":"Managed transaction (auto-callback)"},{"location":"docs/transactions/#throw-errors-to-rollback","text":"When using the managed transaction you should never commit or rollback the transaction manually. If all queries are successful, but you still want to rollback the transaction (for example because of a validation failure) you should throw an error to break and reject the chain: return sequelize.transaction(function (t) { return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { // Woops, the query was successful but we still want to roll back! throw new Error(); }); });","title":"Throw errors to rollback"},{"location":"docs/transactions/#automatically-pass-transactions-to-all-queries","text":"In the examples above, the transaction is still manually passed, by passing { transaction: t } as the second argument. To automatically pass the transaction to all queries you must install the continuation local storage (CLS) module and instantiate a namespace in your own code: var cls = require('continuation-local-storage'), namespace = cls.createNamespace('my-very-own-namespace'); To enable CLS you must tell sequelize which namespace to use by setting it as a property on the sequelize constructor: var Sequelize = require('sequelize'); Sequelize.cls = namespace; new Sequelize(....); Notice, that the cls property must be set on the constructor , not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances. CLS works like a thread-local storage for callbacks. What this means in practice is, that different callback chains can access local variables by using the CLS namespace. When CLS is enabled sequelize will set the transaction property on the namespace when a new transaction is created. Since variables set within a callback chain are private to that chain several concurrent transactions can exist at the same time: sequelize.transaction(function (t1) { namespace.get('transaction') === t1; // true }); sequelize.transaction(function (t2) { namespace.get('transaction') === t2; // true }); In most case you won't need to access namespace.get('transaction') directly, since all queries will automatically look for a transaction on the namespace: sequelize.transaction(function (t1) { // With CLS enabled, the user will be created inside the transaction return User.create({ name: 'Alice' }); });","title":"Automatically pass transactions to all queries"},{"location":"docs/transactions/#concurrentpartial-transactions","text":"You can have concurrent transactions within a sequence of queries or have some of them excluded from any transactions. Use the {transaction: } option to control which transaction a query belong to:","title":"Concurrent/Partial transactions"},{"location":"docs/transactions/#without-cls-enabled","text":"sequelize.transaction(function (t1) { return sequelize.transaction(function (t2) { // With CLS enable, queries here will by default use t2 // Pass in the `transaction` option to define/alter the transaction they belong to. return Promise.all([ User.create({ name: 'Bob' }, { transaction: null }), User.create({ name: 'Mallory' }, { transaction: t1 }), User.create({ name: 'John' }) // this would default to t2 ]); }); });","title":"Without CLS enabled"},{"location":"docs/transactions/#isolation-levels","text":"The possible isolations levels to use when starting a transaction: Sequelize.Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // \"READ UNCOMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED // \"READ COMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.REPEATABLE_READ // \"REPEATABLE READ\" Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE // \"SERIALIZABLE\" By default, sequelize uses \"REPEATABLE READ\". If you want to use a different isolation level, pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }, function (t) { // your transactions });","title":"Isolation levels"},{"location":"docs/transactions/#unmanaged-transaction-then-callback","text":"Unmanaged transactions force you to manually rollback or commit the transaction. If you don't do that, the transaction will hang until it times out. To start an unmanaged transaction, call sequelize.transaction() without a callback (you can still pass an options object) and call then on the returned promise. Notice that commit() and rollback() returns a promise. return sequelize.transaction().then(function (t) { return User.create({ firstName: 'Homer', lastName: 'Simpson' }, {transaction: t}).then(function (user) { return user.addSibling({ firstName: 'Lisa', lastName: 'Simpson' }, {transaction: t}); }).then(function () { return t.commit(); }).catch(function (err) { return t.rollback(); }); });","title":"Unmanaged transaction (then-callback)"},{"location":"docs/transactions/#options","text":"The transaction method can be called with an options object as the first argument, that allows the configuration of the transaction. return sequelize.transaction({ /* options */ }); The following options (with it's default values) are available: { autocommit: true, isolationLevel: 'REPEATABLE_READ', deferrable: 'NOT DEFERRABLE' // implicit default of postgres } The isolationLevel can either be set globally when initializing the Sequelize instance or locally for every transaction: // globally new Sequelize('db', 'user', 'pw', { isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); // locally sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); The deferrable option triggers an additional query after the transaction start that optionally set the constraint checks to be deferred or immediate. Please note that this is only supported in PostgreSQL. sequelize.transaction({ // to defer all constraints: deferrable: Sequelize.Deferrable.SET_DEFERRED, // to defer a specific constraint: deferrable: Sequelize.Deferrable.SET_DEFERRED(['some_constraint']), // to not defer constraints: deferrable: Sequelize.Deferrable.SET_IMMEDIATE })","title":"Options"},{"location":"docs/transactions/#usage-with-other-sequelize-methods","text":"The transaction option goes with most other options, which are usually the first argument of a method. For methods that take values, like .create , .update() , .updateAttributes() etc. transaction should be passed to the option in the second argument. If unsure, refer to the API documentation for the method you are using to be sure of the signature.","title":"Usage with other sequelize methods"},{"location":"docs/usage/","text":"Basic usage To get the ball rollin' you first have to create an instance of Sequelize. Use it the following way: var sequelize = new Sequelize('database', 'username'[, 'password']) This will save the passed database credentials and provide all further methods. Furthermore you can specify a non-default host/port: var sequelize = new Sequelize('database', 'username', 'password', { host: \"my.server.tld\", port: 12345 }) If you just don't have a password: var sequelize = new Sequelize('database', 'username') // or var sequelize = new Sequelize('database', 'username', null) You can also use a connection string: var sequelize = new Sequelize('mysql://user:pass@example.com:9821/dbname', { // Look to the next section for possible options }) Options Besides the host and the port, Sequelize comes with a whole bunch of options. Here they are: var sequelize = new Sequelize('database', 'username', 'password', { // custom host; default: localhost host: 'my.server.tld', // custom port; default: 3306 port: 12345, // custom protocol // - default: 'tcp' // - added in: v1.5.0 // - postgres only, useful for heroku protocol: null, // disable logging; default: console.log logging: false, // the sql dialect of the database // - default is 'mysql' // - currently supported: 'mysql', 'sqlite', 'postgres', 'mariadb', 'mssql' dialect: 'mysql', // you can also pass any dialect options to the underlying dialect library // - default is empty // - currently supported: 'mysql', 'mariadb', 'postgres', 'mssql' dialectOptions: { socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock', supportBigNumbers: true, bigNumberStrings: true }, // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite', // disable inserting undefined values as NULL // - default: false omitNull: true, // a flag for using a native library or not. // in the case of 'pg' -- set this to true will allow SSL support // - default: false native: true, // Specify options, which are used when sequelize.define is called. // The following example: // define: {timestamps: false} // is basically the same as: // sequelize.define(name, attributes, { timestamps: false }) // so defining the timestamps for each model will be not necessary // Below you can see the possible keys for settings. All of them are explained on this page define: { underscored: false freezeTableName: false, syncOnAssociation: true, charset: 'utf8', dialectOptions: { collate: 'utf8_general_ci' }, classMethods: {method1: function() {}}, instanceMethods: {method2: function() {}}, timestamps: true }, // similar for sync: you can define this to always force sync for models sync: { force: true }, // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true syncOnAssociation: true, // use pooling in order to reduce db connection overload and to increase speed // currently only for mysql and postgresql (since v1.5.0) pool: { maxConnections: 5, maxIdleTime: 30}, // language is used to determine how to translate words into singular or plural form based on the [lingo project](https://github.com/visionmedia/lingo) // options are: en [default], es language: 'en', // isolation level of each transaction. Defaults to REPEATABLE_READ // options are: // READ_UNCOMMITTED // READ_COMMITTED // REPEATABLE_READ // SERIALIZABLE isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ }) Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged. Read replication Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is not handled by Sequelize, but should be set up in MySql). var sequelize = new Sequelize('database', null, null, { dialect: 'mysql', port: 3306 replication: { read: [ { host: '8.8.8.8', username: 'anotherusernamethanroot', password: 'lolcats!' }, { host: 'localhost', username: 'root', password: null } ], write: { host: 'localhost', username: 'root', password: null } }, pool: { // If you want to override the options used for the read pool you can do so here maxConnections: 20, maxIdleTime: 30000 }, }) If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options: host , port , username , password , database . Sequelize uses a pool to manage connections to your replicas. The default options are: { maxConnections: 10, minConnections: 0, maxIdleTime: 1000 } If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above. Note: Read replication only works for MySQL at the moment! Dialects With the release of Sequelize 1.6.0 , the library got independent from specific dialects. This means, that you'll have to add the respective connector library to your project yourself. Version 1.7.0 stable has been released in bundles with the connector libraries (sequelize-mysql, sequelize-postgres etc.) but these bundles are not maintained, and will not be released for 2.0.0 upwards. MySQL In order to get Sequelize working nicely together with MySQL, you'll need to install mysql@~2.5.0 or higher. Once that's done you can use it like this: var sequelize = new Sequelize('database', 'username', 'password', { // mysql is the default dialect, but you know... // for demo purposes we are defining it nevertheless :) // so: we want mysql! dialect: 'mysql' }) Note: You can pass options directly to dialect library by setting the dialectOptions parameter. See Options for examples (currently only mysql and mariadb are supported). MariaDB For MariaDB compatibility you have to install the package mariasql@~0.1.20 . The configuration needs to look like this: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mariadb' }) SQLite For SQLite compatibility you'll need sqlite3@~3.0.0 . Configure Sequelize like this: var sequelize = new Sequelize('database', 'username', 'password', { // sqlite! now! dialect: 'sqlite', // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite' }) PostgreSQL The library for PostgreSQL is pg@~3.6.0 You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { // gimme postgres, please! dialect: 'postgres' }) MSSQL The library for MSSQL is tedious@^1.7.0 You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mssql' }) Executing raw SQL queries As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize.query . Here is how it works: // Arguments for raw queries sequelize.query('your query', [, options]) // Quick example sequelize.query(\"SELECT * FROM myTable\").then(function(myTableRows) { console.log(myTableRows) }) // If you want to return sequelize instances use the model options. // This allows you to easily map a query to a predefined model for sequelize e.g: sequelize .query('SELECT * FROM projects', { model: Projects }) .then(function(projects){ // Each record will now be mapped to the project's model. console.log(projects) }) // Options is an object with the following keys: sequelize .query('SELECT 1', { // A function (or false) for logging your queries // Will get called for every SQL query that gets send // to the server. logging: console.log, // If plain is true, then sequelize will only return the first // record of the result set. In case of false it will all records. plain: false, // Set this to true if you don't have a model definition for your query. raw: false }) // Note the second argument being null! // Even if we declared a callee here, the raw: true would // supersede and return a raw object. sequelize .query('SELECT * FROM projects', { raw: true }) .then(function(projects) { console.log(projects) }) Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? The syntax used depends on the replacements option passed to the function: If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown. sequelize .query( 'SELECT * FROM projects WHERE status = ?', { raw: true, replacements: ['active'] ) .then(function(projects) { console.log(projects) }) sequelize .query( 'SELECT * FROM projects WHERE status = :status ', { raw: true, replacements: { status: 'active' } } ) .then(function(projects) { console.log(projects) }) One note: If the attribute names of the table contain dots, the resulting objects will be nested: sequelize.query('select 1 as `foo.bar.baz`').then(function(rows) { console.log(JSON.stringify(rows)) /* [{ \"foo\": { \"bar\": { \"baz\": 1 } } }] */ })","title":"Usage"},{"location":"docs/usage/#basic-usage","text":"To get the ball rollin' you first have to create an instance of Sequelize. Use it the following way: var sequelize = new Sequelize('database', 'username'[, 'password']) This will save the passed database credentials and provide all further methods. Furthermore you can specify a non-default host/port: var sequelize = new Sequelize('database', 'username', 'password', { host: \"my.server.tld\", port: 12345 }) If you just don't have a password: var sequelize = new Sequelize('database', 'username') // or var sequelize = new Sequelize('database', 'username', null) You can also use a connection string: var sequelize = new Sequelize('mysql://user:pass@example.com:9821/dbname', { // Look to the next section for possible options })","title":"Basic usage"},{"location":"docs/usage/#options","text":"Besides the host and the port, Sequelize comes with a whole bunch of options. Here they are: var sequelize = new Sequelize('database', 'username', 'password', { // custom host; default: localhost host: 'my.server.tld', // custom port; default: 3306 port: 12345, // custom protocol // - default: 'tcp' // - added in: v1.5.0 // - postgres only, useful for heroku protocol: null, // disable logging; default: console.log logging: false, // the sql dialect of the database // - default is 'mysql' // - currently supported: 'mysql', 'sqlite', 'postgres', 'mariadb', 'mssql' dialect: 'mysql', // you can also pass any dialect options to the underlying dialect library // - default is empty // - currently supported: 'mysql', 'mariadb', 'postgres', 'mssql' dialectOptions: { socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock', supportBigNumbers: true, bigNumberStrings: true }, // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite', // disable inserting undefined values as NULL // - default: false omitNull: true, // a flag for using a native library or not. // in the case of 'pg' -- set this to true will allow SSL support // - default: false native: true, // Specify options, which are used when sequelize.define is called. // The following example: // define: {timestamps: false} // is basically the same as: // sequelize.define(name, attributes, { timestamps: false }) // so defining the timestamps for each model will be not necessary // Below you can see the possible keys for settings. All of them are explained on this page define: { underscored: false freezeTableName: false, syncOnAssociation: true, charset: 'utf8', dialectOptions: { collate: 'utf8_general_ci' }, classMethods: {method1: function() {}}, instanceMethods: {method2: function() {}}, timestamps: true }, // similar for sync: you can define this to always force sync for models sync: { force: true }, // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true syncOnAssociation: true, // use pooling in order to reduce db connection overload and to increase speed // currently only for mysql and postgresql (since v1.5.0) pool: { maxConnections: 5, maxIdleTime: 30}, // language is used to determine how to translate words into singular or plural form based on the [lingo project](https://github.com/visionmedia/lingo) // options are: en [default], es language: 'en', // isolation level of each transaction. Defaults to REPEATABLE_READ // options are: // READ_UNCOMMITTED // READ_COMMITTED // REPEATABLE_READ // SERIALIZABLE isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ }) Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.","title":"Options"},{"location":"docs/usage/#read-replication","text":"Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is not handled by Sequelize, but should be set up in MySql). var sequelize = new Sequelize('database', null, null, { dialect: 'mysql', port: 3306 replication: { read: [ { host: '8.8.8.8', username: 'anotherusernamethanroot', password: 'lolcats!' }, { host: 'localhost', username: 'root', password: null } ], write: { host: 'localhost', username: 'root', password: null } }, pool: { // If you want to override the options used for the read pool you can do so here maxConnections: 20, maxIdleTime: 30000 }, }) If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options: host , port , username , password , database . Sequelize uses a pool to manage connections to your replicas. The default options are: { maxConnections: 10, minConnections: 0, maxIdleTime: 1000 } If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above. Note: Read replication only works for MySQL at the moment!","title":"Read replication"},{"location":"docs/usage/#dialects","text":"With the release of Sequelize 1.6.0 , the library got independent from specific dialects. This means, that you'll have to add the respective connector library to your project yourself. Version 1.7.0 stable has been released in bundles with the connector libraries (sequelize-mysql, sequelize-postgres etc.) but these bundles are not maintained, and will not be released for 2.0.0 upwards.","title":"Dialects"},{"location":"docs/usage/#mysql","text":"In order to get Sequelize working nicely together with MySQL, you'll need to install mysql@~2.5.0 or higher. Once that's done you can use it like this: var sequelize = new Sequelize('database', 'username', 'password', { // mysql is the default dialect, but you know... // for demo purposes we are defining it nevertheless :) // so: we want mysql! dialect: 'mysql' }) Note: You can pass options directly to dialect library by setting the dialectOptions parameter. See Options for examples (currently only mysql and mariadb are supported).","title":"MySQL"},{"location":"docs/usage/#mariadb","text":"For MariaDB compatibility you have to install the package mariasql@~0.1.20 . The configuration needs to look like this: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mariadb' })","title":"MariaDB"},{"location":"docs/usage/#sqlite","text":"For SQLite compatibility you'll need sqlite3@~3.0.0 . Configure Sequelize like this: var sequelize = new Sequelize('database', 'username', 'password', { // sqlite! now! dialect: 'sqlite', // the storage engine for sqlite // - default ':memory:' storage: 'path/to/database.sqlite' })","title":"SQLite"},{"location":"docs/usage/#postgresql","text":"The library for PostgreSQL is pg@~3.6.0 You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { // gimme postgres, please! dialect: 'postgres' })","title":"PostgreSQL"},{"location":"docs/usage/#mssql","text":"The library for MSSQL is tedious@^1.7.0 You'll just need to define the dialect: var sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mssql' })","title":"MSSQL"},{"location":"docs/usage/#executing-raw-sql-queries","text":"As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize.query . Here is how it works: // Arguments for raw queries sequelize.query('your query', [, options]) // Quick example sequelize.query(\"SELECT * FROM myTable\").then(function(myTableRows) { console.log(myTableRows) }) // If you want to return sequelize instances use the model options. // This allows you to easily map a query to a predefined model for sequelize e.g: sequelize .query('SELECT * FROM projects', { model: Projects }) .then(function(projects){ // Each record will now be mapped to the project's model. console.log(projects) }) // Options is an object with the following keys: sequelize .query('SELECT 1', { // A function (or false) for logging your queries // Will get called for every SQL query that gets send // to the server. logging: console.log, // If plain is true, then sequelize will only return the first // record of the result set. In case of false it will all records. plain: false, // Set this to true if you don't have a model definition for your query. raw: false }) // Note the second argument being null! // Even if we declared a callee here, the raw: true would // supersede and return a raw object. sequelize .query('SELECT * FROM projects', { raw: true }) .then(function(projects) { console.log(projects) }) Replacements in a query can be done in two different ways, either using named parameters (starting with : ), or unnamed, represented by a ? The syntax used depends on the replacements option passed to the function: If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown. sequelize .query( 'SELECT * FROM projects WHERE status = ?', { raw: true, replacements: ['active'] ) .then(function(projects) { console.log(projects) }) sequelize .query( 'SELECT * FROM projects WHERE status = :status ', { raw: true, replacements: { status: 'active' } } ) .then(function(projects) { console.log(projects) }) One note: If the attribute names of the table contain dots, the resulting objects will be nested: sequelize.query('select 1 as `foo.bar.baz`').then(function(rows) { console.log(JSON.stringify(rows)) /* [{ \"foo\": { \"bar\": { \"baz\": 1 } } }] */ })","title":"Executing raw SQL queries"}]}