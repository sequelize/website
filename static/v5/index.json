[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/associations/base.js",
    "content": "'use strict';\n\nconst { AssociationError } = require('./../errors');\n\n/**\n * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).\n *\n * * hasOne - adds a foreign key to the target and singular association mixins to the source.\n * * belongsTo - add a foreign key and singular association mixins to the source.\n * * hasMany - adds a foreign key to target and plural association mixins to the source.\n * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.\n *\n * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.\n *\n * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.\n *\n * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.\n *\n * ```js\n * User.hasMany(Picture)\n * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })\n *\n * user.getPictures() // gets you all pictures\n * user.getProfilePicture() // gets you only the profile picture\n *\n * User.findAll({\n *   where: ...,\n *   include: [\n *     { model: Picture }, // load all pictures\n *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture.\n *     // Notice that the spelling must be the exact same as the one in the association\n *   ]\n * })\n * ```\n * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,\n * equivalent to those passed to `sequelize.define`.\n *\n * ```js\n * User.hasMany(Picture, { foreignKey: 'uid' })\n * ```\n *\n * The foreign key column in Picture will now be called `uid` instead of the default `userId`.\n *\n * ```js\n * User.hasMany(Picture, {\n *   foreignKey: {\n *     name: 'uid',\n *     allowNull: false\n *   }\n * })\n * ```\n *\n * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).\n *\n * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:\n *\n * ```js\n * user.getPictures({\n *   where: {\n *     format: 'jpg'\n *   }\n * })\n * ```\n *\n * There are several ways to update and add new associations. Continuing with our example of users and pictures:\n * ```js\n * user.addPicture(p) // Add a single picture\n * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted\n * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations\n * ```\n *\n * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:\n *\n * ```js\n * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture\n * ```\n *\n * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.\n *\n * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.\n */\nclass Association {\n  constructor(source, target, options = {}) {\n    /**\n     * @type {Model}\n     */\n    this.source = source;\n\n    /**\n     * @type {Model}\n     */\n    this.target = target;\n\n    this.options = options;\n    this.scope = options.scope;\n    this.isSelfAssociation = this.source === this.target;\n    this.as = options.as;\n\n    /**\n     * The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`\n     * @type {string}\n     */\n    this.associationType = '';\n\n    if (source.hasAlias(options.as)) {\n      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. ` +\n      'Aliased associations must have unique aliases.'\n      );\n    }\n  }\n\n  /**\n   * Normalize input\n   *\n   * @param {Array|string} input it may be array or single obj, instance or primary key\n   *\n   * @private\n   * @returns {Array} built objects\n   */\n  toInstanceArray(input) {\n    if (!Array.isArray(input)) {\n      input = [input];\n    }\n\n    return input.map(element => {\n      if (element instanceof this.target) return element;\n\n      const tmpInstance = {};\n      tmpInstance[this.target.primaryKeyAttribute] = element;\n\n      return this.target.build(tmpInstance, { isNewRecord: false });\n    });\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.as;\n  }\n\n  inspect() {\n    return this.as;\n  }\n}\n\nmodule.exports = Association;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/base.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "AssociationError",
    "memberof": "lib/associations/base.js",
    "static": true,
    "longname": "lib/associations/base.js~AssociationError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/base.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "class",
    "name": "Association",
    "memberof": "lib/associations/base.js",
    "static": true,
    "longname": "lib/associations/base.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/base.js",
    "importStyle": null,
    "description": "Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).\n\n* hasOne - adds a foreign key to the target and singular association mixins to the source.\n* belongsTo - add a foreign key and singular association mixins to the source.\n* hasMany - adds a foreign key to target and plural association mixins to the source.\n* belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.\n\nCreating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.\n\nWhen creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.\n\nAs an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.\n\n```js\nUser.hasMany(Picture)\nUser.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })\n\nuser.getPictures() // gets you all pictures\nuser.getProfilePicture() // gets you only the profile picture\n\nUser.findAll({\n  where: ...,\n  include: [\n    { model: Picture }, // load all pictures\n    { model: Picture, as: 'ProfilePicture' }, // load the profile picture.\n    // Notice that the spelling must be the exact same as the one in the association\n  ]\n})\n```\nTo get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,\nequivalent to those passed to `sequelize.define`.\n\n```js\nUser.hasMany(Picture, { foreignKey: 'uid' })\n```\n\nThe foreign key column in Picture will now be called `uid` instead of the default `userId`.\n\n```js\nUser.hasMany(Picture, {\n  foreignKey: {\n    name: 'uid',\n    allowNull: false\n  }\n})\n```\n\nThis specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).\n\nWhen fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:\n\n```js\nuser.getPictures({\n  where: {\n    format: 'jpg'\n  }\n})\n```\n\nThere are several ways to update and add new associations. Continuing with our example of users and pictures:\n```js\nuser.addPicture(p) // Add a single picture\nuser.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted\nuser.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations\n```\n\nYou don't have to pass in a complete object to the association functions, if your associated model has a single primary key:\n\n```js\nuser.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture\n```\n\nIn the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.\n\nNote how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.",
    "lineNumber": 82,
    "interface": false
  },
  {
    "__docId__": 51,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/associations/base.js~Association",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/base.js~Association#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "source",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#source",
    "access": "public",
    "description": "",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "target",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#target",
    "access": "public",
    "description": "",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "options",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#options",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "scope",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#scope",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "isSelfAssociation",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#isSelfAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "as",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#as",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "associationType",
    "memberof": "lib/associations/base.js~Association",
    "static": false,
    "longname": "lib/associations/base.js~Association#associationType",
    "access": "public",
    "description": "The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "toInstanceArray",
    "memberof": "lib/associations/base.js~Association",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/base.js~Association#toInstanceArray",
    "access": "private",
    "description": "Normalize input",
    "lineNumber": 120,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array} built objects"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "it may be array or single obj, instance or primary key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "built objects"
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "[Symbol.for('nodejs.util.inspect.custom')]",
    "memberof": "lib/associations/base.js~Association",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/base.js~Association#[Symbol.for('nodejs.util.inspect.custom')]",
    "access": "public",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "inspect",
    "memberof": "lib/associations/base.js~Association",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/base.js~Association#inspect",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "lib/associations/belongs-to-many.js",
    "content": "'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(project => {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(projects => {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = Object.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: false, // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, { type: sourceKeyType });\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, { type: targetKeyType });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = _.clone(this.scope);\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    return this.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = Object.assign({\n      raw: true\n    }, options, {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    return this.get(sourceInstance, options).then(associatedObjects =>\n      _.differenceWith(instancePrimaryKeys, associatedObjects,\n        (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0\n    );\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, this.through.scope);\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        const where = Object.assign({\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier])\n        }, this.through.scope);\n        promises.push(\n          this.through.model.destroy(_.defaults({\n            where\n          }, options))\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          attributes = _.defaults(attributes, unassociatedObject[this.through.model.name], defaultAttributes);\n\n          Object.assign(attributes, this.through.scope);\n          attributes = Object.assign(attributes, this.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, Object.assign({ validate: true }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return this.through.model.findAll(_.defaults({ where, raw: true }, options))\n      .then(currentRows => updateAssociations(currentRows))\n      .catch(error => {\n        if (error instanceof EmptyResultError) return updateAssociations([]);\n        throw error;\n      });\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n\n    options = _.clone(options) || {};\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey))\n    };\n\n    Object.assign(where, association.through.scope);\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, Object.assign({ validate: true }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        const where = {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        };\n\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where })));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return association.through.model.findAll(_.defaults({ where, raw: true }, options))\n      .then(currentRows => updateAssociations(currentRows))\n      .then(([associations]) => associations)\n      .catch(error => {\n        if (error instanceof EmptyResultError) return updateAssociations();\n        throw error;\n      });\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy(_.defaults({ where }, options));\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {Object} [values] values for target model\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    return association.target.create(values, options).then(newAssociatedObject =>\n      sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject)\n    );\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/belongs-to-many.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 64,
    "kind": "variable",
    "name": "Helpers",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~Helpers",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "name": "BelongsTo",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "HasMany",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~HasMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "variable",
    "name": "HasOne",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~HasOne",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "name": "AssociationError",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~AssociationError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "variable",
    "name": "EmptyResultError",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~EmptyResultError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "class",
    "name": "BelongsToMany",
    "memberof": "lib/associations/belongs-to-many.js",
    "static": true,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to-many.js",
    "importStyle": null,
    "description": "Many-to-many association with a join table.\n\nWhen the join table has additional attributes, these can be passed in the options object:\n\n```js\nUserProject = sequelize.define('user_project', {\n  role: Sequelize.STRING\n});\nUser.belongsToMany(Project, { through: UserProject });\nProject.belongsToMany(User, { through: UserProject });\n// through is required!\n\nuser.addProject(project, { through: { role: 'manager' }});\n```\n\nAll methods allow you to pass either a persisted instance, its primary key, or a mixture:\n\n```js\nProject.create({ id: 11 }).then(project => {\n  user.addProjects([project, 12]);\n});\n```\n\nIf you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n\n```js\np1.UserProjects = {\n  started: true\n}\nuser.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n```\n\nSimilarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n```js\nuser.getProjects().then(projects => {\n  let p1 = projects[0]\n  p1.UserProjects.started // Is this project started yet?\n})\n```\n\nIn the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.",
    "see": [
      "{@link Model.belongsToMany}"
    ],
    "lineNumber": 59,
    "interface": false,
    "extends": [
      "Association"
    ]
  },
  {
    "__docId__": 74,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "associationType",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#associationType",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "targetAssociation",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#targetAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "through",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#through",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "isMultiAssociation",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#isMultiAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "doubleLinked",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#doubleLinked",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "isAliased",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#isAliased",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "as",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#as",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "combinedTableName",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#combinedTableName",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "paired",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#paired",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "sourceKey",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#sourceKey",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "sourceKeyField",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#sourceKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "targetKey",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#targetKey",
    "access": "public",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "targetKeyField",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#targetKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "targetKeyDefault",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#targetKeyDefault",
    "access": "public",
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "options",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#options",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "otherKey",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#otherKey",
    "access": "public",
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "throughModel",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#throughModel",
    "access": "public",
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "associationAccessor",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#associationAccessor",
    "access": "public",
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "accessors",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#accessors",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "type": {
      "types": [
        "{\"get\": *, \"set\": *, \"addMultiple\": *, \"add\": *, \"create\": *, \"remove\": *, \"removeMultiple\": *, \"hasSingle\": *, \"hasAll\": *, \"count\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_createForeignAndOtherKeys",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#_createForeignAndOtherKeys",
    "access": "private",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "foreignKeyAttribute",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#foreignKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 229,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "foreignKey",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#foreignKey",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "otherKeyAttribute",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#otherKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "otherKeyDefault",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#otherKeyDefault",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "_injectAttributes",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#_injectAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "identifier",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#identifier",
    "access": "public",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "foreignIdentifier",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#foreignIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "primaryKeyDeleted",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#primaryKeyDeleted",
    "access": "public",
    "description": null,
    "lineNumber": 277,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "identifierField",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#identifierField",
    "access": "public",
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "foreignIdentifierField",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#foreignIdentifierField",
    "access": "public",
    "description": null,
    "lineNumber": 344,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "toSource",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#toSource",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "manyFromSource",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#manyFromSource",
    "access": "public",
    "description": null,
    "lineNumber": 353,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "oneFromSource",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#oneFromSource",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "toTarget",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#toTarget",
    "access": "public",
    "description": null,
    "lineNumber": 361,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "manyFromTarget",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#manyFromTarget",
    "access": "public",
    "description": null,
    "lineNumber": 364,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "oneFromTarget",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#oneFromTarget",
    "access": "public",
    "description": null,
    "lineNumber": 367,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "mixin",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#mixin",
    "access": "public",
    "description": null,
    "lineNumber": 388,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "get",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#get",
    "access": "public",
    "description": "Get everything currently associated with this, using an optional where clause.",
    "see": [
      "{@link Model} for a full explanation of options"
    ],
    "lineNumber": 414,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<Model>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "An optional where clause to limit the associated models"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.schema",
        "description": "Apply a schema on the related model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<Model>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "count",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#count",
    "access": "public",
    "description": "Count everything currently associated with this, using an optional where clause.",
    "lineNumber": 482,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "An optional where clause to limit the associated models"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "has",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#has",
    "access": "public",
    "description": "Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated",
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<boolean>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance to check for an association with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "instances",
        "description": "Can be an array of instances or their primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to getAssociations"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "set",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#set",
    "access": "public",
    "description": "Set the associated models by passing an array of instances or their primary keys.\nEverything that it not in the passed array will be un-associated.",
    "lineNumber": 552,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance to associate new instances with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "newAssociatedObjects",
        "description": "A single instance or primary key, or a mixed array of persisted instances or primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.validate",
        "description": "Run validation for the join model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.through",
        "description": "Additional attributes for the join table."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "add",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#add",
    "access": "public",
    "description": "Associate one or several rows with source instance. It will not un-associate any already associated instance\nthat may be missing from `newInstances`.",
    "lineNumber": 660,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance to associate new instances with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "newInstances",
        "description": "A single instance or primary key, or a mixed array of persisted instances or primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `through.findAll`, `bulkCreate` and `update`"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.validate",
        "description": "Run validation for the join model."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.through",
        "description": "Additional attributes for the join table."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "remove",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#remove",
    "access": "public",
    "description": "Un-associate one or more instance(s).",
    "lineNumber": 754,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "instance to un associate instances with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string",
          "string[]",
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "oldAssociatedObjects",
        "description": "Can be an Instance or its primary key, or a mixed array of instances and primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `through.destroy`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "create",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#create",
    "access": "public",
    "description": "Create a new instance of the associated model and associate it with this.",
    "lineNumber": 779,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "values",
        "description": "values for target model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to create and add"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.through",
        "description": "Additional attributes for the join table"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "verifyAssociationAlias",
    "memberof": "lib/associations/belongs-to-many.js~BelongsToMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to-many.js~BelongsToMany#verifyAssociationAlias",
    "access": "public",
    "description": null,
    "lineNumber": 804,
    "undocument": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 132,
    "kind": "file",
    "name": "lib/associations/belongs-to.js",
    "content": "'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.as,\n          this.target.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (\n      this.options.targetKey\n      && !this.target.rawAttributes[this.options.targetKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the source table\n  _injectAttributes() {\n    const newAttributes = {};\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n    this.source.refreshAttributes();\n\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {string}         [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(this.foreignKey, { raw: true })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.targetKey, { raw: true })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options={}] options passed to `this.save`\n   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   *\n   *  @returns {Promise}\n   */\n  set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = Object.assign({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n\n    // passes the changed field to save, so only that field get updated.\n    return sourceInstance.save(options);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options={}] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create}  for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    return this.target.create(values, options)\n      .then(newAssociatedObject => sourceInstance[this.accessors.set](newAssociatedObject, options)\n        .then(() => newAssociatedObject)\n      );\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/belongs-to.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 133,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "Helpers",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~Helpers",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "BelongsTo",
    "memberof": "lib/associations/belongs-to.js",
    "static": true,
    "longname": "lib/associations/belongs-to.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/belongs-to.js",
    "importStyle": null,
    "description": "One-to-one association\n\nIn the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.",
    "see": [
      "{@link Model.belongsTo}"
    ],
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "Association"
    ]
  },
  {
    "__docId__": 139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "associationType",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#associationType",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "isSingleAssociation",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#isSingleAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "foreignKeyAttribute",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#foreignKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "isAliased",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#isAliased",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "as",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#as",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "foreignKey",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#foreignKey",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "identifier",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#identifier",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "identifierField",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#identifierField",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "targetKey",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#targetKey",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "targetKeyField",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#targetKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "targetKeyIsPrimary",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#targetKeyIsPrimary",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "targetIdentifier",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#targetIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "associationAccessor",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#associationAccessor",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "accessors",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#accessors",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "{\"get\": *, \"set\": *, \"create\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "_injectAttributes",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#_injectAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "mixin",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#mixin",
    "access": "public",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "get",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#get",
    "access": "public",
    "description": "Get the associated instance.",
    "see": [
      "{@link Model.findOne} for a full explanation of options"
    ],
    "lineNumber": 126,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model",
          "Array<Model>"
        ],
        "spread": false,
        "optional": false,
        "name": "instances",
        "description": "source instances"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.schema",
        "description": "Apply a schema on the related model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "set",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#set",
    "access": "public",
    "description": "Set the associated model.",
    "lineNumber": 194,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": true,
        "types": [
          "<Model>",
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "associatedInstance",
        "description": "An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "options passed to `this.save`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.save",
        "description": "Skip saving this after setting the foreign key if false."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "create",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#create",
    "access": "public",
    "description": "Create a new instance of the associated model and associate it with this.",
    "see": [
      "{@link Model#create}  for a full explanation of options"
    ],
    "lineNumber": 227,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>} The created target model"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "values",
        "description": "values to create associated model instance with"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Options passed to `target.create` and setAssociation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": "The created target model"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "verifyAssociationAlias",
    "memberof": "lib/associations/belongs-to.js~BelongsTo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/belongs-to.js~BelongsTo#verifyAssociationAlias",
    "access": "public",
    "description": null,
    "lineNumber": 237,
    "undocument": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "file",
    "name": "lib/associations/has-many.js",
    "content": "'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n     * Foreign key setup\n     */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    /*\n     * Source key setup\n     */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n\n    // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    const newAttributes = {};\n    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    const constraintOptions = _.clone(this.options);\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findAll}  for a full explanation of options\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  get(instances, options = {}) {\n    const where = {};\n\n    let Model = this.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = Object.assign({}, options);\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    if (instances) {\n      values = instances.map(instance => instance.get(this.sourceKey, { raw: true }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this, // association\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return Model.findAll(options).then(results => {\n      if (instance) return results;\n\n      const result = {};\n      for (const instance of instances) {\n        result[instance.get(this.sourceKey, { raw: true })] = [];\n      }\n\n      for (const instance of results) {\n        result[instance.get(this.foreignKey, { raw: true })].push(instance);\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model}        instance the source instance\n   * @param {Object}         [options] find & count options\n   * @param {Object}         [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  count(instance, options) {\n    options = Utils.cloneDeep(options);\n\n    options.attributes = [\n      [\n        this.sequelize.fn(\n          'COUNT',\n          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)\n        ),\n        'count'\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    return this.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise}\n   */\n  has(sourceInstance, targetInstances, options) {\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = Object.assign({}, options, {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    return this.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === targetInstances.length);\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `target.findAll` and `update`.\n   * @param {Object} [options.validate] Run validation for the join model\n   *\n   * @returns {Promise}\n   */\n  set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n\n    return this.get(sourceInstance, _.defaults({ scope: false, raw: true }, options)).then(oldAssociations => {\n      const promises = [];\n      const obsoleteAssociations = oldAssociations.filter(old =>\n        !targetInstances.find(obj =>\n          obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n        )\n      );\n      const unassociatedObjects = targetInstances.filter(obj =>\n        !oldAssociations.find(old =>\n          obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n        )\n      );\n      let updateWhere;\n      let update;\n\n      if (obsoleteAssociations.length > 0) {\n        update = {};\n        update[this.foreignKey] = null;\n\n        updateWhere = {\n          [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>\n            associatedObject[this.target.primaryKeyAttribute]\n          )\n        };\n\n\n        promises.push(this.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        updateWhere = {};\n\n        update = {};\n        update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n\n        Object.assign(update, this.scope);\n        updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n          unassociatedObject[this.target.primaryKeyAttribute]\n        );\n\n        promises.push(this.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      return Utils.Promise.all(promises).return(sourceInstance);\n    });\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `target.update`.\n   *\n   * @returns {Promise}\n   */\n  add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances) return Utils.Promise.resolve();\n\n    const update = {};\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    Object.assign(update, this.scope);\n\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>\n        unassociatedObject.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    return this.target.unscoped().update(update, _.defaults({ where }, options)).return(sourceInstance);\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `target.update`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>\n        targetInstance.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    return this.target.unscoped().update(update, _.defaults({ where }, options)).return(this);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {Object} [values] values for target model instance\n   * @param {Object} [options] Options passed to `target.create`\n   *\n   * @returns {Promise}\n   */\n  create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/has-many.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 165,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 166,
    "kind": "variable",
    "name": "Helpers",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~Helpers",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 167,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 170,
    "kind": "class",
    "name": "HasMany",
    "memberof": "lib/associations/has-many.js",
    "static": true,
    "longname": "lib/associations/has-many.js~HasMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-many.js",
    "importStyle": null,
    "description": "One-to-many association\n\nIn the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\nIf the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.",
    "see": [
      "{@link Model.hasMany}"
    ],
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "Association"
    ]
  },
  {
    "__docId__": 171,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "associationType",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#associationType",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "targetAssociation",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#targetAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "isMultiAssociation",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#isMultiAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "foreignKeyAttribute",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#foreignKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "isAliased",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#isAliased",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "member",
    "name": "as",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#as",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "foreignKey",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#foreignKey",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "identifierField",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#identifierField",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "foreignKeyField",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#foreignKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "sourceKey",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#sourceKey",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "sourceKeyAttribute",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#sourceKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "sourceKeyField",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#sourceKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "associationAccessor",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#associationAccessor",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "accessors",
    "memberof": "lib/associations/has-many.js~HasMany",
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#accessors",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "{\"get\": *, \"set\": *, \"addMultiple\": *, \"add\": *, \"create\": *, \"remove\": *, \"removeMultiple\": *, \"hasSingle\": *, \"hasAll\": *, \"count\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "_injectAttributes",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#_injectAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "mixin",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#mixin",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "get",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#get",
    "access": "public",
    "description": "Get everything currently associated with this, using an optional where clause.",
    "see": [
      "{@link Model.findAll}  for a full explanation of options"
    ],
    "lineNumber": 171,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<Model>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model",
          "Array<Model>"
        ],
        "spread": false,
        "optional": false,
        "name": "instances",
        "description": "source instances"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "An optional where clause to limit the associated models"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.schema",
        "description": "Apply a schema on the related model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<Model>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "count",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#count",
    "access": "public",
    "description": "Count everything currently associated with this, using an optional where clause.",
    "lineNumber": 252,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": "the source instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find & count options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "An optional where clause to limit the associated models"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "has",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#has",
    "access": "public",
    "description": "Check if one or more rows are associated with `this`.",
    "lineNumber": 279,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "targetInstances",
        "description": "Can be an array of instances or their primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to getAssociations"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "set",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#set",
    "access": "public",
    "description": "Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated",
    "lineNumber": 321,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance to associate new instances with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "targetInstances",
        "description": "An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `target.findAll` and `update`."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.validate",
        "description": "Run validation for the join model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "add",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#add",
    "access": "public",
    "description": "Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\nor a mixed array of Model / string / numbers to associate multiple rows.",
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string[]",
          "string",
          "number[]",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "targetInstances",
        "description": "A single instance or primary key, or a mixed array of persisted instances or primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `target.update`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "remove",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#remove",
    "access": "public",
    "description": "Un-associate one or several target rows.",
    "lineNumber": 423,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "instance to un associate instances with"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "Model[]",
          "string",
          "string[]",
          "number",
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "targetInstances",
        "description": "Can be an Instance or its primary key, or a mixed array of instances and primary keys"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `target.update`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "create",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#create",
    "access": "public",
    "description": "Create a new instance of the associated model and associate it with this.",
    "lineNumber": 449,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "source instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "values",
        "description": "values for target model instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `target.create`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "verifyAssociationAlias",
    "memberof": "lib/associations/has-many.js~HasMany",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-many.js~HasMany#verifyAssociationAlias",
    "access": "public",
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "file",
    "name": "lib/associations/has-one.js",
    "content": "'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          Utils.singularize(this.options.as || this.source.name),\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (\n      this.options.sourceKey\n      && !this.source.rawAttributes[this.options.sourceKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the target table\n  _injectAttributes() {\n    const newAttributes = {};\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  get(instances, options) {\n    const where = {};\n\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(this.sourceKey, { raw: true })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.foreignKey, { raw: true })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   *\n   * @returns {Promise}\n   */\n  set(sourceInstance, associatedInstance, options) {\n    let alreadyAssociated;\n\n    options = Object.assign({}, options, {\n      scope: false\n    });\n\n    return sourceInstance[this.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>\n        oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)\n      );\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[this.foreignKey] = null;\n        return oldInstance.save(Object.assign({}, options, {\n          fields: [this.foreignKey],\n          allowNull: [this.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof this.target)) {\n          const tmpInstance = {};\n          tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = this.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        Object.assign(associatedInstance, this.scope);\n        associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create} for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n\n    return this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasOne;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/has-one.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "name": "Helpers",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~Helpers",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "class",
    "name": "HasOne",
    "memberof": "lib/associations/has-one.js",
    "static": true,
    "longname": "lib/associations/has-one.js~HasOne",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/has-one.js",
    "importStyle": null,
    "description": "One-to-one association\n\nIn the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\nThis is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.",
    "see": [
      "{@link Model.hasOne}"
    ],
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "Association"
    ]
  },
  {
    "__docId__": 214,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "associationType",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#associationType",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "isSingleAssociation",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#isSingleAssociation",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "foreignKeyAttribute",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#foreignKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "isAliased",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#isAliased",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "as",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#as",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "foreignKey",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#foreignKey",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 224,
    "kind": "member",
    "name": "sourceKey",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#sourceKey",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "sourceKeyField",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#sourceKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "sourceKeyIsPrimary",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#sourceKeyIsPrimary",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "associationAccessor",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#associationAccessor",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "identifierField",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#identifierField",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "accessors",
    "memberof": "lib/associations/has-one.js~HasOne",
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#accessors",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "{\"get\": *, \"set\": *, \"create\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "_injectAttributes",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#_injectAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "mixin",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#mixin",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "get",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#get",
    "access": "public",
    "description": "Get the associated instance.",
    "see": [
      "{@link Model.findOne} for a full explanation of options"
    ],
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model",
          "Array<Model>"
        ],
        "spread": false,
        "optional": false,
        "name": "instances",
        "description": "source instances"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "Apply a scope on the related model, or remove its default scope by passing false"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.schema",
        "description": "Apply a schema on the related model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "set",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#set",
    "access": "public",
    "description": "Set the associated model.",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": true,
        "types": [
          "<Model>",
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "associatedInstance",
        "description": "An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to getAssociation and `target.save`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "create",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#create",
    "access": "public",
    "description": "Create a new instance of the associated model and associate it with this.",
    "see": [
      "{@link Model#create} for a full explanation of options"
    ],
    "lineNumber": 246,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>} The created target model"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInstance",
        "description": "the source instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "values",
        "description": "values to create associated model instance with"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options passed to `target.create` and setAssociation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": "The created target model"
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "verifyAssociationAlias",
    "memberof": "lib/associations/has-one.js~HasOne",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/associations/has-one.js~HasOne#verifyAssociationAlias",
    "access": "public",
    "description": null,
    "lineNumber": 267,
    "undocument": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 237,
    "kind": "file",
    "name": "lib/associations/helpers.js",
    "content": "'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = { model: source.tableName };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {Object} association instance\n * @param {Object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {Object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/helpers.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 238,
    "kind": "function",
    "name": "checkNamingCollision",
    "memberof": "lib/associations/helpers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/associations/helpers.js~checkNamingCollision",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/helpers.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "association",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 239,
    "kind": "function",
    "name": "addForeignKeyConstraints",
    "memberof": "lib/associations/helpers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/associations/helpers.js~addForeignKeyConstraints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/helpers.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "newAttribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "mixinMethods",
    "memberof": "lib/associations/helpers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/associations/helpers.js~mixinMethods",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/helpers.js",
    "importStyle": null,
    "description": "Mixin (inject) association methods to model prototype",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "association",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "Model prototype"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "methods",
        "description": "Method names to inject"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "aliases",
        "description": "Mapping between model and association method names"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "lib/associations/index.js",
    "content": "'use strict';\n\nconst Association = require('./base');\n\nAssociation.BelongsTo = require('./belongs-to');\nAssociation.HasOne = require('./has-one');\nAssociation.HasMany = require('./has-many');\nAssociation.BelongsToMany = require('./belongs-to-many');\n\nmodule.exports = Association;\nmodule.exports.default = Association;\nmodule.exports.Association = Association;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/associations/index.js",
    "static": true,
    "longname": "lib/associations/index.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "file",
    "name": "lib/associations/mixin.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model\n    && model.prototype\n    && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    options = Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);\n    }\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);\n    }\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', { source, target, type: Type }, options);\n    }\n    // the id is in the foreign table\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/associations/mixin.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 244,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "variable",
    "name": "HasOne",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~HasOne",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "variable",
    "name": "HasMany",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~HasMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 247,
    "kind": "variable",
    "name": "BelongsToMany",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~BelongsToMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 248,
    "kind": "variable",
    "name": "BelongsTo",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "isModel",
    "memberof": "lib/associations/mixin.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/associations/mixin.js~isModel",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "sequelize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 250,
    "kind": "variable",
    "name": "Mixin",
    "memberof": "lib/associations/mixin.js",
    "static": true,
    "longname": "lib/associations/mixin.js~Mixin",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "{\"hasMany\": function, \"belongsToMany\": function, \"getAssociations\": function, \"getAssociationForAlias\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 251,
    "kind": "function",
    "name": "singleLinked",
    "memberof": "lib/associations/mixin.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/associations/mixin.js~singleLinked",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/associations/mixin.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "Type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 252,
    "kind": "file",
    "name": "lib/data-types.js",
    "content": "'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst wkx = require('wkx');\nconst sequelizeErrors = require('./errors');\nconst Validator = require('./utils/validator-extras').validator;\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\nconst { logger } = require('./utils/logger');\nconst warnings = {};\nconst { classToInvokable } = require('./utils/classToInvokable');\n\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \\n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\n\nABSTRACT.prototype.dialectTypes = '';\n\n/**\n * STRING A variable length string\n */\nclass STRING extends ABSTRACT {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super();\n    const options = typeof length === 'object' && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return `VARCHAR(${this._length})${this._binary ? ' BINARY' : ''}`;\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== '[object String]') {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\n\n/**\n * CHAR A fixed length string\n */\nclass CHAR extends STRING {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super(typeof length === 'object' && length || { length, binary });\n  }\n  toSql() {\n    return `CHAR(${this._length})${this._binary ? ' BINARY' : ''}`;\n  }\n}\n\n/**\n * Unlimited length TEXT column\n */\nclass TEXT extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYTEXT';\n      case 'medium':\n        return 'MEDIUMTEXT';\n      case 'long':\n        return 'LONGTEXT';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n */\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return 'CITEXT';\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Base number type which is used to build other types\n */\nclass NUMBER extends ABSTRACT {\n  /**\n   * @param {Object} options type options\n   * @param {string|number} [options.length] length of type, like `INT(4)`\n   * @param {boolean} [options.zerofill] Is zero filled?\n   * @param {boolean} [options.unsigned] Is unsigned?\n   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   * @param {string|number} [options.precision] defines precision for decimal type\n   * @param {string|number} [options.scale] defines scale for decimal type\n   */\n  constructor(options = {}) {\n    super();\n    if (typeof options === 'number') {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === 'number') {\n        result += `,${this._decimals}`;\n      }\n      result += ')';\n    }\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {\n      return number;\n    }\n    if (typeof number.toString === 'function') {\n      return number.toString();\n    }\n    return number;\n  }\n\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\n\n/**\n * A 32 bit integer\n */\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\n\n/**\n * A 8 bit integer\n */\nclass TINYINT extends INTEGER {\n}\n\n/**\n * A 16 bit integer\n */\nclass SMALLINT extends INTEGER {\n}\n\n/**\n * A 24 bit integer\n */\nclass MEDIUMINT extends INTEGER {\n}\n\n/**\n * A 64 bit integer\n */\nclass BIGINT extends INTEGER {\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass FLOAT extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `FLOAT(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass REAL extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `REAL(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Floating point number (8-byte precision).\n */\nclass DOUBLE extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`\n   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Decimal type, variable precision, take length as specified by user\n */\nclass DECIMAL extends NUMBER {\n  /**\n   * @param {string|number} [precision] defines precision\n   * @param {string|number} [scale] defines scale\n   */\n  constructor(precision, scale) {\n    super(typeof precision === 'object' && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;\n    }\n    return 'DECIMAL';\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n    }\n    return true;\n  }\n}\n\n// TODO: Create intermediate class\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return 'NaN';\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? '-' : '';\n      return `${sign}Infinity`;\n    }\n\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\n\n/**\n * A boolean / tinyint column, depending on dialect\n */\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return 'TINYINT(1)';\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== undefined) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        // Bit fields are returned as buffers\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === 'string') {\n        // Only take action on valid boolean strings.\n        return value === 'true' ? true : value === 'false' ? false : value;\n      }\n      if (type === 'number') {\n        // Only take action on valid boolean integers.\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\n\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n/**\n * A time column\n *\n */\nclass TIME extends ABSTRACT {\n  toSql() {\n    return 'TIME';\n  }\n}\n\n/**\n * Date column with timezone, default is UTC\n */\nclass DATE extends ABSTRACT {\n  /**\n   * @param {string|number} [length] precision to allow storing milliseconds\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    return 'DATETIME';\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value &&\n      (value === originalValue ||\n        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    date = this._applyTimezone(date, options);\n    // Z here means current timezone, _not_ UTC\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n  }\n}\n\n/**\n * A date only column (no timestamp)\n */\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return 'DATE';\n  }\n  _stringify(date) {\n    return moment(date).format('YYYY-MM-DD');\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * A key / value store column. Only available in Postgres.\n */\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A JSON string column. Available in MySQL, Postgres and SQLite\n */\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\n\n/**\n * A binary storage JSON column. Only available in Postgres.\n */\nclass JSONB extends JSONTYPE {\n}\n\n/**\n * A default value of the current timestamp\n */\nclass NOW extends ABSTRACT {\n}\n\n/**\n * Binary storage\n */\nclass BLOB extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYBLOB';\n      case 'medium':\n        return 'MEDIUMBLOB';\n      case 'long':\n        return 'LONGBLOB';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString('hex');\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\n\n\nBLOB.prototype.escape = false;\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n */\nclass RANGE extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)\n   */\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === 'function') {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n    }\n    return true;\n  }\n}\n\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n */\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n */\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n */\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example <caption>Checking password length before hashing it</caption>\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n *\n * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example <caption>Virtual with dependency fields</caption>\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n *\n */\nclass VIRTUAL extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} [ReturnType] return type for virtual type\n   * @param {Array} [fields] array of fields this virtual type is dependent on\n   */\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === 'function')\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\n\n/**\n * An enumeration, Postgres Only\n *\n * @example\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value']\n * })\n */\nclass ENUM extends ABSTRACT {\n  /**\n   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values\n   */\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === 'object' && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n    }\n    return true;\n  }\n}\n\n/**\n * An array of `type`. Only available in Postgres.\n *\n * @example\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n */\nclass ARRAY extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} type type of array values\n   */\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === 'function' ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\n\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `GeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](http://geojson.org/geojson-spec.html) for handling geometry objects.  See the following examples:\n *\n * @example <caption>Defining a Geometry type attribute</caption>\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n *\n * @example <caption>Create a new point</caption>\n * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n *\n * User.create({username: 'username', geometry: point });\n *\n * @example <caption>Create a new linestring</caption>\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * @example <caption>Create a new polygon</caption>\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n *\n * @example <caption>Create a new point with a custom SRID</caption>\n * const point = {\n *   type: 'Point',\n *   coordinates: [39.807222,-76.984722],\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n *\n *\n * @see {@link DataTypes.GEOGRAPHY}\n */\nclass GEOMETRY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\nGEOMETRY.prototype.escape = false;\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * __The difference from geometry and geography type:__\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n *\n * __What is best to use? It depends:__\n *\n * When choosing between the geometry and geography type for data storage, you should consider what youll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * @example <caption>Defining a Geography type attribute</caption>\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n */\nclass GEOGRAPHY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geography data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\n\nGEOGRAPHY.prototype.escape = false;\n\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n */\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n */\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n */\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n */\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  'DOUBLE PRECISION': DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT\n};\n\n_.each(DataTypes, (dataType, name) => {\n  // guard for aliases\n  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nconst dialectMap = {};\ndialectMap.postgres = require('./dialects/postgres/data-types')(DataTypes);\ndialectMap.mysql = require('./dialects/mysql/data-types')(DataTypes);\ndialectMap.mariadb = require('./dialects/mariadb/data-types')(DataTypes);\ndialectMap.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\ndialectMap.mssql = require('./dialects/mssql/data-types')(DataTypes);\n\nconst dialectList = _.values(dialectMap);\n\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\n\n// Wrap all data types to not require `new`\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\n\nObject.assign(DataTypes, dialectMap);\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 253,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "variable",
    "name": "wkx",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~wkx",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 256,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 257,
    "kind": "variable",
    "name": "Validator",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~Validator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 258,
    "kind": "variable",
    "name": "momentTz",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~momentTz",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 259,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 260,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 261,
    "kind": "variable",
    "name": "warnings",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~warnings",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 262,
    "kind": "variable",
    "name": "classToInvokable",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~classToInvokable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 263,
    "kind": "class",
    "name": "ABSTRACT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~ABSTRACT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ABSTRACT#toString",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ABSTRACT#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "stringify",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ABSTRACT#stringify",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "bindParam",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ABSTRACT#bindParam",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~ABSTRACT.toString",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "warn",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~ABSTRACT.warn",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "link",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "extend",
    "memberof": "lib/data-types.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~ABSTRACT.extend",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "oldType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 271,
    "kind": "class",
    "name": "STRING",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~STRING",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "STRING A variable length string",
    "lineNumber": 52,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 272,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~STRING",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~STRING#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "255",
        "defaultRaw": 255,
        "name": "length",
        "description": "length of string"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "binary",
        "description": "Is this binary?"
      }
    ]
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~STRING",
    "static": false,
    "longname": "lib/data-types.js~STRING#options",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "_binary",
    "memberof": "lib/data-types.js~STRING",
    "static": false,
    "longname": "lib/data-types.js~STRING#_binary",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "member",
    "name": "_length",
    "memberof": "lib/data-types.js~STRING",
    "static": false,
    "longname": "lib/data-types.js~STRING#_length",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~STRING",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~STRING#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~STRING",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~STRING#validate",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 278,
    "kind": "get",
    "name": "BINARY",
    "memberof": "lib/data-types.js~STRING",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~STRING#BINARY",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 280,
    "kind": "get",
    "name": "BINARY",
    "memberof": "lib/data-types.js~STRING",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~STRING.BINARY",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 281,
    "kind": "class",
    "name": "CHAR",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~CHAR",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "CHAR A fixed length string",
    "lineNumber": 91,
    "interface": false,
    "extends": [
      "STRING"
    ]
  },
  {
    "__docId__": 282,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~CHAR",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~CHAR#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "255",
        "defaultRaw": 255,
        "name": "length",
        "description": "length of string"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "binary",
        "description": "Is this binary?"
      }
    ]
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~CHAR",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~CHAR#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 284,
    "kind": "class",
    "name": "TEXT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~TEXT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Unlimited length TEXT column",
    "lineNumber": 107,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 285,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~TEXT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~TEXT#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "length",
        "description": "could be tiny, medium, long."
      }
    ]
  },
  {
    "__docId__": 286,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~TEXT",
    "static": false,
    "longname": "lib/data-types.js~TEXT#options",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 287,
    "kind": "member",
    "name": "_length",
    "memberof": "lib/data-types.js~TEXT",
    "static": false,
    "longname": "lib/data-types.js~TEXT#_length",
    "access": "private",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~TEXT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~TEXT#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~TEXT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~TEXT#validate",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 290,
    "kind": "class",
    "name": "CITEXT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~CITEXT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "An unlimited length case-insensitive text column.\nOriginal case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\nOnly available in Postgres and SQLite.",
    "lineNumber": 143,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~CITEXT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~CITEXT#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~CITEXT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~CITEXT#validate",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 293,
    "kind": "class",
    "name": "NUMBER",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~NUMBER",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Base number type which is used to build other types",
    "lineNumber": 158,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 294,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "type options"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.length",
        "description": "length of type, like `INT(4)`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.zerofill",
        "description": "Is zero filled?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.unsigned",
        "description": "Is unsigned?"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.decimals",
        "description": "number of decimal points, used with length `FLOAT(5, 4)`"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.precision",
        "description": "defines precision for decimal type"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scale",
        "description": "defines scale for decimal type"
      }
    ]
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#options",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "_length",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_length",
    "access": "private",
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "member",
    "name": "_zerofill",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_zerofill",
    "access": "private",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "_decimals",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_decimals",
    "access": "private",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "member",
    "name": "_precision",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_precision",
    "access": "private",
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "member",
    "name": "_scale",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_scale",
    "access": "private",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "member",
    "name": "_unsigned",
    "memberof": "lib/data-types.js~NUMBER",
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_unsigned",
    "access": "private",
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#validate",
    "access": "public",
    "description": null,
    "lineNumber": 200,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "number",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "get",
    "name": "UNSIGNED",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#UNSIGNED",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 307,
    "kind": "get",
    "name": "ZEROFILL",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~NUMBER#ZEROFILL",
    "access": "public",
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 309,
    "kind": "get",
    "name": "UNSIGNED",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~NUMBER.UNSIGNED",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 310,
    "kind": "get",
    "name": "ZEROFILL",
    "memberof": "lib/data-types.js~NUMBER",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~NUMBER.ZEROFILL",
    "access": "public",
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 311,
    "kind": "class",
    "name": "INTEGER",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~INTEGER",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A 32 bit integer",
    "lineNumber": 240,
    "interface": false,
    "extends": [
      "NUMBER"
    ]
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~INTEGER",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~INTEGER#validate",
    "access": "public",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 313,
    "kind": "class",
    "name": "TINYINT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~TINYINT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A 8 bit integer",
    "lineNumber": 252,
    "interface": false,
    "extends": [
      "INTEGER"
    ]
  },
  {
    "__docId__": 314,
    "kind": "class",
    "name": "SMALLINT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~SMALLINT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A 16 bit integer",
    "lineNumber": 258,
    "interface": false,
    "extends": [
      "INTEGER"
    ]
  },
  {
    "__docId__": 315,
    "kind": "class",
    "name": "MEDIUMINT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~MEDIUMINT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A 24 bit integer",
    "lineNumber": 264,
    "interface": false,
    "extends": [
      "INTEGER"
    ]
  },
  {
    "__docId__": 316,
    "kind": "class",
    "name": "BIGINT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~BIGINT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A 64 bit integer",
    "lineNumber": 270,
    "interface": false,
    "extends": [
      "INTEGER"
    ]
  },
  {
    "__docId__": 317,
    "kind": "class",
    "name": "FLOAT",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~FLOAT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Floating point number (4-byte precision).",
    "lineNumber": 276,
    "interface": false,
    "extends": [
      "NUMBER"
    ]
  },
  {
    "__docId__": 318,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~FLOAT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~FLOAT#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 281,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "length",
        "description": "length of type, like `FLOAT(4)`"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "decimals",
        "description": "number of decimal points, used with length `FLOAT(5, 4)`"
      }
    ]
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~FLOAT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~FLOAT#validate",
    "access": "public",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 320,
    "kind": "class",
    "name": "REAL",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~REAL",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Floating point number (4-byte precision).",
    "lineNumber": 295,
    "interface": false,
    "extends": [
      "NUMBER"
    ]
  },
  {
    "__docId__": 321,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~REAL",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~REAL#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 300,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "length",
        "description": "length of type, like `REAL(4)`"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "decimals",
        "description": "number of decimal points, used with length `REAL(5, 4)`"
      }
    ]
  },
  {
    "__docId__": 322,
    "kind": "class",
    "name": "DOUBLE",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~DOUBLE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Floating point number (8-byte precision).",
    "lineNumber": 308,
    "interface": false,
    "extends": [
      "NUMBER"
    ]
  },
  {
    "__docId__": 323,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~DOUBLE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DOUBLE#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 313,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "length",
        "description": "length of type, like `DOUBLE PRECISION(25)`"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "decimals",
        "description": "number of decimal points, used with length `DOUBLE PRECISION(25, 10)`"
      }
    ]
  },
  {
    "__docId__": 324,
    "kind": "class",
    "name": "DECIMAL",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~DECIMAL",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Decimal type, variable precision, take length as specified by user",
    "lineNumber": 321,
    "interface": false,
    "extends": [
      "NUMBER"
    ]
  },
  {
    "__docId__": 325,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~DECIMAL",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DECIMAL#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 326,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "precision",
        "description": "defines precision"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "scale",
        "description": "defines scale"
      }
    ]
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~DECIMAL",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DECIMAL#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~DECIMAL",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DECIMAL#validate",
    "access": "public",
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 328,
    "kind": "variable",
    "name": "protoExtensions",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~protoExtensions",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 344,
    "undocument": true,
    "type": {
      "types": [
        "{\"escape\": *, \"_value\": function, \"_stringify\": function, \"_bindParam\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 329,
    "kind": "class",
    "name": "BOOLEAN",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~BOOLEAN",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A boolean / tinyint column, depending on dialect",
    "lineNumber": 372,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~BOOLEAN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BOOLEAN#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 373,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~BOOLEAN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BOOLEAN#validate",
    "access": "public",
    "description": null,
    "lineNumber": 376,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "_sanitize",
    "memberof": "lib/data-types.js~BOOLEAN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BOOLEAN#_sanitize",
    "access": "private",
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "class",
    "name": "TIME",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~TIME",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A time column",
    "lineNumber": 409,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~TIME",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~TIME#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 410,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 335,
    "kind": "class",
    "name": "DATE",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~DATE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Date column with timezone, default is UTC",
    "lineNumber": 418,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 336,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 422,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "length",
        "description": "precision to allow storing milliseconds"
      }
    ]
  },
  {
    "__docId__": 337,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~DATE",
    "static": false,
    "longname": "lib/data-types.js~DATE#options",
    "access": "public",
    "description": null,
    "lineNumber": 425,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 338,
    "kind": "member",
    "name": "_length",
    "memberof": "lib/data-types.js~DATE",
    "static": false,
    "longname": "lib/data-types.js~DATE#_length",
    "access": "private",
    "description": null,
    "lineNumber": 426,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#validate",
    "access": "public",
    "description": null,
    "lineNumber": 431,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "_sanitize",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#_sanitize",
    "access": "private",
    "description": null,
    "lineNumber": 437,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "_isChanged",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#_isChanged",
    "access": "private",
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "originalValue",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "_applyTimezone",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#_applyTimezone",
    "access": "private",
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~DATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATE#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 464,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "class",
    "name": "DATEONLY",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~DATEONLY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A date only column (no timestamp)",
    "lineNumber": 474,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~DATEONLY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATEONLY#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 475,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~DATEONLY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATEONLY#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 478,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "_sanitize",
    "memberof": "lib/data-types.js~DATEONLY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATEONLY#_sanitize",
    "access": "private",
    "description": null,
    "lineNumber": 481,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "_isChanged",
    "memberof": "lib/data-types.js~DATEONLY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~DATEONLY#_isChanged",
    "access": "private",
    "description": null,
    "lineNumber": 487,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "originalValue",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "class",
    "name": "HSTORE",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~HSTORE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A key / value store column. Only available in Postgres.",
    "lineNumber": 502,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~HSTORE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~HSTORE#validate",
    "access": "public",
    "description": null,
    "lineNumber": 503,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 352,
    "kind": "class",
    "name": "JSONTYPE",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~JSONTYPE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A JSON string column. Available in MySQL, Postgres and SQLite",
    "lineNumber": 514,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 353,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~JSONTYPE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~JSONTYPE#validate",
    "access": "public",
    "description": null,
    "lineNumber": 515,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 354,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~JSONTYPE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~JSONTYPE#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 518,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "class",
    "name": "JSONB",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~JSONB",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A binary storage JSON column. Only available in Postgres.",
    "lineNumber": 526,
    "interface": false,
    "extends": [
      "JSONTYPE"
    ]
  },
  {
    "__docId__": 356,
    "kind": "class",
    "name": "NOW",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~NOW",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A default value of the current timestamp",
    "lineNumber": 532,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 357,
    "kind": "class",
    "name": "BLOB",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~BLOB",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Binary storage",
    "lineNumber": 538,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 358,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 542,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "length",
        "description": "could be tiny, medium, long."
      }
    ]
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~BLOB",
    "static": false,
    "longname": "lib/data-types.js~BLOB#options",
    "access": "public",
    "description": null,
    "lineNumber": 545,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "_length",
    "memberof": "lib/data-types.js~BLOB",
    "static": false,
    "longname": "lib/data-types.js~BLOB#_length",
    "access": "private",
    "description": null,
    "lineNumber": 546,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 548,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#validate",
    "access": "public",
    "description": null,
    "lineNumber": 560,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 566,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "_hexify",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#_hexify",
    "access": "private",
    "description": null,
    "lineNumber": 578,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "hex",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "_bindParam",
    "memberof": "lib/data-types.js~BLOB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~BLOB#_bindParam",
    "access": "private",
    "description": null,
    "lineNumber": 581,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "class",
    "name": "RANGE",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~RANGE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "Range types are data types representing a range of values of some element type (called the range's subtype).\nOnly available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details",
    "lineNumber": 601,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 367,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~RANGE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~RANGE#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 605,
    "params": [
      {
        "nullable": null,
        "types": [
          "ABSTRACT"
        ],
        "spread": false,
        "optional": false,
        "name": "subtype",
        "description": "A subtype for range, like RANGE(DATE)"
      }
    ]
  },
  {
    "__docId__": 368,
    "kind": "member",
    "name": "_subtype",
    "memberof": "lib/data-types.js~RANGE",
    "static": false,
    "longname": "lib/data-types.js~RANGE#_subtype",
    "access": "private",
    "description": null,
    "lineNumber": 613,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~RANGE",
    "static": false,
    "longname": "lib/data-types.js~RANGE#options",
    "access": "public",
    "description": null,
    "lineNumber": 614,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~RANGE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~RANGE#validate",
    "access": "public",
    "description": null,
    "lineNumber": 616,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 371,
    "kind": "class",
    "name": "UUID",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~UUID",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A column storing a unique universal identifier.\nUse with `UUIDV1` or `UUIDV4` for default values.",
    "lineNumber": 631,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~UUID",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~UUID#validate",
    "access": "public",
    "description": null,
    "lineNumber": 632,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 373,
    "kind": "class",
    "name": "UUIDV1",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~UUIDV1",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A default unique universal identifier generated following the UUID v1 standard",
    "lineNumber": 643,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 374,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~UUIDV1",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~UUIDV1#validate",
    "access": "public",
    "description": null,
    "lineNumber": 644,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "class",
    "name": "UUIDV4",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~UUIDV4",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A default unique universal identifier generated following the UUID v4 standard",
    "lineNumber": 655,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~UUIDV4",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~UUIDV4#validate",
    "access": "public",
    "description": null,
    "lineNumber": 656,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 377,
    "kind": "class",
    "name": "VIRTUAL",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~VIRTUAL",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n\nYou could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\nIf a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\nReturn type is mostly useful for setups that rely on types like GraphQL.",
    "examples": [
      "<caption>Checking password length before hashing it</caption>\nsequelize.define('user', {\n  password_hash: DataTypes.STRING,\n  password: {\n    type: DataTypes.VIRTUAL,\n    set: function (val) {\n       // Remember to set the data value, otherwise it won't be validated\n       this.setDataValue('password', val);\n       this.setDataValue('password_hash', this.salt + val);\n     },\n     validate: {\n        isLongEnough: function (val) {\n          if (val.length < 7) {\n            throw new Error(\"Please choose a longer password\")\n         }\n      }\n    }\n  }\n})\n\n# In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.",
      "<caption>Virtual with dependency fields</caption>\n{\n  active: {\n    type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n    get: function() {\n      return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n    }\n  }\n}"
    ],
    "lineNumber": 704,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 378,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~VIRTUAL",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~VIRTUAL#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 709,
    "params": [
      {
        "nullable": null,
        "types": [
          "ABSTRACT"
        ],
        "spread": false,
        "optional": true,
        "name": "ReturnType",
        "description": "return type for virtual type"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "fields",
        "description": "array of fields this virtual type is dependent on"
      }
    ]
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "returnType",
    "memberof": "lib/data-types.js~VIRTUAL",
    "static": false,
    "longname": "lib/data-types.js~VIRTUAL#returnType",
    "access": "public",
    "description": null,
    "lineNumber": 713,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "fields",
    "memberof": "lib/data-types.js~VIRTUAL",
    "static": false,
    "longname": "lib/data-types.js~VIRTUAL#fields",
    "access": "public",
    "description": null,
    "lineNumber": 714,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 381,
    "kind": "class",
    "name": "ENUM",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~ENUM",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "An enumeration, Postgres Only",
    "examples": [
      "DataTypes.ENUM('value', 'another value')\nDataTypes.ENUM(['value', 'another value'])\nDataTypes.ENUM({\n  values: ['value', 'another value']\n})"
    ],
    "lineNumber": 728,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 382,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~ENUM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ENUM#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 732,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any",
          "{ values: any[] }",
          "any[]"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "either array of values or options object with values array. It also supports variadic values"
      }
    ]
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "values",
    "memberof": "lib/data-types.js~ENUM",
    "static": false,
    "longname": "lib/data-types.js~ENUM#values",
    "access": "public",
    "description": null,
    "lineNumber": 740,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 384,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~ENUM",
    "static": false,
    "longname": "lib/data-types.js~ENUM#options",
    "access": "public",
    "description": null,
    "lineNumber": 741,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~ENUM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ENUM#validate",
    "access": "public",
    "description": null,
    "lineNumber": 743,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 386,
    "kind": "class",
    "name": "ARRAY",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~ARRAY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "An array of `type`. Only available in Postgres.",
    "examples": [
      "DataTypes.ARRAY(DataTypes.DECIMAL)"
    ],
    "lineNumber": 757,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 387,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~ARRAY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ARRAY#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 761,
    "params": [
      {
        "nullable": null,
        "types": [
          "ABSTRACT"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "type of array values"
      }
    ]
  },
  {
    "__docId__": 388,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~ARRAY",
    "static": false,
    "longname": "lib/data-types.js~ARRAY#options",
    "access": "public",
    "description": null,
    "lineNumber": 764,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 389,
    "kind": "member",
    "name": "type",
    "memberof": "lib/data-types.js~ARRAY",
    "static": false,
    "longname": "lib/data-types.js~ARRAY#type",
    "access": "public",
    "description": null,
    "lineNumber": 765,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/data-types.js~ARRAY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ARRAY#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 767,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~ARRAY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~ARRAY#validate",
    "access": "public",
    "description": null,
    "lineNumber": 770,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "is",
    "memberof": "lib/data-types.js~ARRAY",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/data-types.js~ARRAY.is",
    "access": "public",
    "description": null,
    "lineNumber": 776,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 393,
    "kind": "class",
    "name": "GEOMETRY",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~GEOMETRY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A column storing Geometry information.\nIt is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n\nGeoJSON is accepted as input and returned as output.\n\nIn PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\nIn MySQL it is parsed using the function `GeomFromText`.\n\nTherefore, one can just follow the [GeoJSON spec](http://geojson.org/geojson-spec.html) for handling geometry objects.  See the following examples:",
    "examples": [
      "<caption>Defining a Geometry type attribute</caption>\nDataTypes.GEOMETRY\nDataTypes.GEOMETRY('POINT')\nDataTypes.GEOMETRY('POINT', 4326)",
      "<caption>Create a new point</caption>\nconst point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n\nUser.create({username: 'username', geometry: point });",
      "<caption>Create a new linestring</caption>\nconst line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n\nUser.create({username: 'username', geometry: line });",
      "<caption>Create a new polygon</caption>\nconst polygon = { type: 'Polygon', coordinates: [\n                [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n                  [100.0, 1.0], [100.0, 0.0] ]\n                ]};\n\nUser.create({username: 'username', geometry: polygon });",
      "<caption>Create a new point with a custom SRID</caption>\nconst point = {\n  type: 'Point',\n  coordinates: [39.807222,-76.984722],\n  crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n};\n\nUser.create({username: 'username', geometry: point })"
    ],
    "see": [
      "{@link DataTypes.GEOGRAPHY}"
    ],
    "lineNumber": 827,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 394,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~GEOMETRY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 832,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "type",
        "description": "Type of geometry data"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "srid",
        "description": "SRID of type"
      }
    ]
  },
  {
    "__docId__": 395,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~GEOMETRY",
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#options",
    "access": "public",
    "description": null,
    "lineNumber": 835,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 396,
    "kind": "member",
    "name": "type",
    "memberof": "lib/data-types.js~GEOMETRY",
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#type",
    "access": "public",
    "description": null,
    "lineNumber": 836,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 397,
    "kind": "member",
    "name": "srid",
    "memberof": "lib/data-types.js~GEOMETRY",
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#srid",
    "access": "public",
    "description": null,
    "lineNumber": 837,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~GEOMETRY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 839,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 399,
    "kind": "method",
    "name": "_bindParam",
    "memberof": "lib/data-types.js~GEOMETRY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOMETRY#_bindParam",
    "access": "private",
    "description": null,
    "lineNumber": 842,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 400,
    "kind": "class",
    "name": "GEOGRAPHY",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~GEOGRAPHY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n\n__The difference from geometry and geography type:__\n\nPostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\nCoordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\nbut measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n\n__What is best to use? It depends:__\n\nWhen choosing between the geometry and geography type for data storage, you should consider what youll be using it for.\nIf all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.\nAlthough the new geography data type can cover the globe, the geometry type is far from obsolete.\nThe geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools",
    "examples": [
      "<caption>Defining a Geography type attribute</caption>\nDataTypes.GEOGRAPHY\nDataTypes.GEOGRAPHY('POINT')\nDataTypes.GEOGRAPHY('POINT', 4326)"
    ],
    "lineNumber": 870,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 401,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 875,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "type",
        "description": "Type of geography data"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "srid",
        "description": "SRID of type"
      }
    ]
  },
  {
    "__docId__": 402,
    "kind": "member",
    "name": "options",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#options",
    "access": "public",
    "description": null,
    "lineNumber": 878,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 403,
    "kind": "member",
    "name": "type",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#type",
    "access": "public",
    "description": null,
    "lineNumber": 879,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 404,
    "kind": "member",
    "name": "srid",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#srid",
    "access": "public",
    "description": null,
    "lineNumber": 880,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "_stringify",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#_stringify",
    "access": "private",
    "description": null,
    "lineNumber": 882,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "_bindParam",
    "memberof": "lib/data-types.js~GEOGRAPHY",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~GEOGRAPHY#_bindParam",
    "access": "private",
    "description": null,
    "lineNumber": 885,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "class",
    "name": "CIDR",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~CIDR",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n\nOnly available for Postgres",
    "lineNumber": 898,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~CIDR",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~CIDR#validate",
    "access": "public",
    "description": null,
    "lineNumber": 899,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 409,
    "kind": "class",
    "name": "INET",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~INET",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n\nOnly available for Postgres",
    "lineNumber": 912,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~INET",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~INET#validate",
    "access": "public",
    "description": null,
    "lineNumber": 913,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 411,
    "kind": "class",
    "name": "MACADDR",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~MACADDR",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "The MACADDR type stores MAC addresses. Takes 6 bytes\n\nOnly available for Postgres",
    "lineNumber": 927,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ]
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/data-types.js~MACADDR",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/data-types.js~MACADDR#validate",
    "access": "public",
    "description": null,
    "lineNumber": 928,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 413,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": "A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n```js\nsequelize.define('model', {\n  column: DataTypes.INTEGER\n})\n```\nWhen defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\nthat that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n\nTo provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n\nSome data types have special properties that can be accessed in order to change the data type.\nFor example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\nThe order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n\n* All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n* The `CHAR` and `STRING` types expose the `BINARY` property\n\nThree of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\ndefining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n```js\nsequelize.define('model', {\n  uuid: {\n    type: DataTypes.UUID,\n    defaultValue: DataTypes.UUIDV1,\n    primaryKey: true\n  }\n})\n```\nThere may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\nusing the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\nfrom a function.\n```js\nsequelize.define('model', {\n  uuid: {\n    type: DataTypes.UUID,\n    defaultValue: function() {\n      return generateMyId()\n    },\n    primaryKey: true\n  }\n})\n```",
    "lineNumber": 981,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 414,
    "kind": "variable",
    "name": "dialectMap",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~dialectMap",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1030,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 415,
    "kind": "variable",
    "name": "dialectList",
    "memberof": "lib/data-types.js",
    "static": true,
    "longname": "lib/data-types.js~dialectList",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1037,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 416,
    "kind": "file",
    "name": "lib/deferrable.js",
    "content": "'use strict';\n\nconst { classToInvokable } = require('./utils');\n\nclass ABSTRACT {\n  static toString(...args) {\n    return new this().toString(...args);\n  }\n\n  toString(...args) {\n    return this.toSql(...args);\n  }\n\n  toSql() {\n    throw new Error('toSql implementation missing');\n  }\n}\n\nclass INITIALLY_DEFERRED extends ABSTRACT {\n  toSql() {\n    return 'DEFERRABLE INITIALLY DEFERRED';\n  }\n}\n\nclass INITIALLY_IMMEDIATE extends ABSTRACT {\n  toSql() {\n    return 'DEFERRABLE INITIALLY IMMEDIATE';\n  }\n}\n\nclass NOT extends ABSTRACT {\n  toSql() {\n    return 'NOT DEFERRABLE';\n  }\n}\n\nclass SET_DEFERRED extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n\n  toSql(queryGenerator) {\n    return queryGenerator.setDeferredQuery(this.constraints);\n  }\n}\n\nclass SET_IMMEDIATE extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n\n  toSql(queryGenerator) {\n    return queryGenerator.setImmediateQuery(this.constraints);\n  }\n}\n\n/**\n * A collection of properties related to deferrable constraints. It can be used to\n * make foreign key constraints deferrable and to set the constraints within a\n * transaction. This is only supported in PostgreSQL.\n *\n * The foreign keys can be configured like this. It will create a foreign key\n * that will check the constraints immediately when the data was inserted.\n *\n * ```js\n * sequelize.define('Model', {\n *   foreign_id: {\n *     type: Sequelize.INTEGER,\n *     references: {\n *       model: OtherModel,\n *       key: 'id',\n *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE\n *     }\n *   }\n * });\n * ```\n *\n * The constraints can be configured in a transaction like this. It will\n * trigger a query once the transaction has been started and set the constraints\n * to be checked at the very end of the transaction.\n *\n * ```js\n * sequelize.transaction({\n *   deferrable: Sequelize.Deferrable.SET_DEFERRED\n * });\n * ```\n *\n * @property INITIALLY_DEFERRED Defer constraints checks to the end of transactions.\n * @property INITIALLY_IMMEDIATE Trigger the constraint checks immediately\n * @property NOT Set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction.\n * @property SET_DEFERRED\n * @property SET_IMMEDIATE\n */\n\nconst Deferrable = module.exports = { // eslint-disable-line\n  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),\n  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),\n  NOT: classToInvokable(NOT),\n  SET_DEFERRED: classToInvokable(SET_DEFERRED),\n  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/deferrable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 417,
    "kind": "variable",
    "name": "classToInvokable",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~classToInvokable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 418,
    "kind": "class",
    "name": "ABSTRACT",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~ABSTRACT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/deferrable.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/deferrable.js~ABSTRACT.toString",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/deferrable.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~ABSTRACT#toString",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~ABSTRACT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~ABSTRACT#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 422,
    "kind": "class",
    "name": "INITIALLY_DEFERRED",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~INITIALLY_DEFERRED",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ],
    "ignore": true
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~INITIALLY_DEFERRED",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~INITIALLY_DEFERRED#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 424,
    "kind": "class",
    "name": "INITIALLY_IMMEDIATE",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~INITIALLY_IMMEDIATE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ],
    "ignore": true
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~INITIALLY_IMMEDIATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~INITIALLY_IMMEDIATE#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 426,
    "kind": "class",
    "name": "NOT",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~NOT",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ],
    "ignore": true
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~NOT",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~NOT#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 428,
    "kind": "class",
    "name": "SET_DEFERRED",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~SET_DEFERRED",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ],
    "ignore": true
  },
  {
    "__docId__": 429,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/deferrable.js~SET_DEFERRED",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~SET_DEFERRED#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 430,
    "kind": "member",
    "name": "constraints",
    "memberof": "lib/deferrable.js~SET_DEFERRED",
    "static": false,
    "longname": "lib/deferrable.js~SET_DEFERRED#constraints",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~SET_DEFERRED",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~SET_DEFERRED#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "queryGenerator",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 432,
    "kind": "class",
    "name": "SET_IMMEDIATE",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~SET_IMMEDIATE",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "interface": false,
    "extends": [
      "ABSTRACT"
    ],
    "ignore": true
  },
  {
    "__docId__": 433,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/deferrable.js~SET_IMMEDIATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~SET_IMMEDIATE#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 434,
    "kind": "member",
    "name": "constraints",
    "memberof": "lib/deferrable.js~SET_IMMEDIATE",
    "static": false,
    "longname": "lib/deferrable.js~SET_IMMEDIATE#constraints",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "toSql",
    "memberof": "lib/deferrable.js~SET_IMMEDIATE",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/deferrable.js~SET_IMMEDIATE#toSql",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "queryGenerator",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 436,
    "kind": "variable",
    "name": "Deferrable",
    "memberof": "lib/deferrable.js",
    "static": true,
    "longname": "lib/deferrable.js~Deferrable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/deferrable.js",
    "importStyle": null,
    "description": "A collection of properties related to deferrable constraints. It can be used to\nmake foreign key constraints deferrable and to set the constraints within a\ntransaction. This is only supported in PostgreSQL.\n\nThe foreign keys can be configured like this. It will create a foreign key\nthat will check the constraints immediately when the data was inserted.\n\n```js\nsequelize.define('Model', {\n  foreign_id: {\n    type: Sequelize.INTEGER,\n    references: {\n      model: OtherModel,\n      key: 'id',\n      deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE\n    }\n  }\n});\n```\n\nThe constraints can be configured in a transaction like this. It will\ntrigger a query once the transaction has been started and set the constraints\nto be checked at the very end of the transaction.\n\n```js\nsequelize.transaction({\n  deferrable: Sequelize.Deferrable.SET_DEFERRED\n});\n```",
    "lineNumber": 97,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "INITIALLY_DEFERRED",
        "description": "Defer constraints checks to the end of transactions."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "INITIALLY_IMMEDIATE",
        "description": "Trigger the constraint checks immediately"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "NOT",
        "description": "Set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SET_DEFERRED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SET_IMMEDIATE",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 437,
    "kind": "file",
    "name": "lib/dialects/abstract/connection-manager.js",
    "content": "'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst Promise = require('../../promise');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      // This is needed so that bundlers (like webpack) know which library to include in the bundle\n      switch (moduleName) {\n        case 'pg': return require('pg');\n        case 'mysql2': return require('mysql2');\n        case 'mariadb': return require('mariadb');\n        case 'sqlite3': return require('sqlite3');\n        case 'tedious': return require('tedious');\n        default: return require(moduleName);\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection)\n            .tap(() => { debug('connection destroy'); });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ).tap(() => { debug('all connections destroyed'); });\n      },\n      drain: () => {\n        return Promise.join(\n          this.pool.write.drain(),\n          this.pool.read.drain()\n        );\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  getConnection(options) {\n    options = options || {};\n\n    let promise;\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config)\n          .then(connection => {\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              return this.sequelize.databaseVersion(_options).then(version => {\n                const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n                this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                  ? parsedVersion\n                  : this.defaultVersion;\n                this.versionPromise = null;\n                return this._disconnect(connection);\n              });\n            }\n\n            this.versionPromise = null;\n            return this._disconnect(connection);\n          }).catch(err => {\n            this.versionPromise = null;\n            throw err;\n          });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster)\n        .catch(error => {\n          if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n          throw error;\n        });\n    }).tap(() => { debug('connection acquired'); });\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config)\n      .then(() => this.dialect.connectionManager.connect(config))\n      .then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection)\n      .then(() => this.dialect.connectionManager.disconnect(connection))\n      .then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 438,
    "kind": "variable",
    "name": "Pool",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~Pool",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 439,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "variable",
    "name": "semver",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~semver",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 441,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 442,
    "kind": "variable",
    "name": "errors",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~errors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 443,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 444,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 445,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/abstract/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/connection-manager.js",
    "importStyle": null,
    "description": "Abstract Connection Manager\n\nConnection manager which handles pooling & replication.\nUses sequelize-pool for pooling",
    "lineNumber": 19,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 446,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 447,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 448,
    "kind": "member",
    "name": "config",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#config",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 449,
    "kind": "member",
    "name": "dialect",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#dialect",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 450,
    "kind": "member",
    "name": "versionPromise",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#versionPromise",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 451,
    "kind": "member",
    "name": "dialectName",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#dialectName",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "refreshTypeParser",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#refreshTypeParser",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [
      {
        "name": "dataTypes",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "_loadDialectModule",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#_loadDialectModule",
    "access": "private",
    "description": "Try to load dialect module from various configured options.\nPriority goes like dialectModulePath > dialectModule > require(default)",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "moduleName",
        "description": "Name of dialect module to lookup"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "_onProcessExit",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#_onProcessExit",
    "access": "private",
    "description": "Handler which executes on process exit or connection manager shutdown",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "close",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#close",
    "access": "public",
    "description": "Drain the pool and close it permanently",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "initPools",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#initPools",
    "access": "public",
    "description": "Initialize connection pool. By default pool autostart is set to false, so no connection will be\nbe created unless `pool.acquire` is called.",
    "lineNumber": 130,
    "params": [],
    "return": null
  },
  {
    "__docId__": 457,
    "kind": "member",
    "name": "pool",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#pool",
    "access": "public",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "getConnection",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#getConnection",
    "access": "public",
    "description": "Get connection from pool. It sets database version if it's not already set.\nCall pool.acquire to get a connection",
    "lineNumber": 246,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Connection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Pool options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.type",
        "description": "Set which replica to use. Available options are `read` and `write`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.useMaster",
        "description": "Force master or write replica to get connection from"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Connection>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "releaseConnection",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#releaseConnection",
    "access": "public",
    "description": "Release a pooled connection so it can be utilized by other connection requests",
    "lineNumber": 302,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "_connect",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#_connect",
    "access": "private",
    "description": "Call dialect library to get connection",
    "lineNumber": 316,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Connection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Connection config"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Connection>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "_disconnect",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#_disconnect",
    "access": "private",
    "description": "Call dialect library to disconnect a connection",
    "lineNumber": 329,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "_validate",
    "memberof": "lib/dialects/abstract/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/connection-manager.js~ConnectionManager#_validate",
    "access": "private",
    "description": "Determine if a connection is still valid or not",
    "lineNumber": 342,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 467,
    "kind": "file",
    "name": "lib/dialects/abstract/index.js",
    "content": "'use strict';\n\nclass AbstractDialect {}\n\nAbstractDialect.prototype.supports = {\n  'DEFAULT': true,\n  'DEFAULT VALUES': false,\n  'VALUES ()': false,\n  'LIMIT ON UPDATE': false,\n  'ON DUPLICATE KEY': true,\n  'ORDER NULLS': false,\n  'UNION': true,\n  'UNION ALL': true,\n  'RIGHT JOIN': true,\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false,\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: false,\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: true,\n\n    /* does the dialect support updating autoincrement fields */\n    update: true\n  },\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: '', /* dialect specific words for INSERT IGNORE or DO NOTHING */\n    updateOnDuplicate: false, /* whether dialect supports ON DUPLICATE KEY UPDATE */\n    onConflictDoNothing: '' /* dialect specific words for ON CONFLICT DO NOTHING */\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false\n  },\n  joinTableDependent: true,\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false\n};\n\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports.default = AbstractDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 468,
    "kind": "class",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/abstract/index.js",
    "static": true,
    "longname": "lib/dialects/abstract/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 469,
    "kind": "file",
    "name": "lib/dialects/abstract/query-generator/helpers/quote.js",
    "content": "/**\n * Quote helpers implement quote ability for all dialects.\n * These are basic block of query building\n *\n * Its better to implement all dialect implementation together here. Which will allow\n * even abstract generator to use them by just specifying dialect type.\n *\n * Defining these helpers in each query dialect will leave\n * code in dual dependency of abstract <-> specific dialect\n */\n\n'use strict';\n\nconst Utils = require('../../../../utils');\n\n/**\n * list of reserved words in PostgreSQL 10\n * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html\n *\n * @private\n */\nconst postgresReservedWords = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');\n\n/**\n *\n * @param {string}  dialect         Dialect name\n * @param {string}  identifier      Identifier to quote\n * @param {Object}  [options]\n * @param {boolean} [options.force=false]\n * @param {boolean} [options.quoteIdentifiers=true]\n *\n * @returns {string}\n * @private\n */\nfunction quoteIdentifier(dialect, identifier, options) {\n  if (identifier === '*') return identifier;\n\n  options = Utils.defaults(options || {}, {\n    force: false,\n    quoteIdentifiers: true\n  });\n\n  switch (dialect) {\n    case 'sqlite':\n    case 'mariadb':\n    case 'mysql':\n      return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n\n    case 'postgres':\n      const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n      if (\n        options.force !== true &&\n        options.quoteIdentifiers === false &&\n        !identifier.includes('.') &&\n        !identifier.includes('->') &&\n        !postgresReservedWords.includes(rawIdentifier.toLowerCase())\n      ) {\n        // In Postgres, if tables or attributes are created double-quoted,\n        // they are also case sensitive. If they contain any uppercase\n        // characters, they must always be double-quoted. This makes it\n        // impossible to write queries in portable SQL if tables are created in\n        // this way. Hence, we strip quotes if we don't want case sensitivity.\n        return rawIdentifier;\n      }\n      return Utils.addTicks(rawIdentifier, '\"');\n    case 'mssql':\n      return `[${identifier.replace(/[[\\]']+/g, '')}]`;\n\n    default:\n      throw new Error(`Dialect \"${dialect}\" is not supported`);\n  }\n}\nmodule.exports.quoteIdentifier = quoteIdentifier;\n\n/**\n * Test if a give string is already quoted\n *\n * @param {string} identifier\n *\n * @returns {boolean}\n * @private\n */\nfunction isIdentifierQuoted(identifier) {\n  return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n}\nmodule.exports.isIdentifierQuoted = isIdentifierQuoted;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 470,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/abstract/query-generator/helpers/quote.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/helpers/quote.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/helpers/quote.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 471,
    "kind": "variable",
    "name": "postgresReservedWords",
    "memberof": "lib/dialects/abstract/query-generator/helpers/quote.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/helpers/quote.js~postgresReservedWords",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/helpers/quote.js",
    "importStyle": null,
    "description": "list of reserved words in PostgreSQL 10\nsource: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html",
    "lineNumber": 22,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "function",
    "name": "quoteIdentifier",
    "memberof": "lib/dialects/abstract/query-generator/helpers/quote.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/helpers/quote.js~quoteIdentifier",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/helpers/quote.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dialect",
        "description": "Dialect name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "Identifier to quote"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.force",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.quoteIdentifiers",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 473,
    "kind": "function",
    "name": "isIdentifierQuoted",
    "memberof": "lib/dialects/abstract/query-generator/helpers/quote.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/helpers/quote.js~isIdentifierQuoted",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/helpers/quote.js",
    "importStyle": null,
    "description": "Test if a give string is already quoted",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 474,
    "kind": "file",
    "name": "lib/dialects/abstract/query-generator/operators.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Op = require('../../../operators');\nconst Utils = require('../../../utils');\n\nconst OperatorHelpers = {\n  OperatorMap: {\n    [Op.eq]: '=',\n    [Op.ne]: '!=',\n    [Op.gte]: '>=',\n    [Op.gt]: '>',\n    [Op.lte]: '<=',\n    [Op.lt]: '<',\n    [Op.not]: 'IS NOT',\n    [Op.is]: 'IS',\n    [Op.in]: 'IN',\n    [Op.notIn]: 'NOT IN',\n    [Op.like]: 'LIKE',\n    [Op.notLike]: 'NOT LIKE',\n    [Op.iLike]: 'ILIKE',\n    [Op.notILike]: 'NOT ILIKE',\n    [Op.startsWith]: 'LIKE',\n    [Op.endsWith]: 'LIKE',\n    [Op.substring]: 'LIKE',\n    [Op.regexp]: '~',\n    [Op.notRegexp]: '!~',\n    [Op.iRegexp]: '~*',\n    [Op.notIRegexp]: '!~*',\n    [Op.between]: 'BETWEEN',\n    [Op.notBetween]: 'NOT BETWEEN',\n    [Op.overlap]: '&&',\n    [Op.contains]: '@>',\n    [Op.contained]: '<@',\n    [Op.adjacent]: '-|-',\n    [Op.strictLeft]: '<<',\n    [Op.strictRight]: '>>',\n    [Op.noExtendRight]: '&<',\n    [Op.noExtendLeft]: '&>',\n    [Op.any]: 'ANY',\n    [Op.all]: 'ALL',\n    [Op.and]: ' AND ',\n    [Op.or]: ' OR ',\n    [Op.col]: 'COL',\n    [Op.placeholder]: '$$PLACEHOLDER$$'\n  },\n\n  OperatorsAliasMap: {},\n\n  setOperatorsAliases(aliases) {\n    if (!aliases || _.isEmpty(aliases)) {\n      this.OperatorsAliasMap = false;\n    } else {\n      this.OperatorsAliasMap = Object.assign({}, aliases);\n    }\n  },\n\n  _replaceAliases(orig) {\n    const obj = {};\n    if (!this.OperatorsAliasMap) {\n      return orig;\n    }\n\n    Utils.getOperators(orig).forEach(op => {\n      const item = orig[op];\n      if (_.isPlainObject(item)) {\n        obj[op] = this._replaceAliases(item);\n      } else {\n        obj[op] = item;\n      }\n    });\n\n    _.forOwn(orig, (item, prop) => {\n      prop = this.OperatorsAliasMap[prop] || prop;\n      if (_.isPlainObject(item)) {\n        item = this._replaceAliases(item);\n      }\n      obj[prop] = item;\n    });\n    return obj;\n  }\n};\n\nmodule.exports = OperatorHelpers;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query-generator/operators.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 475,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/abstract/query-generator/operators.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/operators.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/operators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 476,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/abstract/query-generator/operators.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/operators.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/operators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 477,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/abstract/query-generator/operators.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/operators.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/operators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 478,
    "kind": "variable",
    "name": "OperatorHelpers",
    "memberof": "lib/dialects/abstract/query-generator/operators.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/operators.js~OperatorHelpers",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/operators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"OperatorMap\": *, \"OperatorsAliasMap\": *, \"setOperatorsAliases\": function, \"_replaceAliases\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 479,
    "kind": "file",
    "name": "lib/dialects/abstract/query-generator/transaction.js",
    "content": "'use strict';\n\nconst uuidv4 = require('uuid').v4;\n\nconst TransactionQueries = {\n  /**\n   * Returns a query that sets the transaction isolation level.\n   *\n   * @param  {string} value   The isolation level.\n   * @param  {Object} options An object with options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return `SET TRANSACTION ISOLATION LEVEL ${value};`;\n  },\n\n  generateTransactionId() {\n    return uuidv4();\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n\n    return 'START TRANSACTION;';\n  },\n\n  deferConstraintsQuery() {},\n\n  setConstraintQuery() {},\n  setDeferredQuery() {},\n  setImmediateQuery() {},\n\n  /**\n   * Returns a query that commits a transaction.\n   *\n   * @param  {Transaction} transaction An object with options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT;';\n  },\n\n  /**\n   * Returns a query that rollbacks a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n\n    return 'ROLLBACK;';\n  }\n};\n\nmodule.exports = TransactionQueries;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query-generator/transaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 480,
    "kind": "variable",
    "name": "uuidv4",
    "memberof": "lib/dialects/abstract/query-generator/transaction.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/transaction.js~uuidv4",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/transaction.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 481,
    "kind": "variable",
    "name": "TransactionQueries",
    "memberof": "lib/dialects/abstract/query-generator/transaction.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator/transaction.js~TransactionQueries",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator/transaction.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "{\"setIsolationLevelQuery\": function, \"generateTransactionId\": function, \"startTransactionQuery\": function, \"deferConstraintsQuery\": function, \"setConstraintQuery\": function, \"setDeferredQuery\": function, \"setImmediateQuery\": function, \"commitTransactionQuery\": function, \"rollbackTransactionQuery\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 482,
    "kind": "file",
    "name": "lib/dialects/abstract/query-generator.js",
    "content": "'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst uuidv4 = require('uuid').v4;\nconst semver = require('semver');\n\nconst Utils = require('../../utils');\nconst deprecations = require('../../utils/deprecations');\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst Model = require('../../model');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst Op = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst IndexHints = require('../../index-hints');\n\nconst QuoteHelper = require('./query-generator/helpers/quote');\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n\n    // dialect name\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n  }\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  }\n\n  addSchema(param) {\n    if (!param._schema) return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `DESCRIBE ${table};`;\n  }\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {Object} valueHash       attribute value pairs\n   * @param {Object} modelAttributes\n   * @param {Object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const fields = [];\n    const values = [];\n    const bind = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = ''; //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in modelAttributes) {\n            const attribute = modelAttributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns});`;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          const selectFromTmp = ';select * from @tmp';\n\n          valueQuery += selectFromTmp;\n          emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));\n          }\n        }\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = `${`CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter}` +\n          ' BEGIN '}${valueQuery} INTO response; EXCEPTION ${options.exception} END ${delimiter\n        } LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()`;\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF ${quotedTable} AS $body$ BEGIN RETURN QUERY ${valueQuery}; EXCEPTION ${options.exception} END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();`;\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n      emptyQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n    }\n\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {Object} fieldValueHashes\n   * @param {Object} options\n   * @param {Object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this._dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          return fieldValueHash[key] || 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;\n      } else { // mysql / maria\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this._dialect.supports.returnValues && Array.isArray(options.returning)) {\n      const fields = options.returning.map(field => this.quoteIdentifier(field)).join(',');\n      returning += ` RETURNING ${fields}`;\n    } else {\n      returning += this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : '';\n    }\n\n    return `INSERT${ignoreDuplicates} INTO ${this.quoteTable(tableName)} (${attributes}) VALUES ${tuples.join(',')}${onDuplicateKeyUpdate}${onConflictDoNothing}${returning};`;\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {Object} attrValueHash\n   * @param {Object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = ''; // tmpTable declaration for trigger\n    let selectFromTmp = ''; // Select statement for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (this.dialect !== 'mssql') {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      }\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in attributes) {\n            const attribute = attributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns}); `;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          selectFromTmp = ';select * from @tmp';\n\n          suffix += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        suffix += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n        modelAttributeMap[key].autoIncrement === true &&\n        !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator      String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName     Name of the table\n   * @param {Object} attrValueHash A hash with attribute-value-pairs\n   * @param {Object} where         A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   */\n  arithmeticQuery(operator, tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    const values = [];\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        options.mapToModel = true;\n        returningFragment = 'RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.quoteIdentifier(key)}${operator} ${this.escape(value)}`);\n    }\n\n    attributes = attributes || {};\n    for (const key in attributes) {\n      const value = attributes[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.escape(value)}`);\n    }\n\n    return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where)} ${returningFragment}`.trim();\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = Utils.nameIndex(options, options.prefix);\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})`,\n      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !references.field) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const referencesSnippet = `${this.quoteTable(references.table)} (${this.quoteIdentifier(references.field)})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} DROP CONSTRAINT ${this.quoteIdentifiers(constraintName)}`;\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from its alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.includes('.')\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {\n      force,\n      quoteIdentifiers: this.options.quoteIdentifiers\n    });\n  }\n\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, identifiers.length - 1).join('->');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param {string|Object}  param table string or object\n   * @param {string|boolean} alias alias name\n   *\n   * @returns {string}\n   */\n  quoteTable(param, alias) {\n    let table = '';\n\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (alias) {\n      table += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return table;\n  }\n\n  /*\n    Escape a value (e.g. a string, number or date)\n    @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.stringify) {\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\n\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n\n          if (field.type.escape === false) {\n            // The data-type already did the required escaping\n            return value;\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n\n  bindParam(bind) {\n    return value => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n\n    return bindParam(value);\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(\n            error.message,\n            'Validation error',\n            field.fieldName,\n            value,\n            null,\n            `${field.type.key} validator`\n          ));\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  isIdentifierQuoted(identifier) {\n    return QuoteHelper.isIdentifierQuoted(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column  The JSON column\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\n   * @returns {string}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    switch (this.dialect) {\n      case 'mysql':\n      case 'mariadb':\n      case 'sqlite':\n        /**\n         * Non digit sub paths need to be quoted as ECMAScript identifiers\n         * https://bugs.mysql.com/bug.php?id=81896\n         */\n        if (this.dialect === 'mysql') {\n          paths = paths.map(subPath => {\n            return /\\D/.test(subPath)\n              ? Utils.addTicks(subPath, '\"')\n              : subPath;\n          });\n        }\n\n        pathStr = this.escape(['$']\n          .concat(paths)\n          .join('.')\n          .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n        if (this.dialect === 'sqlite') {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n\n      case 'postgres':\n        pathStr = this.escape(`{${paths.join(',')}}`);\n        return `(${quotedColumn}#>>${pathStr})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // Aliases can be passed through subqueries and we don't want to reset them\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = new Map();\n      options.aliasesByTable = {};\n    }\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = Object.assign({}, options.where);\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: Object.assign({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n        })`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);\n\n      if (subQuery) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else {\n          deprecations.noRawAttributes();\n        }\n        let alias = attr[1];\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n\n        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"')\n          ? this.quoteAttribute(attr, options.model)\n          : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n\n        return `${prefix} AS ${this.quoteIdentifier(alias, true)}`;\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  }\n\n  _getMinifiedAlias(alias, tableName, options) {\n    // We do not want to re-alias in case of a subquery\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n\n    // Do not alias custom suquery_orders\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n\n    return minifiedAlias;\n  }\n\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n\n        if (topLevelInfo.subQuery) {\n          subqueryAttributes.push(`${tableName}.${this.quoteIdentifier(fieldLeft)}`);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n\n      return `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)\n      } AS ${\n        this.quoteIdentifier(alias)}`;\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    if (this._dialect.supports.joinTableDependent) {\n      // Generate a wrapped join so that the through table join can be dependent on the target join\n      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n      if (throughWhere) {\n        joinBody += ` AND ${throughWhere}`;\n      }\n      joinBody += ')';\n      joinCondition = sourceJoinOn;\n    } else {\n      // Generate join SQL for left side of through\n      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;\n      joinCondition = targetJoinOn;\n      if (throughWhere) {\n        joinCondition += ` AND ${throughWhere}`;\n      }\n    }\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) { // eslint-disable-line\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [Object.assign({}, child, { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(' = ')),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL'\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = Object.assign({}, include, { attributes: [], include: [] });\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          subQueryOrder.push(this.quote(order, model, '->'));\n        }\n\n        if (subQuery) {\n          // Handle case where sub-query renames attribute we want to order by,\n          // see https://github.com/sequelize/sequelize/issues/8739\n          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);\n          if (subQueryAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n\n            order[0] = new Utils.Col(this._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        if (value === 'NULL') {\n          if (smth.comparator === '=') {\n            smth.comparator = 'IS';\n          }\n          if (smth.comparator === '!=') {\n            smth.comparator = 'IS NOT';\n          }\n        }\n\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n\n      if (value === 'NULL') {\n        if (smth.comparator === '=') {\n          smth.comparator = 'IS';\n        }\n        if (smth.comparator === '!=') {\n          smth.comparator = 'IS NOT';\n        }\n      }\n\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map(arg => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(arg);\n      }).join(', ')})`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null ||\n      where === undefined ||\n      Utils.getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') binding = ` ${binding} `;\n\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach(prop => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field.field || keyParts[0], tmp, Object.assign({ field }, options));\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map(prop => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    Utils.getOperators(value).forEach(op => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, Object.assign({}, options, { json: false })));\n    });\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    const pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach(op => {\n        const value = this._toJSONValue(item[op]);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n\n    return new Utils.Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    return;\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1]\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1]\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`${value}%`), comparator, options.prefix);\n      case Op.endsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}`), comparator, options.prefix);\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}%`), comparator, options.prefix);\n    }\n\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === 'number') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n    if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return '1=1';\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n}\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\n\nmodule.exports = QueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 483,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 484,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "variable",
    "name": "uuidv4",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~uuidv4",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 486,
    "kind": "variable",
    "name": "semver",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~semver",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 487,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 488,
    "kind": "variable",
    "name": "deprecations",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~deprecations",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 489,
    "kind": "variable",
    "name": "SqlString",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~SqlString",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 490,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 491,
    "kind": "variable",
    "name": "Model",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~Model",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 492,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 493,
    "kind": "variable",
    "name": "BelongsTo",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 494,
    "kind": "variable",
    "name": "BelongsToMany",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~BelongsToMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 495,
    "kind": "variable",
    "name": "HasMany",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~HasMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 496,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 497,
    "kind": "variable",
    "name": "sequelizeError",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~sequelizeError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 498,
    "kind": "variable",
    "name": "IndexHints",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~IndexHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 499,
    "kind": "variable",
    "name": "QuoteHelper",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~QuoteHelper",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 500,
    "kind": "class",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/abstract/query-generator.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-generator.js",
    "importStyle": null,
    "description": "Abstract Query Generator",
    "lineNumber": 28,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 501,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 502,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "options",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#options",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 504,
    "kind": "member",
    "name": "dialect",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#dialect",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 505,
    "kind": "member",
    "name": "_dialect",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_dialect",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "extractTableDetails",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#extractTableDetails",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"schema\": *, \"tableName\": *, \"delimiter\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 507,
    "kind": "method",
    "name": "addSchema",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#addSchema",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "param",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 508,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 509,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaDelimiter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "dropTableQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#dropTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "renameTableQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#renameTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [
      {
        "name": "before",
        "types": [
          "*"
        ]
      },
      {
        "name": "after",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "insertQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#insertQuery",
    "access": "private",
    "description": "Returns an insert into command",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "valueHash",
        "description": "attribute value pairs"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "modelAttributes",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "bulkInsertQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#bulkInsertQuery",
    "access": "private",
    "description": "Returns an insert into command for multiple values.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldValueHashes",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldMappedAttributes",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "updateQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#updateQuery",
    "access": "private",
    "description": "Returns an update query",
    "lineNumber": 340,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attrValueHash",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "arithmeticQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#arithmeticQuery",
    "access": "public",
    "description": "Returns an update query using arithmetic operator",
    "lineNumber": 454,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "operator",
        "description": "String with the arithmetic operator (e.g. '+' or '-')"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Name of the table"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attrValueHash",
        "description": "A hash with attribute-value-pairs"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "addIndexQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#addIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 506,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "rawTablename",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "addConstraintQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#addConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 607,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 518,
    "kind": "method",
    "name": "getConstraintSnippet",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#getConstraintSnippet",
    "access": "public",
    "description": null,
    "lineNumber": 620,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "removeConstraintQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#removeConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 691,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "quote",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#quote",
    "access": "public",
    "description": null,
    "lineNumber": 724,
    "undocument": true,
    "params": [
      {
        "name": "collection",
        "types": [
          "*"
        ]
      },
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "connector",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 521,
    "kind": "method",
    "name": "quoteIdentifier",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#quoteIdentifier",
    "access": "public",
    "description": "Split a list of identifiers by \".\" and quote each part",
    "lineNumber": 890,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "force",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "quoteIdentifiers",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#quoteIdentifiers",
    "access": "public",
    "description": null,
    "lineNumber": 897,
    "undocument": true,
    "params": [
      {
        "name": "identifiers",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 523,
    "kind": "method",
    "name": "quoteAttribute",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#quoteAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 910,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "quoteTable",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#quoteTable",
    "access": "public",
    "description": "Quote table name with optional alias and schema attribution",
    "lineNumber": 925,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "table string or object"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "alias",
        "description": "alias name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 525,
    "kind": "method",
    "name": "escape",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#escape",
    "access": "public",
    "description": null,
    "lineNumber": 962,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "bindParam",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#bindParam",
    "access": "public",
    "description": null,
    "lineNumber": 989,
    "undocument": true,
    "params": [
      {
        "name": "bind",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 527,
    "kind": "method",
    "name": "format",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#format",
    "access": "public",
    "description": null,
    "lineNumber": 1000,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "bindParam",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 528,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#validate",
    "access": "public",
    "description": null,
    "lineNumber": 1023,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "isIdentifierQuoted",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#isIdentifierQuoted",
    "access": "public",
    "description": null,
    "lineNumber": 1050,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "jsonPathExtractionQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#jsonPathExtractionQuery",
    "access": "private",
    "description": "Generates an SQL query that extract JSON property of given path.",
    "lineNumber": 1062,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}                       The generated sql query"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "column",
        "description": "The JSON column"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "path",
        "description": "The path to extract (optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query"
    },
    "ignore": true
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "selectQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#selectQuery",
    "access": "public",
    "description": null,
    "lineNumber": 1117,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "aliasGrouping",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#aliasGrouping",
    "access": "public",
    "description": null,
    "lineNumber": 1404,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "escapeAttributes",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#escapeAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 1410,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "mainTableAs",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "generateInclude",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#generateInclude",
    "access": "public",
    "description": null,
    "lineNumber": 1451,
    "undocument": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentTableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "topLevelInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"mainQuery\": *, \"subQuery\": *, \"attributes\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "_getMinifiedAlias",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_getMinifiedAlias",
    "access": "private",
    "description": null,
    "lineNumber": 1611,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 536,
    "kind": "method",
    "name": "_getAliasForField",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_getAliasForField",
    "access": "private",
    "description": null,
    "lineNumber": 1630,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "generateJoin",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#generateJoin",
    "access": "public",
    "description": null,
    "lineNumber": 1639,
    "undocument": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "topLevelInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"join\": *, \"body\": *, \"condition\": *, \"attributes\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "generateThroughJoin",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#generateThroughJoin",
    "access": "public",
    "description": null,
    "lineNumber": 1729,
    "undocument": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "includeAs",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentTableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "topLevelInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"join\": *, \"body\": *, \"condition\": *, \"attributes\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "_generateSubQueryFilter",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_generateSubQueryFilter",
    "access": "private",
    "description": null,
    "lineNumber": 1848,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "includeAs",
        "types": [
          "*"
        ]
      },
      {
        "name": "topLevelInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 540,
    "kind": "method",
    "name": "_getRequiredClosure",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_getRequiredClosure",
    "access": "private",
    "description": null,
    "lineNumber": 1948,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 541,
    "kind": "method",
    "name": "getQueryOrders",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#getQueryOrders",
    "access": "public",
    "description": null,
    "lineNumber": 1960,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "subQuery",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"mainQueryOrder\": *, \"subQueryOrder\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "selectFromTableFragment",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#selectFromTableFragment",
    "access": "public",
    "description": null,
    "lineNumber": 2010,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "tables",
        "types": [
          "*"
        ]
      },
      {
        "name": "mainTableAs",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "addLimitAndOffset",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#addLimitAndOffset",
    "access": "private",
    "description": "Returns an SQL fragment for adding result constraints.",
    "lineNumber": 2035,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}         The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object with selectQuery options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "handleSequelizeMethod",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#handleSequelizeMethod",
    "access": "public",
    "description": null,
    "lineNumber": 2053,
    "undocument": true,
    "params": [
      {
        "name": "smth",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "whereQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#whereQuery",
    "access": "public",
    "description": null,
    "lineNumber": 2143,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 546,
    "kind": "method",
    "name": "whereItemsQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#whereItemsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 2151,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "binding",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "whereItemQuery",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#whereItemQuery",
    "access": "public",
    "description": null,
    "lineNumber": 2182,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "_findField",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_findField",
    "access": "private",
    "description": null,
    "lineNumber": 2286,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "_whereGroupBind",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_whereGroupBind",
    "access": "private",
    "description": null,
    "lineNumber": 2301,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 550,
    "kind": "method",
    "name": "_whereBind",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_whereBind",
    "access": "private",
    "description": null,
    "lineNumber": 2327,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "binding",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "_whereJSON",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_whereJSON",
    "access": "private",
    "description": null,
    "lineNumber": 2342,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "_traverseJSON",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_traverseJSON",
    "access": "private",
    "description": null,
    "lineNumber": 2368,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "items",
        "types": [
          "*"
        ]
      },
      {
        "name": "baseKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "prop",
        "types": [
          "*"
        ]
      },
      {
        "name": "item",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "_toJSONValue",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_toJSONValue",
    "access": "private",
    "description": null,
    "lineNumber": 2395,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "method",
    "name": "_castKey",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_castKey",
    "access": "private",
    "description": null,
    "lineNumber": 2399,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "cast",
        "types": [
          "*"
        ]
      },
      {
        "name": "json",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 555,
    "kind": "method",
    "name": "_getJsonCast",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_getJsonCast",
    "access": "private",
    "description": null,
    "lineNumber": 2408,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 556,
    "kind": "method",
    "name": "_joinKeyValue",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_joinKeyValue",
    "access": "private",
    "description": null,
    "lineNumber": 2421,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "comparator",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 557,
    "kind": "method",
    "name": "_getSafeKey",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_getSafeKey",
    "access": "private",
    "description": null,
    "lineNumber": 2432,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "_prefixKey",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_prefixKey",
    "access": "private",
    "description": null,
    "lineNumber": 2455,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 559,
    "kind": "method",
    "name": "_whereParseSingleValueObject",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#_whereParseSingleValueObject",
    "access": "private",
    "description": null,
    "lineNumber": 2467,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "prop",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 560,
    "kind": "method",
    "name": "getWhereConditions",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#getWhereConditions",
    "access": "public",
    "description": null,
    "lineNumber": 2563,
    "undocument": true,
    "params": [
      {
        "name": "smth",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 561,
    "kind": "method",
    "name": "parseConditionObject",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#parseConditionObject",
    "access": "public",
    "description": null,
    "lineNumber": 2634,
    "undocument": true,
    "params": [
      {
        "name": "conditions",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 562,
    "kind": "method",
    "name": "booleanValue",
    "memberof": "lib/dialects/abstract/query-generator.js~QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-generator.js~QueryGenerator#booleanValue",
    "access": "public",
    "description": null,
    "lineNumber": 2645,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 563,
    "kind": "file",
    "name": "lib/dialects/abstract/query-interface.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst Transaction = require(\"../../transaction\");\nconst QueryTypes = require(\"../../query-types\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map((schemaName) => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map((value) => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), { type: QueryTypes.VERSION }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: \"createTable\" });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), { cascade: true }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { supportsSearchPath: false }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWINDEXES }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.FOREIGNKEYS });\n    const results = await Promise.all(tableNames.map((tableName) => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map((r) => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance)\n      results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n      const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find((fields) => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\")\n      identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances)\n        continue;\n      if (!Array.isArray(instances))\n        instances = [instances];\n      for (const _instance of instances)\n        await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\")\n      where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), { type: QueryTypes.SELECT, model });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {\n  }\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql)\n      return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 564,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 565,
    "kind": "variable",
    "name": "__defProps",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__defProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 566,
    "kind": "variable",
    "name": "__getOwnPropDescs",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__getOwnPropDescs",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 568,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 570,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 571,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "function",
    "name": "__spreadProps",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~__spreadProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 573,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 575,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 576,
    "kind": "variable",
    "name": "Transaction",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~Transaction",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 577,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 578,
    "kind": "class",
    "name": "QueryInterface",
    "memberof": "lib/dialects/abstract/query-interface.js",
    "static": true,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 579,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 580,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 581,
    "kind": "member",
    "name": "queryGenerator",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#queryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "createDatabase",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#createDatabase",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 583,
    "kind": "method",
    "name": "dropDatabase",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropDatabase",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 586,
    "kind": "method",
    "name": "dropAllSchemas",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropAllSchemas",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 587,
    "kind": "method",
    "name": "showAllSchemas",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#showAllSchemas",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 588,
    "kind": "method",
    "name": "databaseVersion",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#databaseVersion",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "createTable",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#createTable",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "dropTable",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropTable",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "_dropAllTables",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#_dropAllTables",
    "access": "private",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "tableNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "skip",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "dropAllTables",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropAllTables",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "renameTable",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#renameTable",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "params": [
      {
        "name": "before",
        "types": [
          "*"
        ]
      },
      {
        "name": "after",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "showAllTables",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#showAllTables",
    "access": "public",
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "describeTable",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#describeTable",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "addColumn",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#addColumn",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "removeColumn",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#removeColumn",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "normalizeAttribute",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#normalizeAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "dataTypeOrOptions",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "quoteIdentifier",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#quoteIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "params": [
      {
        "name": "identifier2",
        "types": [
          "*"
        ]
      },
      {
        "name": "force",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "quoteIdentifiers",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#quoteIdentifiers",
    "access": "public",
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "params": [
      {
        "name": "identifiers",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 601,
    "kind": "method",
    "name": "changeColumn",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#changeColumn",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataTypeOrOptions",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 602,
    "kind": "method",
    "name": "assertTableHasColumn",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#assertTableHasColumn",
    "access": "public",
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 603,
    "kind": "method",
    "name": "renameColumn",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#renameColumn",
    "access": "public",
    "description": null,
    "lineNumber": 211,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrNameBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrNameAfter",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 604,
    "kind": "method",
    "name": "addIndex",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#addIndex",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "rawTablename",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 605,
    "kind": "method",
    "name": "showIndex",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#showIndex",
    "access": "public",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 606,
    "kind": "method",
    "name": "getForeignKeysForTables",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#getForeignKeysForTables",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [
      {
        "name": "tableNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 607,
    "kind": "method",
    "name": "getForeignKeyReferencesForTable",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#getForeignKeyReferencesForTable",
    "access": "public",
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 608,
    "kind": "method",
    "name": "removeIndex",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#removeIndex",
    "access": "public",
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "addConstraint",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#addConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 273,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "showConstraint",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#showConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "removeConstraint",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#removeConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "insert",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#insert",
    "access": "public",
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "upsert",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#upsert",
    "access": "public",
    "description": null,
    "lineNumber": 302,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "bulkInsert",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#bulkInsert",
    "access": "public",
    "description": null,
    "lineNumber": 332,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "records",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "update",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#update",
    "access": "public",
    "description": null,
    "lineNumber": 338,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier2",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "bulkUpdate",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#bulkUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier2",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "delete",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#delete",
    "access": "public",
    "description": null,
    "lineNumber": 357,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier2",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 618,
    "kind": "method",
    "name": "bulkDelete",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#bulkDelete",
    "access": "public",
    "description": null,
    "lineNumber": 384,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 619,
    "kind": "method",
    "name": "select",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#select",
    "access": "public",
    "description": null,
    "lineNumber": 394,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 620,
    "kind": "method",
    "name": "increment",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#increment",
    "access": "public",
    "description": null,
    "lineNumber": 398,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "incrementAmountsByField",
        "types": [
          "*"
        ]
      },
      {
        "name": "extraAttributesToBeUpdated",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 621,
    "kind": "method",
    "name": "decrement",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#decrement",
    "access": "public",
    "description": null,
    "lineNumber": 405,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "incrementAmountsByField",
        "types": [
          "*"
        ]
      },
      {
        "name": "extraAttributesToBeUpdated",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 622,
    "kind": "method",
    "name": "rawSelect",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#rawSelect",
    "access": "public",
    "description": null,
    "lineNumber": 412,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeSelector",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "createTrigger",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#createTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 449,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "timingType",
        "types": [
          "*"
        ]
      },
      {
        "name": "fireOnArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionParams",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 624,
    "kind": "method",
    "name": "dropTrigger",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 625,
    "kind": "method",
    "name": "renameTrigger",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#renameTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 463,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "oldTriggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "newTriggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "createFunction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#createFunction",
    "access": "public",
    "description": null,
    "lineNumber": 470,
    "undocument": true,
    "params": [
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "returnType",
        "types": [
          "*"
        ]
      },
      {
        "name": "language",
        "types": [
          "*"
        ]
      },
      {
        "name": "body",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "dropFunction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#dropFunction",
    "access": "public",
    "description": null,
    "lineNumber": 477,
    "undocument": true,
    "params": [
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 628,
    "kind": "method",
    "name": "renameFunction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#renameFunction",
    "access": "public",
    "description": null,
    "lineNumber": 484,
    "undocument": true,
    "params": [
      {
        "name": "oldFunctionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "newFunctionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "ensureEnums",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#ensureEnums",
    "access": "public",
    "description": null,
    "lineNumber": 491,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 630,
    "kind": "method",
    "name": "setIsolationLevel",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#setIsolationLevel",
    "access": "public",
    "description": null,
    "lineNumber": 493,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 631,
    "kind": "method",
    "name": "startTransaction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#startTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 508,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 632,
    "kind": "method",
    "name": "deferConstraints",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#deferConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 517,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 633,
    "kind": "method",
    "name": "commitTransaction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#commitTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 524,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 634,
    "kind": "method",
    "name": "rollbackTransaction",
    "memberof": "lib/dialects/abstract/query-interface.js~QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/abstract/query-interface.js~QueryInterface#rollbackTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 541,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 635,
    "kind": "file",
    "name": "lib/dialects/abstract/query.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst SqlString = require('../../sql-string');\nconst QueryTypes = require('../../query-types');\nconst Dot = require('dottie');\nconst deprecations = require('../../utils/deprecations');\nconst uuid = require('uuid').v4;\n\nclass AbstractQuery {\n\n  constructor(connection, sequelize, options) {\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = Object.assign({\n      plain: false,\n      raw: false,\n      // eslint-disable-next-line no-console\n      logging: console.log\n    }, options || {});\n    this.checkLoggingOption();\n  }\n\n  /**\n   * rewrite query with parameters\n   *\n   * Examples:\n   *\n   *   query.formatBindParameters('select $1 as foo', ['fooval']);\n   *\n   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });\n   *\n   * Options\n   *   skipUnescape: bool, skip unescaping $$\n   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available\n   *\n   * @param {string} sql\n   * @param {Object|Array} values\n   * @param {string} dialect\n   * @param {Function} [replacementFunc]\n   * @param {Object} [options]\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n\n    options = options || {};\n    if (typeof replacementFunc !== 'function') {\n      options = replacementFunc || {};\n      replacementFunc = undefined;\n    }\n\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values) => {\n          if (values[key] !== undefined) {\n            return match;\n          }\n          return undefined;\n        };\n      } else {\n        replacementFunc = (match, key, values, timeZone, dialect) => {\n          if (values[key] !== undefined) {\n            return SqlString.escape(values[key], timeZone, dialect);\n          }\n          return undefined;\n        };\n      }\n    } else if (options.skipValueReplace) {\n      const origReplacementFunc = replacementFunc;\n      replacementFunc = (match, key, values, timeZone, dialect, options) => {\n        if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {\n          return match;\n        }\n        return undefined;\n      };\n    }\n\n    const timeZone = null;\n    const list = Array.isArray(values);\n\n    sql = sql.replace(/\\$(\\$|\\w+)/g, (match, key) => {\n      if ('$' === key) {\n        return options.skipUnescape ? match : key;\n      }\n\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else if (!key.match(/^\\d*$/)) {\n        replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n      }\n      if (replVal === undefined) {\n        throw new Error(`Named bind parameter \"${match}\" has no value in the given object.`);\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n\n  /**\n   * Execute the passed sql query.\n   *\n   * Examples:\n   *\n   *     query.run('SELECT 1')\n   *\n   * @private\n   */\n  run() {\n    throw new Error('The run method wasn\\'t overwritten!');\n  }\n\n  /**\n   * Check the logging option of the instance and print deprecation warnings.\n   *\n   * @private\n   */\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      // eslint-disable-next-line no-console\n      this.options.logging = console.log;\n    }\n  }\n\n  /**\n   * Get the attributes of an insert query, which contains the just inserted id.\n   *\n   * @returns {string} The field name.\n   * @private\n   */\n  getInsertIdField() {\n    return 'insertId';\n  }\n\n  getUniqueConstraintErrorMessage(field) {\n    let message = field ? `${field} must be unique` : 'Must be unique';\n\n    if (field && this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, ''))) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n\n  isInsertQuery(results, metaData) {\n    let result = true;\n\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n\n    // is insert query if sql contains insert into\n    result = result && this.sql.toLowerCase().startsWith('insert into');\n\n    // is insert query if no results are passed or if the result has the inserted id\n    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n\n    // is insert query if no metadata are passed or if the metadata has the inserted id\n    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n\n    return result;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n\n  handleShowTablesQuery(results) {\n    return _.flatten(results.map(resultSet => _.values(resultSet)));\n  }\n\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n\n  handleSelectQuery(results) {\n    let result = null;\n\n    // Map raw fields to names if a mapping is provided\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = results.map(result => _.reduce(fieldMap, (result, name, field) => {\n        if (result[field] !== undefined && name !== field) {\n          result[name] = result[field];\n          delete result[field];\n        }\n        return result;\n      }, result));\n    }\n\n    // Raw queries\n    if (this.options.raw) {\n      result = results.map(result => {\n        let o = {};\n\n        for (const key in result) {\n          if (Object.prototype.hasOwnProperty.call(result, key)) {\n            o[key] = result[key];\n          }\n        }\n\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n\n        return o;\n      });\n    // Queries with include\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    // Regular queries\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.originalAttributes || this.options.attributes\n      });\n    }\n\n    // return the first real model instance if options.plain is set (e.g. Model.find)\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().startsWith('show');\n    result = result || this.sql.toLowerCase().startsWith('describe');\n\n    return result;\n  }\n\n  isCallQuery() {\n    return this.sql.toLowerCase().startsWith('call');\n  }\n\n  /**\n   * @param {string} sql\n   * @param {Function} debugContext\n   * @param {Array|Object} parameters\n   * @protected\n   * @returns {Function} A function to call after the query was completed.\n   */\n  _logQuery(sql, debugContext, parameters) {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = '';\n\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(';') ? '' : ';';\n      let paramStr;\n      if (Array.isArray(parameters)) {\n        paramStr = parameters.map(p=>JSON.stringify(p)).join(', ');\n      } else {\n        paramStr = JSON.stringify(parameters);\n      }\n      logParameter = `${delimiter} ${paramStr}`;\n    }\n    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;\n    const msg = `Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`Executing ${fmt}`, options);\n    }\n    return () => {\n      const afterMsg = `Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n\n  /**\n   * The function takes the result of the query execution and groups\n   * the associated data by the callee.\n   *\n   * Example:\n   *   groupJoinData([\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 1 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 2 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 3 }\n   *     }\n   *   ])\n   *\n   * Result:\n   *   Something like this:\n   *\n   *   [\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: [\n   *         { foo: 'bar', id: 1 },\n   *         { foo: 'bar', id: 2 },\n   *         { foo: 'bar', id: 3 }\n   *       ]\n   *     }\n   *   ]\n   *\n   * @param {Array} rows\n   * @param {Object} includeOptions\n   * @param {Object} options\n   * @private\n   */\n  static _groupJoinData(rows, includeOptions, options) {\n\n    /*\n     * Assumptions\n     * ID is not necessarily the first field\n     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)\n     * Parent keys will be seen before any include/child keys\n     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)\n     */\n\n    /*\n     * Author (MH) comment: This code is an unreadable mess, but it's performant.\n     * groupJoinData is a performance critical function so we prioritize perf over readability.\n     */\n    if (!rows.length) {\n      return [];\n    }\n\n    // Generic looping\n    let i;\n    let length;\n    let $i;\n    let $length;\n    // Row specific looping\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    // Key specific looping\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    // If we don't have to deduplicate we can pre-allocate the resulting array\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    // Result variables for the respective functions\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString; // eslint-disable-line\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    // Map each key to an include option\n    let previousPiece;\n    const buildIncludeMap = piece => {\n      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = `${previousPiece}.${piece}`;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key, memo) => {\n      if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n        memo[key] = key.substr(0, key.lastIndexOf('.'));\n      }\n      return memo[key];\n    };\n    // Removes the prefix from a key ('id' for 'User.Results.id')\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = key => {\n      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {\n        const index = key.lastIndexOf('.');\n        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key];\n    };\n    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')\n    const keyPrefixMemo = {};\n    const keyPrefix = key => {\n      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values\n      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {\n        const prefixString = keyPrefixString(key, keyPrefixStringMemo);\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];\n        }\n        keyPrefixMemo[key] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key];\n    };\n    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = key => {\n      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {\n        const prefix = keyPrefix(key);\n        const length = prefix.length;\n\n        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];\n      }\n      return lastKeyPrefixMemo[key];\n    };\n    const getUniqueKeyAttributes = model => {\n      let uniqueKeyAttributes = _.chain(model.uniqueKeys);\n      uniqueKeyAttributes = uniqueKeyAttributes\n        .result(`${uniqueKeyAttributes.findKey()}.fields`)\n        .map(field => _.findKey(model.attributes, chr => chr.field === field))\n        .value();\n\n      return uniqueKeyAttributes;\n    };\n    const stringify = obj => obj instanceof Buffer ? obj.toString('hex') : obj;\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n\n      // Keys are the same for all rows, so only need to compute them on the first row\n      if (rowsI === 0) {\n        keys = Object.keys(row);\n        keyLength = keys.length;\n      }\n\n      if (checkExisting) {\n        topExists = false;\n\n        // Compute top level hash key (this is usually just the primary key values)\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = '';\n        if ($length === 1) {\n          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n        }\n        else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n          }\n        }\n        else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n\n      topValues = values = {};\n      $prevKeyPrefix = undefined;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n\n        // The string prefix isn't actualy needed\n        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix\n        // TODO: Find a better way?\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n\n        // On the first row we compute the includeMap\n        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[''] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = undefined;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        // End of key set\n        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            // Compute hash key for this set instance\n            // TODO: Optimize\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n                }\n                else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n                  }\n                }\n                else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else if (!resultMap[itemHash]) {\n              $parent = resultMap[parentHash];\n              $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n              if (includeMap[prevKey].association.isSingleAssociation) {\n                if ($parent) {\n                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                }\n              } else {\n                if (!$parent[$lastKeyPrefix]) {\n                  $parent[$lastKeyPrefix] = [];\n                }\n                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n              }\n            }\n\n            // Reset values\n            values = {};\n          } else {\n            // If checkExisting is false it's because there's only 1:1 associations in this query\n            // However we still need to map onto the appropriate parent\n            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length - 1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]] || {};\n              }\n            }\n          }\n        }\n\n        // End of iteration, set value and set prev values (for next iteration)\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n            }\n            else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n              }\n            }\n            else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else if (!resultMap[itemHash]) {\n          $parent = resultMap[parentHash];\n          $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n          if (includeMap[prevKey].association.isSingleAssociation) {\n            if ($parent) {\n              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n            }\n          } else {\n            if (!$parent[$lastKeyPrefix]) {\n              $parent[$lastKeyPrefix] = [];\n            }\n            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n\n    return results;\n  }\n}\n\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports.default = AbstractQuery;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/abstract/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 636,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "variable",
    "name": "SqlString",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~SqlString",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 638,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 639,
    "kind": "variable",
    "name": "Dot",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~Dot",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 640,
    "kind": "variable",
    "name": "deprecations",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~deprecations",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 641,
    "kind": "variable",
    "name": "uuid",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~uuid",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 642,
    "kind": "class",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/abstract/query.js",
    "static": true,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/abstract/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 643,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 644,
    "kind": "member",
    "name": "uuid",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#uuid",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 645,
    "kind": "member",
    "name": "connection",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#connection",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 646,
    "kind": "member",
    "name": "instance",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#instance",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 647,
    "kind": "member",
    "name": "model",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#model",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 648,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 649,
    "kind": "member",
    "name": "options",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#options",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery.formatBindParameters",
    "access": "private",
    "description": "rewrite query with parameters\n\nExamples:\n\n  query.formatBindParameters('select $1 as foo', ['fooval']);\n\n  query.formatBindParameters('select $foo as foo', { foo: 'fooval' });\n\nOptions\n  skipUnescape: bool, skip unescaping $$\n  skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dialect",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "replacementFunc",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#run",
    "access": "private",
    "description": "Execute the passed sql query.\n\nExamples:\n\n    query.run('SELECT 1')",
    "lineNumber": 118,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "checkLoggingOption",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#checkLoggingOption",
    "access": "private",
    "description": "Check the logging option of the instance and print deprecation warnings.",
    "lineNumber": 127,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "getInsertIdField",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#getInsertIdField",
    "access": "private",
    "description": "Get the attributes of an insert query, which contains the just inserted id.",
    "lineNumber": 141,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The field name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The field name."
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "getUniqueConstraintErrorMessage",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#getUniqueConstraintErrorMessage",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "isRawQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isRawQuery",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 656,
    "kind": "method",
    "name": "isVersionQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isVersionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 657,
    "kind": "method",
    "name": "isUpsertQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isUpsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "isInsertQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "handleInsertQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#handleInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaData",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 660,
    "kind": "method",
    "name": "isShowTablesQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isShowTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "handleShowTablesQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#handleShowTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "isShowIndexesQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 663,
    "kind": "method",
    "name": "isShowConstraintsQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isShowConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 664,
    "kind": "method",
    "name": "isDescribeQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isDescribeQuery",
    "access": "public",
    "description": null,
    "lineNumber": 220,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 665,
    "kind": "method",
    "name": "isSelectQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isSelectQuery",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "isBulkUpdateQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isBulkUpdateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "isBulkDeleteQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isBulkDeleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "isForeignKeysQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isForeignKeysQuery",
    "access": "public",
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "isUpdateQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isUpdateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 670,
    "kind": "method",
    "name": "handleSelectQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#handleSelectQuery",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 671,
    "kind": "method",
    "name": "isShowOrDescribeQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isShowOrDescribeQuery",
    "access": "public",
    "description": null,
    "lineNumber": 311,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 672,
    "kind": "method",
    "name": "isCallQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#isCallQuery",
    "access": "public",
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 673,
    "kind": "method",
    "name": "_logQuery",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery#_logQuery",
    "access": "protected",
    "description": "",
    "lineNumber": 331,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Function} A function to call after the query was completed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "debugContext",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "A function to call after the query was completed."
    },
    "ignore": true
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "_groupJoinData",
    "memberof": "lib/dialects/abstract/query.js~AbstractQuery",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/abstract/query.js~AbstractQuery._groupJoinData",
    "access": "private",
    "description": "The function takes the result of the query execution and groups\nthe associated data by the callee.\n\nExample:\n  groupJoinData([\n    {\n      some: 'data',\n      id: 1,\n      association: { foo: 'bar', id: 1 }\n    }, {\n      some: 'data',\n      id: 1,\n      association: { foo: 'bar', id: 2 }\n    }, {\n      some: 'data',\n      id: 1,\n      association: { foo: 'bar', id: 3 }\n    }\n  ])\n\nResult:\n  Something like this:\n\n  [\n    {\n      some: 'data',\n      id: 1,\n      association: [\n        { foo: 'bar', id: 1 },\n        { foo: 'bar', id: 2 },\n        { foo: 'bar', id: 3 }\n      ]\n    }\n  ]",
    "lineNumber": 404,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "rows",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "includeOptions",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 675,
    "kind": "file",
    "name": "lib/dialects/db2/connection-manager.js",
    "content": "\"use strict\";\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst sequelizeErrors = require(\"../../errors\");\nconst { logger } = require(\"../../utils/logger\");\nconst DataTypes = require(\"../../data-types\").db2;\nconst debug = logger.debugContext(\"connection:db2\");\nconst parserStore = require(\"../parserStore\")(\"db2\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, (error) => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close((error) => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n    return Promise.resolve();\n  }\n  validate(connection) {\n    return connection && connection.connected;\n  }\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 676,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 677,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 678,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 679,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 680,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 681,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 682,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/db2/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractConnectionManager"
    ],
    "ignore": true
  },
  {
    "__docId__": 683,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 684,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "_typecast",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager._typecast",
    "access": "private",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "next",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 687,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#connect",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "_disconnect",
    "memberof": "lib/dialects/db2/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/connection-manager.js~ConnectionManager#_disconnect",
    "access": "private",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 692,
    "kind": "file",
    "name": "lib/dialects/db2/data-types.js",
    "content": "\"use strict\";\nconst momentTz = require(\"moment-timezone\");\nconst moment = require(\"moment\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008478.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`Db2 does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.db2 = [\"TIMESTAMP\"];\n  BaseTypes.STRING.types.db2 = [\"VARCHAR\"];\n  BaseTypes.CHAR.types.db2 = [\"CHAR\"];\n  BaseTypes.TEXT.types.db2 = [\"VARCHAR\", \"CLOB\"];\n  BaseTypes.TINYINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.SMALLINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.db2 = [\"INTEGER\"];\n  BaseTypes.INTEGER.types.db2 = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.db2 = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.db2 = [\"DOUBLE\", \"REAL\", \"FLOAT\"];\n  BaseTypes.TIME.types.db2 = [\"TIME\"];\n  BaseTypes.DATEONLY.types.db2 = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.db2 = [\"BOOLEAN\", \"BOOL\", \"SMALLINT\", \"BIT\"];\n  BaseTypes.BLOB.types.db2 = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.db2 = [\"DECIMAL\"];\n  BaseTypes.UUID.types.db2 = [\"CHAR () FOR BIT DATA\"];\n  BaseTypes.ENUM.types.db2 = [\"VARCHAR\"];\n  BaseTypes.REAL.types.db2 = [\"REAL\"];\n  BaseTypes.DOUBLE.types.db2 = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.db2 = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          return \"BLOB(255)\";\n        }\n        if (this._length.toLowerCase() === \"medium\") {\n          return \"BLOB(16M)\";\n        }\n        if (this._length.toLowerCase() === \"long\") {\n          return \"BLOB(2G)\";\n        }\n        return `BLOB(${this._length})`;\n      }\n      return \"BLOB\";\n    }\n    escape(blob) {\n      return `BLOB('${blob.toString().replace(/'/g, \"''\")}')`;\n    }\n    _stringify(value) {\n      if (Buffer.isBuffer(value)) {\n        return `BLOB('${value.toString().replace(/'/g, \"''\")}')`;\n      }\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n      const hex = value.toString(\"hex\");\n      return this._hexify(hex);\n    }\n    _hexify(hex) {\n      return `x'${hex}'`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        if (this._length <= 4e3) {\n          return `VARCHAR(${this._length})`;\n        }\n        return `CLOB(${this._length})`;\n      }\n      if (this._length < 255) {\n        return `CHAR(${this._length}) FOR BIT DATA`;\n      }\n      if (this._length <= 4e3) {\n        return `VARCHAR(${this._length}) FOR BIT DATA`;\n      }\n      return `BLOB(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._hexify(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      let len = 0;\n      if (this._length) {\n        switch (this._length.toLowerCase()) {\n          case \"tiny\":\n            len = 256;\n            break;\n          case \"medium\":\n            len = 8192;\n            break;\n          case \"long\":\n            len = 65536;\n            break;\n        }\n        if (isNaN(this._length)) {\n          this._length = 32672;\n        }\n        if (len > 0) {\n          this._length = len;\n        }\n      } else {\n        this._length = 32672;\n      }\n      if (this._length > 32672) {\n        len = `CLOB(${this._length})`;\n      } else {\n        len = `VARCHAR(${this._length})`;\n      }\n      warn(`Db2 does not support TEXT datatype. ${len} will be used instead.`);\n      return len;\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          value = value === \"true\" ? true : value === \"false\" ? false : value;\n          value = value === \"\u0001\" ? true : value === \"\\0\" ? false : value;\n        } else if (typeof value === \"number\") {\n          value = value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) FOR BIT DATA\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"CURRENT TIME\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      if (this._length < 0) {\n        this._length = 0;\n      }\n      if (this._length > 6) {\n        this._length = 6;\n      }\n      return `TIMESTAMP${this._length ? `(${this._length})` : \"\"}`;\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length > 0) {\n        let msec = \".\";\n        for (let i = 0; i < this._length && i < 6; i++) {\n          msec += \"S\";\n        }\n        return date.format(`YYYY-MM-DD HH:mm:ss${msec}`);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value) {\n      if (typeof value !== \"string\") {\n        value = value.string();\n      }\n      if (value === null) {\n        return value;\n      }\n      value = new Date(momentTz.utc(value));\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return momentTz(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Db2 does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"Db2 does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"Db2 does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"Db2 does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"db2 does not support DOUBLE with options. Plain DOUBLE will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"DOUBLE\";\n    }\n  }\n  DOUBLE.prototype.key = DOUBLE.key = \"DOUBLE\";\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    DOUBLE,\n    \"DOUBLE PRECISION\": DOUBLE,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 693,
    "kind": "variable",
    "name": "momentTz",
    "memberof": "lib/dialects/db2/data-types.js",
    "static": true,
    "longname": "lib/dialects/db2/data-types.js~momentTz",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 694,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/db2/data-types.js",
    "static": true,
    "longname": "lib/dialects/db2/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 695,
    "kind": "file",
    "name": "lib/dialects/db2/index.js",
    "content": "\"use strict\";\nconst _ = require(\"lodash\");\nconst AbstractDialect = require(\"../abstract\");\nconst ConnectionManager = require(\"./connection-manager\");\nconst Query = require(\"./query\");\nconst QueryGenerator = require(\"./query-generator\");\nconst DataTypes = require(\"../../data-types\").db2;\nconst { Db2QueryInterface } = require(\"./query-interface\");\nclass Db2Dialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new Db2QueryInterface(sequelize, this.queryGenerator);\n  }\n}\nDb2Dialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: false,\n  schemas: true,\n  finalTable: true,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: false,\n    update: true\n  },\n  constraints: {\n    restrict: true,\n    default: false\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nDb2Dialect.prototype.defaultVersion = \"1.0.0\";\nDb2Dialect.prototype.Query = Query;\nDb2Dialect.prototype.name = \"db2\";\nDb2Dialect.prototype.TICK_CHAR = '\"';\nDb2Dialect.prototype.TICK_CHAR_LEFT = '\"';\nDb2Dialect.prototype.TICK_CHAR_RIGHT = '\"';\nDb2Dialect.prototype.DataTypes = DataTypes;\nmodule.exports = Db2Dialect;\n//# sourceMappingURL=index.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 696,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 697,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 698,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 699,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 700,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 701,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 702,
    "kind": "variable",
    "name": "Db2QueryInterface",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~Db2QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 703,
    "kind": "class",
    "name": "Db2Dialect",
    "memberof": "lib/dialects/db2/index.js",
    "static": true,
    "longname": "lib/dialects/db2/index.js~Db2Dialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 704,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/db2/index.js~Db2Dialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/index.js~Db2Dialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 705,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/db2/index.js~Db2Dialect",
    "static": false,
    "longname": "lib/dialects/db2/index.js~Db2Dialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 706,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/db2/index.js~Db2Dialect",
    "static": false,
    "longname": "lib/dialects/db2/index.js~Db2Dialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 707,
    "kind": "member",
    "name": "queryGenerator",
    "memberof": "lib/dialects/db2/index.js~Db2Dialect",
    "static": false,
    "longname": "lib/dialects/db2/index.js~Db2Dialect#queryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 708,
    "kind": "member",
    "name": "queryInterface",
    "memberof": "lib/dialects/db2/index.js~Db2Dialect",
    "static": false,
    "longname": "lib/dialects/db2/index.js~Db2Dialect#queryInterface",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 709,
    "kind": "file",
    "name": "lib/dialects/db2/query-generator.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst randomBytes = require(\"crypto\").randomBytes;\nconst Op = require(\"../../operators\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP_LIKE\",\n      [Op.notRegexp]: \"NOT REGEXP_LIKE\"\n    });\n    this.autoGenValue = 1;\n  }\n  createSchema(schema) {\n    return [\n      \"CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;\n    const sql = { query };\n    sql.bind = [\n      { ParamType: \"INOUT\", Data: \"ERRORSCHEMA\" },\n      { ParamType: \"INOUT\", Data: \"ERRORTABLE\" }\n    ];\n    return sql;\n  }\n  showSchemasQuery() {\n    return `SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;\n  }\n  versionQuery() {\n    return \"select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const query = \"CREATE TABLE <%= table %> (<%= attributes %>)\", primaryKeys = [], foreignKeys = {}, attrStr = [], commentTemplate = \" -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;\";\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, \"\").trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            dataType = commentMatch[1];\n          }\n        }\n        if (_.includes(dataType, \"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (_.includes(dataType, \"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, \"\")}`);\n          }\n        } else if (_.includes(dataType, \"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, \"NOT NULL\")) {\n                dataType += \" NOT NULL\";\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(\", \")\n    }, pkString = primaryKeys.map((pk) => {\n      return this.quoteIdentifier(pk);\n    }).join(\", \");\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",',\n      'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",',\n      'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",',\n      'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"',\n      \"FROM\",\n      \"SYSIBM.SYSCOLUMNS\",\n      \"WHERE TBNAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += \" AND TBCREATOR = USER\";\n    }\n    return `${sql};`;\n  }\n  renameTableQuery(before, after) {\n    const query = \"RENAME TABLE <%= before %> TO <%= after %>;\";\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n  showTablesQuery() {\n    return `SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;\n  }\n  dropTableQuery(tableName) {\n    const query = \"DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const query = \"ALTER TABLE <%= table %> ADD <%= attribute %>;\", attribute = _.template(\"<%= key %> <%= definition %>\", this._templateSettings)({\n      key: this.quoteIdentifier(key),\n      definition: this.attributeToSQL(dataType, {\n        context: \"addColumn\"\n      })\n    });\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const query = \"ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;\";\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> <%= query %>;\";\n    const attrString = [], constraintString = [];\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template(\"<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>\", this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, \"\")\n          }));\n        } else if (_.startsWith(definition, \"DROP \")) {\n          attrString.push(_.template(\"<%= attrName %> <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template(\"<%= attrName %> SET <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n    let finalQuery = \"\";\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(\" ALTER COLUMN \")}`;\n      finalQuery += constraintString.length ? \" \" : \"\";\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(\" ADD CONSTRAINT \")}`;\n    }\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;\", newName = Object.keys(attributes)[0];\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === \"CASCADE\") {\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = \"INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;\";\n    if (options.returning) {\n      query = \"SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);\";\n    }\n    const emptyQuery = \"INSERT INTO <%= table %>\", tuples = [], allAttributes = [], allQueries = [];\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n    if (options.returning) {\n      outputFragment = \"\";\n    }\n    _.forEach(attrValueHashes, (attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(\",\")}`);\n    }\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, (attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key]), void 0, { context: \"INSERT\" }).join(\",\")})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\"),\n      tuples,\n      output: outputFragment\n    };\n    const generatedQuery = _.template(allQueries.join(\";\"), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if (!options.limit) {\n      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;\n      return sql;\n    }\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(\",\")}`;\n    query = `SELECT * FROM FINAL TABLE (${query});`;\n    return { query, bind };\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    }).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(\", \");\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const query = \"DELETE FROM <%= table %><%= where %><%= limit %>\";\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = \"\";\n    if (options.offset > 0) {\n      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n    return _.template(query, this._templateSettings)(replacements);\n  }\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = void 0;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n    return `${sql} ORDER BY CONSTNAME;`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = \"DROP INDEX <%= indexName %>\";\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n    return _.template(sql, this._templateSettings)(values);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let template;\n    let changeNull = 1;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n    } else {\n      template = attribute.type.toString();\n    }\n    if (options && options.context === \"changeColumn\" && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {\n      template += \" NOT NULL\";\n      changeNull = 0;\n    }\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName}_${attrName}_fidx`;\n        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != \"CASCADE\") {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (options && options.context === \"changeColumn\" && changeNull === 1 && attribute.allowNull !== void 0) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push(\"DROP NOT NULL\");\n      } else {\n        template.push(\"NOT NULL\");\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n      if (key && !attribute.field && typeof attribute === \"object\")\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQuerySQL(condition) {\n    return `SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT TABNAME AS \"tableName\",',\n      'COLNAME AS \"columnName\",',\n      'CONSTNAME AS \"constraintName\"',\n      \"FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'\",\n      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,\n      `AND TABNAME = ${tableName};`\n    ].join(\" \");\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template(\"ALTER TABLE <%= table %> DROP <%= key %>\", this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = \"ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;\";\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n  setAutocommitQuery() {\n    return \"\";\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = \"\";\n    if (offset > 0) {\n      fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n    }\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === void 0 ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === void 0) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now(\"db2\");\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${identifier}'`;\n  }\n  return \"\";\n}\nmodule.exports = Db2QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 710,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 711,
    "kind": "variable",
    "name": "__defProps",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__defProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 712,
    "kind": "variable",
    "name": "__getOwnPropDescs",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__getOwnPropDescs",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 713,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 714,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 715,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 716,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/db2/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 717,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/db2/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 718,
    "kind": "function",
    "name": "__spreadProps",
    "memberof": "lib/dialects/db2/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~__spreadProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 719,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 720,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 721,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 722,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 723,
    "kind": "variable",
    "name": "randomBytes",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~randomBytes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 724,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 725,
    "kind": "function",
    "name": "throwMethodUndefined",
    "memberof": "lib/dialects/db2/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~throwMethodUndefined",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "methodName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 726,
    "kind": "class",
    "name": "Db2QueryGenerator",
    "memberof": "lib/dialects/db2/query-generator.js",
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 727,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 728,
    "kind": "member",
    "name": "OperatorMap",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#OperatorMap",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 729,
    "kind": "member",
    "name": "autoGenValue",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#autoGenValue",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 730,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 731,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 732,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 733,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 734,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 735,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 736,
    "kind": "method",
    "name": "renameTableQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#renameTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "params": [
      {
        "name": "before",
        "types": [
          "*"
        ]
      },
      {
        "name": "after",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 738,
    "kind": "method",
    "name": "dropTableQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 740,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 741,
    "kind": "method",
    "name": "changeColumnQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#changeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 742,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 743,
    "kind": "method",
    "name": "addConstraintQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#addConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 744,
    "kind": "method",
    "name": "bulkInsertQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#bulkInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 251,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrValueHashes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 745,
    "kind": "method",
    "name": "updateQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#updateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrValueHash",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"query\": *, \"bind\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 746,
    "kind": "method",
    "name": "upsertQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#upsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 332,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 747,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 412,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 748,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 749,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 436,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 750,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 452,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 751,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 459,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 752,
    "kind": "method",
    "name": "attributeToSQL",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#attributeToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 471,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 753,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 754,
    "kind": "method",
    "name": "createTrigger",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#createTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 565,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 755,
    "kind": "method",
    "name": "dropTrigger",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 568,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 756,
    "kind": "method",
    "name": "renameTrigger",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#renameTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 571,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 757,
    "kind": "method",
    "name": "createFunction",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#createFunction",
    "access": "public",
    "description": null,
    "lineNumber": 574,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 758,
    "kind": "method",
    "name": "dropFunction",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropFunction",
    "access": "public",
    "description": null,
    "lineNumber": 577,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 759,
    "kind": "method",
    "name": "renameFunction",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#renameFunction",
    "access": "public",
    "description": null,
    "lineNumber": 580,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 760,
    "kind": "method",
    "name": "_getForeignKeysQuerySQL",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#_getForeignKeysQuerySQL",
    "access": "private",
    "description": null,
    "lineNumber": 583,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 761,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#getForeignKeysQuery",
    "access": "public",
    "description": null,
    "lineNumber": 586,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 762,
    "kind": "method",
    "name": "getForeignKeyQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#getForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 598,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 763,
    "kind": "method",
    "name": "getPrimaryKeyConstraintQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#getPrimaryKeyConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 613,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 764,
    "kind": "method",
    "name": "dropForeignKeyQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 624,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "foreignKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 765,
    "kind": "method",
    "name": "dropConstraintQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#dropConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 630,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 766,
    "kind": "method",
    "name": "setAutocommitQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#setAutocommitQuery",
    "access": "public",
    "description": null,
    "lineNumber": 637,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 767,
    "kind": "method",
    "name": "setIsolationLevelQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#setIsolationLevelQuery",
    "access": "public",
    "description": null,
    "lineNumber": 640,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "generateTransactionId",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#generateTransactionId",
    "access": "public",
    "description": null,
    "lineNumber": 642,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 769,
    "kind": "method",
    "name": "startTransactionQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#startTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 645,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 770,
    "kind": "method",
    "name": "commitTransactionQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#commitTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 651,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 771,
    "kind": "method",
    "name": "rollbackTransactionQuery",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#rollbackTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 657,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "addLimitAndOffset",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#addLimitAndOffset",
    "access": "public",
    "description": null,
    "lineNumber": 663,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "booleanValue",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#booleanValue",
    "access": "public",
    "description": null,
    "lineNumber": 674,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 774,
    "kind": "method",
    "name": "addUniqueFields",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#addUniqueFields",
    "access": "public",
    "description": null,
    "lineNumber": 677,
    "undocument": true,
    "params": [
      {
        "name": "dataValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "rawAttributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "uniqno",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 775,
    "kind": "method",
    "name": "quoteIdentifier",
    "memberof": "lib/dialects/db2/query-generator.js~Db2QueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query-generator.js~Db2QueryGenerator#quoteIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 694,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "force",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 776,
    "kind": "function",
    "name": "wrapSingleQuote",
    "memberof": "lib/dialects/db2/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-generator.js~wrapSingleQuote",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 698,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 777,
    "kind": "file",
    "name": "lib/dialects/db2/query-interface.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst Op = require(\"../../operators\");\nconst { QueryInterface } = require(\"../abstract/query-interface\");\nconst QueryTypes = require(\"../../query-types\");\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    indexes = _.map(model.uniqueKeys, (value) => {\n      return value.fields;\n    });\n    model._indexes.forEach((value) => {\n      if (value.unique) {\n        indexFields = value.fields.map((field) => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    if (options.indexes) {\n      options.indexes.forEach((fields) => {\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach((field) => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach((fields) => {\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach((field) => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: \"createTable\" });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.Db2QueryInterface = Db2QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 778,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 779,
    "kind": "variable",
    "name": "__defProps",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__defProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 780,
    "kind": "variable",
    "name": "__getOwnPropDescs",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__getOwnPropDescs",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 781,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 782,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 783,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 784,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/db2/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 785,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/db2/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 786,
    "kind": "function",
    "name": "__spreadProps",
    "memberof": "lib/dialects/db2/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~__spreadProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 787,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 788,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 789,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 790,
    "kind": "variable",
    "name": "QueryInterface",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 791,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 792,
    "kind": "class",
    "name": "Db2QueryInterface",
    "memberof": "lib/dialects/db2/query-interface.js",
    "static": true,
    "longname": "lib/dialects/db2/query-interface.js~Db2QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "interface": false,
    "extends": [
      "QueryInterface"
    ],
    "ignore": true
  },
  {
    "__docId__": 793,
    "kind": "method",
    "name": "getForeignKeyReferencesForTable",
    "memberof": "lib/dialects/db2/query-interface.js~Db2QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/query-interface.js~Db2QueryInterface#getForeignKeyReferencesForTable",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "upsert",
    "memberof": "lib/dialects/db2/query-interface.js~Db2QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/query-interface.js~Db2QueryInterface#upsert",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 795,
    "kind": "method",
    "name": "createTable",
    "memberof": "lib/dialects/db2/query-interface.js~Db2QueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/query-interface.js~Db2QueryInterface#createTable",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 796,
    "kind": "file",
    "name": "lib/dialects/db2/query.js",
    "content": "\"use strict\";\nconst AbstractQuery = require(\"../abstract/query\");\nconst sequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"db2\");\nconst _ = require(\"lodash\");\nconst { logger } = require(\"../../utils/logger\");\nconst moment = require(\"moment\");\nconst debug = logger.debugContext(\"sql:db2\");\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value) {\n    const param = { ParamType: \"INPUT\", Data: value };\n    if (Buffer.isBuffer(value)) {\n      param.DataType = \"BLOB\";\n      return param;\n    }\n    return value;\n  }\n  async _run(connection, sql, parameters) {\n    this.sql = sql;\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log(`Executing (${this.connection.uuid || \"default\"}): ${this.sql}`, this.options);\n    }\n    const errStack = new Error().stack;\n    return new Promise((resolve, reject) => {\n      if (_.startsWith(this.sql, \"BEGIN TRANSACTION\")) {\n        connection.beginTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"COMMIT TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"ROLLBACK TRANSACTION\")) {\n        connection.rollbackTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"SAVE TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            connection.beginTransaction((err2) => {\n              if (err2) {\n                reject(this.formatError(err2, errStack));\n              } else {\n                resolve(this.formatResults());\n              }\n            });\n          }\n        }, this.options.transaction.name);\n      } else {\n        const params = [];\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const param = this.getSQLTypeFromJsType(value, key);\n            params.push(param);\n          });\n        }\n        const SQL = this.sql.toUpperCase();\n        let newSql = this.sql;\n        if ((this.isSelectQuery() || _.startsWith(SQL, \"SELECT \")) && SQL.indexOf(\" FROM \", 8) === -1) {\n          if (this.sql.charAt(this.sql.length - 1) === \";\") {\n            newSql = this.sql.slice(0, this.sql.length - 1);\n          }\n          newSql += \" FROM SYSIBM.SYSDUMMY1;\";\n        }\n        connection.prepare(newSql, (err, stmt) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          }\n          stmt.execute(params, (err2, result, outparams) => {\n            debug(`executed(${this.connection.uuid || \"default\"}):${newSql} ${parameters ? JSON.stringify(parameters) : \"\"}`);\n            if (benchmark) {\n              this.sequelize.log(`Executed (${this.connection.uuid || \"default\"}): ${newSql} ${parameters ? JSON.stringify(parameters) : \"\"}`, Date.now() - queryBegin, this.options);\n            }\n            if (err2 && err2.message) {\n              err2 = this.filterSQLError(err2, this.sql, connection);\n              if (err2 === null) {\n                stmt.closeSync();\n                resolve(this.formatResults([], 0));\n              }\n            }\n            if (err2) {\n              err2.sql = sql;\n              stmt.closeSync();\n              reject(this.formatError(err2, errStack, connection, parameters));\n            } else {\n              let data = [];\n              let metadata = [];\n              let affectedRows = 0;\n              if (typeof result === \"object\") {\n                if (_.startsWith(this.sql, \"DELETE FROM \")) {\n                  affectedRows = result.getAffectedRowsSync();\n                } else {\n                  data = result.fetchAllSync();\n                  metadata = result.getColumnMetadataSync();\n                }\n                result.closeSync();\n              }\n              stmt.closeSync();\n              const datalen = data.length;\n              if (datalen > 0) {\n                const coltypes = {};\n                for (let i = 0; i < metadata.length; i++) {\n                  coltypes[metadata[i].SQL_DESC_NAME] = metadata[i].SQL_DESC_TYPE_NAME;\n                }\n                for (let i = 0; i < datalen; i++) {\n                  for (const column in data[i]) {\n                    const parse = parserStore.get(coltypes[column]);\n                    const value = data[i][column];\n                    if (value !== null) {\n                      if (parse) {\n                        data[i][column] = parse(value);\n                      } else if (coltypes[column] === \"TIMESTAMP\") {\n                        data[i][column] = new Date(moment.utc(value));\n                      } else if (coltypes[column] === \"BLOB\") {\n                        data[i][column] = new Buffer.from(value);\n                      } else if (coltypes[column].indexOf(\"FOR BIT DATA\") > 0) {\n                        data[i][column] = new Buffer.from(value, \"hex\");\n                      }\n                    }\n                  }\n                }\n                if (outparams && outparams.length) {\n                  data.unshift(outparams);\n                }\n                resolve(this.formatResults(data, datalen, metadata, connection));\n              } else {\n                resolve(this.formatResults(data, affectedRows));\n              }\n            }\n          });\n        });\n      }\n    });\n  }\n  async run(sql, parameters) {\n    return await this._run(this.connection, sql, parameters);\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    if (Array.isArray(values) && typeof values[0] === \"object\") {\n      bindParam = values;\n    }\n    return [sql, bindParam];\n  }\n  filterSQLError(err, sql, connection) {\n    if (err.message.search(\"SQL0204N\") != -1 && _.startsWith(sql, \"DROP \")) {\n      err = null;\n    } else if (err.message.search(\"SQL0443N\") != -1) {\n      if (this.isDropSchemaQuery()) {\n        connection.querySync(\"DROP TABLE ERRORSCHEMA.ERRORTABLE;\");\n        connection.querySync(this.sql);\n      }\n      err = null;\n    } else if (err.message.search(\"SQL0601N\") != -1) {\n      const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name \"(.*)\" of type \"(.*)\"./);\n      if (match && match.length > 1 && match[2] === \"TABLE\") {\n        let table;\n        const mtarray = match[1].split(\".\");\n        if (mtarray[1]) {\n          table = `\"${mtarray[0]}\".\"${mtarray[1]}\"`;\n        } else {\n          table = `\"${mtarray[0]}\"`;\n        }\n        if (connection.dropTable !== false) {\n          connection.querySync(`DROP TABLE ${table}`);\n          err = connection.querySync(sql);\n        } else {\n          err = null;\n        }\n      } else {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0911N\") != -1) {\n      if (err.message.search('Reason code \"2\"') != -1) {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0605W\") != -1) {\n      err = null;\n    } else if (err.message.search(\"SQL0668N\") != -1 && _.startsWith(sql, \"ALTER TABLE \")) {\n      connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(\" \")[0]}')`);\n      err = connection.querySync(sql);\n    }\n    if (err && err.length === 0) {\n      err = null;\n    }\n    return err;\n  }\n  formatResults(data, rowCount, metadata, conn) {\n    let result = this.instance;\n    if (this.isInsertQuery(data, metadata)) {\n      this.handleInsertQuery(data, metadata);\n      if (!this.instance) {\n        if (this.options.plain) {\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      result = data;\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"Y\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.KeySeq > 0,\n          autoIncrement: _result.IsIdentity === \"Y\" ? true : false,\n          comment: _result.Comment\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n    } else if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isUpsertQuery()) {\n      result = data;\n    } else if (this.isDropSchemaQuery()) {\n      result = data[0];\n      if (conn) {\n        const query = \"DROP TABLE ERRORSCHEMA.ERRORTABLE\";\n        conn.querySync(query);\n      }\n    } else if (this.isCallQuery()) {\n      result = data;\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.length;\n    } else if (this.isBulkDeleteQuery()) {\n      result = rowCount;\n    } else if (this.isVersionQuery()) {\n      result = data[0].VERSION;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, rowCount];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      result = [data, metadata];\n    } else {\n      result = data;\n    }\n    return result;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return _.remove(data, (constraint) => {\n      return !_.startsWith(constraint.constraintName, \"SQL\");\n    });\n  }\n  formatError(err, errStack, conn, parameters) {\n    let match;\n    if (!(err && err.message)) {\n      err[\"message\"] = \"No error message found.\";\n    }\n    match = err.message.match(/SQL0803N {2}One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by \"(\\d)+\" constrains table \"(.*)\\.(.*)\" from having duplicate values for the index key./);\n    if (match && match.length > 0) {\n      let uniqueIndexName = \"\";\n      let uniqueKey = \"\";\n      const fields = {};\n      let message = err.message;\n      const query = `SELECT INDNAME FROM SYSCAT.INDEXES  WHERE IID = ${match[1]} AND TABSCHEMA = '${match[2]}' AND TABNAME = '${match[3]}'`;\n      if (!!conn && match.length > 3) {\n        uniqueIndexName = conn.querySync(query);\n        uniqueIndexName = uniqueIndexName[0][\"INDNAME\"];\n      }\n      if (this.model && !!uniqueIndexName) {\n        uniqueKey = this.model.uniqueKeys[uniqueIndexName];\n      }\n      if (!uniqueKey && this.options.fields) {\n        uniqueKey = this.options.fields[match[1] - 1];\n      }\n      if (uniqueKey) {\n        if (this.options.where && this.options.where[uniqueKey.column] !== void 0) {\n          fields[uniqueKey.column] = this.options.where[uniqueKey.column];\n        } else if (this.options.instance && this.options.instance.dataValues && this.options.instance.dataValues[uniqueKey.column]) {\n          fields[uniqueKey.column] = this.options.instance.dataValues[uniqueKey.column];\n        } else if (parameters) {\n          fields[uniqueKey.column] = parameters[\"0\"];\n        }\n      }\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/SQL0532N {2}A parent row cannot be deleted because the relationship \"(.*)\" restricts the deletion/) || err.message.match(/SQL0530N/) || err.message.match(/SQL0531N/);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/SQL0204N {2}\"(.*)\" is an undefined name./);\n    if (match && match.length > 1) {\n      const constraint = match[1];\n      let table = err.sql.match(/table \"(.+?)\"/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[0],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isDropSchemaQuery() {\n    let result = false;\n    if (_.startsWith(this.sql, \"CALL SYSPROC.ADMIN_DROP_SCHEMA\")) {\n      result = true;\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    result = result || this.sql.startsWith('SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES');\n    return result;\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.keyType === \"P\",\n          fields: [],\n          name: item.name,\n          tableName: item.tableName,\n          unique: item.keyType === \"U\",\n          type: item.type\n        };\n        _.forEach(item.COLNAMES.replace(/\\+|-/g, (x) => {\n          return ` ${x}`;\n        }).split(\" \"), (column) => {\n          let columnName = column.trim();\n          if (columnName) {\n            columnName = columnName.replace(/\\+|-/, \"\");\n            currItem.fields.push({\n              attribute: columnName,\n              length: void 0,\n              order: column.indexOf(\"-\") === -1 ? \"ASC\" : \"DESC\",\n              collate: void 0\n            });\n          }\n        });\n        result.push(currItem);\n      }\n    });\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n//# sourceMappingURL=query.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/db2/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 797,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 798,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 799,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 800,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 801,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 802,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 803,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 804,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/db2/query.js",
    "static": true,
    "longname": "lib/dialects/db2/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/db2/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 805,
    "kind": "method",
    "name": "getInsertIdField",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#getInsertIdField",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 806,
    "kind": "method",
    "name": "getSQLTypeFromJsType",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#getSQLTypeFromJsType",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 807,
    "kind": "method",
    "name": "_run",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#_run",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 808,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/db2/query.js~Query",
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 809,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 810,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/db2/query.js~Query.formatBindParameters",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 811,
    "kind": "method",
    "name": "filterSQLError",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#filterSQLError",
    "access": "public",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 812,
    "kind": "method",
    "name": "formatResults",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#formatResults",
    "access": "public",
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "rowCount",
        "types": [
          "*"
        ]
      },
      {
        "name": "metadata",
        "types": [
          "*"
        ]
      },
      {
        "name": "conn",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 813,
    "kind": "method",
    "name": "handleShowTablesQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#handleShowTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 814,
    "kind": "method",
    "name": "handleShowConstraintsQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#handleShowConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 815,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 293,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "errStack",
        "types": [
          "*"
        ]
      },
      {
        "name": "conn",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 816,
    "kind": "method",
    "name": "isDropSchemaQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#isDropSchemaQuery",
    "access": "public",
    "description": null,
    "lineNumber": 357,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 817,
    "kind": "method",
    "name": "isShowOrDescribeQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#isShowOrDescribeQuery",
    "access": "public",
    "description": null,
    "lineNumber": 364,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 818,
    "kind": "method",
    "name": "isShowIndexesQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#isShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 371,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 819,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 377,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 820,
    "kind": "method",
    "name": "handleInsertQuery",
    "memberof": "lib/dialects/db2/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/db2/query.js~Query#handleInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 409,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaData",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 821,
    "kind": "file",
    "name": "lib/dialects/mariadb/connection-manager.js",
    "content": "'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mariadb;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mariadb');\nconst parserStore = require('../parserStore')('mariadb');\n\n/**\n * MariaDB Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MariaDB specific connections\n * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server\n *\n * @extends AbstractConnectionManager\n * @returns Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mariadb');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with MariaDB database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {Object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  connect(config) {\n    // Named timezone is not supported in mariadb, convert to offset\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')\n      : tzOffset;\n\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false\n    };\n\n    if (config.dialectOptions) {\n      Object.assign(connectionConfig, config.dialectOptions);\n    }\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      // set timezone for this connection\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(\n          connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n\n    return this.lib.createConnection(connectionConfig)\n      .then(connection => {\n        this.sequelize.options.databaseVersion = connection.serverVersion();\n        debug('connection acquired');\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n            case 'EPIPE':\n            case 'PROTOCOL_CONNECTION_LOST':\n              this.pool.destroy(connection);\n          }\n        });\n        return connection;\n      })\n      .catch(err => {\n        switch (err.code) {\n          case 'ECONNREFUSED':\n            throw new SequelizeErrors.ConnectionRefusedError(err);\n          case 'ER_ACCESS_DENIED_ERROR':\n          case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':\n            throw new SequelizeErrors.AccessDeniedError(err);\n          case 'ENOTFOUND':\n            throw new SequelizeErrors.HostNotFoundError(err);\n          case 'EHOSTUNREACH':\n          case 'ENETUNREACH':\n          case 'EADDRNOTAVAIL':\n            throw new SequelizeErrors.HostNotReachableError(err);\n          case 'EINVAL':\n            throw new SequelizeErrors.InvalidConnectionError(err);\n          default:\n            throw new SequelizeErrors.ConnectionError(err);\n        }\n      });\n  }\n\n  disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isValid()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Promise.resolve();\n    }\n    //wrap native Promise into bluebird\n    return Promise.resolve(connection.end());\n  }\n\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mariadb/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 822,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 823,
    "kind": "variable",
    "name": "SequelizeErrors",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~SequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 824,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 825,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 826,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 827,
    "kind": "variable",
    "name": "momentTz",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~momentTz",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 828,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 829,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 830,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mariadb/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/connection-manager.js",
    "importStyle": null,
    "description": "MariaDB Connection Manager\n\nGet connections, validate and disconnect them.\nAbstractConnectionManager pooling use it to handle MariaDB specific connections\nUse https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "Class<ConnectionManager>"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Class<ConnectionManager>"
    },
    "interface": false,
    "extends": [
      "*"
    ],
    "ignore": true
  },
  {
    "__docId__": 831,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 832,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 833,
    "kind": "method",
    "name": "_typecast",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager._typecast",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "next",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 834,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 835,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 836,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#connect",
    "access": "private",
    "description": "Connect with MariaDB database based on config, Handle any errors in connection\nSet the pool handlers on connection.error\nAlso set proper timezone once connection is connected.",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Connection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Connection>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 837,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 838,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/mariadb/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 839,
    "kind": "file",
    "name": "lib/dialects/mariadb/data-types.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst moment = require('moment-timezone');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';\n\n  /**\n   * types: [buffer_type, ...]\n   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types\n   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js\n   */\n\n  BaseTypes.DATE.types.mariadb = ['DATETIME'];\n  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mariadb = ['STRING'];\n  BaseTypes.TEXT.types.mariadb = ['BLOB'];\n  BaseTypes.TINYINT.types.mariadb = ['TINY'];\n  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];\n  BaseTypes.INTEGER.types.mariadb = ['LONG'];\n  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];\n  BaseTypes.TIME.types.mariadb = ['TIME'];\n  BaseTypes.DATEONLY.types.mariadb = ['DATE'];\n  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];\n  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];\n  BaseTypes.JSON.types.mariadb = ['JSON'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        definition += ' ZEROFILL';\n      }\n      return definition;\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return `DATETIME${this._length ? `(${this._length})` : ''}`;\n    }\n    _stringify(date, options) {\n      date = this._applyTimezone(date, options);\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (moment.tz.zone(options.timezone)) {\n        value = moment.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36) BINARY';\n    }\n  }\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      }\n      else {\n        this.sqlType = this.type;\n      }\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value\n        : JSON.stringify(value);\n    }\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mariadb/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 840,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mariadb/data-types.js",
    "static": true,
    "longname": "lib/dialects/mariadb/data-types.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 841,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/mariadb/data-types.js",
    "static": true,
    "longname": "lib/dialects/mariadb/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 842,
    "kind": "file",
    "name": "lib/dialects/mariadb/index.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').mariadb;\n\nclass MariadbDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nMariadbDialect.prototype.supports = _.merge(\n  _.cloneDeep(AbstractDialect.prototype.supports), {\n    'VALUES ()': true,\n    'LIMIT ON UPDATE': true,\n    lock: true,\n    forShare: 'LOCK IN SHARE MODE',\n    settingIsolationLevelDuringTransaction: false,\n    schemas: true,\n    inserts: {\n      ignoreDuplicates: ' IGNORE',\n      updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'\n    },\n    index: {\n      collate: false,\n      length: true,\n      parser: true,\n      type: true,\n      using: 1\n    },\n    constraints: {\n      dropConstraint: false,\n      check: false\n    },\n    indexViaAlter: true,\n    indexHints: true,\n    NUMERIC: true,\n    GEOMETRY: true,\n    JSON: true,\n    REGEXP: true\n  });\n\nConnectionManager.prototype.defaultVersion = '5.5.3';\nMariadbDialect.prototype.Query = Query;\nMariadbDialect.prototype.QueryGenerator = QueryGenerator;\nMariadbDialect.prototype.DataTypes = DataTypes;\nMariadbDialect.prototype.name = 'mariadb';\nMariadbDialect.prototype.TICK_CHAR = '`';\nMariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;\nMariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;\n\nmodule.exports = MariadbDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mariadb/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 843,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 844,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 845,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 846,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 847,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 848,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 849,
    "kind": "class",
    "name": "MariadbDialect",
    "memberof": "lib/dialects/mariadb/index.js",
    "static": true,
    "longname": "lib/dialects/mariadb/index.js~MariadbDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 850,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mariadb/index.js~MariadbDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/index.js~MariadbDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 851,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/mariadb/index.js~MariadbDialect",
    "static": false,
    "longname": "lib/dialects/mariadb/index.js~MariadbDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 852,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/mariadb/index.js~MariadbDialect",
    "static": false,
    "longname": "lib/dialects/mariadb/index.js~MariadbDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 853,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mariadb/index.js~MariadbDialect",
    "static": false,
    "longname": "lib/dialects/mariadb/index.js~MariadbDialect#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 854,
    "kind": "file",
    "name": "lib/dialects/mariadb/query-generator.js",
    "content": "'use strict';\n\nconst MySQLQueryGenerator = require('../mysql/query-generator');\n\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n  createSchema(schema, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)}${charset}${collate};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n\n  showSchemasQuery(options) {\n    const skip = options.skip && Array.isArray(options.skip) && options.skip.length > 0 ? options.skip : null;\n    return `SELECT SCHEMA_NAME as schema_name FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA'${skip ? skip.reduce( (sql, schemaName) => sql += `,${this.escape(schemaName)}`, '') : ''});`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\')';\n    }\n    return `${query};`;\n  }\n}\n\nmodule.exports = MariaDBQueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mariadb/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 855,
    "kind": "variable",
    "name": "MySQLQueryGenerator",
    "memberof": "lib/dialects/mariadb/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query-generator.js~MySQLQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 856,
    "kind": "class",
    "name": "MariaDBQueryGenerator",
    "memberof": "lib/dialects/mariadb/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "MySQLQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 857,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 858,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 859,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 860,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query-generator.js~MariaDBQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 861,
    "kind": "file",
    "name": "lib/dialects/mariadb/query.js",
    "content": "'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst _ = require('lodash');\nconst DataTypes = require('../../data-types');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\n\nconst ER_DUP_ENTRY = 1062;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\n\nconst debug = logger.debugContext('sql:mariadb');\n\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, Object.assign({ showWarnings: false }, options));\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, val) => {\n      if (val[key] !== undefined) {\n        bindParam.push(val[key]);\n        return '?';\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect,\n      replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : undefined];\n  }\n\n  run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n\n    const showWarnings = this.sequelize.options.showWarnings\n      || options.showWarnings;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    if (parameters) {\n      debug('parameters(%j)', parameters);\n    }\n    return Promise.resolve(\n      connection.query(this.sql, parameters)\n        .then(results => {\n          complete();\n\n          // Log warnings if we've got them.\n          if (showWarnings && results && results.warningStatus > 0) {\n            return this.logWarnings(results);\n          }\n          return results;\n        })\n        .catch(err => {\n          // MariaDB automatically rolls-back transactions in the event of a deadlock\n          if (options.transaction && err.errno === 1213) {\n            options.transaction.finished = 'rollback';\n          }\n\n          complete();\n\n          err.sql = sql;\n          err.parameters = parameters;\n          throw this.formatError(err);\n        })\n    )\n      // Log warnings if we've got them.\n      .then(results => {\n        if (showWarnings && results && results.warningStatus > 0) {\n          return this.logWarnings(results);\n        }\n        return results;\n      })\n      // Return formatted results...\n      .then(results => this.formatResults(results));\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @private\n   */\n  formatResults(data) {\n    let result = this.instance;\n\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()\n      || this.isUpsertQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          //ONLY TRUE IF @auto_increment_increment is set to 1 !!\n          //Doesn't work with GALERA => each node will reserve increment (x for first server, x+1 for next node ...\n          const startId = data[this.getInsertIdField()];\n          result = new Array(data.affectedRows);\n          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;\n          for (let i = 0; i < data.affectedRows; i++) {\n            result[i] = { [pkField]: startId + i };\n          }\n          return [result, data.affectedRows];\n        }\n        return [data[this.getInsertIdField()], data.affectedRows];\n      }\n    }\n\n    if (this.isSelectQuery()) {\n      this.handleJsonSelectQuery(data);\n      return this.handleSelectQuery(data);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isRawQuery()) {\n      const meta = data.meta;\n      delete data.meta;\n      return [data, meta];\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toLowerCase().startsWith('enum') ? _result.Type.replace(/^enum/i,\n            'ENUM') : _result.Type.toUpperCase(),\n          allowNull: _result.Null === 'YES',\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === 'PRI',\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')\n            && _result.Extra.toLowerCase() === 'auto_increment',\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n\n    return result;\n  }\n\n  handleJsonSelectQuery(rows) {\n    if (!this.model || !this.model.fieldRawAttributesMap) {\n      return;\n    }\n    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {\n      const modelField = this.model.fieldRawAttributesMap[_field];\n      if (modelField.type instanceof DataTypes.JSON) {\n        //value is return as String, no JSON\n        rows = rows.map(row => {\n          row[modelField.fieldName] = row[modelField.fieldName] ? JSON.parse(\n            row[modelField.fieldName]) : null;\n          if (DataTypes.JSON.parse) {\n            return DataTypes.JSON.parse(modelField, this.sequelize.options,\n              row[modelField.fieldName]);\n          }\n          return row;\n        });\n      }\n    }\n  }\n\n  logWarnings(results) {\n    return this.run('SHOW WARNINGS').then(warningResults => {\n      const warningMessage = `MariaDB Warnings (${this.connection.uuid\n      || 'default'}): `;\n      const messages = [];\n      for (const _warningRow of warningResults) {\n        if (_warningRow === undefined || typeof _warningRow[Symbol.iterator]\n          !== 'function') {\n          continue;\n        }\n        for (const _warningResult of _warningRow) {\n          if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {\n            messages.push(_warningResult.Message);\n          } else {\n            for (const _objectKey of _warningResult.keys()) {\n              messages.push(\n                [_objectKey, _warningResult[_objectKey]].join(': '));\n            }\n          }\n        }\n      }\n\n      this.sequelize.log(warningMessage + messages.join('; '), this.options);\n\n      return results;\n    });\n  }\n\n  formatError(err) {\n    switch (err.errno) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(\n          /Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?\\s.*$/);\n\n        let fields = {};\n        let message = 'Validation error';\n        const values = match ? match[1].split('-') : undefined;\n        const fieldKey = match ? match[2] : undefined;\n        const fieldVal = match ? match[1] : undefined;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n\n        if (uniqueKey) {\n          if (uniqueKey.msg) {\n            message = uniqueKey.msg;\n          }\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            value,\n            this.instance,\n            'not_unique'\n          ));\n        });\n\n        return new sequelizeErrors.UniqueConstraintError(\n          { message, errors, parent: err, fields });\n      }\n\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)\n        const match = err.message.match(\n          /CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : '`';\n        const fields = match ? match[3].split(\n          new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: err.errno === 1451 ? 'parent' : 'child',\n          table: match ? match[4] : undefined,\n          fields,\n          value: fields && fields.length && this.instance\n            && this.instance[fields[0]] || undefined,\n          index: match ? match[2] : undefined,\n          parent: err\n        });\n      }\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => ({\n      tableName: resultSet.TABLE_NAME,\n      schema: resultSet.TABLE_SCHEMA\n    }));\n  }\n\n  handleShowIndexesQuery(data) {\n\n    let currItem;\n    const result = [];\n\n    data.forEach(item => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.Key_name === 'PRIMARY',\n          fields: [],\n          name: item.Key_name,\n          tableName: item.Table,\n          unique: item.Non_unique !== 1,\n          type: item.Index_type\n        };\n        result.push(currItem);\n      }\n\n      currItem.fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || undefined,\n        order: item.Collation === 'A' ? 'ASC' : undefined\n      };\n    });\n\n    return result;\n  }\n}\n\nmodule.exports = Query;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mariadb/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 862,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 863,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 864,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 865,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 866,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 867,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 868,
    "kind": "variable",
    "name": "ER_DUP_ENTRY",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~ER_DUP_ENTRY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 869,
    "kind": "variable",
    "name": "ER_ROW_IS_REFERENCED",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~ER_ROW_IS_REFERENCED",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 870,
    "kind": "variable",
    "name": "ER_NO_REFERENCED_ROW",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~ER_NO_REFERENCED_ROW",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 871,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 872,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/mariadb/query.js",
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mariadb/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 873,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 874,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mariadb/query.js~Query.formatBindParameters",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 875,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 876,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 877,
    "kind": "method",
    "name": "formatResults",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#formatResults",
    "access": "private",
    "description": "High level function that handles the results of a query execution.\n\n\nExample:\n query.formatResults([\n   {\n     id: 1,              // this is from the main table\n     attr2: 'snafu',     // this is from the main table\n     Tasks.id: 1,        // this is from the associated table\n     Tasks.title: 'task' // this is from the associated table\n   }\n ])",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The result of the query execution."
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 878,
    "kind": "method",
    "name": "handleJsonSelectQuery",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#handleJsonSelectQuery",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "rows",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 879,
    "kind": "method",
    "name": "logWarnings",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#logWarnings",
    "access": "public",
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 880,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 881,
    "kind": "method",
    "name": "handleShowTablesQuery",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#handleShowTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 289,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 882,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/mariadb/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mariadb/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 883,
    "kind": "file",
    "name": "lib/dialects/mssql/async-queue.js",
    "content": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  AsyncQueueError: () => AsyncQueueError,\n  default: () => async_queue_default\n});\nvar import_base_error = __toModule(require(\"../../errors/base-error\"));\nvar import_connection_error = __toModule(require(\"../../errors/connection-error\"));\nclass AsyncQueueError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n}\nclass AsyncQueue {\n  constructor() {\n    __publicField(this, \"previous\");\n    __publicField(this, \"closed\");\n    __publicField(this, \"rejectCurrent\");\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {\n    };\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could finish executing\")));\n  }\n  enqueue(asyncFunction) {\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could be executed\")));\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\nvar async_queue_default = AsyncQueue;\n//# sourceMappingURL=async-queue.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/async-queue.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 884,
    "kind": "variable",
    "name": "__create",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__create",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 885,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 886,
    "kind": "variable",
    "name": "__getOwnPropDesc",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__getOwnPropDesc",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 887,
    "kind": "variable",
    "name": "__getOwnPropNames",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__getOwnPropNames",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 888,
    "kind": "variable",
    "name": "__getProtoOf",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__getProtoOf",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 889,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 890,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 891,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 892,
    "kind": "function",
    "name": "__export",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__export",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "all",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 893,
    "kind": "function",
    "name": "__reExport",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__reExport",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "module2",
        "types": [
          "*"
        ]
      },
      {
        "name": "desc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 894,
    "kind": "function",
    "name": "__toModule",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__toModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "module2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 895,
    "kind": "function",
    "name": "__publicField",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~__publicField",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 896,
    "kind": "variable",
    "name": "import_base_error",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~import_base_error",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 897,
    "kind": "variable",
    "name": "import_connection_error",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~import_connection_error",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 898,
    "kind": "class",
    "name": "AsyncQueueError",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueueError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "interface": false,
    "extends": [
      "import_base_error~import_base_error.default"
    ],
    "ignore": true
  },
  {
    "__docId__": 899,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueueError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueueError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 900,
    "kind": "member",
    "name": "name",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueueError",
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueueError#name",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 901,
    "kind": "class",
    "name": "AsyncQueue",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 902,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 903,
    "kind": "member",
    "name": "previous",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#previous",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 904,
    "kind": "member",
    "name": "closed",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#closed",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 905,
    "kind": "member",
    "name": "rejectCurrent",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#rejectCurrent",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 906,
    "kind": "method",
    "name": "close",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#close",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 908,
    "kind": "method",
    "name": "enqueue",
    "memberof": "lib/dialects/mssql/async-queue.js~AsyncQueue",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/async-queue.js~AsyncQueue#enqueue",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [
      {
        "name": "asyncFunction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 911,
    "kind": "variable",
    "name": "async_queue_default",
    "memberof": "lib/dialects/mssql/async-queue.js",
    "static": true,
    "longname": "lib/dialects/mssql/async-queue.js~async_queue_default",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/async-queue.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 912,
    "kind": "file",
    "name": "lib/dialects/mssql/connection-manager.js",
    "content": "'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst ResourceLock = require('./resource-lock');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        encrypt: false\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    return new Promise((resolve, reject) => {\n      const connection = new this.lib.Connection(connectionConfig);\n      if (connection.state === connection.STATE.INITIALIZED) {\n        connection.connect();\n      }\n      connection.lib = this.lib;\n      const resourceLock = new ResourceLock(connection);\n\n      const connectHandler = error => {\n        connection.removeListener('end', endHandler);\n        connection.removeListener('error', errorHandler);\n\n        if (error) return reject(error);\n\n        debug('connection acquired');\n        resolve(resourceLock);\n      };\n\n      const endHandler = () => {\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('error', errorHandler);\n        reject(new Error('Connection was closed by remote server'));\n      };\n\n      const errorHandler = error => {\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('end', endHandler);\n        reject(error);\n      };\n\n      connection.once('error', errorHandler);\n      connection.once('end', endHandler);\n      connection.once('connect', connectHandler);\n\n      /*\n       * Permanently attach this event before connection is even acquired\n       * tedious sometime emits error even after connect(with error).\n       *\n       * If we dont attach this even that unexpected error event will crash node process\n       *\n       * E.g. connectTimeout is set higher than requestTimeout\n       */\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n            this.pool.destroy(resourceLock);\n        }\n      });\n\n      if (config.dialectOptions && config.dialectOptions.debug) {\n        connection.on('debug', debugTedious.log.bind(debugTedious));\n      }\n    }).catch(error => {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    });\n  }\n\n  disconnect(connectionLock) {\n    /**\n     * Abstract connection may try to disconnect raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap\n      ? connectionLock.unwrap()\n      : connectionLock;\n\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connectionLock) {\n    /**\n     * Abstract connection may try to validate raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap\n      ? connectionLock.unwrap()\n      : connectionLock;\n\n    return connection && connection.loggedIn;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 913,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 914,
    "kind": "variable",
    "name": "ResourceLock",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~ResourceLock",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 915,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 916,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 917,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 918,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 919,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 920,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 921,
    "kind": "variable",
    "name": "debugTedious",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~debugTedious",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 922,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mssql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractConnectionManager"
    ],
    "ignore": true
  },
  {
    "__docId__": 923,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 924,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 925,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 926,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 927,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#connect",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 928,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [
      {
        "name": "connectionLock",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 929,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/mssql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [
      {
        "name": "connectionLock",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 930,
    "kind": "file",
    "name": "lib/dialects/mssql/data-types.js",
    "content": "'use strict';\n\nconst moment = require('moment');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');\n\n  /**\n   * Removes unsupported MSSQL options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {Object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types: [hex, ...]\n   * @see hex here https://github.com/tediousjs/tedious/blob/master/src/data-type.js\n   */\n\n  BaseTypes.DATE.types.mssql = [43];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  // https://msdn.microsoft.com/en-us/library/ms187745(v=sql.110).aspx\n  BaseTypes.TINYINT.types.mssql = [30];\n  BaseTypes.SMALLINT.types.mssql = [34];\n  BaseTypes.MEDIUMINT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported\n  BaseTypes.GEOMETRY.types.mssql = false;\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n          warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');\n          return 'VARBINARY(256)';\n        }\n        warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');\n      }\n      return 'VARBINARY(MAX)';\n    }\n    _hexify(hex) {\n      return `0x${hex}`;\n    }\n  }\n\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        return `NVARCHAR(${this._length})`;\n      }\n      return `BINARY(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._stringify(value);\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n\n  STRING.prototype.escape = false;\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.\n      // Using unicode is just future proof\n      if (this._length) {\n        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n          warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');\n          return 'NVARCHAR(256)';\n        }\n        warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');\n      }\n      return 'NVARCHAR(MAX)';\n    }\n  }\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BIT';\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36)';\n    }\n  }\n\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return 'GETDATE()';\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'DATETIMEOFFSET';\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // MSSQL does not support any options for real\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // MSSQL does only support lengths as option.\n      // Values between 1-24 result in 7 digits precision (4 bytes storage size)\n      // Values between 25-53 result in 15 digits precision (8 bytes storage size)\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n      }\n      if (this._unsigned) {\n        warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'VARCHAR(255)';\n    }\n  }\n\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 931,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/mssql/data-types.js",
    "static": true,
    "longname": "lib/dialects/mssql/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 932,
    "kind": "file",
    "name": "lib/dialects/mssql/index.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').mssql;\n\nclass MssqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nMssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT': true,\n  'DEFAULT VALUES': true,\n  'LIMIT ON UPDATE': true,\n  'ORDER NULLS': false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: {\n    output: true\n  },\n  schemas: true,\n  autoIncrement: {\n    identityInsert: true,\n    defaultValue: false,\n    update: false\n  },\n  constraints: {\n    restrict: false,\n    default: true\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: true,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\n\nConnectionManager.prototype.defaultVersion = '12.0.2000'; // SQL Server 2014 Express\nMssqlDialect.prototype.Query = Query;\nMssqlDialect.prototype.name = 'mssql';\nMssqlDialect.prototype.TICK_CHAR = '\"';\nMssqlDialect.prototype.TICK_CHAR_LEFT = '[';\nMssqlDialect.prototype.TICK_CHAR_RIGHT = ']';\nMssqlDialect.prototype.DataTypes = DataTypes;\n\nmodule.exports = MssqlDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 933,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 934,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 935,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 936,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 937,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 938,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 939,
    "kind": "class",
    "name": "MssqlDialect",
    "memberof": "lib/dialects/mssql/index.js",
    "static": true,
    "longname": "lib/dialects/mssql/index.js~MssqlDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 940,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mssql/index.js~MssqlDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/index.js~MssqlDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 941,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/mssql/index.js~MssqlDialect",
    "static": false,
    "longname": "lib/dialects/mssql/index.js~MssqlDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 942,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/mssql/index.js~MssqlDialect",
    "static": false,
    "longname": "lib/dialects/mssql/index.js~MssqlDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 943,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mssql/index.js~MssqlDialect",
    "static": false,
    "longname": "lib/dialects/mssql/index.js~MssqlDialect#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 944,
    "kind": "file",
    "name": "lib/dialects/mssql/query-generator.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      collate: null\n    }, options || {});\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const query = (table, attrs) => `IF OBJECT_ID('${table}', 'U') IS NULL CREATE TABLE ${table} (${attrs})`,\n      primaryKeys = [],\n      foreignKeys = {},\n      attrStr = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `${query(this.quoteTable(tableName), attributesClause)};${commentStr}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"prop.value AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  dropTableQuery(tableName) {\n    const qouteTbl = this.quoteTable(tableName);\n    return `IF OBJECT_ID('${qouteTbl}', 'U') IS NOT NULL DROP TABLE ${qouteTbl};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    const def = this.attributeToSQL(dataType, {\n      context: 'addColumn'\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${def};${commentStr}`;\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP COLUMN ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};${commentString}`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `EXEC sp_rename '${this.quoteTable(tableName)}.${attrBefore}', '${newName}', 'COLUMN';`;\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      outputFragment = ' OUTPUT INSERTED.*';\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      }).join(', ');\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    let limit = '';\n\n    if (options.limit) {\n      limit = ` TOP(${this.escape(options.limit)})`;\n    }\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    return `DELETE${limit} FROM ${table}${whereClause}; SELECT @@ROWCOUNT AS AFFECTEDROWS;`;\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|Object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix()\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)\n    } AND COL.NAME =${wrapSingleQuote(attributeName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName};`\n    ].join(' ');\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(foreignKey)}`;\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return 'SELECT name FROM sys.default_constraints ' +\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U') ` +\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}') ` +\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'));`;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};`;\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    let topFragment = '';\n    let mainFragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    // Handle SQL Server 2008 with TOP instead of LIMIT\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      if (options.limit) {\n        topFragment = `TOP ${options.limit} `;\n      }\n      if (options.offset) {\n        const offset = options.offset || 0,\n          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n        let orders = { mainQueryOrder: [] };\n        if (options.order) {\n          orders = this.getQueryOrders(options, model, isSubQuery);\n        }\n\n        if (!orders.mainQueryOrder.length) {\n          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n        }\n\n        const tmpTable = mainTableAs ? mainTableAs : 'OffsetTable';\n        const whereFragment = where ? ` WHERE ${where}` : '';\n\n        /*\n         * For earlier versions of SQL server, we need to nest several queries\n         * in order to emulate the OFFSET behavior.\n         *\n         * 1. The outermost query selects all items from the inner query block.\n         *    This is due to a limitation in SQL server with the use of computed\n         *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n         * 2. The next query handles the LIMIT and OFFSET behavior by getting\n         *    the TOP N rows of the query where the row number is > OFFSET\n         * 3. The innermost query is the actual set we want information from\n         */\n        const fragment = `SELECT TOP 100 PERCENT ${attributes.join(', ')} FROM ` +\n                        `(SELECT ${topFragment}*` +\n                          ` FROM (SELECT ROW_NUMBER() OVER (ORDER BY ${orders.mainQueryOrder.join(', ')}) as row_num, * ` +\n                            ` FROM ${tables} AS ${tmpTable}${whereFragment})` +\n                          ` AS ${tmpTable} WHERE row_num > ${offset})` +\n                        ` AS ${tmpTable}`;\n        return fragment;\n      }\n      mainFragment = `SELECT ${topFragment}${attributes.join(', ')} FROM ${tables}`;\n    }\n\n    if (mainTableAs) {\n      mainFragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.tableHint && TableHints[options.tableHint]) {\n      mainFragment += ` WITH (${TableHints[options.tableHint]})`;\n    }\n\n    return mainFragment;\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || options.include && !orders.subQueryOrder.length) {\n        fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n        fragment += `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 945,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 946,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 947,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 948,
    "kind": "variable",
    "name": "TableHints",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~TableHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 949,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 950,
    "kind": "variable",
    "name": "randomBytes",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~randomBytes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 951,
    "kind": "variable",
    "name": "semver",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~semver",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 952,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 953,
    "kind": "function",
    "name": "throwMethodUndefined",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~throwMethodUndefined",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "methodName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 954,
    "kind": "class",
    "name": "MSSQLQueryGenerator",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 955,
    "kind": "method",
    "name": "createDatabaseQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#createDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 956,
    "kind": "method",
    "name": "dropDatabaseQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 957,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 958,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 959,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 960,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 961,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 962,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 963,
    "kind": "method",
    "name": "renameTableQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#renameTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 220,
    "undocument": true,
    "params": [
      {
        "name": "before",
        "types": [
          "*"
        ]
      },
      {
        "name": "after",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 964,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 965,
    "kind": "method",
    "name": "dropTableQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 966,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 967,
    "kind": "method",
    "name": "commentTemplate",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#commentTemplate",
    "access": "public",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [
      {
        "name": "comment",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 968,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 969,
    "kind": "method",
    "name": "changeColumnQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#changeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 970,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 299,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 971,
    "kind": "method",
    "name": "bulkInsertQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#bulkInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 304,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrValueHashes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 972,
    "kind": "method",
    "name": "updateQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#updateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 374,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrValueHash",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 973,
    "kind": "method",
    "name": "upsertQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#upsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 383,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 974,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 494,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 975,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 498,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 976,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 515,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 977,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 519,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 978,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 523,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 979,
    "kind": "method",
    "name": "attributeToSQL",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#attributeToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 533,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 980,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 614,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 981,
    "kind": "method",
    "name": "createTrigger",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#createTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 647,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 982,
    "kind": "method",
    "name": "dropTrigger",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 651,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 983,
    "kind": "method",
    "name": "renameTrigger",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#renameTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 655,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 984,
    "kind": "method",
    "name": "createFunction",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#createFunction",
    "access": "public",
    "description": null,
    "lineNumber": 659,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 985,
    "kind": "method",
    "name": "dropFunction",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropFunction",
    "access": "public",
    "description": null,
    "lineNumber": 663,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 986,
    "kind": "method",
    "name": "renameFunction",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#renameFunction",
    "access": "public",
    "description": null,
    "lineNumber": 667,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 987,
    "kind": "method",
    "name": "_getForeignKeysQueryPrefix",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#_getForeignKeysQueryPrefix",
    "access": "private",
    "description": "Generate common SQL prefix for ForeignKeysQuery.",
    "lineNumber": 677,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "catalogName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 988,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#getForeignKeysQuery",
    "access": "public",
    "description": "Generates an SQL query that returns all foreign keys details of a table.",
    "lineNumber": 706,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "catalogName",
        "description": "database name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 989,
    "kind": "method",
    "name": "getForeignKeyQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#getForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 717,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 990,
    "kind": "method",
    "name": "getPrimaryKeyConstraintQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#getPrimaryKeyConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 730,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 991,
    "kind": "method",
    "name": "dropForeignKeyQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 748,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "foreignKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 992,
    "kind": "method",
    "name": "getDefaultConstraintQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#getDefaultConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 752,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 993,
    "kind": "method",
    "name": "dropConstraintQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#dropConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 760,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 994,
    "kind": "method",
    "name": "setIsolationLevelQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#setIsolationLevelQuery",
    "access": "public",
    "description": null,
    "lineNumber": 764,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 995,
    "kind": "method",
    "name": "generateTransactionId",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#generateTransactionId",
    "access": "public",
    "description": null,
    "lineNumber": 768,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 996,
    "kind": "method",
    "name": "startTransactionQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#startTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 772,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 997,
    "kind": "method",
    "name": "commitTransactionQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#commitTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 780,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 998,
    "kind": "method",
    "name": "rollbackTransactionQuery",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#rollbackTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 788,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 999,
    "kind": "method",
    "name": "selectFromTableFragment",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#selectFromTableFragment",
    "access": "public",
    "description": null,
    "lineNumber": 796,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "tables",
        "types": [
          "*"
        ]
      },
      {
        "name": "mainTableAs",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1000,
    "kind": "method",
    "name": "addLimitAndOffset",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#addLimitAndOffset",
    "access": "public",
    "description": null,
    "lineNumber": 853,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1001,
    "kind": "method",
    "name": "booleanValue",
    "memberof": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query-generator.js~MSSQLQueryGenerator#booleanValue",
    "access": "public",
    "description": null,
    "lineNumber": 889,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1002,
    "kind": "function",
    "name": "wrapSingleQuote",
    "memberof": "lib/dialects/mssql/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/query-generator.js~wrapSingleQuote",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 895,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1003,
    "kind": "file",
    "name": "lib/dialects/mssql/query-interface.js",
    "content": "'use strict';\n\n/**\n Returns an object that treats MSSQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.\n\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName     The name of the table.\n  @param  {string} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @private\n */\nconst removeColumn = function(qi, tableName, attributeName, options) {\n  options = Object.assign({ raw: true }, options || {});\n\n  const findConstraintSql = qi.QueryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n  return qi.sequelize.query(findConstraintSql, options)\n    .then(([results]) => {\n      if (!results.length) {\n        // No default constraint found -- we can cleanly remove the column\n        return;\n      }\n      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, results[0].name);\n      return qi.sequelize.query(dropConstraintSql, options);\n    })\n    .then(() => {\n      const findForeignKeySql = qi.QueryGenerator.getForeignKeyQuery(tableName, attributeName);\n      return qi.sequelize.query(findForeignKeySql, options);\n    })\n    .then(([results]) => {\n      if (!results.length) {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      const dropForeignKeySql = qi.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      return qi.sequelize.query(dropForeignKeySql, options);\n    })\n    .then(() => {\n      //Check if the current column is a primaryKey\n      const primaryKeyConstraintSql = qi.QueryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n      return qi.sequelize.query(primaryKeyConstraintSql, options);\n    })\n    .then(([result]) => {\n      if (!result.length) {\n        return;\n      }\n      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      return qi.sequelize.query(dropConstraintSql, options);\n    })\n    .then(() => {\n      const removeSql = qi.QueryGenerator.removeColumnQuery(tableName, attributeName);\n      return qi.sequelize.query(removeSql, options);\n    });\n};\n\nmodule.exports = {\n  removeColumn\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1004,
    "kind": "function",
    "name": "removeColumn",
    "memberof": "lib/dialects/mssql/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/query-interface.js~removeColumn",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query-interface.js",
    "importStyle": null,
    "description": "A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attributeName",
        "description": "The name of the attribute that we want to remove."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs the sql queries, or false for explicitly not logging these queries"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1005,
    "kind": "file",
    "name": "lib/dialects/mssql/query.js",
    "content": "'use strict';\n\nconst Promise = require('../../promise');\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('mssql');\nconst _ = require('lodash');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:mssql');\n\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum)) return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum) e *= 10;\n  return Math.log10(e);\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = { type: TYPES.VarChar, typeOptions: {} };\n    paramType.type = TYPES.NVarChar;\n    if (typeof value === 'number') {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        //Default to a reasonable numeric precision/scale pending more sophisticated logic\n        paramType.typeOptions = { precision: 30, scale: getScale(value) };\n      }\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n\n  _run(connection, sql, parameters) {\n    this.sql = sql;\n    const { options } = this;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => {\n      const handleTransaction = err => {\n        if (err) {\n          reject(this.formatError(err));\n          return;\n        }\n        resolve(this.formatResults());\n      };\n      // TRANSACTION SUPPORT\n      if (sql.startsWith('BEGIN TRANSACTION')) {\n        return connection.beginTransaction(handleTransaction, options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith('COMMIT TRANSACTION')) {\n        return connection.commitTransaction(handleTransaction);\n      }\n      if (sql.startsWith('ROLLBACK TRANSACTION')) {\n        return connection.rollbackTransaction(handleTransaction, options.transaction.name);\n      }\n      if (sql.startsWith('SAVE TRANSACTION')) {\n        return connection.saveTransaction(handleTransaction, options.transaction.name);\n      }\n      const results = [];\n      const request = new connection.lib.Request(sql, (err, rowCount) => {\n\n        complete();\n\n        if (err) {\n          err.sql = sql;\n          err.parameters = parameters;\n          reject(this.formatError(err));\n        } else {\n          resolve(this.formatResults(results, rowCount));\n        }\n      });\n\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n\n      request.on('row', columns => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n\n        results.push(row);\n      });\n\n      connection.execSql(request);\n    });\n  }\n\n  run(sql, parameters) {\n    return Promise.using(this.connection.lock(), connection => this._run(connection, sql, parameters));\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        bindParam[key] = values[key];\n        return `@${key}`;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, bindParam];\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   * @param {Array} data - The result of the query execution.\n   * @param {number} rowCount\n   * @private\n   * @example\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   */\n  formatResults(data, rowCount) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        if (this.options.plain) {\n          // NOTE: super contrived. This just passes the newly added query-interface\n          //       test returning only the PK. There isn't a way in MSSQL to identify\n          //       that a given return value is the PK, and we have no schema information\n          //       because there was no calling Model.\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n        }\n\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === 'YES' ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === 'PRIMARY KEY',\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n\n        if (\n          result[_result.Name].type.includes('CHAR')\n          && _result.Length\n        ) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += '(MAX)';\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n\n      }\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isUpsertQuery()) {\n      this.handleInsertQuery(data);\n      return this.instance || data[0];\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] && data[0].AFFECTEDROWS;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      // MSSQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  handleShowConstraintsQuery(data) {\n    //Convert snake_case keys to camelCase as it's generated by stored procedure\n    return data.slice(1).map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n\n  formatError(err) {\n    let match;\n\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '((.|\\s)*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = 'Validation error';\n\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[4]) {\n        const values = match[4].split(',').map(part => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[4];\n        }\n      }\n\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(\n          this.getUniqueConstraintErrorMessage(field),\n          'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n          field,\n          value,\n          this.instance,\n          'not_unique'\n        ));\n      });\n\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n    }\n\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||\n      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) ||\n      err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : undefined;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : undefined;\n\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err\n      });\n    }\n\n    return new sequelizeErrors.DatabaseError(err);\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');\n    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n\n    return result;\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n\n      item.index_keys.split(',').forEach(column => {\n        let columnName = column.trim();\n        if (columnName.includes('(-)')) {\n          columnName = columnName.replace('(-)', '');\n        }\n\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: undefined,\n          order: column.includes('(-)') ? 'DESC' : 'ASC',\n          collate: undefined\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n\n    return _.map(data, item => ({\n      primary: item.index_name.toLowerCase().startsWith('pk'),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: undefined,\n      unique: item.index_description.toLowerCase().includes('unique'),\n      type: undefined\n    }));\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) &&\n        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n\n      this.instance[autoIncrementAttribute] = id;\n\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n\n            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1006,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1007,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1008,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1009,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1010,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1011,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1012,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1013,
    "kind": "function",
    "name": "getScale",
    "memberof": "lib/dialects/mssql/query.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/query.js~getScale",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "aNum",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1014,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/mssql/query.js",
    "static": true,
    "longname": "lib/dialects/mssql/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 1015,
    "kind": "method",
    "name": "getInsertIdField",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#getInsertIdField",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1016,
    "kind": "method",
    "name": "getSQLTypeFromJsType",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#getSQLTypeFromJsType",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "TYPES",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1017,
    "kind": "method",
    "name": "_run",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#_run",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1018,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1019,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1020,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mssql/query.js~Query.formatBindParameters",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1021,
    "kind": "method",
    "name": "formatResults",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#formatResults",
    "access": "private",
    "description": "High level function that handles the results of a query execution.",
    "examples": [
      "Example:\n query.formatResults([\n   {\n     id: 1,              // this is from the main table\n     attr2: 'snafu',     // this is from the main table\n     Tasks.id: 1,        // this is from the associated table\n     Tasks.title: 'task' // this is from the associated table\n   }\n ])"
    ],
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The result of the query execution."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rowCount",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1022,
    "kind": "method",
    "name": "handleShowTablesQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#handleShowTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1023,
    "kind": "method",
    "name": "handleShowConstraintsQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#handleShowConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1024,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1025,
    "kind": "method",
    "name": "isShowOrDescribeQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#isShowOrDescribeQuery",
    "access": "public",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1026,
    "kind": "method",
    "name": "isShowIndexesQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#isShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 339,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1027,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1028,
    "kind": "method",
    "name": "handleInsertQuery",
    "memberof": "lib/dialects/mssql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/query.js~Query#handleInsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 378,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaData",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1029,
    "kind": "file",
    "name": "lib/dialects/mssql/resource-lock.js",
    "content": "'use strict';\n\nconst Promise = require('../../promise');\n\nclass ResourceLock {\n  constructor(resource) {\n    this.resource = resource;\n    this.previous = Promise.resolve(resource);\n  }\n\n  unwrap() {\n    return this.resource;\n  }\n\n  lock() {\n    const lock = this.previous;\n    let resolve;\n    this.previous = new Promise(r => {\n      resolve = r;\n    });\n    return lock.disposer(resolve);\n  }\n}\n\nmodule.exports = ResourceLock;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mssql/resource-lock.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1030,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mssql/resource-lock.js",
    "static": true,
    "longname": "lib/dialects/mssql/resource-lock.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/resource-lock.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1031,
    "kind": "class",
    "name": "ResourceLock",
    "memberof": "lib/dialects/mssql/resource-lock.js",
    "static": true,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mssql/resource-lock.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1032,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1033,
    "kind": "member",
    "name": "resource",
    "memberof": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "static": false,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock#resource",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1034,
    "kind": "member",
    "name": "previous",
    "memberof": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "static": false,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock#previous",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1035,
    "kind": "method",
    "name": "unwrap",
    "memberof": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock#unwrap",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1036,
    "kind": "method",
    "name": "lock",
    "memberof": "lib/dialects/mssql/resource-lock.js~ResourceLock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mssql/resource-lock.js~ResourceLock#lock",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1038,
    "kind": "file",
    "name": "lib/dialects/mysql/connection-manager.js",
    "content": "'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mysql');\nconst parserStore = require('../parserStore')('mysql');\n\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @returns Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {Object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  connect(config) {\n    const connectionConfig = Object.assign({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n\n    return new Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect & error event if there is error\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('error', connectHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        // clean up error event if connected\n        connection.removeListener('error', errorHandler);\n        resolve(connection);\n      };\n\n      // don't use connection.once for error event handling here\n      // mysql2 emit error two times in case handshake was failed\n      // first error is protocol_lost and second is timeout\n      // if we will use `once.error` node process will crash on 2nd error emit\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    })\n      .tap(() => { debug('connection acquired'); })\n      .then(connection => {\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n            case 'EPIPE':\n            case 'PROTOCOL_CONNECTION_LOST':\n              this.pool.destroy(connection);\n          }\n        });\n\n        return new Promise((resolve, reject) => {\n          if (!this.sequelize.config.keepDefaultTimezone) {\n            // set timezone for this connection\n            // but named timezone are not directly supported in mysql, so get its offset first\n            let tzOffset = this.sequelize.options.timezone;\n            tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n            return connection.query(`SET time_zone = '${tzOffset}'`, err => {\n              if (err) { reject(err); } else { resolve(connection); }\n            });\n          }\n\n          // return connection without executing SET time_zone query\n          resolve(connection);\n        });\n      })\n      .catch(err => {\n        switch (err.code) {\n          case 'ECONNREFUSED':\n            throw new SequelizeErrors.ConnectionRefusedError(err);\n          case 'ER_ACCESS_DENIED_ERROR':\n            throw new SequelizeErrors.AccessDeniedError(err);\n          case 'ENOTFOUND':\n            throw new SequelizeErrors.HostNotFoundError(err);\n          case 'EHOSTUNREACH':\n            throw new SequelizeErrors.HostNotReachableError(err);\n          case 'EINVAL':\n            throw new SequelizeErrors.InvalidConnectionError(err);\n          default:\n            throw new SequelizeErrors.ConnectionError(err);\n        }\n      });\n  }\n\n  disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return connection\n      && !connection._fatalError\n      && !connection._protocolError\n      && !connection._closing\n      && !connection.stream.destroyed;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1039,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1040,
    "kind": "variable",
    "name": "SequelizeErrors",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~SequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1041,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1042,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1043,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1044,
    "kind": "variable",
    "name": "momentTz",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~momentTz",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1045,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1046,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1047,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mysql/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/connection-manager.js",
    "importStyle": null,
    "description": "MySQL Connection Manager\n\nGet connections, validate and disconnect them.\nAbstractConnectionManager pooling use it to handle MySQL specific connections\nUse https://github.com/sidorares/node-mysql2 to connect with MySQL server",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "Class<ConnectionManager>"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Class<ConnectionManager>"
    },
    "interface": false,
    "extends": [
      "*"
    ],
    "ignore": true
  },
  {
    "__docId__": 1048,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1049,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1050,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1051,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1052,
    "kind": "method",
    "name": "_typecast",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager._typecast",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "next",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1053,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#connect",
    "access": "private",
    "description": "Connect with MySQL database based on config, Handle any errors in connection\nSet the pool handlers on connection.error\nAlso set proper timezone once connection is connected.",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Connection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Connection>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1054,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1055,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/mysql/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1056,
    "kind": "file",
    "name": "lib/dialects/mysql/data-types.js",
    "content": "'use strict';\n\nconst wkx = require('wkx');\nconst _ = require('lodash');\nconst moment = require('moment-timezone');\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';\n\n  /**\n   * types: [buffer_type, ...]\n   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html\n   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js\n   */\n\n  BaseTypes.DATE.types.mysql = ['DATETIME'];\n  BaseTypes.STRING.types.mysql = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mysql = ['STRING'];\n  BaseTypes.TEXT.types.mysql = ['BLOB'];\n  BaseTypes.TINYINT.types.mysql = ['TINY'];\n  BaseTypes.SMALLINT.types.mysql = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.mysql = ['INT24'];\n  BaseTypes.INTEGER.types.mysql = ['LONG'];\n  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mysql = ['FLOAT'];\n  BaseTypes.TIME.types.mysql = ['TIME'];\n  BaseTypes.DATEONLY.types.mysql = ['DATE'];\n  BaseTypes.BOOLEAN.types.mysql = ['TINY'];\n  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];\n  BaseTypes.JSON.types.mysql = ['JSON'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        definition += ' ZEROFILL';\n      }\n      return definition;\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return `DATETIME${this._length ? `(${this._length})` : ''}`;\n    }\n    _stringify(date, options) {\n      date = this._applyTimezone(date, options);\n      // Fractional DATETIMEs only supported on MySQL 5.6.4+\n      if (this._length) {\n        return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n      }\n      return date.format('YYYY-MM-DD HH:mm:ss');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (moment.tz.zone(options.timezone)) {\n        value = moment.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36) BINARY';\n    }\n  }\n\n  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(', ')}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      // Empty buffer, MySQL doesn't support POINT EMPTY\n      // check, https://dev.mysql.com/worklog/task/?id=2381\n      if (!value || value.length === 0) {\n        return null;\n      }\n      // For some reason, discard the first 4 bytes\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON();\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1057,
    "kind": "variable",
    "name": "wkx",
    "memberof": "lib/dialects/mysql/data-types.js",
    "static": true,
    "longname": "lib/dialects/mysql/data-types.js~wkx",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1058,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mysql/data-types.js",
    "static": true,
    "longname": "lib/dialects/mysql/data-types.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1059,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/mysql/data-types.js",
    "static": true,
    "longname": "lib/dialects/mysql/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1060,
    "kind": "file",
    "name": "lib/dialects/mysql/index.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').mysql;\n\nclass MysqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nMysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'VALUES ()': true,\n  'LIMIT ON UPDATE': true,\n  lock: true,\n  forShare: 'LOCK IN SHARE MODE',\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: ' IGNORE',\n    updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\n\nConnectionManager.prototype.defaultVersion = '5.6.0';\nMysqlDialect.prototype.Query = Query;\nMysqlDialect.prototype.QueryGenerator = QueryGenerator;\nMysqlDialect.prototype.DataTypes = DataTypes;\nMysqlDialect.prototype.name = 'mysql';\nMysqlDialect.prototype.TICK_CHAR = '`';\nMysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;\nMysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;\n\nmodule.exports = MysqlDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1061,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1062,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1063,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1064,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1065,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1066,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1067,
    "kind": "class",
    "name": "MysqlDialect",
    "memberof": "lib/dialects/mysql/index.js",
    "static": true,
    "longname": "lib/dialects/mysql/index.js~MysqlDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 1068,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mysql/index.js~MysqlDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/index.js~MysqlDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1069,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/mysql/index.js~MysqlDialect",
    "static": false,
    "longname": "lib/dialects/mysql/index.js~MysqlDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1070,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/mysql/index.js~MysqlDialect",
    "static": false,
    "longname": "lib/dialects/mysql/index.js~MysqlDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1071,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/mysql/index.js~MysqlDialect",
    "static": false,
    "longname": "lib/dialects/mysql/index.js~MysqlDialect#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1072,
    "kind": "file",
    "name": "lib/dialects/mysql/query-generator.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,'\n  + 'CONSTRAINT_NAME as constraintName,'\n  + 'CONSTRAINT_SCHEMA as constraintSchema,'\n  + 'CONSTRAINT_SCHEMA as constraintCatalog,'\n  + 'TABLE_NAME as tableName,'\n  + 'TABLE_SCHEMA as tableSchema,'\n  + 'TABLE_SCHEMA as tableCatalog,'\n  + 'COLUMN_NAME as columnName,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,'\n  + 'REFERENCED_TABLE_NAME as referencedTableName,'\n  + 'REFERENCED_COLUMN_NAME as referencedColumnName';\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `${`CREATE DATABASE IF NOT EXISTS ${database}${charset}${collate}`.trim()};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName).trim()};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? ` COMMENT ${this.escape(options.comment)}` : '';\n    const engine = options.engine;\n    const charset = options.charset ? ` DEFAULT CHARSET=${options.charset}` : '';\n    const collation = options.collate ? ` COLLATE ${options.collate}` : '';\n    const rowFormat = options.rowFormat ? ` ROW_FORMAT=${options.rowFormat}` : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? ` AUTO_INCREMENT=${options.initialAutoIncrement}` : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${table} (${attributesClause}) ENGINE=${engine}${comment}${charset}${collation}${initialAutoIncrement}${rowFormat};`;\n  }\n\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `CHANGE ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return `${key}=VALUES(${key})`;\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return `SHOW INDEX FROM ${this.quoteTable(tableName)}${(options || {}).database ? ` FROM \\`${options.database}\\`` : ''}`;\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}' AND REFERENCED_TABLE_NAME IS NOT NULL;`;\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE`\n      + ` WHERE (REFERENCED_TABLE_NAME = ${quotedTableName}${table.schema\n        ? ` AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`\n        : ''} AND REFERENCED_COLUMN_NAME = ${quotedColumnName})`\n      + ` OR (TABLE_NAME = ${quotedTableName}${table.schema ?\n        ` AND TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND COLUMN_NAME = ${quotedColumnName} AND REFERENCED_TABLE_NAME IS NOT NULL)`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)}\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1073,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1074,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1075,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1076,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1077,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1078,
    "kind": "variable",
    "name": "jsonFunctionRegex",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~jsonFunctionRegex",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1079,
    "kind": "variable",
    "name": "jsonOperatorRegex",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~jsonOperatorRegex",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1080,
    "kind": "variable",
    "name": "tokenCaptureRegex",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~tokenCaptureRegex",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1081,
    "kind": "variable",
    "name": "foreignKeyFields",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~foreignKeyFields",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1082,
    "kind": "variable",
    "name": "typeWithoutDefault",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~typeWithoutDefault",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1083,
    "kind": "class",
    "name": "MySQLQueryGenerator",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 1084,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1085,
    "kind": "member",
    "name": "OperatorMap",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#OperatorMap",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1086,
    "kind": "method",
    "name": "createDatabaseQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#createDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1087,
    "kind": "method",
    "name": "dropDatabaseQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#dropDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1088,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1089,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1090,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1091,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1092,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaDelimiter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1093,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1094,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1095,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1096,
    "kind": "method",
    "name": "changeColumnQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#changeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1097,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1098,
    "kind": "method",
    "name": "handleSequelizeMethod",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#handleSequelizeMethod",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "smth",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1099,
    "kind": "method",
    "name": "_toJSONValue",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#_toJSONValue",
    "access": "private",
    "description": null,
    "lineNumber": 258,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1100,
    "kind": "method",
    "name": "upsertQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#upsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1101,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 281,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1102,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1103,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 302,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1104,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 306,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1105,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 332,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1106,
    "kind": "method",
    "name": "attributeToSQL",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#attributeToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 342,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1107,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1108,
    "kind": "method",
    "name": "_checkValidJsonStatement",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#_checkValidJsonStatement",
    "access": "private",
    "description": "Check whether the statmement is json function or simple path",
    "lineNumber": 434,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}       true if the given statement is json function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "stmt",
        "description": "The statement to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given statement is json function"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "throw if the statement looks like json function but has invalid token"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1109,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#getForeignKeysQuery",
    "access": "private",
    "description": "Generates an SQL query that returns all foreign keys of a table.",
    "lineNumber": 496,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": "The table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schemaName",
        "description": "The name of the schema."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1110,
    "kind": "method",
    "name": "getForeignKeyQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#getForeignKeyQuery",
    "access": "private",
    "description": "Generates an SQL query that returns the foreign key constraint of a given column.",
    "lineNumber": 509,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": "The table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "columnName",
        "description": "The name of the column."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1111,
    "kind": "method",
    "name": "dropForeignKeyQuery",
    "memberof": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query-generator.js~MySQLQueryGenerator#dropForeignKeyQuery",
    "access": "private",
    "description": "Generates an SQL query that removes a foreign key from a table.",
    "lineNumber": 530,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "foreignKey",
        "description": "The name of the foreign key constraint."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1112,
    "kind": "function",
    "name": "wrapSingleQuote",
    "memberof": "lib/dialects/mysql/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mysql/query-generator.js~wrapSingleQuote",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 537,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1113,
    "kind": "file",
    "name": "lib/dialects/mysql/query-interface.js",
    "content": "'use strict';\n\n/**\n Returns an object that treats MySQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors');\n\n/**\n A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.\n\n @param  {QueryInterface} qi\n @param  {string} tableName     The name of the table.\n @param  {string} columnName    The name of the attribute that we want to remove.\n @param  {Object} options\n\n @private\n */\nfunction removeColumn(qi, tableName, columnName, options) {\n  options = options || {};\n\n  return qi.sequelize.query(\n    qi.QueryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: qi.sequelize.config.database\n    }, columnName),\n    Object.assign({ raw: true }, options)\n  )\n    .then(([results]) => {\n      //Exclude primary key constraint\n      if (!results.length || results[0].constraint_name === 'PRIMARY') {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      return Promise.map(results, constraint => qi.sequelize.query(\n        qi.QueryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name),\n        Object.assign({ raw: true }, options)\n      ));\n    })\n    .then(() => qi.sequelize.query(\n      qi.QueryGenerator.removeColumnQuery(tableName, columnName),\n      Object.assign({ raw: true }, options)\n    ));\n}\n\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {string} constraintName\n * @param {Object} options\n *\n * @private\n */\nfunction removeConstraint(qi, tableName, constraintName, options) {\n  const sql = qi.QueryGenerator.showConstraintsQuery(\n    tableName.tableName ? tableName : {\n      tableName,\n      schema: qi.sequelize.config.database\n    }, constraintName);\n\n  return qi.sequelize.query(sql, Object.assign({}, options,\n    { type: qi.sequelize.QueryTypes.SHOWCONSTRAINTS }))\n    .then(constraints => {\n      const constraint = constraints[0];\n      let query;\n      if (!constraint || !constraint.constraintType) {\n        throw new sequelizeErrors.UnknownConstraintError(\n          {\n            message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n            constraint: constraintName,\n            table: tableName\n          });\n      }\n\n      if (constraint.constraintType === 'FOREIGN KEY') {\n        query = qi.QueryGenerator.dropForeignKeyQuery(tableName, constraintName);\n      } else {\n        query = qi.QueryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n      }\n\n      return qi.sequelize.query(query, options);\n    });\n}\n\nexports.removeConstraint = removeConstraint;\nexports.removeColumn = removeColumn;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1114,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/mysql/query-interface.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-interface.js~Promise",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-interface.js",
    "importStyle": null,
    "description": "Returns an object that treats MySQL's inabilities to do certain queries.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "QueryInterface"
      }
    ],
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1115,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/mysql/query-interface.js",
    "static": true,
    "longname": "lib/dialects/mysql/query-interface.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1116,
    "kind": "function",
    "name": "removeColumn",
    "memberof": "lib/dialects/mysql/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mysql/query-interface.js~removeColumn",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-interface.js",
    "importStyle": null,
    "description": "A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "columnName",
        "description": "The name of the attribute that we want to remove."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1117,
    "kind": "function",
    "name": "removeConstraint",
    "memberof": "lib/dialects/mysql/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mysql/query-interface.js~removeConstraint",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query-interface.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "constraintName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1118,
    "kind": "file",
    "name": "lib/dialects/mysql/query.js",
    "content": "'use strict';\n\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst _ = require('lodash');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:mysql');\n\n\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, Object.assign({ showWarnings: false }, options));\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        bindParam.push(values[key]);\n        return '?';\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : undefined];\n  }\n\n  run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n\n    //do we need benchmark for this query execution\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Utils.Promise((resolve, reject) => {\n      const handler = (err, results) => {\n        complete();\n\n        if (err) {\n          // MySQL automatically rolls-back transactions in the event of a deadlock\n          if (options.transaction && err.errno === 1213) {\n            options.transaction.finished = 'rollback';\n          }\n          err.sql = sql;\n          err.parameters = parameters;\n\n          reject(this.formatError(err));\n        } else {\n          resolve(results);\n        }\n      };\n      if (parameters) {\n        debug('parameters(%j)', parameters);\n        connection.execute(sql, parameters, handler).setMaxListeners(100);\n      } else {\n        connection.query({ sql }, handler).setMaxListeners(100);\n      }\n    })\n    // Log warnings if we've got them.\n      .then(results => {\n        if (showWarnings && results && results.warningStatus > 0) {\n          return this.logWarnings(results);\n        }\n        return results;\n      })\n    // Return formatted results...\n      .then(results => this.formatResults(results));\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @private\n   */\n  formatResults(data) {\n    let result = this.instance;\n\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primiary key\n        if (\n          data.constructor.name === 'ResultSetHeader'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.Field] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.Type.toUpperCase(),\n          allowNull: _result.Null === 'YES',\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === 'PRI',\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra') && _result.Extra.toLowerCase() === 'auto_increment',\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery() || this.isUpsertQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  logWarnings(results) {\n    return this.run('SHOW WARNINGS').then(warningResults => {\n      const warningMessage = `MySQL Warnings (${this.connection.uuid || 'default'}): `;\n      const messages = [];\n      for (const _warningRow of warningResults) {\n        if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') continue;\n        for (const _warningResult of _warningRow) {\n          if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {\n            messages.push(_warningResult.Message);\n          } else {\n            for (const _objectKey of _warningResult.keys()) {\n              messages.push([_objectKey, _warningResult[_objectKey]].join(': '));\n            }\n          }\n        }\n      }\n\n      this.sequelize.log(warningMessage + messages.join('; '), this.options);\n\n      return results;\n    });\n  }\n\n  formatError(err) {\n    const errCode = err.errno || err.code;\n\n    switch (errCode) {\n      case 1062: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = 'Validation error';\n        const values = match ? match[1].split('-') : undefined;\n        const fieldKey = match ? match[2] : undefined;\n        const fieldVal = match ? match[1] : undefined;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n\n        if (uniqueKey) {\n          if (uniqueKey.msg) message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            value,\n            this.instance,\n            'not_unique'\n          ));\n        });\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n\n      case 1451:\n      case 1452: {\n        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : '`';\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;\n\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === '1451' ? 'parent' : 'child',\n          table: match ? match[4] : undefined,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,\n          index: match ? match[2] : undefined,\n          parent: err\n        });\n      }\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || undefined,\n        order: item.Collation === 'A' ? 'ASC' : undefined\n      };\n      delete item.column_name;\n\n      return acc;\n    }, {});\n\n    return _.map(data, item => ({\n      primary: item.Key_name === 'PRIMARY',\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/mysql/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1119,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1120,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1121,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1122,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1123,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1124,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1125,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/mysql/query.js",
    "static": true,
    "longname": "lib/dialects/mysql/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/mysql/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 1126,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1127,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/mysql/query.js~Query.formatBindParameters",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1128,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1129,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1130,
    "kind": "method",
    "name": "formatResults",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#formatResults",
    "access": "private",
    "description": "High level function that handles the results of a query execution.\n\n\nExample:\n query.formatResults([\n   {\n     id: 1,              // this is from the main table\n     attr2: 'snafu',     // this is from the main table\n     Tasks.id: 1,        // this is from the associated table\n     Tasks.title: 'task' // this is from the associated table\n   }\n ])",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The result of the query execution."
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1131,
    "kind": "method",
    "name": "logWarnings",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#logWarnings",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1132,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1133,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/mysql/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/mysql/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1134,
    "kind": "file",
    "name": "lib/dialects/parserStore.js",
    "content": "'use strict';\n\nconst stores = new Map();\n\nmodule.exports = dialect => {\n  if (!stores.has(dialect)) {\n    stores.set(dialect, new Map());\n  }\n\n  return {\n    clear() {\n      stores.get(dialect).clear();\n    },\n    refresh(dataType) {\n      for (const type of dataType.types[dialect]) {\n        stores.get(dialect).set(type, dataType.parse);\n      }\n    },\n    get(type) {\n      return stores.get(dialect).get(type);\n    }\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/parserStore.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1135,
    "kind": "variable",
    "name": "stores",
    "memberof": "lib/dialects/parserStore.js",
    "static": true,
    "longname": "lib/dialects/parserStore.js~stores",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/parserStore.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1136,
    "kind": "file",
    "name": "lib/dialects/postgres/connection-manager.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:pg');\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors');\nconst semver = require('semver');\nconst dataTypes = require('../../data-types');\nconst moment = require('moment-timezone');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule('pg');\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser => {\n      return value => this.lib.types.arrayParser.create(value, parser).parse();\n    };\n    const rangeParserBuilder = parser => {\n      return value => dataType.parse(value, { parser });\n    };\n\n    // Set range parsers\n    if (dataType.key.toLowerCase() === 'range') {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (! entry.rangeOid) continue;\n\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (! entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n\n    // Create parsers for normal or enum data types\n    const parser = value => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n\n    // Set enum parsers\n    if (dataType.key.toLowerCase() === 'enum') {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n\n    // Set parsers for normal data types\n    dataType.types.postgres.forEach(name => {\n      if (! this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n\n      if (! this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      'user', 'password', 'host', 'database', 'port'\n    ]);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig,\n        _.pick(config.dialectOptions, [\n        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n          'application_name',\n          // choose the SSL mode with the PGSSLMODE environment variable\n          // object format: [https://github.com/brianc/node-postgres/blob/master/lib/connection.js#L79]\n          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n          'ssl',\n          // In addition to the values accepted by the corresponding server,\n          // you can use \"auto\" to determine the right encoding from the\n          // current locale in the client (LC_CTYPE environment variable on Unix systems)\n          'client_encoding',\n          // !! DO NOT SET THIS TO TRUE !!\n          // (unless you know what you're doing)\n          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n          'binary',\n          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n          'keepAlive',\n          // Times out queries after a set time in milliseconds. Added in pg v7.3\n          'statement_timeout'\n        ]));\n    }\n\n    return new Promise((resolve, reject) => {\n      let responded = false;\n\n      const connection = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case 'server_version':\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version)\n                ? version\n                : this.defaultVersion;\n            }\n            break;\n          case 'standard_conforming_strings':\n            connection['standard_conforming_strings'] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug('connection timeout');\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      };\n\n      // If we didn't ever hear from the client.connect() callback the connection timeout\n      // node-postgres does not treat this as an error since no active query was ever emitted\n      connection.once('end', endHandler);\n\n      if (!this.sequelize.config.native) {\n        // Receive various server parameters for further configuration\n        connection.connection.on('parameterStatus', parameterHandler);\n      }\n\n      connection.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          // remove parameter handler\n          connection.connection.removeListener('parameterStatus', parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug('connection acquired');\n          connection.removeListener('end', endHandler);\n          resolve(connection);\n        }\n      });\n    }).tap(connection => {\n      let query = '';\n\n      if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {\n        // Disable escape characters in strings\n        // see https://github.com/sequelize/sequelize/issues/3545 (security issue)\n        // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS\n        query += 'SET standard_conforming_strings=on;';\n      }\n\n      if (this.sequelize.options.clientMinMessages !== false) {\n        query += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`;\n      }\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const isZone = !!moment.tz.zone(this.sequelize.options.timezone);\n        if (isZone) {\n          query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n        } else {\n          query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n        }\n      }\n\n      if (query) {\n        return connection.query(query);\n      }\n    }).tap(connection => {\n      if (Object.keys(this.nameOidMap).length === 0 &&\n        this.enumOids.oids.length === 0 &&\n        this.enumOids.arrayOids.length === 0) {\n        return this._refreshDynamicOIDs(connection);\n      }\n    }).tap(connection => {\n      // Don't let a Postgres restart (or error) to take down the whole app\n      connection.on('error', error => {\n        connection._invalid = true;\n        debug(`connection error ${error.code || error.message}`);\n        this.pool.destroy(connection);\n      });\n    });\n  }\n\n  disconnect(connection) {\n    if (connection._ending) {\n      debug('connection tried to disconnect but was already at ENDING state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = '8.3.0';\n\n    // Check for supported version\n    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return Promise.resolve();\n    }\n\n    // Refresh dynamic OIDs for some types\n    // These include Geometry / Geography / HStore / Enum / Citext / Range\n    return (connection || this.sequelize).query(\n      'WITH ranges AS (' +\n      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +\n      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +\n      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +\n      ')' +\n      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +\n      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +\n      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +\n      ' WHERE (pg_type.typtype IN(\\'b\\', \\'e\\'));'\n    ).then(results => {\n      let result = Array.isArray(results) ? results.pop() : results;\n\n      // When searchPath is prepended then two statements are executed and the result is\n      // an array of those two statements. First one is the SET search_path and second is\n      // the SELECT query result.\n      if (Array.isArray(result)) {\n        if (result[0].command === 'SET') {\n          result = result.pop();\n        }\n      }\n\n      const newNameOidMap = {};\n      const newEnumOids = { oids: [], arrayOids: [] };\n\n      for (const row of result.rows) {\n        // Mapping enums, handled separatedly\n        if (row.typtype === 'e') {\n          newEnumOids.oids.push(row.oid);\n          if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n          continue;\n        }\n\n        // Mapping base types and their arrays\n        newNameOidMap[row.typname] = { oid: row.oid };\n        if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n\n        // Mapping ranges(of base types) and their arrays\n        if (row.rngtypid) {\n          newNameOidMap[row.typname].rangeOid = row.rngtypid;\n          if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n        }\n      }\n\n      // Replace all OID mappings. Avoids temporary empty OID mappings.\n      this.nameOidMap = newNameOidMap;\n      this.enumOids = newEnumOids;\n\n      this.refreshTypeParser(dataTypes.postgres);\n    });\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1137,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1138,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1139,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1140,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1141,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1142,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1143,
    "kind": "variable",
    "name": "semver",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~semver",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1144,
    "kind": "variable",
    "name": "dataTypes",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~dataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1145,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1146,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/postgres/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractConnectionManager"
    ],
    "ignore": true
  },
  {
    "__docId__": 1147,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1148,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1149,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1150,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1151,
    "kind": "member",
    "name": "oidParserMap",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#oidParserMap",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1152,
    "kind": "method",
    "name": "getTypeParser",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#getTypeParser",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "params": [
      {
        "name": "oid",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1153,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#connect",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1154,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1155,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1156,
    "kind": "method",
    "name": "_refreshDynamicOIDs",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#_refreshDynamicOIDs",
    "access": "private",
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1157,
    "kind": "member",
    "name": "nameOidMap",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#nameOidMap",
    "access": "public",
    "description": null,
    "lineNumber": 305,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1158,
    "kind": "member",
    "name": "enumOids",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#enumOids",
    "access": "public",
    "description": null,
    "lineNumber": 306,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1159,
    "kind": "method",
    "name": "_clearDynamicOIDs",
    "memberof": "lib/dialects/postgres/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/connection-manager.js~ConnectionManager#_clearDynamicOIDs",
    "access": "private",
    "description": null,
    "lineNumber": 312,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1162,
    "kind": "file",
    "name": "lib/dialects/postgres/data-types.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {Object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;\n        }\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int8\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float4\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float8\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n      return 'BYTEA';\n    }\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON();\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON();\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.parse(value);\n    }\n  }\n\n  HSTORE.prototype.escape = false;\n\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      // Array.map does not preserve extra array properties\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: val => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  };\n\n  // TODO: Why are base types being manipulated??\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        castKey = `${Utils.addTicks(\n          Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName),\n          '\"'\n        ) }[]`;\n      }\n\n      str += `::${castKey}`;\n    }\n\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1163,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/data-types.js",
    "static": true,
    "longname": "lib/dialects/postgres/data-types.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1164,
    "kind": "variable",
    "name": "wkx",
    "memberof": "lib/dialects/postgres/data-types.js",
    "static": true,
    "longname": "lib/dialects/postgres/data-types.js~wkx",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1165,
    "kind": "file",
    "name": "lib/dialects/postgres/hstore.js",
    "content": "'use strict';\n\nconst hstore = require('pg-hstore')({ sanitize: true });\n\nfunction stringify(data) {\n  if (data === null) return null;\n  return hstore.stringify(data);\n}\nexports.stringify = stringify;\n\nfunction parse(value) {\n  if (value === null) return null;\n  return hstore.parse(value);\n}\nexports.parse = parse;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/hstore.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1166,
    "kind": "variable",
    "name": "hstore",
    "memberof": "lib/dialects/postgres/hstore.js",
    "static": true,
    "longname": "lib/dialects/postgres/hstore.js~hstore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/hstore.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1167,
    "kind": "function",
    "name": "stringify",
    "memberof": "lib/dialects/postgres/hstore.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/hstore.js~stringify",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/hstore.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1168,
    "kind": "function",
    "name": "parse",
    "memberof": "lib/dialects/postgres/hstore.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/hstore.js~parse",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/hstore.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1169,
    "kind": "file",
    "name": "lib/dialects/postgres/index.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').postgres;\n\nclass PostgresDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nPostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT VALUES': true,\n  'EXCEPTION': true,\n  'ON DUPLICATE KEY': false,\n  'ORDER NULLS': true,\n  returnValues: {\n    returning: true\n  },\n  bulkDefault: true,\n  schemas: true,\n  lock: true,\n  lockOf: true,\n  lockKey: true,\n  lockOuterJoinFailure: true,\n  skipLocked: true,\n  forShare: 'FOR SHARE',\n  index: {\n    concurrently: true,\n    using: 2,\n    where: true,\n    functionBased: true\n  },\n  inserts: {\n    onConflictDoNothing: ' ON CONFLICT DO NOTHING',\n    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'\n  },\n  NUMERIC: true,\n  ARRAY: true,\n  RANGE: true,\n  GEOMETRY: true,\n  REGEXP: true,\n  GEOGRAPHY: true,\n  JSON: true,\n  JSONB: true,\n  HSTORE: true,\n  deferrableConstraints: true,\n  searchPath: true\n});\n\nConnectionManager.prototype.defaultVersion = '9.4.0';\nPostgresDialect.prototype.Query = Query;\nPostgresDialect.prototype.DataTypes = DataTypes;\nPostgresDialect.prototype.name = 'postgres';\nPostgresDialect.prototype.TICK_CHAR = '\"';\nPostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;\nPostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;\n\nmodule.exports = PostgresDialect;\nmodule.exports.default = PostgresDialect;\nmodule.exports.PostgresDialect = PostgresDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1170,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1171,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1172,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1173,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1174,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1175,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1176,
    "kind": "class",
    "name": "PostgresDialect",
    "memberof": "lib/dialects/postgres/index.js",
    "static": true,
    "longname": "lib/dialects/postgres/index.js~PostgresDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 1177,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/postgres/index.js~PostgresDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/index.js~PostgresDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1178,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/postgres/index.js~PostgresDialect",
    "static": false,
    "longname": "lib/dialects/postgres/index.js~PostgresDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1179,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/postgres/index.js~PostgresDialect",
    "static": false,
    "longname": "lib/dialects/postgres/index.js~PostgresDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1180,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/postgres/index.js~PostgresDialect",
    "static": false,
    "longname": "lib/dialects/postgres/index.js~PostgresDialect#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1181,
    "kind": "file",
    "name": "lib/dialects/postgres/query-generator.js",
    "content": "'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst semver = require('semver');\nconst _ = require('lodash');\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      encoding: null,\n      collate: null\n    }, options || {});\n\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''\n    };\n\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({}, options || {});\n\n    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  }\n\n  describeTableQuery(tableName, schema) {\n    if (!schema) schema = 'public';\n\n    return 'SELECT ' +\n      'pk.constraint_type as \"Constraint\",' +\n      'c.column_name as \"Field\", ' +\n      'c.column_default as \"Default\",' +\n      'c.is_nullable as \"Null\", ' +\n      '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' +\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", ' +\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" ' +\n      'FROM information_schema.columns c ' +\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +\n      'cu.column_name, tc.constraint_type ' +\n      'FROM information_schema.TABLE_CONSTRAINTS tc ' +\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +\n      'and tc.constraint_name=cu.constraint_name ' +\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' +\n      'ON pk.table_schema=c.table_schema ' +\n      'AND pk.table_name=c.table_name ' +\n      'AND pk.column_name=c.column_name ' +\n      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://www.postgresql.org/docs/current/static/functions-json.html\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the postgres json syntax\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n\n    const dbDataType = this.attributeToSQL(dataType, { context: 'addColumn', table, key });\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType.type && dataType.type instanceof DataTypes.ENUM || dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  exceptionFn(fnName, tableName, parameters, main, then, when, returns, language) {\n    when = when || 'unique_violation';\n\n    const body = `${main} EXCEPTION WHEN ${when} THEN ${then};`;\n\n    return this.fn(fnName, tableName, parameters, body, returns, language);\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const primaryField = this.quoteIdentifier(model.primaryKeyField);\n\n    const upsertOptions = _.defaults({ bindParam: false }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    if (options.returning) {\n      const returningRegex = /RETURNING \\*(?![\\s\\S]*RETURNING \\*)/;\n\n      insert.query = insert.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n      update.query = update.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n    }\n\n    return this.exceptionFn(\n      'sequelize_upsert',\n      tableName,\n      'OUT created boolean, OUT primary_key text',\n      `${insert.query} created := true;`,\n      `${update.query}; created := false`\n    );\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? ' RESTART IDENTITY' : '',\n      options.cascade ? ' CASCADE' : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = _.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n    if (typeof tableName !== 'string') {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    // This is ARCANE!\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +\n      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +\n      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +\n      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  }\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      'from INFORMATION_SCHEMA.table_constraints',\n      `WHERE table_name='${tableName}';`\n    ].join(' ');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM ||\n      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.model || typeof attribute.references.model == 'string')\n        && options.table\n        && options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (attribute.references.key) {\n        referencesKey = this.quoteIdentifiers(attribute.references.key);\n      } else {\n        referencesKey = this.quoteIdentifier('id');\n      }\n\n      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n      if (attribute.onDelete) {\n        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n\n      if (attribute.references.deferrable) {\n        sql += ` ${attribute.references.deferrable.toString(this)}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, Object.assign({ key }, options || {}));\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this.expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${\n      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n\n    const paramList = this.expandFunctionParamList(params);\n    const variableList = options && options.variables ? this.expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName');\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this.expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this.expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  databaseConnectionUri(config) {\n    let uri = `${config.protocol}://${config.user}:${config.password}@${config.host}`;\n    if (config.port) {\n      uri += `:${config.port}`;\n    }\n    uri += `/${config.database}`;\n    if (config.ssl) {\n      uri += `?ssl=${config.ssl}`;\n    }\n    return uri;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) { paramDef.push(curParam.direction); }\n        if (curParam.name) { paramDef.push(curParam.name); }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n\n    });\n\n    return paramList.join(', ');\n  }\n\n  expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error('expandFunctionVariableList: function variables must be an array');\n    }\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || _.isEmpty(options) ?\n      '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE') {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(', ')}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n\n    // pgListEnums requires the enum name only, without the schema\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/g, ''));\n\n    return matches.slice(0, -1);\n  }\n\n  padInt(i) {\n    return i < 10 ? `0${i.toString()}` : i.toString();\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +\n      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  /**\n   * Generate common SQL prefix for getForeignKeyReferencesQuery.\n   *\n   * @returns {string}\n   */\n  _getForeignKeyReferencesQueryPrefix() {\n    return 'SELECT ' +\n      'DISTINCT tc.constraint_name as constraint_name, ' +\n      'tc.constraint_schema as constraint_schema, ' +\n      'tc.constraint_catalog as constraint_catalog, ' +\n      'tc.table_name as table_name,' +\n      'tc.table_schema as table_schema,' +\n      'tc.table_catalog as table_catalog,' +\n      'kcu.column_name as column_name,' +\n      'ccu.table_schema  AS referenced_table_schema,' +\n      'ccu.table_catalog  AS referenced_table_catalog,' +\n      'ccu.table_name  AS referenced_table_name,' +\n      'ccu.column_name AS referenced_column_name ' +\n      'FROM information_schema.table_constraints AS tc ' +\n      'JOIN information_schema.key_column_usage AS kcu ' +\n      'ON tc.constraint_name = kcu.constraint_name ' +\n      'JOIN information_schema.constraint_column_usage AS ccu ' +\n      'ON ccu.constraint_name = tc.constraint_name ';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.\n   *\n   * @param {string} tableName\n   * @param {string} catalogName\n   * @param {string} schemaName\n   */\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${\n      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''\n    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${\n      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\nmodule.exports = PostgresQueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1182,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1183,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1184,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1185,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1186,
    "kind": "variable",
    "name": "semver",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~semver",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1187,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1188,
    "kind": "class",
    "name": "PostgresQueryGenerator",
    "memberof": "lib/dialects/postgres/query-generator.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 1189,
    "kind": "method",
    "name": "setSearchPath",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#setSearchPath",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "searchPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1190,
    "kind": "method",
    "name": "createDatabaseQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#createDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1191,
    "kind": "method",
    "name": "dropDatabaseQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1192,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1193,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1194,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1195,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1196,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1197,
    "kind": "method",
    "name": "dropTableQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1198,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1199,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1200,
    "kind": "method",
    "name": "_checkValidJsonStatement",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#_checkValidJsonStatement",
    "access": "private",
    "description": "Check whether the statmement is json function or simple path",
    "lineNumber": 153,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}       true if the given statement is json function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "stmt",
        "description": "The statement to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given statement is json function"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "throw if the statement looks like json function but has invalid token"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1201,
    "kind": "method",
    "name": "handleSequelizeMethod",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#handleSequelizeMethod",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "smth",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1202,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1203,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1204,
    "kind": "method",
    "name": "changeColumnQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#changeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1205,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 315,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1206,
    "kind": "method",
    "name": "fn",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#fn",
    "access": "public",
    "description": null,
    "lineNumber": 326,
    "undocument": true,
    "params": [
      {
        "name": "fnName",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      },
      {
        "name": "body",
        "types": [
          "*"
        ]
      },
      {
        "name": "returns",
        "types": [
          "*"
        ]
      },
      {
        "name": "language",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1207,
    "kind": "method",
    "name": "exceptionFn",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#exceptionFn",
    "access": "public",
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "params": [
      {
        "name": "fnName",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      },
      {
        "name": "main",
        "types": [
          "*"
        ]
      },
      {
        "name": "then",
        "types": [
          "*"
        ]
      },
      {
        "name": "when",
        "types": [
          "*"
        ]
      },
      {
        "name": "returns",
        "types": [
          "*"
        ]
      },
      {
        "name": "language",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1208,
    "kind": "method",
    "name": "upsertQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#upsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1209,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 366,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1210,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 374,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1211,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 400,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1212,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 418,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1213,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 435,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1214,
    "kind": "method",
    "name": "addLimitAndOffset",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#addLimitAndOffset",
    "access": "public",
    "description": null,
    "lineNumber": 445,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1215,
    "kind": "method",
    "name": "attributeToSQL",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#attributeToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 459,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1216,
    "kind": "method",
    "name": "deferConstraintsQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#deferConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 579,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1217,
    "kind": "method",
    "name": "setConstraintQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#setConstraintQuery",
    "access": "public",
    "description": null,
    "lineNumber": 583,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1218,
    "kind": "method",
    "name": "setDeferredQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#setDeferredQuery",
    "access": "public",
    "description": null,
    "lineNumber": 593,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1219,
    "kind": "method",
    "name": "setImmediateQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#setImmediateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 597,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1220,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 601,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1221,
    "kind": "method",
    "name": "createTrigger",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#createTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 612,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "eventType",
        "types": [
          "*"
        ]
      },
      {
        "name": "fireOnSpec",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionParams",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1222,
    "kind": "method",
    "name": "dropTrigger",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 622,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1223,
    "kind": "method",
    "name": "renameTrigger",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#renameTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 626,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "oldTriggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "newTriggerName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1224,
    "kind": "method",
    "name": "createFunction",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#createFunction",
    "access": "public",
    "description": null,
    "lineNumber": 630,
    "undocument": true,
    "params": [
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "returnType",
        "types": [
          "*"
        ]
      },
      {
        "name": "language",
        "types": [
          "*"
        ]
      },
      {
        "name": "body",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1225,
    "kind": "method",
    "name": "dropFunction",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropFunction",
    "access": "public",
    "description": null,
    "lineNumber": 642,
    "undocument": true,
    "params": [
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1226,
    "kind": "method",
    "name": "renameFunction",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#renameFunction",
    "access": "public",
    "description": null,
    "lineNumber": 649,
    "undocument": true,
    "params": [
      {
        "name": "oldFunctionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "newFunctionName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1227,
    "kind": "method",
    "name": "databaseConnectionUri",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#databaseConnectionUri",
    "access": "public",
    "description": null,
    "lineNumber": 654,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1228,
    "kind": "method",
    "name": "pgEscapeAndQuote",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgEscapeAndQuote",
    "access": "public",
    "description": null,
    "lineNumber": 666,
    "undocument": true,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1229,
    "kind": "method",
    "name": "expandFunctionParamList",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#expandFunctionParamList",
    "access": "public",
    "description": null,
    "lineNumber": 670,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1230,
    "kind": "method",
    "name": "expandFunctionVariableList",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#expandFunctionVariableList",
    "access": "public",
    "description": null,
    "lineNumber": 694,
    "undocument": true,
    "params": [
      {
        "name": "variables",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1231,
    "kind": "method",
    "name": "expandOptions",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#expandOptions",
    "access": "public",
    "description": null,
    "lineNumber": 713,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1232,
    "kind": "method",
    "name": "decodeTriggerEventType",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#decodeTriggerEventType",
    "access": "public",
    "description": null,
    "lineNumber": 718,
    "undocument": true,
    "params": [
      {
        "name": "eventSpecifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1233,
    "kind": "method",
    "name": "triggerEventTypeIsConstraint",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#triggerEventTypeIsConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 733,
    "undocument": true,
    "params": [
      {
        "name": "eventSpecifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1234,
    "kind": "method",
    "name": "expandTriggerEventSpec",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#expandTriggerEventSpec",
    "access": "public",
    "description": null,
    "lineNumber": 737,
    "undocument": true,
    "params": [
      {
        "name": "fireOnSpec",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1235,
    "kind": "method",
    "name": "pgEnumName",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgEnumName",
    "access": "public",
    "description": null,
    "lineNumber": 765,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1236,
    "kind": "method",
    "name": "pgListEnums",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgListEnums",
    "access": "public",
    "description": null,
    "lineNumber": 779,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1237,
    "kind": "method",
    "name": "pgEnum",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgEnum",
    "access": "public",
    "description": null,
    "lineNumber": 793,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1238,
    "kind": "method",
    "name": "pgEnumAdd",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgEnumAdd",
    "access": "public",
    "description": null,
    "lineNumber": 810,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1239,
    "kind": "method",
    "name": "pgEnumDrop",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#pgEnumDrop",
    "access": "public",
    "description": null,
    "lineNumber": 828,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "enumName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1240,
    "kind": "method",
    "name": "fromArray",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#fromArray",
    "access": "public",
    "description": null,
    "lineNumber": 833,
    "undocument": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1241,
    "kind": "method",
    "name": "padInt",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#padInt",
    "access": "public",
    "description": null,
    "lineNumber": 846,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1242,
    "kind": "method",
    "name": "dataTypeMapping",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dataTypeMapping",
    "access": "public",
    "description": null,
    "lineNumber": 850,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1243,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#getForeignKeysQuery",
    "access": "private",
    "description": "Generates an SQL query that returns all foreign keys of a table.",
    "lineNumber": 882,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1244,
    "kind": "method",
    "name": "_getForeignKeyReferencesQueryPrefix",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#_getForeignKeyReferencesQueryPrefix",
    "access": "private",
    "description": "Generate common SQL prefix for getForeignKeyReferencesQuery.",
    "lineNumber": 892,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1245,
    "kind": "method",
    "name": "getForeignKeyReferencesQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#getForeignKeyReferencesQuery",
    "access": "public",
    "description": "Generates an SQL query that returns all foreign keys details of a table.\n\nAs for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.",
    "lineNumber": 921,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "catalogName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schemaName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1246,
    "kind": "method",
    "name": "getForeignKeyReferenceQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#getForeignKeyReferenceQuery",
    "access": "public",
    "description": null,
    "lineNumber": 928,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1247,
    "kind": "method",
    "name": "dropForeignKeyQuery",
    "memberof": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query-generator.js~PostgresQueryGenerator#dropForeignKeyQuery",
    "access": "private",
    "description": "Generates an SQL query that removes a foreign key from a table.",
    "lineNumber": 944,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "foreignKey",
        "description": "The name of the foreign key constraint."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1248,
    "kind": "file",
    "name": "lib/dialects/postgres/query-interface.js",
    "content": "'use strict';\n\nconst DataTypes = require('../../data-types');\nconst Promise = require('../../promise');\nconst QueryTypes = require('../../query-types');\nconst _ = require('lodash');\n\n\n/**\n Returns an object that handles Postgres special needs to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n   * Ensure enum and their values.\n   *\n   * @param {QueryInterface} qi\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of normalized table attributes\n   * @param {Object} [options]\n   * @param {Model}  [model]\n   *\n   * @returns {Promise}\n   * @private\n   */\nfunction ensureEnums(qi, tableName, attributes, options, model) {\n  const keys = Object.keys(attributes);\n  const keyLen = keys.length;\n\n  let sql = '';\n  let promises = [];\n  let i = 0;\n\n  for (i = 0; i < keyLen; i++) {\n    const attribute = attributes[keys[i]];\n    const type = attribute.type;\n\n    if (\n      type instanceof DataTypes.ENUM ||\n      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n    ) {\n      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n      promises.push(qi.sequelize.query(\n        sql,\n        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })\n      ));\n    }\n  }\n\n  return Promise.all(promises).then(results => {\n    promises = [];\n    let enumIdx = 0;\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = _.clone(options);\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(\n          tableName, field, value, valueOptions\n        ), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        // If the enum type doesn't exist then create it\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n\n          // Going through already existing values allows us to make queries that depend on those values\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n          // Then we append the rest of new values AFTER the latest already existing value\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            // we go in reverse order so we could stop when we meet old value\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n            }\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    return promises\n      .reduce((promise, asyncFunction) => promise.then(asyncFunction), Promise.resolve())\n      .tap(() => {\n        // If ENUM processed, then refresh OIDs\n        if (promises.length) {\n          return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n        }\n      });\n  });\n}\n\n\nexports.ensureEnums = ensureEnums;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1249,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/postgres/query-interface.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-interface.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1250,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/postgres/query-interface.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-interface.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1251,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/postgres/query-interface.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1252,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/query-interface.js",
    "static": true,
    "longname": "lib/dialects/postgres/query-interface.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1253,
    "kind": "function",
    "name": "ensureEnums",
    "memberof": "lib/dialects/postgres/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/query-interface.js~ensureEnums",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query-interface.js",
    "importStyle": null,
    "description": "Ensure enum and their values.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Name of table to create"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "Object representing a list of normalized table attributes"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "model",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1254,
    "kind": "file",
    "name": "lib/dialects/postgres/query.js",
    "content": "'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors');\nconst _ = require('lodash');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:pg');\n\n\nclass Query extends AbstractQuery {\n  /**\n   * Rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|Object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    const stringReplaceFunc = value => typeof value === 'string' ? value.replace(/\\0/g, '\\\\0') : value;\n\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = values.map(stringReplaceFunc);\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = [];\n      let i = 0;\n      const seen = {};\n      const replacementFunc = (match, key, values) => {\n        if (seen[key] !== undefined) {\n          return seen[key];\n        }\n        if (values[key] !== undefined) {\n          i = i + 1;\n          bindParam.push(stringReplaceFunc(values[key]));\n          seen[key] = `$${i}`;\n          return `$${i}`;\n        }\n        return undefined;\n      };\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n    return [sql, bindParam];\n  }\n\n  run(sql, parameters) {\n    const { connection } = this;\n\n    if (!_.isEmpty(this.options.searchPath)) {\n      sql = this.sequelize.getQueryInterface().QueryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n    this.sql = sql;\n\n    const query = parameters && parameters.length\n      ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result)))\n      : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return query.catch(err => {\n      // set the client so that it will be reaped if the connection resets while executing\n      if (err.code === 'ECONNRESET') {\n        connection._invalid = true;\n      }\n\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err);\n    })\n      .then(queryResult => {\n        complete();\n\n        let rows = Array.isArray(queryResult)\n          ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), [])\n          : queryResult.rows;\n        const rowCount = Array.isArray(queryResult)\n          ? queryResult.reduce(\n            (count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count,\n            0\n          )\n          : queryResult.rowCount;\n\n        if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {\n          rows = rows\n            .map(row => _.toPairs(row)\n              .reduce((acc, [key, value]) => {\n                const mapping = this.options.aliasesMapping.get(key);\n                acc[mapping || key] = value;\n                return acc;\n              }, {})\n            );\n        }\n\n        const isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');\n        const isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');\n\n        if (isRelNameQuery) {\n          return rows.map(row => ({\n            name: row.relname,\n            tableName: row.relname.split('_')[0]\n          }));\n        }\n        if (isTableNameQuery) {\n          return rows.map(row => _.values(row));\n        }\n\n        if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {\n          if (rows[0].sequelize_caught_exception !== null) {\n            throw this.formatError({\n              code: '23505',\n              detail: rows[0].sequelize_caught_exception\n            });\n          }\n          for (const row of rows) {\n            delete row.sequelize_caught_exception;\n          }\n        }\n\n        if (this.isShowIndexesQuery()) {\n          for (const row of rows) {\n            const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(',');\n\n            // Map column index in table to column name\n            const columns = _.zipObject(\n              row.column_indexes,\n              this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.column_names)\n            );\n            delete row.column_indexes;\n            delete row.column_names;\n\n            let field;\n            let attribute;\n\n            // Indkey is the order of attributes in the index, specified by a string of attribute indexes\n            row.fields = row.indkey.split(' ').map((indKey, index) => {\n              field = columns[indKey];\n              // for functional indices indKey = 0\n              if (!field) {\n                return null;\n              }\n              attribute = attributes[index];\n              return {\n                attribute: field,\n                collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : undefined,\n                order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,\n                length: undefined\n              };\n            }).filter(n => n !== null);\n            delete row.columns;\n          }\n          return rows;\n        }\n        if (this.isForeignKeysQuery()) {\n          const result = [];\n          for (const row of rows) {\n            let defParts;\n            if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n              row.id = row.constraint_name;\n              row.table = defParts[2];\n              row.from = defParts[1];\n              row.to = defParts[3];\n              let i;\n              for (i = 5; i <= 8; i += 3) {\n                if (/(UPDATE|DELETE)/.test(defParts[i])) {\n                  row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];\n                }\n              }\n            }\n            result.push(row);\n          }\n          return result;\n        }\n        if (this.isSelectQuery()) {\n          let result = rows;\n          // Postgres will treat tables as case-insensitive, so fix the case\n          // of the returned values to match attributes\n          if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n            const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n              m[k.toLowerCase()] = k;\n              return m;\n            }, {});\n            result = rows.map(row => {\n              return _.mapKeys(row, (value, key) => {\n                const targetAttr = attrsMap[key];\n                if (typeof targetAttr === 'string' && targetAttr !== key) {\n                  return targetAttr;\n                }\n                return key;\n              });\n            });\n          }\n          return this.handleSelectQuery(result);\n        }\n        if (QueryTypes.DESCRIBE === this.options.type) {\n          const result = {};\n\n          for (const row of rows) {\n            result[row.Field] = {\n              type: row.Type.toUpperCase(),\n              allowNull: row.Null === 'YES',\n              defaultValue: row.Default,\n              comment: row.Comment,\n              special: row.special ? this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.special) : [],\n              primaryKey: row.Constraint === 'PRIMARY KEY'\n            };\n\n            if (result[row.Field].type === 'BOOLEAN') {\n              result[row.Field].defaultValue = { 'false': false, 'true': true }[result[row.Field].defaultValue];\n\n              if (result[row.Field].defaultValue === undefined) {\n                result[row.Field].defaultValue = null;\n              }\n            }\n\n            if (typeof result[row.Field].defaultValue === 'string') {\n              result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');\n\n              if (result[row.Field].defaultValue.includes('::')) {\n                const split = result[row.Field].defaultValue.split('::');\n                if (split[1].toLowerCase() !== 'regclass)') {\n                  result[row.Field].defaultValue = split[0];\n                }\n              }\n            }\n          }\n\n          return result;\n        }\n        if (this.isVersionQuery()) {\n          return rows[0].server_version;\n        }\n        if (this.isShowOrDescribeQuery()) {\n          return rows;\n        }\n        if (QueryTypes.BULKUPDATE === this.options.type) {\n          if (!this.options.returning) {\n            return parseInt(rowCount, 10);\n          }\n          return this.handleSelectQuery(rows);\n        }\n        if (QueryTypes.BULKDELETE === this.options.type) {\n          return parseInt(rowCount, 10);\n        }\n        if (this.isUpsertQuery()) {\n          return rows[0];\n        }\n        if (this.isInsertQuery() || this.isUpdateQuery()) {\n          if (this.instance && this.instance.dataValues) {\n            for (const key in rows[0]) {\n              if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n                const record = rows[0][key];\n\n                const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n                this.instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            }\n          }\n\n          return [\n            this.instance || rows && (this.options.plain && rows[0] || rows) || undefined,\n            rowCount\n          ];\n        }\n        if (this.isRawQuery()) {\n          return [rows, queryResult];\n        }\n        return rows;\n      });\n  }\n\n  formatError(err) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n\n    switch (code) {\n      case '23503':\n        index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n        index = index ? index[1] : undefined;\n        table = errMessage.match(/on table \"(.+?)\"/);\n        table = table ? table[1] : undefined;\n\n        return new sequelizeErrors.ForeignKeyConstraintError({ message: errMessage, fields: null, index, table, parent: err });\n      case '23505':\n        // there are multiple different formats of error messages for this error code\n        // this regex should check at least two\n        if (errDetail && (match = errDetail.replace(/\"/g, '').match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n          errors = [];\n          message = 'Validation error';\n\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n              field,\n              value,\n              this.instance,\n              'not_unique'\n            ));\n          });\n\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err\n        });\n\n      case '23P01':\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n\n        if (match) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n        }\n        message = 'Exclusion constraint error';\n\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err\n        });\n\n      case '42704':\n        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n          message = 'Unknown constraint error';\n          index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n          index = index ? index[1] : undefined;\n          table = errMessage.match(/relation \"(.+?)\"/i);\n          table = table ? table[1] : undefined;\n\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: index,\n            fields,\n            table,\n            parent: err\n          });\n        }\n      // falls through\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n}\n\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1255,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1256,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1257,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1258,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1259,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1260,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1261,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1262,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/postgres/query.js",
    "static": true,
    "longname": "lib/dialects/postgres/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 1263,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/query.js~Query.formatBindParameters",
    "access": "private",
    "description": "Rewrite query with parameters.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dialect",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1264,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1265,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "static": false,
    "longname": "lib/dialects/postgres/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1266,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 276,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1267,
    "kind": "method",
    "name": "isForeignKeysQuery",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query.js~Query#isForeignKeysQuery",
    "access": "public",
    "description": null,
    "lineNumber": 370,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1268,
    "kind": "method",
    "name": "getInsertIdField",
    "memberof": "lib/dialects/postgres/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/postgres/query.js~Query#getInsertIdField",
    "access": "public",
    "description": null,
    "lineNumber": 374,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1269,
    "kind": "file",
    "name": "lib/dialects/postgres/range.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === 'infinity') {\n    return Infinity;\n  }\n  if (bound === '-infinity') {\n    return -Infinity;\n  }\n  return parseType(bound);\n\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!Array.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    return [];\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'\n    };\n  });\n\n  return result;\n}\nexports.parse = parse;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/postgres/range.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1270,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/postgres/range.js",
    "static": true,
    "longname": "lib/dialects/postgres/range.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/range.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1271,
    "kind": "function",
    "name": "stringifyRangeBound",
    "memberof": "lib/dialects/postgres/range.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/range.js~stringifyRangeBound",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/range.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "bound",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1272,
    "kind": "function",
    "name": "parseRangeBound",
    "memberof": "lib/dialects/postgres/range.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/range.js~parseRangeBound",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/range.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "bound",
        "types": [
          "*"
        ]
      },
      {
        "name": "parseType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1273,
    "kind": "function",
    "name": "stringify",
    "memberof": "lib/dialects/postgres/range.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/range.js~stringify",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/range.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1274,
    "kind": "function",
    "name": "parse",
    "memberof": "lib/dialects/postgres/range.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/postgres/range.js~parse",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/postgres/range.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "parser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1275,
    "kind": "file",
    "name": "lib/dialects/snowflake/connection-manager.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst SequelizeErrors = require(\"../../errors\");\nconst { logger } = require(\"../../utils/logger\");\nconst DataTypes = require(\"../../data-types\").snowflake;\nconst debug = logger.debugContext(\"connection:snowflake\");\nconst parserStore = require(\"../parserStore\")(\"snowflake\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      connection.destroy((err) => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n  validate(connection) {\n    return connection.isUp();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1276,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1277,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1278,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1279,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1280,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1281,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1282,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1283,
    "kind": "variable",
    "name": "SequelizeErrors",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~SequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1284,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1285,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1286,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1287,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1288,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/snowflake/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractConnectionManager"
    ],
    "ignore": true
  },
  {
    "__docId__": 1289,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1290,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1291,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1292,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1293,
    "kind": "method",
    "name": "_typecast",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager._typecast",
    "access": "private",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "next",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1294,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#connect",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1295,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1296,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/dialects/snowflake/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/connection-manager.js~ConnectionManager#validate",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1297,
    "kind": "file",
    "name": "lib/dialects/snowflake/data-types.js",
    "content": "\"use strict\";\nconst momentTz = require(\"moment-timezone\");\nconst moment = require(\"moment\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.snowflake.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.snowflake = [\"DATETIME\"];\n  BaseTypes.STRING.types.snowflake = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.snowflake = [\"STRING\"];\n  BaseTypes.TEXT.types.snowflake = [\"BLOB\"];\n  BaseTypes.TINYINT.types.snowflake = [\"TINY\"];\n  BaseTypes.SMALLINT.types.snowflake = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.snowflake = [\"INT24\"];\n  BaseTypes.INTEGER.types.snowflake = [\"LONG\"];\n  BaseTypes.BIGINT.types.snowflake = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.snowflake = [\"FLOAT\"];\n  BaseTypes.TIME.types.snowflake = [\"TIME\"];\n  BaseTypes.DATEONLY.types.snowflake = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.snowflake = [\"TINY\"];\n  BaseTypes.BLOB.types.snowflake = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.snowflake = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.snowflake = false;\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.snowflake = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.snowflake = [\"JSON\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR(36)\";\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1298,
    "kind": "variable",
    "name": "momentTz",
    "memberof": "lib/dialects/snowflake/data-types.js",
    "static": true,
    "longname": "lib/dialects/snowflake/data-types.js~momentTz",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1299,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/dialects/snowflake/data-types.js",
    "static": true,
    "longname": "lib/dialects/snowflake/data-types.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/data-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1300,
    "kind": "file",
    "name": "lib/dialects/snowflake/index.js",
    "content": "\"use strict\";\nconst _ = require(\"lodash\");\nconst AbstractDialect = require(\"../abstract\");\nconst ConnectionManager = require(\"./connection-manager\");\nconst Query = require(\"./query\");\nconst QueryGenerator = require(\"./query-generator\");\nconst DataTypes = require(\"../../data-types\").snowflake;\nconst { SnowflakeQueryInterface } = require(\"./query-interface\");\nclass SnowflakeDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SnowflakeQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSnowflakeDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: false\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: false,\n  JSON: false,\n  REGEXP: true,\n  schemas: true\n});\nSnowflakeDialect.prototype.defaultVersion = \"5.7.0\";\nSnowflakeDialect.prototype.Query = Query;\nSnowflakeDialect.prototype.QueryGenerator = QueryGenerator;\nSnowflakeDialect.prototype.DataTypes = DataTypes;\nSnowflakeDialect.prototype.name = \"snowflake\";\nSnowflakeDialect.prototype.TICK_CHAR = '\"';\nSnowflakeDialect.prototype.TICK_CHAR_LEFT = SnowflakeDialect.prototype.TICK_CHAR;\nSnowflakeDialect.prototype.TICK_CHAR_RIGHT = SnowflakeDialect.prototype.TICK_CHAR;\nmodule.exports = SnowflakeDialect;\n//# sourceMappingURL=index.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1301,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1302,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1303,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1304,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1305,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1306,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1307,
    "kind": "variable",
    "name": "SnowflakeQueryInterface",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1308,
    "kind": "class",
    "name": "SnowflakeDialect",
    "memberof": "lib/dialects/snowflake/index.js",
    "static": true,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 1309,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1310,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "static": false,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1311,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "static": false,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1312,
    "kind": "member",
    "name": "queryGenerator",
    "memberof": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "static": false,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect#queryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1313,
    "kind": "member",
    "name": "queryInterface",
    "memberof": "lib/dialects/snowflake/index.js~SnowflakeDialect",
    "static": false,
    "longname": "lib/dialects/snowflake/index.js~SnowflakeDialect#queryInterface",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1314,
    "kind": "file",
    "name": "lib/dialects/snowflake/query-generator.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst util = require(\"util\");\nconst Op = require(\"../../operators\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\",\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"ALTER COLUMN\",\n      ...subQuerys,\n      \";\"\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n      sql.push(attrSql.join(\"\"));\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"RENAME COLUMN\",\n      attrString.join(\" to \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (attr.path) {\n        let str;\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"TRUNCATE\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\n        \"DELETE FROM\",\n        table,\n        \"WHERE\",\n        primaryKeys,\n        \"IN (SELECT\",\n        primaryKeysSelection,\n        \"FROM\",\n        table,\n        whereClause,\n        limit,\n        \")\",\n        \";\"\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"DELETE FROM\",\n      table,\n      whereClause,\n      \";\"\n    ]);\n  }\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName),\n      \";\"\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n    return fragment.join(\"\");\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1315,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1316,
    "kind": "variable",
    "name": "__defProps",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__defProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1317,
    "kind": "variable",
    "name": "__getOwnPropDescs",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__getOwnPropDescs",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1318,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1319,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1320,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1321,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1322,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1323,
    "kind": "function",
    "name": "__spreadProps",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~__spreadProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1324,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1325,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1326,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1327,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1328,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1329,
    "kind": "variable",
    "name": "JSON_FUNCTION_REGEX",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~JSON_FUNCTION_REGEX",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1330,
    "kind": "variable",
    "name": "JSON_OPERATOR_REGEX",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~JSON_OPERATOR_REGEX",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1331,
    "kind": "variable",
    "name": "TOKEN_CAPTURE_REGEX",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~TOKEN_CAPTURE_REGEX",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1332,
    "kind": "variable",
    "name": "FOREIGN_KEY_FIELDS",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~FOREIGN_KEY_FIELDS",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1333,
    "kind": "variable",
    "name": "SNOWFLAKE_RESERVED_WORDS",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~SNOWFLAKE_RESERVED_WORDS",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1334,
    "kind": "variable",
    "name": "typeWithoutDefault",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~typeWithoutDefault",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1335,
    "kind": "class",
    "name": "SnowflakeQueryGenerator",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 1336,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1337,
    "kind": "member",
    "name": "OperatorMap",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#OperatorMap",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1338,
    "kind": "method",
    "name": "createDatabaseQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#createDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1339,
    "kind": "method",
    "name": "dropDatabaseQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#dropDatabaseQuery",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "databaseName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1340,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1341,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1342,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1343,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1344,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaDelimiter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1345,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1346,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1347,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1348,
    "kind": "method",
    "name": "changeColumnQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#changeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1349,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1350,
    "kind": "method",
    "name": "handleSequelizeMethod",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#handleSequelizeMethod",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1351,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1352,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 269,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1353,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 307,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1354,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 310,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1355,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 327,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1356,
    "kind": "method",
    "name": "attributeToSQL",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#attributeToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 340,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1357,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 393,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1358,
    "kind": "method",
    "name": "_checkValidJsonStatement",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#_checkValidJsonStatement",
    "access": "private",
    "description": null,
    "lineNumber": 401,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "stmt",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1359,
    "kind": "method",
    "name": "dataTypeMapping",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#dataTypeMapping",
    "access": "public",
    "description": null,
    "lineNumber": 445,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1360,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#getForeignKeysQuery",
    "access": "public",
    "description": null,
    "lineNumber": 463,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1361,
    "kind": "method",
    "name": "getForeignKeyQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#getForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 474,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1362,
    "kind": "method",
    "name": "dropForeignKeyQuery",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#dropForeignKeyQuery",
    "access": "public",
    "description": null,
    "lineNumber": 498,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "foreignKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1363,
    "kind": "method",
    "name": "addLimitAndOffset",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#addLimitAndOffset",
    "access": "public",
    "description": null,
    "lineNumber": 507,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1364,
    "kind": "method",
    "name": "quoteIdentifier",
    "memberof": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query-generator.js~SnowflakeQueryGenerator#quoteIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "force",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1365,
    "kind": "function",
    "name": "wrapSingleQuote",
    "memberof": "lib/dialects/snowflake/query-generator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-generator.js~wrapSingleQuote",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 526,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1366,
    "kind": "file",
    "name": "lib/dialects/snowflake/query-interface.js",
    "content": "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = require(\"../../errors\");\nconst { QueryInterface } = require(\"../abstract/query-interface\");\nconst QueryTypes = require(\"../../query-types\");\nclass SnowflakeQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.SnowflakeQueryInterface = SnowflakeQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1367,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1368,
    "kind": "variable",
    "name": "__defProps",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__defProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1369,
    "kind": "variable",
    "name": "__getOwnPropDescs",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__getOwnPropDescs",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1370,
    "kind": "variable",
    "name": "__getOwnPropSymbols",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__getOwnPropSymbols",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1371,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1372,
    "kind": "variable",
    "name": "__propIsEnum",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__propIsEnum",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1373,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1374,
    "kind": "function",
    "name": "__spreadValues",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__spreadValues",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1375,
    "kind": "function",
    "name": "__spreadProps",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~__spreadProps",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1376,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1377,
    "kind": "variable",
    "name": "QueryInterface",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1378,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1379,
    "kind": "class",
    "name": "SnowflakeQueryInterface",
    "memberof": "lib/dialects/snowflake/query-interface.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "QueryInterface"
    ],
    "ignore": true
  },
  {
    "__docId__": 1380,
    "kind": "method",
    "name": "removeColumn",
    "memberof": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface#removeColumn",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1381,
    "kind": "method",
    "name": "upsert",
    "memberof": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface#upsert",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1382,
    "kind": "method",
    "name": "removeConstraint",
    "memberof": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/query-interface.js~SnowflakeQueryInterface#removeConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1383,
    "kind": "file",
    "name": "lib/dialects/snowflake/query.js",
    "content": "\"use strict\";\nconst AbstractQuery = require(\"../abstract/query\");\nconst sequelizeErrors = require(\"../../errors\");\nconst _ = require(\"lodash\");\nconst { logger } = require(\"../../utils/logger\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:snowflake\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (_match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    try {\n      results = await new Promise((resolve, reject) => {\n        connection.execute({\n          sqlText: sql,\n          binds: parameters,\n          complete(err, _stmt, rows) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(rows);\n            }\n          }\n        });\n      });\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const sfAttrMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toUpperCase()] = k;\n          return m;\n        }, {});\n        data = data.map((data2) => _.reduce(data2, (prev, value, key) => {\n          if (value !== void 0 && sfAttrMap[key]) {\n            prev[sfAttrMap[key]] = value;\n            delete prev[key];\n          }\n          return prev;\n        }, data2));\n      }\n      this.options.fieldMap = _.mapKeys(this.options.fieldMap, (v, k) => {\n        return k.toUpperCase();\n      });\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data[0][\"number of rows updated\"];\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `Snowflake Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n//# sourceMappingURL=query.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/snowflake/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1384,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1385,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1386,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1387,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1388,
    "kind": "variable",
    "name": "ER_DUP_ENTRY",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~ER_DUP_ENTRY",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1389,
    "kind": "variable",
    "name": "ER_DEADLOCK",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~ER_DEADLOCK",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1390,
    "kind": "variable",
    "name": "ER_ROW_IS_REFERENCED",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~ER_ROW_IS_REFERENCED",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1391,
    "kind": "variable",
    "name": "ER_NO_REFERENCED_ROW",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~ER_NO_REFERENCED_ROW",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1392,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1393,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/snowflake/query.js",
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/snowflake/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 1394,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/snowflake/query.js~Query.formatBindParameters",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1395,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1396,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1397,
    "kind": "method",
    "name": "formatResults",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#formatResults",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1398,
    "kind": "method",
    "name": "logWarnings",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#logWarnings",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1399,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1400,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/snowflake/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/snowflake/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1401,
    "kind": "file",
    "name": "lib/dialects/sqlite/connection-manager.js",
    "content": "'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3').verbose();\n    this.refreshTypeParser(dataTypes);\n  }\n\n  _onProcessExit() {\n    const promises = Object.getOwnPropertyNames(this.connections)\n      .map(connection => Promise.fromCallback(callback => this.connections[connection].close(callback)));\n\n    return Promise\n      .all(promises)\n      .then(() => super._onProcessExit.call(this));\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        this.sequelize.options.storage || this.sequelize.options.host || ':memory:',\n        options.readWriteMode || this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE, // default mode\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    }).tap(connection => {\n      if (this.sequelize.config.password) {\n        // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n        connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n      }\n      if (this.sequelize.options.foreignKeys !== false) {\n        // Make it possible to define and use foreign key constraints unless\n        // explicitly disallowed. It's still opt-in per relation\n        connection.run('PRAGMA FOREIGN_KEYS=ON');\n      }\n    });\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/connection-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1402,
    "kind": "variable",
    "name": "AbstractConnectionManager",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~AbstractConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1403,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1404,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1405,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1406,
    "kind": "variable",
    "name": "dataTypes",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~dataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1407,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1408,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1409,
    "kind": "class",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/sqlite/connection-manager.js",
    "static": true,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/connection-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractConnectionManager"
    ],
    "ignore": true
  },
  {
    "__docId__": 1410,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1411,
    "kind": "member",
    "name": "connections",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#connections",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1412,
    "kind": "member",
    "name": "lib",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#lib",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1413,
    "kind": "method",
    "name": "_onProcessExit",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#_onProcessExit",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1414,
    "kind": "method",
    "name": "_refreshTypeParser",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#_refreshTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1415,
    "kind": "method",
    "name": "_clearTypeParser",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#_clearTypeParser",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1416,
    "kind": "method",
    "name": "getConnection",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#getConnection",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1417,
    "kind": "method",
    "name": "releaseConnection",
    "memberof": "lib/dialects/sqlite/connection-manager.js~ConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/connection-manager.js~ConnectionManager#releaseConnection",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      },
      {
        "name": "force",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1418,
    "kind": "file",
    "name": "lib/dialects/sqlite/data-types.js",
    "content": "'use strict';\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');\n\n  /**\n   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {Object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * @see https://sqlite.org/datatype3.html\n   */\n\n  BaseTypes.DATE.types.sqlite = ['DATETIME'];\n  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];\n  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];\n  BaseTypes.TEXT.types.sqlite = ['TEXT'];\n  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];\n  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];\n  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];\n  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];\n  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];\n  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];\n  BaseTypes.TIME.types.sqlite = ['TIME'];\n  BaseTypes.DATEONLY.types.sqlite = ['DATE'];\n  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];\n  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];\n  BaseTypes.UUID.types.sqlite = ['UUID'];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = ['REAL'];\n  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];\n\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes('+')) {\n        // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set\n        return new Date(date + options.timezone);\n      }\n      return new Date(date); // We already have a timezone stored in the string\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n  }\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n      return super.toSql(this);\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return 'TEXT COLLATE NOCASE';\n    }\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n      return super.toSql();\n    }\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n      if (this._unsigned) {\n        result += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        result += ' ZEROFILL';\n      }\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === 'number') {\n          result += `,${this._decimals}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n  }\n\n  class REAL extends BaseTypes.REAL { }\n\n  function parseFloating(value) {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    if (value === 'NaN') {\n      return NaN;\n    }\n    if (value === 'Infinity') {\n      return Infinity;\n    }\n    if (value === '-Infinity') {\n      return -Infinity;\n    }\n  }\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n\n\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'TEXT';\n    }\n  }\n\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/data-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1419,
    "kind": "file",
    "name": "lib/dialects/sqlite/index.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst AbstractDialect = require('../abstract');\nconst ConnectionManager = require('./connection-manager');\nconst Query = require('./query');\nconst QueryGenerator = require('./query-generator');\nconst DataTypes = require('../../data-types').sqlite;\n\nclass SqliteDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.QueryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n  }\n}\n\nSqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  'DEFAULT': false,\n  'DEFAULT VALUES': true,\n  'UNION ALL': false,\n  'RIGHT JOIN': false,\n  inserts: {\n    ignoreDuplicates: ' OR IGNORE',\n    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'\n  },\n  index: {\n    using: false,\n    where: true,\n    functionBased: true\n  },\n  transactionOptions: {\n    type: true\n  },\n  constraints: {\n    addConstraint: false,\n    dropConstraint: false\n  },\n  joinTableDependent: false,\n  groupedLimit: false,\n  JSON: true\n});\n\nConnectionManager.prototype.defaultVersion = '3.8.0';\nSqliteDialect.prototype.Query = Query;\nSqliteDialect.prototype.DataTypes = DataTypes;\nSqliteDialect.prototype.name = 'sqlite';\nSqliteDialect.prototype.TICK_CHAR = '`';\nSqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;\nSqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;\n\nmodule.exports = SqliteDialect;\nmodule.exports.SqliteDialect = SqliteDialect;\nmodule.exports.default = SqliteDialect;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1420,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1421,
    "kind": "variable",
    "name": "AbstractDialect",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~AbstractDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1422,
    "kind": "variable",
    "name": "ConnectionManager",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~ConnectionManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1423,
    "kind": "variable",
    "name": "Query",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1424,
    "kind": "variable",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~QueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1425,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1426,
    "kind": "class",
    "name": "SqliteDialect",
    "memberof": "lib/dialects/sqlite/index.js",
    "static": true,
    "longname": "lib/dialects/sqlite/index.js~SqliteDialect",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractDialect"
    ],
    "ignore": true
  },
  {
    "__docId__": 1427,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/dialects/sqlite/index.js~SqliteDialect",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/index.js~SqliteDialect#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1428,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/dialects/sqlite/index.js~SqliteDialect",
    "static": false,
    "longname": "lib/dialects/sqlite/index.js~SqliteDialect#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1429,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/dialects/sqlite/index.js~SqliteDialect",
    "static": false,
    "longname": "lib/dialects/sqlite/index.js~SqliteDialect#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1430,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/dialects/sqlite/index.js~SqliteDialect",
    "static": false,
    "longname": "lib/dialects/sqlite/index.js~SqliteDialect#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1431,
    "kind": "file",
    "name": "lib/dialects/sqlite/query-generator.js",
    "content": "'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const bind = [];\n    const bindParam = this.bindParam(bind);\n\n    const upsertOptions = _.defaults({ bindParam }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    const query = `${insert.query} ${update.query}`;\n\n    return { query, bind };\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n}\n\nmodule.exports = SQLiteQueryGenerator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/query-generator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1432,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1433,
    "kind": "variable",
    "name": "Transaction",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~Transaction",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1434,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1435,
    "kind": "variable",
    "name": "MySqlQueryGenerator",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~MySqlQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1436,
    "kind": "variable",
    "name": "AbstractQueryGenerator",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~AbstractQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1437,
    "kind": "class",
    "name": "SQLiteQueryGenerator",
    "memberof": "lib/dialects/sqlite/query-generator.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-generator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "MySqlQueryGenerator"
    ],
    "ignore": true
  },
  {
    "__docId__": 1438,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#createSchema",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1439,
    "kind": "method",
    "name": "showSchemasQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#showSchemasQuery",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1440,
    "kind": "method",
    "name": "versionQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#versionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1441,
    "kind": "method",
    "name": "createTableQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#createTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1442,
    "kind": "method",
    "name": "booleanValue",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#booleanValue",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1443,
    "kind": "method",
    "name": "_checkValidJsonStatement",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#_checkValidJsonStatement",
    "access": "private",
    "description": "Check whether the statmement is json function or simple path",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}       true if the given statement is json function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "stmt",
        "description": "The statement to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given statement is json function"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "throw if the statement looks like json function but has invalid token"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1444,
    "kind": "method",
    "name": "_toJSONValue",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#_toJSONValue",
    "access": "private",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1445,
    "kind": "method",
    "name": "handleSequelizeMethod",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#handleSequelizeMethod",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [
      {
        "name": "smth",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "factory",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "prepend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1446,
    "kind": "method",
    "name": "addColumnQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#addColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1447,
    "kind": "method",
    "name": "showTablesQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#showTablesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1448,
    "kind": "method",
    "name": "upsertQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#upsertQuery",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "insertValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "updateValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"query\": *, \"bind\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1449,
    "kind": "method",
    "name": "updateQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#updateQuery",
    "access": "public",
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrValueHash",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"query\": *, \"bind\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1450,
    "kind": "method",
    "name": "truncateTableQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#truncateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 239,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1451,
    "kind": "method",
    "name": "deleteQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#deleteQuery",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1452,
    "kind": "method",
    "name": "attributesToSQL",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#attributesToSQL",
    "access": "public",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1453,
    "kind": "method",
    "name": "showIndexesQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#showIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 326,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1454,
    "kind": "method",
    "name": "showConstraintsQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#showConstraintsQuery",
    "access": "public",
    "description": null,
    "lineNumber": 330,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1455,
    "kind": "method",
    "name": "removeIndexQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#removeIndexQuery",
    "access": "public",
    "description": null,
    "lineNumber": 340,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexNameOrAttributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1456,
    "kind": "method",
    "name": "describeTableQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#describeTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaDelimiter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1457,
    "kind": "method",
    "name": "describeCreateTableQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#describeCreateTableQuery",
    "access": "public",
    "description": null,
    "lineNumber": 359,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1458,
    "kind": "method",
    "name": "removeColumnQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#removeColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 363,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1459,
    "kind": "method",
    "name": "_alterConstraintQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#_alterConstraintQuery",
    "access": "private",
    "description": null,
    "lineNumber": 390,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "createTableSql",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1460,
    "kind": "method",
    "name": "renameColumnQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#renameColumnQuery",
    "access": "public",
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrNameBefore",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrNameAfter",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1461,
    "kind": "method",
    "name": "startTransactionQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#startTransactionQuery",
    "access": "public",
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1462,
    "kind": "method",
    "name": "setIsolationLevelQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#setIsolationLevelQuery",
    "access": "public",
    "description": null,
    "lineNumber": 454,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1463,
    "kind": "method",
    "name": "replaceBooleanDefaults",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#replaceBooleanDefaults",
    "access": "public",
    "description": null,
    "lineNumber": 469,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1464,
    "kind": "method",
    "name": "getForeignKeysQuery",
    "memberof": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query-generator.js~SQLiteQueryGenerator#getForeignKeysQuery",
    "access": "private",
    "description": "Generates an SQL query that returns all foreign keys of a table.",
    "lineNumber": 480,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}            The generated sql query."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated sql query."
    },
    "ignore": true
  },
  {
    "__docId__": 1465,
    "kind": "file",
    "name": "lib/dialects/sqlite/query-interface.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Promise = require('../../promise');\nconst sequelizeErrors = require('../../errors');\nconst QueryTypes = require('../../query-types');\n\n/**\n Returns an object that treats SQLite's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes SQLite's inability to remove columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but without the obsolete column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName     The name of the table.\n  @param  {string} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction removeColumn(qi, tableName, attributeName, options) {\n  options = options || {};\n\n  return qi.describeTable(tableName, options).then(fields => {\n    delete fields[attributeName];\n\n    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));\n  });\n}\nexports.removeColumn = removeColumn;\n\n/**\n  A wrapper that fixes SQLite's inability to change columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a modified version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {Object} attributes An object with the attribute's name as key and its options as value object.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction changeColumn(qi, tableName, attributes, options) {\n  const attributeName = Object.keys(attributes)[0];\n  options = options || {};\n\n  return qi.describeTable(tableName, options).then(fields => {\n    Object.assign(fields[attributeName], attributes[attributeName]);\n\n    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));\n  });\n}\nexports.changeColumn = changeColumn;\n\n/**\n  A wrapper that fixes SQLite's inability to rename columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a renamed version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {string} attrNameBefore The name of the attribute before it was renamed.\n  @param  {string} attrNameAfter The name of the attribute after it was renamed.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\nfunction renameColumn(qi, tableName, attrNameBefore, attrNameAfter, options) {\n  options = options || {};\n\n  return qi.describeTable(tableName, options).then(fields => {\n    fields[attrNameAfter] = _.clone(fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n\n    const sql = qi.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));\n  });\n}\nexports.renameColumn = renameColumn;\n\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {string} constraintName\n * @param {Object} options\n *\n * @private\n */\nfunction removeConstraint(qi, tableName, constraintName, options) {\n  let createTableSql;\n\n  return qi.showConstraint(tableName, constraintName)\n    .then(constraints => {\n      // sqlite can't show only one constraint, so we find here the one to remove\n      const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n      if (constraint) {\n        createTableSql = constraint.sql;\n        constraint.constraintName = qi.QueryGenerator.quoteIdentifier(constraint.constraintName);\n        let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n\n        if (constraint.constraintType === 'FOREIGN KEY') {\n          const referenceTableName = qi.QueryGenerator.quoteTable(constraint.referenceTableName);\n          constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => qi.QueryGenerator.quoteIdentifier(columnName));\n          const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n          constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n          constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n          constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n        }\n\n        createTableSql = createTableSql.replace(constraintSnippet, '');\n        createTableSql += ';';\n\n        return qi.describeTable(tableName, options);\n      }\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    })\n    .then(fields => {\n      const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n      const subQueries = sql.split(';').filter(q => q !== '');\n\n      return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));\n    });\n}\nexports.removeConstraint = removeConstraint;\n\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options\n *\n * @private\n */\nfunction addConstraint(qi, tableName, options) {\n  const constraintSnippet = qi.QueryGenerator.getConstraintSnippet(tableName, options);\n  const describeCreateTableSql = qi.QueryGenerator.describeCreateTableQuery(tableName);\n  let createTableSql;\n\n  return qi.sequelize.query(describeCreateTableSql, Object.assign({}, options, { type: QueryTypes.SELECT, raw: true }))\n    .then(constraints => {\n      const sql = constraints[0].sql;\n      const index = sql.length - 1;\n      //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n      //http://stackoverflow.com/questions/1431094\n      createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n\n      return qi.describeTable(tableName, options);\n    })\n    .then(fields => {\n      const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n      const subQueries = sql.split(';').filter(q => q !== '');\n\n      return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));\n    });\n}\nexports.addConstraint = addConstraint;\n\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options  Query Options\n *\n * @private\n * @returns {Promise}\n */\nfunction getForeignKeyReferencesForTable(qi, tableName, options) {\n  const database = qi.sequelize.config.database;\n  const query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);\n  return qi.sequelize.query(query, options)\n    .then(result => {\n      return result.map(row => ({\n        tableName,\n        columnName: row.from,\n        referencedTableName: row.table,\n        referencedColumnName: row.to,\n        tableCatalog: database,\n        referencedTableCatalog: database\n      }));\n    });\n}\n\nexports.getForeignKeyReferencesForTable = getForeignKeyReferencesForTable;\n\n/**\n * Describe a table structure\n *\n * This method returns an array of hashes containing information about all attributes in the table.\n *\n * ```js\n * {\n *    name: {\n *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n *      allowNull:    true,\n *      defaultValue: null,\n *      unique:       true,           // available for sqlite only\n *      references:   {},             // available for sqlite only\n *    },\n *    isBetaMember: {\n *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n *      allowNull:    false,\n *      defaultValue: false,\n *      unique:       false,        // available for sqlite only\n *      references:   {},           // available for sqlite only\n *    }\n * }\n * ```\n *\n * @param {QueryInterface} qi\n * @param {string} tableName table name\n * @param {Object} [options] Query options\n *\n * @returns {Promise<Object>}\n */\nfunction describeTable(qi, tableName, options) {\n  let schema = null;\n  let schemaDelimiter = null;\n\n  if (typeof options === 'string') {\n    schema = options;\n  } else if (typeof options === 'object' && options !== null) {\n    schema = options.schema || null;\n    schemaDelimiter = options.schemaDelimiter || null;\n  }\n\n  if (typeof tableName === 'object' && tableName !== null) {\n    schema = tableName.schema;\n    tableName = tableName.tableName;\n  }\n\n  const sql = qi.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n  options = Object.assign({}, options, { type: QueryTypes.DESCRIBE });\n\n  return qi.sequelize.query(sql, options).then(data => {\n    /*\n      * If no data is returned from the query, then the table name may be wrong.\n      * Query generators that use information_schema for retrieving table info will just return an empty result set,\n      * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n      */\n    if (_.isEmpty(data)) {\n      throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n    }\n\n    return qi.showIndex(tableName, options).then(indexes => {\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      return qi.getForeignKeyReferencesForTable(tableName, options).then(foreignKeys => {\n        for (const foreignKey of foreignKeys) {\n          data[foreignKey.columnName].references = {\n            model: foreignKey.referencedTableName,\n            key: foreignKey.referencedColumnName\n          };\n        }\n        return data;\n      });\n    });\n  }).catch(e => {\n    if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n      throw Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n    }\n\n    throw e;\n  });\n}\nexports.describeTable = describeTable;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1466,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1467,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1468,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1469,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1470,
    "kind": "function",
    "name": "removeColumn",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~removeColumn",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "A wrapper that fixes SQLite's inability to remove columns from existing tables.\nIt will create a backup of the table, drop the table afterwards and create a\nnew table with the same name but without the obsolete column.",
    "lineNumber": 30,
    "since": "1.6.0",
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attributeName",
        "description": "The name of the attribute that we want to remove."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs the sql queries, or false for explicitly not logging these queries"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1471,
    "kind": "function",
    "name": "changeColumn",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~changeColumn",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "A wrapper that fixes SQLite's inability to change columns from existing tables.\nIt will create a backup of the table, drop the table afterwards and create a\nnew table with the same name but with a modified version of the respective column.",
    "lineNumber": 58,
    "since": "1.6.0",
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "An object with the attribute's name as key and its options as value object."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs the sql queries, or false for explicitly not logging these queries"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1472,
    "kind": "function",
    "name": "renameColumn",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~renameColumn",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "A wrapper that fixes SQLite's inability to rename columns from existing tables.\nIt will create a backup of the table, drop the table afterwards and create a\nnew table with the same name but with a renamed version of the respective column.",
    "lineNumber": 88,
    "since": "1.6.0",
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "The name of the table."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attrNameBefore",
        "description": "The name of the attribute before it was renamed."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attrNameAfter",
        "description": "The name of the attribute after it was renamed."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs the sql queries, or false for explicitly not logging these queries"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1473,
    "kind": "function",
    "name": "removeConstraint",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~removeConstraint",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "constraintName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1474,
    "kind": "function",
    "name": "addConstraint",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~addConstraint",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1475,
    "kind": "function",
    "name": "getForeignKeyReferencesForTable",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~getForeignKeyReferencesForTable",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 192,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Query Options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1476,
    "kind": "function",
    "name": "describeTable",
    "memberof": "lib/dialects/sqlite/query-interface.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query-interface.js~describeTable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query-interface.js",
    "importStyle": null,
    "description": "Describe a table structure\n\nThis method returns an array of hashes containing information about all attributes in the table.\n\n```js\n{\n   name: {\n     type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n     allowNull:    true,\n     defaultValue: null,\n     unique:       true,           // available for sqlite only\n     references:   {},             // available for sqlite only\n   },\n   isBetaMember: {\n     type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n     allowNull:    false,\n     defaultValue: false,\n     unique:       false,        // available for sqlite only\n     references:   {},           // available for sqlite only\n   }\n}\n```",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "QueryInterface"
        ],
        "spread": false,
        "optional": false,
        "name": "qi",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1477,
    "kind": "file",
    "name": "lib/dialects/sqlite/query.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Promise = require('../../promise');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|Object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData)) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.UPSERT) {\n      return undefined;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    let complete;\n    if (method === 'exec') {\n      // exec does not support bind parameter\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', { skipUnescape: true })[0];\n      this.sql = sql;\n      complete = this._logQuery(sql, debug);\n    } else {\n      complete = this._logQuery(sql, debug, parameters);\n    }\n    \n\n    return new Promise(resolve => {\n      const columnTypes = {};\n      conn.serialize(() => {\n        const executeSql = () => {\n          if (sql.startsWith('-- ')) {\n            return resolve();\n          }\n          resolve(new Promise((resolve, reject) => {\n            const query = this;\n            // cannot use arrow function here because the function is bound to the statement\n            function afterExecute(executionError, results) {\n              try {\n                complete();\n                // `this` is passed from sqlite, we have no control over this.\n                // eslint-disable-next-line no-invalid-this\n                resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n                return;\n              } catch (error) {\n                reject(error);\n              }\n            }\n\n            if (method === 'exec') {\n              // exec does not support bind parameter\n              conn[method](sql, afterExecute);\n            } else {\n              if (!parameters) parameters = [];\n              conn[method](sql, parameters, afterExecute);\n            }\n          }));\n          return null;\n        };\n\n        if (this.getDatabaseMethod() === 'all') {\n          let tableNames = [];\n          if (this.options && this.options.tableNames) {\n            tableNames = this.options.tableNames;\n          } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n            tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n          }\n\n          // If we already have the metadata for the table, there's no need to ask for it again\n          tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n          if (!tableNames.length) {\n            return executeSql();\n          }\n          return Promise.map(tableNames, tableName =>\n            new Promise(resolve => {\n              tableName = tableName.replace(/`/g, '');\n              columnTypes[tableName] = {};\n\n              conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n                if (!err) {\n                  for (const result of results) {\n                    columnTypes[tableName][result.name] = result.type;\n                  }\n                }\n                resolve();\n              });\n            })\n          ).then(executeSql);\n        }\n        return executeSql();\n      });\n    });\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.map(data.reverse(), item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      return this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`).then(columns => {\n        for (const column of columns) {\n          item.fields[column.seqno] = {\n            attribute: column.name,\n            length: undefined,\n            order: undefined\n          };\n        }\n\n        return item;\n      });\n    });\n  }\n\n  getDatabaseMethod() {\n    if (this.isUpsertQuery()) {\n      return 'exec'; // Needed to run multiple queries in one\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/dialects/sqlite/query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1478,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1479,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1480,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1481,
    "kind": "variable",
    "name": "AbstractQuery",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~AbstractQuery",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1482,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1483,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1484,
    "kind": "variable",
    "name": "parserStore",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~parserStore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1485,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1486,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1487,
    "kind": "class",
    "name": "Query",
    "memberof": "lib/dialects/sqlite/query.js",
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~Query",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/dialects/sqlite/query.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "interface": false,
    "extends": [
      "AbstractQuery"
    ],
    "ignore": true
  },
  {
    "__docId__": 1488,
    "kind": "method",
    "name": "getInsertIdField",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#getInsertIdField",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1489,
    "kind": "method",
    "name": "formatBindParameters",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/dialects/sqlite/query.js~Query.formatBindParameters",
    "access": "private",
    "description": "rewrite query with parameters.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dialect",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1490,
    "kind": "method",
    "name": "_collectModels",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#_collectModels",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1491,
    "kind": "method",
    "name": "_handleQueryResponse",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#_handleQueryResponse",
    "access": "private",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "metaData",
        "types": [
          "*"
        ]
      },
      {
        "name": "columnTypes",
        "types": [
          "*"
        ]
      },
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "results",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1492,
    "kind": "method",
    "name": "run",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 220,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1493,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1495,
    "kind": "method",
    "name": "parseConstraintsFromSql",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#parseConstraintsFromSql",
    "access": "public",
    "description": null,
    "lineNumber": 303,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1496,
    "kind": "method",
    "name": "applyParsers",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#applyParsers",
    "access": "public",
    "description": null,
    "lineNumber": 353,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1497,
    "kind": "method",
    "name": "formatError",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#formatError",
    "access": "public",
    "description": null,
    "lineNumber": 368,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1498,
    "kind": "method",
    "name": "handleShowIndexesQuery",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#handleShowIndexesQuery",
    "access": "public",
    "description": null,
    "lineNumber": 426,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1499,
    "kind": "method",
    "name": "getDatabaseMethod",
    "memberof": "lib/dialects/sqlite/query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/dialects/sqlite/query.js~Query#getDatabaseMethod",
    "access": "public",
    "description": null,
    "lineNumber": 447,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1500,
    "kind": "file",
    "name": "lib/errors/aggregate-error.js",
    "content": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => aggregate_error_default\n});\nvar import_base_error = __toModule(require(\"./base-error\"));\nclass AggregateError extends import_base_error.default {\n  constructor(errors) {\n    super();\n    __publicField(this, \"errors\");\n    this.errors = errors;\n    this.name = \"AggregateError\";\n  }\n  toString() {\n    const message = `AggregateError of:\n${this.errors.map((error) => error === this ? \"[Circular AggregateError]\" : error instanceof AggregateError ? String(error).replace(/\\n$/, \"\").replace(/^/gm, \"  \") : String(error).replace(/^/gm, \"    \").substring(2)).join(\"\\n\")}\n`;\n    return message;\n  }\n}\nvar aggregate_error_default = AggregateError;\n//# sourceMappingURL=aggregate-error.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/aggregate-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1501,
    "kind": "variable",
    "name": "__create",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__create",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1502,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1503,
    "kind": "variable",
    "name": "__getOwnPropDesc",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__getOwnPropDesc",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1504,
    "kind": "variable",
    "name": "__getOwnPropNames",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__getOwnPropNames",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1505,
    "kind": "variable",
    "name": "__getProtoOf",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__getProtoOf",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1506,
    "kind": "variable",
    "name": "__hasOwnProp",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__hasOwnProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1507,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1508,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1509,
    "kind": "function",
    "name": "__export",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__export",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "all",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1510,
    "kind": "function",
    "name": "__reExport",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__reExport",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "module2",
        "types": [
          "*"
        ]
      },
      {
        "name": "desc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1511,
    "kind": "function",
    "name": "__toModule",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__toModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "module2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1512,
    "kind": "function",
    "name": "__publicField",
    "memberof": "lib/errors/aggregate-error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/errors/aggregate-error.js~__publicField",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1513,
    "kind": "variable",
    "name": "import_base_error",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~import_base_error",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1514,
    "kind": "class",
    "name": "AggregateError",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~AggregateError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "interface": false,
    "extends": [
      "import_base_error~import_base_error.default"
    ],
    "ignore": true
  },
  {
    "__docId__": 1515,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/aggregate-error.js~AggregateError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/aggregate-error.js~AggregateError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1516,
    "kind": "member",
    "name": "errors",
    "memberof": "lib/errors/aggregate-error.js~AggregateError",
    "static": false,
    "longname": "lib/errors/aggregate-error.js~AggregateError#errors",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1517,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/aggregate-error.js~AggregateError",
    "static": false,
    "longname": "lib/errors/aggregate-error.js~AggregateError#name",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1518,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/errors/aggregate-error.js~AggregateError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/aggregate-error.js~AggregateError#toString",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1519,
    "kind": "variable",
    "name": "aggregate_error_default",
    "memberof": "lib/errors/aggregate-error.js",
    "static": true,
    "longname": "lib/errors/aggregate-error.js~aggregate_error_default",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/aggregate-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1520,
    "kind": "file",
    "name": "lib/errors/association-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when an association is improperly constructed (see message for details)\n */\nclass AssociationError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAssociationError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = AssociationError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/association-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1521,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/association-error.js",
    "static": true,
    "longname": "lib/errors/association-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/association-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1522,
    "kind": "class",
    "name": "AssociationError",
    "memberof": "lib/errors/association-error.js",
    "static": true,
    "longname": "lib/errors/association-error.js~AssociationError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/association-error.js",
    "importStyle": null,
    "description": "Thrown when an association is improperly constructed (see message for details)",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1523,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/association-error.js~AssociationError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/association-error.js~AssociationError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1524,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/association-error.js~AssociationError",
    "static": false,
    "longname": "lib/errors/association-error.js~AssociationError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1525,
    "kind": "file",
    "name": "lib/errors/base-error.js",
    "content": "'use strict';\n\n/**\n * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.\n * All sequelize errors inherit from the base JS error object.\n *\n * This means that errors can be accessed using `Sequelize.ValidationError`\n * The Base Error all Sequelize Errors inherit from.\n */\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeBaseError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = BaseError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/base-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1526,
    "kind": "class",
    "name": "BaseError",
    "memberof": "lib/errors/base-error.js",
    "static": true,
    "longname": "lib/errors/base-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/base-error.js",
    "importStyle": null,
    "description": "Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.\nAll sequelize errors inherit from the base JS error object.\n\nThis means that errors can be accessed using `Sequelize.ValidationError`\nThe Base Error all Sequelize Errors inherit from.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 1527,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/base-error.js~BaseError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/base-error.js~BaseError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1528,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/base-error.js~BaseError",
    "static": false,
    "longname": "lib/errors/base-error.js~BaseError#name",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1529,
    "kind": "file",
    "name": "lib/errors/bulk-record-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when bulk operation fails, it represent per record level error.\n * Used with Promise.AggregateError\n *\n * @param {Error}  error   Error for a given record/instance\n * @param {Object} record  DAO instance that error belongs to\n */\nclass BulkRecordError extends BaseError {\n  constructor(error, record) {\n    super(error.message);\n    this.name = 'SequelizeBulkRecordError';\n    this.errors = error;\n    this.record = record;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = BulkRecordError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/bulk-record-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1530,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/bulk-record-error.js",
    "static": true,
    "longname": "lib/errors/bulk-record-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/bulk-record-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1531,
    "kind": "class",
    "name": "BulkRecordError",
    "memberof": "lib/errors/bulk-record-error.js",
    "static": true,
    "longname": "lib/errors/bulk-record-error.js~BulkRecordError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/bulk-record-error.js",
    "importStyle": null,
    "description": "Thrown when bulk operation fails, it represent per record level error.\nUsed with Promise.AggregateError",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": "Error for a given record/instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "record",
        "description": "DAO instance that error belongs to"
      }
    ],
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1532,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/bulk-record-error.js~BulkRecordError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/bulk-record-error.js~BulkRecordError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1533,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/bulk-record-error.js~BulkRecordError",
    "static": false,
    "longname": "lib/errors/bulk-record-error.js~BulkRecordError#name",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1534,
    "kind": "member",
    "name": "errors",
    "memberof": "lib/errors/bulk-record-error.js~BulkRecordError",
    "static": false,
    "longname": "lib/errors/bulk-record-error.js~BulkRecordError#errors",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1535,
    "kind": "member",
    "name": "record",
    "memberof": "lib/errors/bulk-record-error.js~BulkRecordError",
    "static": false,
    "longname": "lib/errors/bulk-record-error.js~BulkRecordError#record",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1536,
    "kind": "file",
    "name": "lib/errors/connection/access-denied-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database is refused due to insufficient privileges\n */\nclass AccessDeniedError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeAccessDeniedError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = AccessDeniedError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/access-denied-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1537,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/access-denied-error.js",
    "static": true,
    "longname": "lib/errors/connection/access-denied-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/access-denied-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1538,
    "kind": "class",
    "name": "AccessDeniedError",
    "memberof": "lib/errors/connection/access-denied-error.js",
    "static": true,
    "longname": "lib/errors/connection/access-denied-error.js~AccessDeniedError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/access-denied-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database is refused due to insufficient privileges",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1539,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/access-denied-error.js~AccessDeniedError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/access-denied-error.js~AccessDeniedError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1540,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/access-denied-error.js~AccessDeniedError",
    "static": false,
    "longname": "lib/errors/connection/access-denied-error.js~AccessDeniedError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1541,
    "kind": "file",
    "name": "lib/errors/connection/connection-acquire-timeout-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when connection is not acquired due to timeout\n */\nclass ConnectionAcquireTimeoutError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeConnectionAcquireTimeoutError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ConnectionAcquireTimeoutError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/connection-acquire-timeout-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1542,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/connection-acquire-timeout-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-acquire-timeout-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1543,
    "kind": "class",
    "name": "ConnectionAcquireTimeoutError",
    "memberof": "lib/errors/connection/connection-acquire-timeout-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-acquire-timeout-error.js",
    "importStyle": null,
    "description": "Thrown when connection is not acquired due to timeout",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1544,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1545,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError",
    "static": false,
    "longname": "lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1546,
    "kind": "file",
    "name": "lib/errors/connection/connection-refused-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database is refused\n */\nclass ConnectionRefusedError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeConnectionRefusedError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ConnectionRefusedError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/connection-refused-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1547,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/connection-refused-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-refused-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-refused-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1548,
    "kind": "class",
    "name": "ConnectionRefusedError",
    "memberof": "lib/errors/connection/connection-refused-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-refused-error.js~ConnectionRefusedError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-refused-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database is refused",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1549,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/connection-refused-error.js~ConnectionRefusedError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/connection-refused-error.js~ConnectionRefusedError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1550,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/connection-refused-error.js~ConnectionRefusedError",
    "static": false,
    "longname": "lib/errors/connection/connection-refused-error.js~ConnectionRefusedError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1551,
    "kind": "file",
    "name": "lib/errors/connection/connection-timed-out-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database times out\n */\nclass ConnectionTimedOutError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeConnectionTimedOutError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ConnectionTimedOutError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/connection-timed-out-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1552,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/connection-timed-out-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-timed-out-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-timed-out-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1553,
    "kind": "class",
    "name": "ConnectionTimedOutError",
    "memberof": "lib/errors/connection/connection-timed-out-error.js",
    "static": true,
    "longname": "lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/connection-timed-out-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database times out",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1554,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1555,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError",
    "static": false,
    "longname": "lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1556,
    "kind": "file",
    "name": "lib/errors/connection/host-not-found-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database has a hostname that was not found\n */\nclass HostNotFoundError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeHostNotFoundError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = HostNotFoundError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/host-not-found-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1557,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/host-not-found-error.js",
    "static": true,
    "longname": "lib/errors/connection/host-not-found-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/host-not-found-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1558,
    "kind": "class",
    "name": "HostNotFoundError",
    "memberof": "lib/errors/connection/host-not-found-error.js",
    "static": true,
    "longname": "lib/errors/connection/host-not-found-error.js~HostNotFoundError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/host-not-found-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database has a hostname that was not found",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1559,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/host-not-found-error.js~HostNotFoundError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/host-not-found-error.js~HostNotFoundError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1560,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/host-not-found-error.js~HostNotFoundError",
    "static": false,
    "longname": "lib/errors/connection/host-not-found-error.js~HostNotFoundError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1561,
    "kind": "file",
    "name": "lib/errors/connection/host-not-reachable-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database has a hostname that was not reachable\n */\nclass HostNotReachableError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeHostNotReachableError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = HostNotReachableError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/host-not-reachable-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1562,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/host-not-reachable-error.js",
    "static": true,
    "longname": "lib/errors/connection/host-not-reachable-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/host-not-reachable-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1563,
    "kind": "class",
    "name": "HostNotReachableError",
    "memberof": "lib/errors/connection/host-not-reachable-error.js",
    "static": true,
    "longname": "lib/errors/connection/host-not-reachable-error.js~HostNotReachableError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/host-not-reachable-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database has a hostname that was not reachable",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1564,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/host-not-reachable-error.js~HostNotReachableError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/host-not-reachable-error.js~HostNotReachableError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1565,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/host-not-reachable-error.js~HostNotReachableError",
    "static": false,
    "longname": "lib/errors/connection/host-not-reachable-error.js~HostNotReachableError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1566,
    "kind": "file",
    "name": "lib/errors/connection/invalid-connection-error.js",
    "content": "'use strict';\n\nconst ConnectionError = require('./../connection-error');\n\n/**\n * Thrown when a connection to a database has invalid values for any of the connection parameters\n */\nclass InvalidConnectionError extends ConnectionError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeInvalidConnectionError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = InvalidConnectionError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection/invalid-connection-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1567,
    "kind": "variable",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection/invalid-connection-error.js",
    "static": true,
    "longname": "lib/errors/connection/invalid-connection-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/invalid-connection-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1568,
    "kind": "class",
    "name": "InvalidConnectionError",
    "memberof": "lib/errors/connection/invalid-connection-error.js",
    "static": true,
    "longname": "lib/errors/connection/invalid-connection-error.js~InvalidConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection/invalid-connection-error.js",
    "importStyle": null,
    "description": "Thrown when a connection to a database has invalid values for any of the connection parameters",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ConnectionError"
    ]
  },
  {
    "__docId__": 1569,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection/invalid-connection-error.js~InvalidConnectionError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection/invalid-connection-error.js~InvalidConnectionError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1570,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection/invalid-connection-error.js~InvalidConnectionError",
    "static": false,
    "longname": "lib/errors/connection/invalid-connection-error.js~InvalidConnectionError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1571,
    "kind": "file",
    "name": "lib/errors/connection-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * A base class for all connection related errors.\n */\nclass ConnectionError extends BaseError {\n  constructor(parent) {\n    super(parent ? parent.message : '');\n    this.name = 'SequelizeConnectionError';\n    /**\n     * The connection specific error which triggered this one\n     * @type {Error}\n     */\n    this.parent = parent;\n    this.original = parent;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ConnectionError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/connection-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1572,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/connection-error.js",
    "static": true,
    "longname": "lib/errors/connection-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1573,
    "kind": "class",
    "name": "ConnectionError",
    "memberof": "lib/errors/connection-error.js",
    "static": true,
    "longname": "lib/errors/connection-error.js~ConnectionError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/connection-error.js",
    "importStyle": null,
    "description": "A base class for all connection related errors.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1574,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/connection-error.js~ConnectionError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/connection-error.js~ConnectionError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1575,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/connection-error.js~ConnectionError",
    "static": false,
    "longname": "lib/errors/connection-error.js~ConnectionError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1576,
    "kind": "member",
    "name": "parent",
    "memberof": "lib/errors/connection-error.js~ConnectionError",
    "static": false,
    "longname": "lib/errors/connection-error.js~ConnectionError#parent",
    "access": "public",
    "description": "The connection specific error which triggered this one",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1577,
    "kind": "member",
    "name": "original",
    "memberof": "lib/errors/connection-error.js~ConnectionError",
    "static": false,
    "longname": "lib/errors/connection-error.js~ConnectionError#original",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1578,
    "kind": "file",
    "name": "lib/errors/database/exclusion-constraint-error.js",
    "content": "'use strict';\n\nconst DatabaseError = require('./../database-error');\n\n/**\n * Thrown when an exclusion constraint is violated in the database\n */\nclass ExclusionConstraintError extends DatabaseError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n\n    super(options.parent);\n    this.name = 'SequelizeExclusionConstraintError';\n\n    this.message = options.message || options.parent.message || '';\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ExclusionConstraintError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/database/exclusion-constraint-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1579,
    "kind": "variable",
    "name": "DatabaseError",
    "memberof": "lib/errors/database/exclusion-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/exclusion-constraint-error.js~DatabaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/exclusion-constraint-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1580,
    "kind": "class",
    "name": "ExclusionConstraintError",
    "memberof": "lib/errors/database/exclusion-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/exclusion-constraint-error.js",
    "importStyle": null,
    "description": "Thrown when an exclusion constraint is violated in the database",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "DatabaseError"
    ]
  },
  {
    "__docId__": 1581,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1582,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#name",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1583,
    "kind": "member",
    "name": "message",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#message",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1584,
    "kind": "member",
    "name": "constraint",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#constraint",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1585,
    "kind": "member",
    "name": "fields",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#fields",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1586,
    "kind": "member",
    "name": "table",
    "memberof": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError",
    "static": false,
    "longname": "lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError#table",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1587,
    "kind": "file",
    "name": "lib/errors/database/foreign-key-constraint-error.js",
    "content": "'use strict';\n\nconst DatabaseError = require('./../database-error');\n\n/**\n * Thrown when a foreign key constraint is violated in the database\n */\nclass ForeignKeyConstraintError extends DatabaseError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n\n    super(options.parent);\n    this.name = 'SequelizeForeignKeyConstraintError';\n\n    this.message = options.message || options.parent.message || 'Database Error';\n    this.fields = options.fields;\n    this.table = options.table;\n    this.value = options.value;\n    this.index = options.index;\n    this.reltype = options.reltype;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = ForeignKeyConstraintError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/database/foreign-key-constraint-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1588,
    "kind": "variable",
    "name": "DatabaseError",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~DatabaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/foreign-key-constraint-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1589,
    "kind": "class",
    "name": "ForeignKeyConstraintError",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/foreign-key-constraint-error.js",
    "importStyle": null,
    "description": "Thrown when a foreign key constraint is violated in the database",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "DatabaseError"
    ]
  },
  {
    "__docId__": 1590,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1591,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#name",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1592,
    "kind": "member",
    "name": "message",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#message",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1593,
    "kind": "member",
    "name": "fields",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#fields",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1594,
    "kind": "member",
    "name": "table",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#table",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1595,
    "kind": "member",
    "name": "value",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#value",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1596,
    "kind": "member",
    "name": "index",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#index",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1597,
    "kind": "member",
    "name": "reltype",
    "memberof": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError",
    "static": false,
    "longname": "lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError#reltype",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1598,
    "kind": "file",
    "name": "lib/errors/database/timeout-error.js",
    "content": "'use strict';\n\nconst DatabaseError = require('./../database-error');\n\n/**\n * Thrown when a database query times out because of a deadlock\n */\nclass TimeoutError extends DatabaseError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeTimeoutError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = TimeoutError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/database/timeout-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1599,
    "kind": "variable",
    "name": "DatabaseError",
    "memberof": "lib/errors/database/timeout-error.js",
    "static": true,
    "longname": "lib/errors/database/timeout-error.js~DatabaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/timeout-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1600,
    "kind": "class",
    "name": "TimeoutError",
    "memberof": "lib/errors/database/timeout-error.js",
    "static": true,
    "longname": "lib/errors/database/timeout-error.js~TimeoutError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/timeout-error.js",
    "importStyle": null,
    "description": "Thrown when a database query times out because of a deadlock",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "DatabaseError"
    ]
  },
  {
    "__docId__": 1601,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/database/timeout-error.js~TimeoutError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/database/timeout-error.js~TimeoutError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1602,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/database/timeout-error.js~TimeoutError",
    "static": false,
    "longname": "lib/errors/database/timeout-error.js~TimeoutError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1603,
    "kind": "file",
    "name": "lib/errors/database/unknown-constraint-error.js",
    "content": "'use strict';\n\nconst DatabaseError = require('./../database-error');\n\n/**\n * Thrown when constraint name is not found in the database\n */\nclass UnknownConstraintError extends DatabaseError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n\n    super(options.parent);\n    this.name = 'SequelizeUnknownConstraintError';\n\n    this.message = options.message || 'The specified constraint does not exist';\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = UnknownConstraintError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/database/unknown-constraint-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1604,
    "kind": "variable",
    "name": "DatabaseError",
    "memberof": "lib/errors/database/unknown-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/unknown-constraint-error.js~DatabaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/unknown-constraint-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1605,
    "kind": "class",
    "name": "UnknownConstraintError",
    "memberof": "lib/errors/database/unknown-constraint-error.js",
    "static": true,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database/unknown-constraint-error.js",
    "importStyle": null,
    "description": "Thrown when constraint name is not found in the database",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "DatabaseError"
    ]
  },
  {
    "__docId__": 1606,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1607,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#name",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1608,
    "kind": "member",
    "name": "message",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#message",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1609,
    "kind": "member",
    "name": "constraint",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#constraint",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1610,
    "kind": "member",
    "name": "fields",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#fields",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1611,
    "kind": "member",
    "name": "table",
    "memberof": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError",
    "static": false,
    "longname": "lib/errors/database/unknown-constraint-error.js~UnknownConstraintError#table",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1612,
    "kind": "file",
    "name": "lib/errors/database-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * A base class for all database related errors.\n */\nclass DatabaseError extends BaseError {\n  constructor(parent) {\n    super(parent.message);\n    this.name = 'SequelizeDatabaseError';\n    /**\n     * @type {Error}\n     */\n    this.parent = parent;\n    /**\n     * @type {Error}\n     */\n    this.original = parent;\n    /**\n     * The SQL that triggered the error\n     * @type {string}\n     */\n    this.sql = parent.sql;\n    /**\n     * The parameters for the sql that triggered the error\n     * @type {Array<any>}\n     */\n    this.parameters = parent.parameters;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = DatabaseError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/database-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1613,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/database-error.js",
    "static": true,
    "longname": "lib/errors/database-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1614,
    "kind": "class",
    "name": "DatabaseError",
    "memberof": "lib/errors/database-error.js",
    "static": true,
    "longname": "lib/errors/database-error.js~DatabaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/database-error.js",
    "importStyle": null,
    "description": "A base class for all database related errors.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1615,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1616,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1617,
    "kind": "member",
    "name": "parent",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#parent",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1618,
    "kind": "member",
    "name": "original",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#original",
    "access": "public",
    "description": "",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1619,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#sql",
    "access": "public",
    "description": "The SQL that triggered the error",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1620,
    "kind": "member",
    "name": "parameters",
    "memberof": "lib/errors/database-error.js~DatabaseError",
    "static": false,
    "longname": "lib/errors/database-error.js~DatabaseError#parameters",
    "access": "public",
    "description": "The parameters for the sql that triggered the error",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Array<any>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1621,
    "kind": "file",
    "name": "lib/errors/eager-loading-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when an include statement is improperly constructed (see message for details)\n */\nclass EagerLoadingError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeEagerLoadingError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = EagerLoadingError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/eager-loading-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1622,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/eager-loading-error.js",
    "static": true,
    "longname": "lib/errors/eager-loading-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/eager-loading-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1623,
    "kind": "class",
    "name": "EagerLoadingError",
    "memberof": "lib/errors/eager-loading-error.js",
    "static": true,
    "longname": "lib/errors/eager-loading-error.js~EagerLoadingError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/eager-loading-error.js",
    "importStyle": null,
    "description": "Thrown when an include statement is improperly constructed (see message for details)",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1624,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/eager-loading-error.js~EagerLoadingError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/eager-loading-error.js~EagerLoadingError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1625,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/eager-loading-error.js~EagerLoadingError",
    "static": false,
    "longname": "lib/errors/eager-loading-error.js~EagerLoadingError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1626,
    "kind": "file",
    "name": "lib/errors/empty-result-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)\n */\nclass EmptyResultError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeEmptyResultError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = EmptyResultError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/empty-result-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1627,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/empty-result-error.js",
    "static": true,
    "longname": "lib/errors/empty-result-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/empty-result-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1628,
    "kind": "class",
    "name": "EmptyResultError",
    "memberof": "lib/errors/empty-result-error.js",
    "static": true,
    "longname": "lib/errors/empty-result-error.js~EmptyResultError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/empty-result-error.js",
    "importStyle": null,
    "description": "Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1629,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/empty-result-error.js~EmptyResultError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/empty-result-error.js~EmptyResultError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1630,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/empty-result-error.js~EmptyResultError",
    "static": false,
    "longname": "lib/errors/empty-result-error.js~EmptyResultError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1631,
    "kind": "file",
    "name": "lib/errors/index.js",
    "content": "'use strict';\n\nexports.BaseError = require('./base-error');\n\nexports.AssociationError = require('./association-error');\nexports.BulkRecordError = require('./bulk-record-error');\nexports.ConnectionError = require('./connection-error');\nexports.DatabaseError = require('./database-error');\nexports.EagerLoadingError = require('./eager-loading-error');\nexports.EmptyResultError = require('./empty-result-error');\nexports.InstanceError = require('./instance-error');\nexports.OptimisticLockError = require('./optimistic-lock-error');\nexports.QueryError = require('./query-error');\nexports.SequelizeScopeError = require('./sequelize-scope-error');\nexports.ValidationError = require('./validation-error');\nexports.ValidationErrorItem = exports.ValidationError.ValidationErrorItem;\n\nexports.AccessDeniedError = require('./connection/access-denied-error');\nexports.ConnectionAcquireTimeoutError = require('./connection/connection-acquire-timeout-error');\nexports.ConnectionRefusedError = require('./connection/connection-refused-error');\nexports.ConnectionTimedOutError = require('./connection/connection-timed-out-error');\nexports.HostNotFoundError = require('./connection/host-not-found-error');\nexports.HostNotReachableError = require('./connection/host-not-reachable-error');\nexports.InvalidConnectionError = require('./connection/invalid-connection-error');\n\nexports.ExclusionConstraintError = require('./database/exclusion-constraint-error');\nexports.ForeignKeyConstraintError = require('./database/foreign-key-constraint-error');\nexports.TimeoutError = require('./database/timeout-error');\nexports.UnknownConstraintError = require('./database/unknown-constraint-error');\n\nexports.UniqueConstraintError = require('./validation/unique-constraint-error');\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1632,
    "kind": "file",
    "name": "lib/errors/instance-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when a some problem occurred with Instance methods (see message for details)\n */\nclass InstanceError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeInstanceError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = InstanceError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/instance-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1633,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/instance-error.js",
    "static": true,
    "longname": "lib/errors/instance-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/instance-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1634,
    "kind": "class",
    "name": "InstanceError",
    "memberof": "lib/errors/instance-error.js",
    "static": true,
    "longname": "lib/errors/instance-error.js~InstanceError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/instance-error.js",
    "importStyle": null,
    "description": "Thrown when a some problem occurred with Instance methods (see message for details)",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1635,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/instance-error.js~InstanceError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/instance-error.js~InstanceError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1636,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/instance-error.js~InstanceError",
    "static": false,
    "longname": "lib/errors/instance-error.js~InstanceError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1637,
    "kind": "file",
    "name": "lib/errors/optimistic-lock-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when attempting to update a stale model instance\n */\nclass OptimisticLockError extends BaseError {\n  constructor(options) {\n    options = options || {};\n    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;\n    super(options.message);\n    this.name = 'SequelizeOptimisticLockError';\n    /**\n     * The name of the model on which the update was attempted\n     * @type {string}\n     */\n    this.modelName = options.modelName;\n    /**\n     * The values of the attempted update\n     * @type {object}\n     */\n    this.values = options.values;\n    /**\n     *\n     * @type {object}\n     */\n    this.where = options.where;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = OptimisticLockError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/optimistic-lock-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1638,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/optimistic-lock-error.js",
    "static": true,
    "longname": "lib/errors/optimistic-lock-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/optimistic-lock-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1639,
    "kind": "class",
    "name": "OptimisticLockError",
    "memberof": "lib/errors/optimistic-lock-error.js",
    "static": true,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/optimistic-lock-error.js",
    "importStyle": null,
    "description": "Thrown when attempting to update a stale model instance",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1640,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1641,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "static": false,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError#name",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1642,
    "kind": "member",
    "name": "modelName",
    "memberof": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "static": false,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError#modelName",
    "access": "public",
    "description": "The name of the model on which the update was attempted",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1643,
    "kind": "member",
    "name": "values",
    "memberof": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "static": false,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError#values",
    "access": "public",
    "description": "The values of the attempted update",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1644,
    "kind": "member",
    "name": "where",
    "memberof": "lib/errors/optimistic-lock-error.js~OptimisticLockError",
    "static": false,
    "longname": "lib/errors/optimistic-lock-error.js~OptimisticLockError#where",
    "access": "public",
    "description": "",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1645,
    "kind": "file",
    "name": "lib/errors/query-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Thrown when a query is passed invalid options (see message for details)\n */\nclass QueryError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeQueryError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = QueryError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/query-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1646,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/query-error.js",
    "static": true,
    "longname": "lib/errors/query-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/query-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1647,
    "kind": "class",
    "name": "QueryError",
    "memberof": "lib/errors/query-error.js",
    "static": true,
    "longname": "lib/errors/query-error.js~QueryError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/query-error.js",
    "importStyle": null,
    "description": "Thrown when a query is passed invalid options (see message for details)",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1648,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/query-error.js~QueryError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/query-error.js~QueryError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1649,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/query-error.js~QueryError",
    "static": false,
    "longname": "lib/errors/query-error.js~QueryError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1650,
    "kind": "file",
    "name": "lib/errors/sequelize-scope-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Scope Error. Thrown when the sequelize cannot query the specified scope.\n */\nclass SequelizeScopeError extends BaseError {\n  constructor(parent) {\n    super(parent);\n    this.name = 'SequelizeScopeError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = SequelizeScopeError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/sequelize-scope-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1651,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/sequelize-scope-error.js",
    "static": true,
    "longname": "lib/errors/sequelize-scope-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/sequelize-scope-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1652,
    "kind": "class",
    "name": "SequelizeScopeError",
    "memberof": "lib/errors/sequelize-scope-error.js",
    "static": true,
    "longname": "lib/errors/sequelize-scope-error.js~SequelizeScopeError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/sequelize-scope-error.js",
    "importStyle": null,
    "description": "Scope Error. Thrown when the sequelize cannot query the specified scope.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1653,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/sequelize-scope-error.js~SequelizeScopeError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/sequelize-scope-error.js~SequelizeScopeError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1654,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/sequelize-scope-error.js~SequelizeScopeError",
    "static": false,
    "longname": "lib/errors/sequelize-scope-error.js~SequelizeScopeError#name",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1655,
    "kind": "file",
    "name": "lib/errors/validation/unique-constraint-error.js",
    "content": "'use strict';\n\nconst ValidationError = require('./../validation-error');\n\n/**\n * Thrown when a unique constraint is violated in the database\n */\nclass UniqueConstraintError extends ValidationError {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: '' };\n    options.message = options.message || options.parent.message || 'Validation Error';\n    options.errors = options.errors || {};\n    super(options.message, options.errors);\n\n    this.name = 'SequelizeUniqueConstraintError';\n    this.errors = options.errors;\n    this.fields = options.fields;\n    this.parent = options.parent;\n    this.original = options.parent;\n    this.sql = options.parent.sql;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = UniqueConstraintError;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/validation/unique-constraint-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1656,
    "kind": "variable",
    "name": "ValidationError",
    "memberof": "lib/errors/validation/unique-constraint-error.js",
    "static": true,
    "longname": "lib/errors/validation/unique-constraint-error.js~ValidationError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/validation/unique-constraint-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1657,
    "kind": "class",
    "name": "UniqueConstraintError",
    "memberof": "lib/errors/validation/unique-constraint-error.js",
    "static": true,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/validation/unique-constraint-error.js",
    "importStyle": null,
    "description": "Thrown when a unique constraint is violated in the database",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "ValidationError"
    ]
  },
  {
    "__docId__": 1658,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1659,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#name",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1660,
    "kind": "member",
    "name": "errors",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#errors",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1661,
    "kind": "member",
    "name": "fields",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#fields",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1662,
    "kind": "member",
    "name": "parent",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#parent",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1663,
    "kind": "member",
    "name": "original",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#original",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1664,
    "kind": "member",
    "name": "sql",
    "memberof": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError",
    "static": false,
    "longname": "lib/errors/validation/unique-constraint-error.js~UniqueConstraintError#sql",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1665,
    "kind": "file",
    "name": "lib/errors/validation-error.js",
    "content": "'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors {ValidationErrorItems[]}\n */\nclass ValidationError extends BaseError {\n  constructor(message, errors) {\n    super(message);\n    this.name = 'SequelizeValidationError';\n    this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n    this.errors = errors || [];\n\n    // Use provided error message if available...\n    if (message) {\n      this.message = message;\n\n      // ... otherwise create a concatenated message out of existing errors.\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\\n');\n    }\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   *\n   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path\n   */\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\n\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n */\nclass ValidationErrorItem {\n  /**\n   * Creates new validation error item\n   *\n   * @param {string} message An error message\n   * @param {string} type The type/origin of the validation error\n   * @param {string} path The field that triggered the validation error\n   * @param {string} value The value that generated the error\n   * @param {Object} [inst] the DAO instance that caused the validation error\n   * @param {Object} [validatorKey] a validation \"key\", used for identification\n   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n   * @param {string} [fnArgs] parameters used with the BUILT-IN validator function, if applicable\n   */\n  constructor(message, type, path, value, inst, validatorKey, fnName, fnArgs) {\n    /**\n     * An error message\n     *\n     * @type {string} message\n     */\n    this.message = message || '';\n\n    /**\n     * The type/origin of the validation error\n     *\n     * @type {string}\n     */\n    this.type = null;\n\n    /**\n     * The field that triggered the validation error\n     *\n     * @type {string}\n     */\n    this.path = path || null;\n\n    /**\n     * The value that generated the error\n     *\n     * @type {string}\n     */\n    this.value = value !== undefined ? value : null;\n\n    this.origin = null;\n\n    /**\n     * The DAO instance that caused the validation error\n     *\n     * @type {Model}\n     */\n    this.instance = inst || null;\n\n    /**\n     * A validation \"key\", used for identification\n     *\n     * @type {string}\n     */\n    this.validatorKey = validatorKey || null;\n\n    /**\n     * Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n     *\n     * @type {string}\n     */\n    this.validatorName = fnName || null;\n\n    /**\n     * Parameters used with the BUILT-IN validator function, if applicable\n     *\n     * @type {string}\n     */\n    this.validatorArgs = fnArgs || [];\n\n    if (type) {\n      if (ValidationErrorItem.Origins[ type ]) {\n        this.origin = type;\n      } else {\n        const lowercaseType = `${type}`.toLowerCase().trim();\n        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];\n\n        if (realType && ValidationErrorItem.Origins[ realType ]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n\n    // This doesn't need captureStackTrace because it's not a subclass of Error\n  }\n\n  /**\n   * return a lowercase, trimmed string \"key\" that identifies the validator.\n   *\n   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property\n   *\n   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is \"namespace\",\n   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins\n   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,\n   *                                            defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE.\n   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.\n   * @returns  {string}\n   *\n   * @private\n   */\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;\n    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;\n\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];\n\n    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {\n      throw new Error('Invalid namespace separator given, must be a non-empty string');\n    }\n\n    if (!(typeof key === 'string' && key.length)) {\n      return '';\n    }\n\n    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n\n/**\n * An enum that defines valid ValidationErrorItem `origin` values\n *\n * @type {Object}\n * @property CORE       {string}  specifies errors that originate from the sequelize \"core\"\n * @property DB         {string}  specifies validation errors that originate from the storage engine\n * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute\n */\nValidationErrorItem.Origins = {\n  CORE: 'CORE',\n  DB: 'DB',\n  FUNCTION: 'FUNCTION'\n};\n\n/**\n * An object that is used internally by the `ValidationErrorItem` class\n * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to\n * our new `origin` values.\n *\n * @type {Object}\n */\nValidationErrorItem.TypeStringMap = {\n  'notnull violation': 'CORE',\n  'string violation': 'CORE',\n  'unique violation': 'DB',\n  'validation error': 'FUNCTION'\n};\n\nmodule.exports = ValidationError;\nmodule.exports.ValidationErrorItem = ValidationErrorItem;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/errors/validation-error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1666,
    "kind": "variable",
    "name": "BaseError",
    "memberof": "lib/errors/validation-error.js",
    "static": true,
    "longname": "lib/errors/validation-error.js~BaseError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/validation-error.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1667,
    "kind": "class",
    "name": "ValidationError",
    "memberof": "lib/errors/validation-error.js",
    "static": true,
    "longname": "lib/errors/validation-error.js~ValidationError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/validation-error.js",
    "importStyle": null,
    "description": "Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\nwhich is an array with 1 or more ValidationErrorItems, one for each validation that failed.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "Error message"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "errors",
        "description": "Array of ValidationErrorItem objects describing the validation errors"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "errors",
        "description": "{ValidationErrorItems[]}"
      }
    ],
    "interface": false,
    "extends": [
      "BaseError"
    ]
  },
  {
    "__docId__": 1668,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/validation-error.js~ValidationError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1669,
    "kind": "member",
    "name": "name",
    "memberof": "lib/errors/validation-error.js~ValidationError",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationError#name",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1670,
    "kind": "member",
    "name": "message",
    "memberof": "lib/errors/validation-error.js~ValidationError",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationError#message",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1671,
    "kind": "member",
    "name": "errors",
    "memberof": "lib/errors/validation-error.js~ValidationError",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationError#errors",
    "access": "public",
    "description": "",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "ValidationErrorItem[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1674,
    "kind": "method",
    "name": "get",
    "memberof": "lib/errors/validation-error.js~ValidationError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationError#get",
    "access": "public",
    "description": "Gets all validation error items for the path / field specified.",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<ValidationErrorItem>} Validation error items for the specified path"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to be checked for error items"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<ValidationErrorItem>"
      ],
      "spread": false,
      "description": "Validation error items for the specified path"
    }
  },
  {
    "__docId__": 1675,
    "kind": "class",
    "name": "ValidationErrorItem",
    "memberof": "lib/errors/validation-error.js",
    "static": true,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/errors/validation-error.js",
    "importStyle": null,
    "description": "Validation Error Item\nInstances of this class are included in the `ValidationError.errors` property.",
    "lineNumber": 57,
    "interface": false
  },
  {
    "__docId__": 1676,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#constructor",
    "access": "public",
    "description": "Creates new validation error item",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "An error message"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type/origin of the validation error"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The field that triggered the validation error"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value that generated the error"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "inst",
        "description": "the DAO instance that caused the validation error"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "validatorKey",
        "description": "a validation \"key\", used for identification"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "fnName",
        "description": "property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "fnArgs",
        "description": "parameters used with the BUILT-IN validator function, if applicable"
      }
    ]
  },
  {
    "__docId__": 1677,
    "kind": "member",
    "name": "message",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#message",
    "access": "public",
    "description": "An error message",
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1678,
    "kind": "member",
    "name": "type",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#type",
    "access": "public",
    "description": "The type/origin of the validation error",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1679,
    "kind": "member",
    "name": "path",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#path",
    "access": "public",
    "description": "The field that triggered the validation error",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1680,
    "kind": "member",
    "name": "value",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#value",
    "access": "public",
    "description": "The value that generated the error",
    "lineNumber": 97,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1681,
    "kind": "member",
    "name": "origin",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#origin",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1682,
    "kind": "member",
    "name": "instance",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#instance",
    "access": "public",
    "description": "The DAO instance that caused the validation error",
    "lineNumber": 106,
    "type": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1683,
    "kind": "member",
    "name": "validatorKey",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#validatorKey",
    "access": "public",
    "description": "A validation \"key\", used for identification",
    "lineNumber": 113,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1684,
    "kind": "member",
    "name": "validatorName",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#validatorName",
    "access": "public",
    "description": "Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable",
    "lineNumber": 120,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1685,
    "kind": "member",
    "name": "validatorArgs",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#validatorArgs",
    "access": "public",
    "description": "Parameters used with the BUILT-IN validator function, if applicable",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1689,
    "kind": "method",
    "name": "getValidatorKey",
    "memberof": "lib/errors/validation-error.js~ValidationErrorItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/errors/validation-error.js~ValidationErrorItem#getValidatorKey",
    "access": "private",
    "description": "return a lowercase, trimmed string \"key\" that identifies the validator.\n\nNote: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property",
    "lineNumber": 160,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "useTypeAsNS",
        "description": "controls whether the returned value is \"namespace\",\n                                           this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'.'",
        "defaultRaw": "'.'",
        "name": "NSSeparator",
        "description": "a separator string for concatenating the namespace, must be not be empty,\n                                           defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "thrown if NSSeparator is found to be invalid."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1690,
    "kind": "file",
    "name": "lib/generic/falsy.js",
    "content": "var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\n__markAsModule(exports);\n//# sourceMappingURL=falsy.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/generic/falsy.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1691,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/generic/falsy.js",
    "static": true,
    "longname": "lib/generic/falsy.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/generic/falsy.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1692,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/generic/falsy.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/generic/falsy.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/generic/falsy.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1693,
    "kind": "file",
    "name": "lib/generic/sql-fragment.js",
    "content": "var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\n__markAsModule(exports);\n//# sourceMappingURL=sql-fragment.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/generic/sql-fragment.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1694,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/generic/sql-fragment.js",
    "static": true,
    "longname": "lib/generic/sql-fragment.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/generic/sql-fragment.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1695,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/generic/sql-fragment.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/generic/sql-fragment.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/generic/sql-fragment.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1696,
    "kind": "file",
    "name": "lib/hooks.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst { logger } = require('./utils/logger');\nconst Promise = require('./promise');\nconst debug = logger.debugContext('hooks');\n\nconst hookTypes = {\n  beforeValidate: { params: 2 },\n  afterValidate: { params: 2 },\n  validationFailed: { params: 3 },\n  beforeCreate: { params: 2 },\n  afterCreate: { params: 2 },\n  beforeDestroy: { params: 2 },\n  afterDestroy: { params: 2 },\n  beforeRestore: { params: 2 },\n  afterRestore: { params: 2 },\n  beforeUpdate: { params: 2 },\n  afterUpdate: { params: 2 },\n  beforeSave: { params: 2, proxies: ['beforeUpdate', 'beforeCreate'] },\n  afterSave: { params: 2, proxies: ['afterUpdate', 'afterCreate'] },\n  beforeUpsert: { params: 2 },\n  afterUpsert: { params: 2 },\n  beforeBulkCreate: { params: 2 },\n  afterBulkCreate: { params: 2 },\n  beforeBulkDestroy: { params: 1 },\n  afterBulkDestroy: { params: 1 },\n  beforeBulkRestore: { params: 1 },\n  afterBulkRestore: { params: 1 },\n  beforeBulkUpdate: { params: 1 },\n  afterBulkUpdate: { params: 1 },\n  beforeFind: { params: 1 },\n  beforeFindAfterExpandIncludeAll: { params: 1 },\n  beforeFindAfterOptions: { params: 1 },\n  afterFind: { params: 2 },\n  beforeCount: { params: 1 },\n  beforeDefine: { params: 2, sync: true, noModel: true },\n  afterDefine: { params: 1, sync: true, noModel: true },\n  beforeInit: { params: 2, sync: true, noModel: true },\n  afterInit: { params: 1, sync: true, noModel: true },\n  beforeAssociate: { params: 2, sync: true },\n  afterAssociate: { params: 2, sync: true },\n  beforeConnect: { params: 1, noModel: true },\n  afterConnect: { params: 2, noModel: true },\n  beforeDisconnect: { params: 1, noModel: true },\n  afterDisconnect: { params: 1, noModel: true },\n  beforeSync: { params: 1 },\n  afterSync: { params: 1 },\n  beforeBulkSync: { params: 1 },\n  afterBulkSync: { params: 1 },\n  beforeQuery: { params: 2 },\n  afterQuery: { params: 2 }\n};\nexports.hooks = hookTypes;\n\n\n/**\n * get array of current hook and its proxies combined\n *\n * @param {string} hookType any hook type @see {@link hookTypes}\n *\n * @private\n */\nconst getProxiedHooks = hookType =>\n  hookTypes[hookType].proxies\n    ? hookTypes[hookType].proxies.concat(hookType)\n    : [hookType]\n;\n\nfunction getHooks(hooked, hookType) {\n  return (hooked.options.hooks || {})[hookType] || [];\n}\n\nconst Hooks = {\n  /**\n   * Process user supplied hooks definition\n   *\n   * @param {Object} hooks hooks definition\n   *\n   * @private\n   * @memberof Sequelize\n   * @memberof Sequelize.Model\n   */\n  _setupHooks(hooks) {\n    this.options.hooks = {};\n    _.map(hooks || {}, (hooksArray, hookName) => {\n      if (!Array.isArray(hooksArray)) hooksArray = [hooksArray];\n      hooksArray.forEach(hookFn => this.addHook(hookName, hookFn));\n    });\n  },\n\n  runHooks(hooks, ...hookArgs) {\n    if (!hooks) throw new Error('runHooks requires at least 1 argument');\n\n    let hookType;\n\n    if (typeof hooks === 'string') {\n      hookType = hooks;\n      hooks = getHooks(this, hookType);\n\n      if (this.sequelize) {\n        hooks = hooks.concat(getHooks(this.sequelize, hookType));\n      }\n    }\n\n    if (!Array.isArray(hooks)) {\n      hooks = [hooks];\n    }\n\n    // synchronous hooks\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      for (let hook of hooks) {\n        if (typeof hook === 'object') {\n          hook = hook.fn;\n        }\n\n        debug(`running hook(sync) ${hookType}`);\n        hook.apply(this, hookArgs);\n      }\n      return;\n    }\n\n    // asynchronous hooks (default)\n    return Promise.each(hooks, hook => {\n      if (typeof hook === 'object') {\n        hook = hook.fn;\n      }\n\n      debug(`running hook ${hookType}`);\n      return hook.apply(this, hookArgs);\n    }).return();\n  },\n\n  /**\n   * Add a hook to the model\n   *\n   * @param {string}          hookType hook name @see {@link hookTypes}\n   * @param {string|Function} [name] Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.\n   * @param {Function}        fn The hook function\n   *\n   * @memberof Sequelize\n   * @memberof Sequelize.Model\n   */\n  addHook(hookType, name, fn) {\n    if (typeof name === 'function') {\n      fn = name;\n      name = null;\n    }\n\n    debug(`adding hook ${hookType}`);\n    // check for proxies, add them too\n    hookType = getProxiedHooks(hookType);\n\n    hookType.forEach(type => {\n      const hooks = getHooks(this, type);\n      hooks.push(name ? { name, fn } : fn);\n      this.options.hooks[type] = hooks;\n    });\n\n    return this;\n  },\n\n  /**\n   * Remove hook from the model\n   *\n   * @param {string} hookType @see {@link hookTypes}\n   * @param {string|Function} name name of hook or function reference which was attached\n   *\n   * @memberof Sequelize\n   * @memberof Sequelize.Model\n   */\n  removeHook(hookType, name) {\n    const isReference = typeof name === 'function' ? true : false;\n\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n\n    debug(`removing hook ${hookType}`);\n\n    // check for proxies, add them too\n    hookType = getProxiedHooks(hookType);\n\n    for (const type of hookType) {\n      this.options.hooks[type] = this.options.hooks[type].filter(hook => {\n        if (isReference && typeof hook === 'function') {\n          return hook !== name; // check if same method\n        }\n        if (!isReference && typeof hook === 'object') {\n          return hook.name !== name;\n        }\n        return true;\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * Check whether the mode has any hooks of this type\n   *\n   * @param {string} hookType @see {@link hookTypes}\n   *\n   * @alias hasHooks\n   *\n   * @memberof Sequelize\n   * @memberof Sequelize.Model\n   */\n  hasHook(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  }\n};\nHooks.hasHooks = Hooks.hasHook;\n\n\nfunction applyTo(target, isModel = false) {\n  _.mixin(target, Hooks);\n\n  for (const hook of Object.keys(hookTypes)) {\n    if (isModel && hookTypes[hook].noModel) {\n      continue;\n    }\n    target[hook] = function(name, callback) {\n      return this.addHook(hook, name, callback);\n    };\n  }\n}\nexports.applyTo = applyTo;\n\n/**\n * A hook that is run before validation\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeValidate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after validation\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterValidate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run when validation fails\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options, error. Error is the\n * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.\n * @name validationFailed\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before creating a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeCreate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after creating a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name afterCreate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeSave\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before upserting\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeUpsert\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after upserting\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with the result of upsert(), options\n * @name afterUpsert\n * @memberof Sequelize.Model\n */\n\n/**\n  * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`\n  * @param {string}   name\n  * @param {Function} fn   A callback function that is called with attributes, options\n  * @name afterSave\n  * @memberof Sequelize.Model\n  */\n\n/**\n * A hook that is run before destroying a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeDestroy\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after destroying a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterDestroy\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before restoring a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeRestore\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after restoring a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterRestore\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before updating a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeUpdate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after updating a single instance\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterUpdate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before creating instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name beforeBulkCreate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after creating instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name afterBulkCreate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before destroying instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkDestroy\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after destroying instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkDestroy\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before restoring instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkRestore\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after restoring instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkRestore\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before updating instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeBulkUpdate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after updating instances in bulk\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name afterBulkUpdate\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFind\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterExpandIncludeAll\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before a find (select) query, after all option parsing is complete\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterOptions\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run after a find (select) query\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with instance(s), options\n * @name afterFind\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before a count query\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeCount\n * @memberof Sequelize.Model\n */\n\n/**\n * A hook that is run before a define call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeDefine\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run after a define call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with factory\n * @name afterDefine\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run before Sequelize() call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with config, options\n * @name beforeInit\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run after Sequelize() call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with sequelize\n * @name afterInit\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run before a connection is created\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with config passed to connection\n * @name beforeConnect\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run after a connection is created\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with the connection object and the config passed to connection\n * @name afterConnect\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run before a connection is disconnected\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with the connection object\n * @name beforeDisconnect\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run after a connection is disconnected\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with the connection object\n * @name afterDisconnect\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run before Model.sync call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options passed to Model.sync\n * @name beforeSync\n * @memberof Sequelize\n */\n\n/**\n * A hook that is run after Model.sync call\n * @param {string}   name\n * @param {Function} fn   A callback function that is called with options passed to Model.sync\n * @name afterSync\n * @memberof Sequelize\n */\n\n/**\n  * A hook that is run before sequelize.sync call\n  * @param {string}   name\n  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n  * @name beforeBulkSync\n  * @memberof Sequelize\n  */\n\n/**\n  * A hook that is run after sequelize.sync call\n  * @param {string}   name\n  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n  * @name afterBulkSync\n  * @memberof Sequelize\n  */\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/hooks.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1697,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1698,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1699,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1700,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~debug",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1701,
    "kind": "variable",
    "name": "hookTypes",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~hookTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{\"beforeValidate\": *, \"afterValidate\": *, \"validationFailed\": *, \"beforeCreate\": *, \"afterCreate\": *, \"beforeDestroy\": *, \"afterDestroy\": *, \"beforeRestore\": *, \"afterRestore\": *, \"beforeUpdate\": *, \"afterUpdate\": *, \"beforeSave\": *, \"afterSave\": *, \"beforeUpsert\": *, \"afterUpsert\": *, \"beforeBulkCreate\": *, \"afterBulkCreate\": *, \"beforeBulkDestroy\": *, \"afterBulkDestroy\": *, \"beforeBulkRestore\": *, \"afterBulkRestore\": *, \"beforeBulkUpdate\": *, \"afterBulkUpdate\": *, \"beforeFind\": *, \"beforeFindAfterExpandIncludeAll\": *, \"beforeFindAfterOptions\": *, \"afterFind\": *, \"beforeCount\": *, \"beforeDefine\": *, \"afterDefine\": *, \"beforeInit\": *, \"afterInit\": *, \"beforeAssociate\": *, \"afterAssociate\": *, \"beforeConnect\": *, \"afterConnect\": *, \"beforeDisconnect\": *, \"afterDisconnect\": *, \"beforeSync\": *, \"afterSync\": *, \"beforeBulkSync\": *, \"afterBulkSync\": *, \"beforeQuery\": *, \"afterQuery\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1702,
    "kind": "function",
    "name": "getProxiedHooks",
    "memberof": "lib/hooks.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/hooks.js~getProxiedHooks",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": "get array of current hook and its proxies combined",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hookType",
        "description": "any hook type @see {@link hookTypes}"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1703,
    "kind": "function",
    "name": "getHooks",
    "memberof": "lib/hooks.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/hooks.js~getHooks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [
      {
        "name": "hooked",
        "types": [
          "*"
        ]
      },
      {
        "name": "hookType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1704,
    "kind": "variable",
    "name": "Hooks",
    "memberof": "lib/hooks.js",
    "static": true,
    "longname": "lib/hooks.js~Hooks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "{\"_setupHooks\": function, \"runHooks\": function, \"addHook\": function, \"removeHook\": function, \"hasHook\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1705,
    "kind": "function",
    "name": "applyTo",
    "memberof": "lib/hooks.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/hooks.js~applyTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/hooks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "isModel",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1706,
    "kind": "file",
    "name": "lib/index-hints.js",
    "content": "'use strict';\n\n/**\n * An enum of index hints to be used in mysql for querying with index hints\n *\n * @property USE\n * @property FORCE\n * @property IGNORE\n */\nconst IndexHints = module.exports = { // eslint-disable-line\n  USE: 'USE',\n  FORCE: 'FORCE',\n  IGNORE: 'IGNORE'\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/index-hints.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1707,
    "kind": "variable",
    "name": "IndexHints",
    "memberof": "lib/index-hints.js",
    "static": true,
    "longname": "lib/index-hints.js~IndexHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/index-hints.js",
    "importStyle": null,
    "description": "An enum of index hints to be used in mysql for querying with index hints",
    "lineNumber": 10,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "USE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "FORCE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "IGNORE",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1708,
    "kind": "file",
    "name": "lib/index.js",
    "content": "\"use strict\";\nmodule.exports = require(\"./sequelize\");\n//# sourceMappingURL=index.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1709,
    "kind": "file",
    "name": "lib/instance-validator.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst Promise = require('./promise');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {Object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = _.clone(options) || {};\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    }\n\n    // assign defined and default options\n    this.options = _.defaults(options, {\n      skip: [],\n      hooks: true\n    });\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    return Promise.all([\n      this._perAttributeValidators().reflect(),\n      this._customValidators().reflect()\n    ]).then(() => {\n      if (this.errors.length) {\n        throw new sequelizeError.ValidationError(null, this.errors);\n      }\n    });\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  validate() {\n    return this.options.hooks ? this._validateAndRunHooks() : this._validate();\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    return runHooks('beforeValidate', this.modelInstance, this.options)\n      .then(() =>\n        this._validate()\n          .catch(error => runHooks('validationFailed', this.modelInstance, this.options, error)\n            .then(newError => { throw newError || error; }))\n      )\n      .then(() => runHooks('afterValidate', this.modelInstance, this.options))\n      .return(this.modelInstance);\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().\n   * @private\n   */\n  _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull).reflect());\n      }\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().\n   * @private\n   */\n  _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {})\n        .reflect();\n\n      validators.push(valprom);\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return Promise.resolve();\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise.reflect());\n    });\n\n    return Promise\n      .all(validators)\n      .then(results => this._handleReflectedResult(field, value, results));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let validatorFunction = null; // the validation function to call\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      if (optAttrDefined) {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));\n      } else {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance));\n      }\n      return validatorFunction()\n        .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n    }\n    return Promise\n      .try(() => validator.call(this.modelInstance, invokeArgs))\n      .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {Object} An object with specific keys to invoke the validator.\n   */\n  _invokeBuiltinValidator(value, test, validatorType, field) {\n    return Promise.try(() => {\n      // Cast value as string to pass new Validator.js string requirement\n      const valueString = String(value);\n      // check if Validator knows that kind of validation test\n      if (typeof validator[validatorType] !== 'function') {\n        throw new Error(`Invalid validator function: ${validatorType}`);\n      }\n\n      const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n      if (!validator[validatorType](valueString, ...validatorArgs)) {\n        throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n      }\n    });\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {Object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = _.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n\n  /**\n   * Handles the returned result of a Promise.reflect.\n   *\n   * If errors are found it populates this.error.\n   *\n   * @param {string} field The attribute name.\n   * @param {string|number} value The data value.\n   * @param {Array<Promise.PromiseInspection>} promiseInspections objects.\n   *\n   * @private\n   */\n  _handleReflectedResult(field, value, promiseInspections) {\n    for (const promiseInspection of promiseInspections) {\n      if (promiseInspection.isRejected()) {\n        const rejection = promiseInspection.error();\n        const isBuiltIn = !!rejection.validatorName;\n\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * @define {string} The error key for arguments as passed by custom validators\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/instance-validator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1710,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1711,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1712,
    "kind": "variable",
    "name": "sequelizeError",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~sequelizeError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1713,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1714,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1715,
    "kind": "variable",
    "name": "BelongsTo",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1716,
    "kind": "variable",
    "name": "validator",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~validator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1717,
    "kind": "class",
    "name": "InstanceValidator",
    "memberof": "lib/instance-validator.js",
    "static": true,
    "longname": "lib/instance-validator.js~InstanceValidator",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/instance-validator.js",
    "importStyle": null,
    "description": "Instance Validator.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instance"
        ],
        "spread": false,
        "optional": false,
        "name": "modelInstance",
        "description": "The model instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "A dictionary with options."
      }
    ],
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1718,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1719,
    "kind": "member",
    "name": "options",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#options",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1720,
    "kind": "member",
    "name": "modelInstance",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#modelInstance",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1721,
    "kind": "member",
    "name": "validator",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#validator",
    "access": "private",
    "description": "Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`",
    "lineNumber": 40,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1722,
    "kind": "member",
    "name": "errors",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#errors",
    "access": "private",
    "description": " All errors will be stored here from the validations.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 1723,
    "kind": "member",
    "name": "inProgress",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#inProgress",
    "access": "private",
    "description": "",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 1724,
    "kind": "method",
    "name": "_validate",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_validate",
    "access": "private",
    "description": "The main entry point for the Validation module, invoke to start the dance.",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1726,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#validate",
    "access": "private",
    "description": "Invoke the Validation sequence and run validation hooks if defined\n  - Before Validation Model Hooks\n  - Validation\n  - On validation success: After Validation Model Hooks\n  - On validation failure: Validation Failed Model Hooks",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1727,
    "kind": "method",
    "name": "_validateAndRunHooks",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_validateAndRunHooks",
    "access": "private",
    "description": "Invoke the Validation sequence and run hooks\n  - Before Validation Model Hooks\n  - Validation\n  - On validation success: After Validation Model Hooks\n  - On validation failure: Validation Failed Model Hooks",
    "lineNumber": 103,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1728,
    "kind": "method",
    "name": "_perAttributeValidators",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_perAttributeValidators",
    "access": "private",
    "description": "Will run all the validators defined per attribute (built-in validators and custom validators)",
    "lineNumber": 121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect()."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array.<Promise.PromiseInspection>>"
      ],
      "spread": false,
      "description": "A promise from .reflect()."
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1729,
    "kind": "method",
    "name": "_customValidators",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_customValidators",
    "access": "private",
    "description": "Will run all the custom validators defined in the model's options.",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect()."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array.<Promise.PromiseInspection>>"
      ],
      "spread": false,
      "description": "A promise from .reflect()."
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1730,
    "kind": "method",
    "name": "_singleAttrValidate",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_singleAttrValidate",
    "access": "private",
    "description": "Validate a single attribute with all the defined built-in validators and custom validators.",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A promise, will always resolve, auto populates error on this.error local object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Anything."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "The field name."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "allowNull",
        "description": "Whether or not the schema allows null values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise, will always resolve, auto populates error on this.error local object."
    },
    "ignore": true
  },
  {
    "__docId__": 1731,
    "kind": "method",
    "name": "_invokeCustomValidator",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_invokeCustomValidator",
    "access": "private",
    "description": "Prepare and invoke a custom validator.",
    "lineNumber": 241,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "validator",
        "description": "The custom validator."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "validatorType",
        "description": "the custom validator type (name)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "optAttrDefined",
        "description": "Set to true if custom validator was defined from the attribute"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "optValue",
        "description": "value for attribute"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "optField",
        "description": "field for attribute"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise."
    },
    "ignore": true
  },
  {
    "__docId__": 1732,
    "kind": "method",
    "name": "_invokeBuiltinValidator",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_invokeBuiltinValidator",
    "access": "private",
    "description": "Prepare and invoke a build-in validator.",
    "lineNumber": 285,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} An object with specific keys to invoke the validator."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Anything."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "The test case."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "validatorType",
        "description": "One of known to Sequelize validators."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "The field that is being validated"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An object with specific keys to invoke the validator."
    },
    "ignore": true
  },
  {
    "__docId__": 1733,
    "kind": "method",
    "name": "_extractValidatorArgs",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_extractValidatorArgs",
    "access": "private",
    "description": "Will extract arguments for the validator.",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "The test case."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "validatorType",
        "description": "One of known to Sequelize validators."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "The field that is being validated."
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1734,
    "kind": "method",
    "name": "_validateSchema",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_validateSchema",
    "access": "private",
    "description": "Will validate a single field against its schema definition (isnull).",
    "lineNumber": 338,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "rawAttribute",
        "description": "As defined in the Schema."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "The field name."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "anything."
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1735,
    "kind": "method",
    "name": "_handleReflectedResult",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_handleReflectedResult",
    "access": "private",
    "description": "Handles the returned result of a Promise.reflect.\n\nIf errors are found it populates this.error.",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "The attribute name."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The data value."
      },
      {
        "nullable": null,
        "types": [
          "Array<Promise.PromiseInspection>"
        ],
        "spread": false,
        "optional": false,
        "name": "promiseInspections",
        "description": "objects."
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1736,
    "kind": "method",
    "name": "_pushError",
    "memberof": "lib/instance-validator.js~InstanceValidator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/instance-validator.js~InstanceValidator#_pushError",
    "access": "private",
    "description": "Signs all errors retaining the original.",
    "lineNumber": 405,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isBuiltin",
        "description": "Determines if error is from builtin validator."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "errorKey",
        "description": "name of invalid attribute."
      },
      {
        "nullable": null,
        "types": [
          "Error",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rawError",
        "description": "The original error."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The data that triggered the error."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fnName",
        "description": "Name of the validator, if any"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "fnArgs",
        "description": "Arguments for the validator [function], if any"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1737,
    "kind": "file",
    "name": "lib/model-manager.js",
    "content": "'use strict';\n\nconst Toposort = require('toposort-class');\nconst _ = require('lodash');\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: 'name'\n    });\n\n    return this.models.find(model => model[options.attribute] === against);\n  }\n\n  get all() {\n    return this.models;\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables.\n   * Will take foreign key constraints into account so that dependencies are visited before dependents.\n   *\n   * @param {Function} iterator method to execute on each model\n   * @param {Object} [options] iterator options\n   * @private\n   */\n  forEachModel(iterator, options) {\n    const models = {};\n    const sorter = new Toposort();\n    let sorted;\n    let dep;\n\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      models[tableName] = model;\n\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    sorted = sorter.sort();\n    if (options.reverse) {\n      sorted = sorted.reverse();\n    }\n    for (const name of sorted) {\n      iterator(models[name], name);\n    }\n  }\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/model-manager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1738,
    "kind": "variable",
    "name": "Toposort",
    "memberof": "lib/model-manager.js",
    "static": true,
    "longname": "lib/model-manager.js~Toposort",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1739,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/model-manager.js",
    "static": true,
    "longname": "lib/model-manager.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/model-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1740,
    "kind": "class",
    "name": "ModelManager",
    "memberof": "lib/model-manager.js",
    "static": true,
    "longname": "lib/model-manager.js~ModelManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model-manager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1741,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1742,
    "kind": "member",
    "name": "models",
    "memberof": "lib/model-manager.js~ModelManager",
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#models",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1743,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/model-manager.js~ModelManager",
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1744,
    "kind": "method",
    "name": "addModel",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#addModel",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1745,
    "kind": "method",
    "name": "removeModel",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#removeModel",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "modelToRemove",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1747,
    "kind": "method",
    "name": "getModel",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#getModel",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "against",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1748,
    "kind": "get",
    "name": "all",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#all",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1749,
    "kind": "method",
    "name": "forEachModel",
    "memberof": "lib/model-manager.js~ModelManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model-manager.js~ModelManager#forEachModel",
    "access": "private",
    "description": "Iterate over Models in an order suitable for e.g. creating tables.\nWill take foreign key constraints into account so that dependencies are visited before dependents.",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": "method to execute on each model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "iterator options"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1750,
    "kind": "file",
    "name": "lib/model.js",
    "content": "'use strict';\n\nconst assert = require('assert');\nconst _ = require('lodash');\nconst Dottie = require('dottie');\n\nconst Utils = require('./utils');\nconst { logger } = require('./utils/logger');\nconst BelongsTo = require('./associations/belongs-to');\nconst BelongsToMany = require('./associations/belongs-to-many');\nconst InstanceValidator = require('./instance-validator');\nconst QueryTypes = require('./query-types');\nconst sequelizeErrors = require('./errors');\nconst Promise = require('./promise');\nconst Association = require('./associations/base');\nconst HasMany = require('./associations/has-many');\nconst DataTypes = require('./data-types');\nconst Hooks = require('./hooks');\nconst associationsMixin = require('./associations/mixin');\nconst Op = require('./operators');\nconst { noDoubleNestedGroup } = require('./utils/deprecations');\n\n\n// This list will quickly become dated, but failing to maintain this list just means\n// we won't throw a warning when we should. At least most common cases will forever be covered\n// so we stop throwing erroneous warnings when we shouldn't.\nconst validQueryKeywords = new Set(['where', 'attributes', 'paranoid', 'include', 'order', 'limit', 'offset',\n  'transaction', 'lock', 'raw', 'logging', 'benchmark', 'having', 'searchPath', 'rejectOnEmpty', 'plain',\n  'scope', 'group', 'through', 'defaults', 'distinct', 'primary', 'exception', 'type', 'hooks', 'force',\n  'name']);\n\n// List of attributes that should not be implicitly passed into subqueries/includes.\nconst nonCascadingOptions = ['include', 'attributes', 'originalAttributes', 'order', 'where', 'limit', 'offset', 'plain', 'group', 'having'];\n\n/**\n * A Model represents a table in the database. Instances of this class represent a database row.\n *\n * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.\n * By default, the values from dataValues can also be accessed directly from the Instance, that is:\n * ```js\n * instance.field\n * // is the same as\n * instance.get('field')\n * // is the same as\n * instance.getDataValue('field')\n * ```\n * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.\n * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.\n *\n * @see\n   * {@link Sequelize#define} for more information about getters and setters\n * @mixes Hooks\n */\nclass Model {\n  static get QueryInterface() {\n    return this.sequelize.getQueryInterface();\n  }\n\n  static get QueryGenerator() {\n    return this.QueryInterface.QueryGenerator;\n  }\n\n  /**\n   * A reference to the sequelize instance\n   *\n   * @see\n   * {@link Sequelize}\n   *\n   * @property sequelize\n   *\n   * @returns {Sequelize}\n   */\n  get sequelize() {\n    return this.constructor.sequelize;\n  }\n\n  /**\n   * Builds a new model instance.\n   *\n   * @param {Object}  [values={}] an object of key value pairs\n   * @param {Object}  [options] instance construction options\n   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {boolean} [options.isNewRecord=true] Is this a new record\n   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   */\n  constructor(values = {}, options = {}) {\n    options = Object.assign({\n      isNewRecord: true,\n      _schema: this.constructor._schema,\n      _schemaDelimiter: this.constructor._schemaDelimiter\n    }, options || {});\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n\n    if (!options.includeValidated) {\n      this.constructor._conformIncludes(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        this.constructor._validateIncludedElements(options);\n      }\n    }\n\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this._changed = {};\n    this._modelOptions = this.constructor.options;\n    this._options = options || {};\n\n    /**\n     * Returns true if this instance has not yet been persisted to the database\n     * @property isNewRecord\n     * @returns {boolean}\n     */\n    this.isNewRecord = options.isNewRecord;\n\n    this._initValues(values, options);\n  }\n\n  _initValues(values, options) {\n    let defaults;\n    let key;\n\n    values = values && _.clone(values) || {};\n\n    if (options.isNewRecord) {\n      defaults = {};\n\n      if (this.constructor._hasDefaultValues) {\n        defaults = _.mapValues(this.constructor._defaultValues, valueFn => {\n          const value = valueFn();\n          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);\n        });\n      }\n\n      // set id to null if not passed as value, a newly created dao has no id\n      // removing this breaks bulkCreate\n      // do after default values since it might have UUID as a default value\n      if (this.constructor.primaryKeyAttributes.length) {\n        this.constructor.primaryKeyAttributes.forEach(primaryKeyAttribute => {\n          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {\n            defaults[primaryKeyAttribute] = null;\n          }\n        });\n      }\n\n      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {\n        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.createdAt];\n      }\n\n      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.updatedAt];\n      }\n\n      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.deletedAt];\n      }\n\n      if (Object.keys(defaults).length) {\n        for (key in defaults) {\n          if (values[key] === undefined) {\n            this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });\n            delete values[key];\n          }\n        }\n      }\n    }\n\n    this.set(values, options);\n  }\n\n  // validateIncludedElements should have been called before this method\n  static _paranoidClause(model, options = {}) {\n    // Apply on each include\n    // This should be handled before handling where conditions because of logic with returns\n    // otherwise this code will never run on includes of a already conditionable where\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n\n    // apply paranoid when groupedLimit is used\n    if (_.get(options, 'groupedLimit.on.options.paranoid')) {\n      const throughModel = _.get(options, 'groupedLimit.on.through.model');\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);\n      }\n    }\n\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      // This model is not paranoid, nothing to do here;\n      return options;\n    }\n\n    const deletedAtCol = model._timestampAttributes.deletedAt;\n    const deletedAtAttribute = model.rawAttributes[deletedAtCol];\n    const deletedAtObject = {};\n\n    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n    deletedAtDefaultValue = deletedAtDefaultValue || {\n      [Op.eq]: null\n    };\n\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n\n    if (Utils.isWhereEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { [Op.and]: [deletedAtObject, options.where] };\n    }\n\n    return options;\n  }\n\n  static _addDefaultAttributes() {\n    const tail = {};\n    let head = {};\n\n    // Add id if no primary key was manually added to definition\n    // Can't use this.primaryKeys here, since this function is called before PKs are identified\n    if (!_.some(this.rawAttributes, 'primaryKey')) {\n      if ('id' in this.rawAttributes) {\n        // Something is fishy here!\n        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);\n      }\n\n      head = {\n        id: {\n          type: new DataTypes.INTEGER(),\n          allowNull: false,\n          primaryKey: true,\n          autoIncrement: true,\n          _autoGenerated: true\n        }\n      };\n    }\n\n    if (this._timestampAttributes.createdAt) {\n      tail[this._timestampAttributes.createdAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._timestampAttributes.updatedAt) {\n      tail[this._timestampAttributes.updatedAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._timestampAttributes.deletedAt) {\n      tail[this._timestampAttributes.deletedAt] = {\n        type: DataTypes.DATE,\n        _autoGenerated: true\n      };\n    }\n\n    if (this._versionAttribute) {\n      tail[this._versionAttribute] = {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n        defaultValue: 0,\n        _autoGenerated: true\n      };\n    }\n\n    const existingAttributes = _.clone(this.rawAttributes);\n    this.rawAttributes = {};\n\n    _.each(head, (value, attr) => {\n      this.rawAttributes[attr] = value;\n    });\n\n    _.each(existingAttributes, (value, attr) => {\n      this.rawAttributes[attr] = value;\n    });\n\n    _.each(tail, (value, attr) => {\n      if (this.rawAttributes[attr] === undefined) {\n        this.rawAttributes[attr] = value;\n      }\n    });\n\n    if (!Object.keys(this.primaryKeys).length) {\n      this.primaryKeys.id = this.rawAttributes.id;\n    }\n  }\n\n  static _findAutoIncrementAttribute() {\n    this.autoIncrementAttribute = null;\n\n    for (const name in this.rawAttributes) {\n      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {\n        const definition = this.rawAttributes[name];\n        if (definition && definition.autoIncrement) {\n          if (this.autoIncrementAttribute) {\n            throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');\n          }\n          this.autoIncrementAttribute = name;\n        }\n      }\n    }\n  }\n\n  static _conformIncludes(options, self) {\n    if (!options.include) return;\n\n    // if include is not an array, wrap in an array\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (!options.include.length) {\n      delete options.include;\n      return;\n    }\n\n    // convert all included elements to { model: Model } form\n    options.include = options.include.map(include => this._conformInclude(include, self));\n  }\n\n  static _transformStringAssociation(include, self) {\n    if (self && typeof include === 'string') {\n      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {\n        throw new Error(`Association with alias \"${include}\" does not exist on ${self.name}`);\n      }\n      return self.associations[include];\n    }\n    return include;\n  }\n\n  static _conformInclude(include, self) {\n    if (include) {\n      let model;\n\n      if (include._pseudo) return include;\n\n      include = this._transformStringAssociation(include, self);\n\n      if (include instanceof Association) {\n        if (self && include.target.name === self.name) {\n          model = include.source;\n        } else {\n          model = include.target;\n        }\n\n        return { model, association: include, as: include.as };\n      }\n\n      if (include.prototype && include.prototype instanceof Model) {\n        return { model: include };\n      }\n\n      if (_.isPlainObject(include)) {\n        if (include.association) {\n          include.association = this._transformStringAssociation(include.association, self);\n\n          if (self && include.association.target.name === self.name) {\n            model = include.association.source;\n          } else {\n            model = include.association.target;\n          }\n\n          if (!include.model) include.model = model;\n          if (!include.as) include.as = include.association.as;\n\n          this._conformIncludes(include, model);\n          return include;\n        }\n\n        if (include.model) {\n          this._conformIncludes(include, include.model);\n          return include;\n        }\n\n        if (include.all) {\n          this._conformIncludes(include);\n          return include;\n        }\n      }\n    }\n\n    throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');\n  }\n\n  static _expandIncludeAllElement(includes, include) {\n    // check 'all' attribute provided is valid\n    let all = include.all;\n    delete include.all;\n\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: ['BelongsTo', 'HasOne'],\n        Has: ['HasOne', 'HasMany'],\n        Many: ['HasMany']\n      };\n\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === 'All') {\n          all = true;\n          break;\n        }\n\n        const types = validTypes[type];\n        if (!types) {\n          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);\n        }\n\n        if (types !== true) {\n          // replace type placeholder e.g. 'One' with its constituent types e.g. 'HasOne', 'BelongsTo'\n          all.splice(i, 1);\n          i--;\n          for (let j = 0; j < types.length; j++) {\n            if (!all.includes(types[j])) {\n              all.unshift(types[j]);\n              i++;\n            }\n          }\n        }\n      }\n    }\n\n    // add all associations of types specified to includes\n    const nested = include.nested;\n    if (nested) {\n      delete include.nested;\n\n      if (!include.include) {\n        include.include = [];\n      } else if (!Array.isArray(include.include)) {\n        include.include = [include.include];\n      }\n    }\n\n    const used = [];\n    (function addAllIncludes(parent, includes) {\n      _.forEach(parent.associations, association => {\n        if (all !== true && !all.includes(association.associationType)) {\n          return;\n        }\n\n        // check if model already included, and skip if so\n        const model = association.target;\n        const as = association.options.as;\n\n        const predicate = { model };\n        if (as) {\n          // We only add 'as' to the predicate if it actually exists\n          predicate.as = as;\n        }\n\n        if (_.some(includes, predicate)) {\n          return;\n        }\n\n        // skip if recursing over a model already nested\n        if (nested && used.includes(model)) {\n          return;\n        }\n        used.push(parent);\n\n        // include this model\n        const thisInclude = Utils.cloneDeep(include);\n        thisInclude.model = model;\n        if (as) {\n          thisInclude.as = as;\n        }\n        includes.push(thisInclude);\n\n        // run recursively if nested\n        if (nested) {\n          addAllIncludes(model, thisInclude.include);\n          if (thisInclude.include.length === 0) delete thisInclude.include;\n        }\n      });\n      used.pop();\n    })(this, includes);\n  }\n\n  static _validateIncludedElements(options, tableNames) {\n    if (!options.model) options.model = this;\n\n    tableNames = tableNames || {};\n    options.includeNames = [];\n    options.includeMap = {};\n\n    /* Legacy */\n    options.hasSingleAssociation = false;\n    options.hasMultiAssociation = false;\n\n    if (!options.parent) {\n      options.topModel = options.model;\n      options.topLimit = options.limit;\n    }\n\n    options.include = options.include.map(include => {\n      include = this._conformInclude(include);\n      include.parent = options;\n      include.topLimit = options.topLimit;\n\n      this._validateIncludedElement.call(options.model, include, tableNames, options);\n\n      if (include.duplicating === undefined) {\n        include.duplicating = include.association.isMultiAssociation;\n      }\n\n      include.hasDuplicating = include.hasDuplicating || include.duplicating;\n      include.hasRequired = include.hasRequired || include.required;\n\n      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n      options.hasRequired = options.hasRequired || include.required;\n\n      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n      return include;\n    });\n\n    for (const include of options.include) {\n      include.hasParentWhere = options.hasParentWhere || !!options.where;\n      include.hasParentRequired = options.hasParentRequired || !!options.required;\n\n      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n        if (include.duplicating) {\n          include.subQuery = false;\n          include.subQueryFilter = include.hasRequired;\n        } else {\n          include.subQuery = include.hasRequired;\n          include.subQueryFilter = false;\n        }\n      } else {\n        include.subQuery = include.subQuery || false;\n        if (include.duplicating) {\n          include.subQueryFilter = include.subQuery;\n          include.subQuery = false;\n        } else {\n          include.subQueryFilter = false;\n          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\n        }\n      }\n\n      options.includeMap[include.as] = include;\n      options.includeNames.push(include.as);\n\n      // Set top level options\n      if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {\n        if (include.subQuery) {\n          options.subQuery = include.subQuery;\n        } else if (include.hasDuplicating) {\n          options.subQuery = true;\n        }\n      }\n\n      /* Legacy */\n      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n\n      if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n        options.hasMultiAssociation = true;\n      }\n      if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n        options.hasSingleAssociation = true;\n      }\n    }\n\n    if (options.topModel === options.model && options.subQuery === undefined) {\n      options.subQuery = false;\n    }\n    return options;\n  }\n\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.getTableName()] = true;\n\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n\n      include.originalAttributes = this._injectDependentVirtualAttributes(include.attributes);\n\n      include = Utils.mapFinderOptions(include, include.model);\n\n      if (include.attributes.length) {\n        _.each(include.model.primaryKeys, (attr, key) => {\n          // Include the primary key if it's not already included - take into account that the pk might be aliased (due to a .field prop)\n          if (!include.attributes.some(includeAttr => {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = Utils.mapFinderOptions(include, include.model);\n    }\n\n    // pseudo include just needed the attribute logic, return\n    if (include._pseudo) {\n      if (!include.attributes) {\n        include.attributes = Object.keys(include.model.tableAttributes);\n      }\n      return Utils.mapFinderOptions(include, include.model);\n    }\n\n    // check if the current Model is actually associated with the passed Model - or it's a pseudo include\n    const association = include.association || this._getIncludedAssociation(include.model, include.as);\n\n    include.association = association;\n    include.as = association.as;\n\n    // If through, we create a pseudo child include, to ease our parsing later on\n    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n      if (!include.include) include.include = [];\n      const through = include.association.through;\n\n      include.through = _.defaults(include.through || {}, {\n        model: through.model,\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true\n        },\n        _pseudo: true,\n        parent: include\n      });\n\n\n      if (through.scope) {\n        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;\n      }\n\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n\n    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source\n    let model;\n    if (include.model.scoped === true) {\n      // If the passed model is already scoped, keep that\n      model = include.model;\n    } else {\n      // Otherwise use the model that was originally passed to the association\n      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n    }\n\n    model._injectScope(include);\n\n    // This check should happen after injecting the scope, since the scope may contain a .attributes\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n\n    include = Utils.mapFinderOptions(include, include.model);\n\n    if (include.required === undefined) {\n      include.required = !!include.where;\n    }\n\n    if (include.association.scope) {\n      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;\n    }\n\n    if (include.limit && include.separate === undefined) {\n      include.separate = true;\n    }\n\n    if (include.separate === true) {\n      if (!(include.association instanceof HasMany)) {\n        throw new Error('Only HasMany associations support include.separate');\n      }\n\n      include.duplicating = false;\n\n      if (\n        options.attributes\n        && options.attributes.length\n        && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)\n      ) {\n        options.attributes.push(association.sourceKey);\n      }\n\n      if (\n        include.attributes\n        && include.attributes.length\n        && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)\n      ) {\n        include.attributes.push(association.foreignKey);\n      }\n    }\n\n    // Validate child includes\n    if (Object.prototype.hasOwnProperty.call(include, 'include')) {\n      this._validateIncludedElements.call(include.model, include, tableNames);\n    }\n\n    return include;\n  }\n\n  static _getIncludedAssociation(targetModel, targetAlias) {\n    const associations = this.getAssociations(targetModel);\n    let association = null;\n    if (associations.length === 0) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);\n    }\n    if (associations.length === 1) {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (association) {\n        return association;\n      }\n      if (targetAlias) {\n        const existingAliases = this.getAssociations(targetModel).map(association => association.as);\n        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +\n          `You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(', ')}).`);\n      }\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +\n        'You must use the \\'as\\' keyword to specify the alias within your include statement.');\n    }\n    association = this.getAssociationForAlias(targetModel, targetAlias);\n    if (!association) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. ` +\n        'To identify the correct association, you must use the \\'as\\' keyword to specify the alias of the association you want to include.');\n    }\n    return association;\n  }\n\n\n  static _expandIncludeAll(options) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n\n        this._expandIncludeAllElement(includes, include);\n      }\n    }\n\n    includes.forEach(include => {\n      this._expandIncludeAll.call(include.model, include);\n    });\n  }\n\n  static _conformIndex(index) {\n    if (!index.fields) {\n      throw new Error('Missing \"fields\" property for index definition');\n    }\n\n    index = _.defaults(index, {\n      type: '',\n      parser: null\n    });\n\n    if (index.type && index.type.toLowerCase() === 'unique') {\n      index.unique = true;\n      delete index.type;\n    }\n\n    return index;\n  }\n\n\n  static _uniqIncludes(options) {\n    if (!options.include) return;\n\n    options.include = _(options.include)\n      .groupBy(include => `${include.model && include.model.name}-${include.as}`)\n      .map(includes => this._assignOptions(...includes))\n      .value();\n  }\n\n  static _baseMerge(...args) {\n    _.assignWith(...args);\n    this._conformIncludes(args[0], this);\n    this._uniqIncludes(args[0]);\n    return args[0];\n  }\n\n  static _mergeFunction(objValue, srcValue, key) {\n    if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n      return _.union(objValue, srcValue);\n    }\n    if (key === 'where' || key === 'having') {\n      if (srcValue instanceof Utils.SequelizeMethod) {\n        srcValue = { [Op.and]: srcValue };\n      }\n      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n    } else if (key === 'attributes' && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n      return _.assignWith(objValue, srcValue, (objValue, srcValue) => {\n        if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n          return _.union(objValue, srcValue);\n        }\n      });\n    }\n    // If we have a possible object/array to clone, we try it.\n    // Otherwise, we return the original value when it's not undefined,\n    // or the resulting object in that case.\n    if (srcValue) {\n      return Utils.cloneDeep(srcValue, true);\n    }\n    return srcValue === undefined ? objValue : srcValue;\n  }\n\n  static _assignOptions(...args) {\n    return this._baseMerge(...args, this._mergeFunction);\n  }\n\n  static _defaultsOptions(target, opts) {\n    return this._baseMerge(target, opts, (srcValue, objValue, key) => {\n      return this._mergeFunction(objValue, srcValue, key);\n    });\n  }\n\n  /**\n   * Initialize a model, representing a table in the DB, with attributes and options.\n   *\n   * The table columns are defined by the hash that is given as the first argument.\n   * Each attribute of the hash represents a column.\n   *\n   * For more about <a href=\"/manual/tutorial/models-definition.html#validations\"/>Validations</a>\n   *\n   * More examples, <a href=\"/manual/tutorial/models-definition.html\"/>Model Definition</a>\n   *\n   * @example\n   * Project.init({\n   *   columnA: {\n   *     type: Sequelize.BOOLEAN,\n   *     validate: {\n   *       is: ['[a-z]','i'],        // will only allow letters\n   *       max: 23,                  // only allow values <= 23\n   *       isIn: {\n   *         args: [['en', 'zh']],\n   *         msg: \"Must be English or Chinese\"\n   *       }\n   *     },\n   *     field: 'column_a'\n   *     // Other attributes here\n   *   },\n   *   columnB: Sequelize.STRING,\n   *   columnC: 'MY VERY OWN COLUMN TYPE'\n   * }, {sequelize})\n   *\n   * sequelize.models.modelName // The model will now be available in models under the class name\n   *\n   * @see\n   * {@link DataTypes}\n   * @see\n   * {@link Hooks}\n   *\n   * @param {Object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:\n   * @param {string|DataTypes|Object} attributes.column The description of a database column\n   * @param {string|DataTypes}        attributes.column.type A string or a data type\n   * @param {boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.\n   * @param {any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)\n   * @param {string|boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index\n   * @param {boolean}                 [attributes.column.primaryKey=false] If true, this attribute will be marked as primary key\n   * @param {string}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database\n   * @param {boolean}                 [attributes.column.autoIncrement=false] If true, this column will be set to auto increment\n   * @param {boolean}                 [attributes.column.autoIncrementIdentity=false] If true, combined with autoIncrement=true, will use Postgres `GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL`. Postgres 10+ only.\n   * @param {string}                  [attributes.column.comment=null] Comment for this column\n   * @param {string|Model}            [attributes.column.references=null] An object with reference configurations\n   * @param {string|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string\n   * @param {string}                  [attributes.column.references.key='id'] The column of the foreign table that this column references\n   * @param {string}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n   * @param {string}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n   * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.\n   * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.\n   * @param {Object}                  [attributes.column.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field and the instance itself as the `this` binding, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation; if it is async, the callback should be called with the error text.\n   * @param {Object}                  options These options are merged with the default define options provided to the Sequelize constructor\n   * @param {Object}                  options.sequelize Define the sequelize instance to attach to the new Model. Throw error if none is provided.\n   * @param {string}                  [options.modelName] Set name of the model. By default its same as Class name.\n   * @param {Object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll\n   * @param {Object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them\n   * @param {boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved\n   * @param {boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.\n   * @param {boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work\n   * @param {boolean}                 [options.underscored=false] Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set `field` option\n   * @param {boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized\n   * @param {Object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.\n   * @param {string}                  [options.name.singular=Utils.singularize(modelName)] Singular name for model\n   * @param {string}                  [options.name.plural=Utils.pluralize(modelName)] Plural name for model\n   * @param {Array<Object>}           [options.indexes] indexes definitions\n   * @param {string}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated\n   * @param {string}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`\n   * @param {string}                  [options.indexes[].using] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.\n   * @param {string}                  [options.indexes[].operator] Specify index operator.\n   * @param {boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`\n   * @param {boolean}                 [options.indexes[].concurrently=false] PostgresSQL will build the index without taking any write locks. Postgres only\n   * @param {Array<string|Object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)\n   * @param {string|boolean}          [options.createdAt] Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.\n   * @param {string|boolean}          [options.updatedAt] Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.\n   * @param {string|boolean}          [options.deletedAt] Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.\n   * @param {string}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim\n   * @param {string}                  [options.schema='public'] schema\n   * @param {string}                  [options.engine] Specify engine for model's table\n   * @param {string}                  [options.charset] Specify charset for model's table\n   * @param {string}                  [options.comment] Specify comment for model's table\n   * @param {string}                  [options.collate] Specify collation for model's table\n   * @param {string}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.\n   * @param {Object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, beforeSave, afterDestroy, afterUpdate, afterBulkCreate, afterSave, afterBulkDestroy and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.\n   * @param {Object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.\n   *\n   * @returns {Model}\n   */\n  static init(attributes, options = {}) {\n    if (!options.sequelize) {\n      throw new Error('No Sequelize instance passed');\n    }\n\n    this.sequelize = options.sequelize;\n\n    const globalOptions = this.sequelize.options;\n\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n\n    if (!options.modelName) {\n      options.modelName = this.name;\n    }\n\n    options = Utils.merge({\n      name: {\n        plural: Utils.pluralize(options.modelName),\n        singular: Utils.singularize(options.modelName)\n      },\n      indexes: [],\n      omitNull: globalOptions.omitNull,\n      schema: globalOptions.schema\n    }, options);\n\n    this.sequelize.runHooks('beforeDefine', attributes, options);\n\n    if (options.modelName !== this.name) {\n      Object.defineProperty(this, 'name', { value: options.modelName });\n    }\n    delete options.modelName;\n\n    this.options = Object.assign({\n      timestamps: true,\n      validate: {},\n      freezeTableName: false,\n      underscored: false,\n      paranoid: false,\n      rejectOnEmpty: false,\n      whereCollection: null,\n      schema: null,\n      schemaDelimiter: '',\n      defaultScope: {},\n      scopes: {},\n      indexes: []\n    }, options);\n\n    // if you call \"define\" multiple times for the same modelName, do not clutter the factory\n    if (this.sequelize.isDefined(this.name)) {\n      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));\n    }\n\n    this.associations = {};\n    this._setupHooks(options.hooks);\n\n    this.underscored = this.options.underscored;\n\n    if (!this.options.tableName) {\n      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);\n    } else {\n      this.tableName = this.options.tableName;\n    }\n\n    this._schema = this.options.schema;\n    this._schemaDelimiter = this.options.schemaDelimiter;\n\n    // error check options\n    _.each(options.validate, (validator, validatorType) => {\n      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {\n        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);\n      }\n\n      if (typeof validator !== 'function') {\n        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);\n      }\n    });\n\n    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {\n      attribute = this.sequelize.normalizeAttribute(attribute);\n\n      if (attribute.type === undefined) {\n        throw new Error(`Unrecognized datatype for attribute \"${this.name}.${name}\"`);\n      }\n\n      if (attribute.allowNull !== false && _.get(attribute, 'validate.notNull')) {\n        throw new Error(`Invalid definition for \"${this.name}.${name}\", \"notNull\" validator is only allowed with \"allowNull:false\"`);\n      }\n\n      if (_.get(attribute, 'references.model.prototype') instanceof Model) {\n        attribute.references.model = attribute.references.model.getTableName();\n      }\n\n      return attribute;\n    });\n\n    const tableName = this.getTableName();\n    this._indexes = this.options.indexes\n      .map(index => Utils.nameIndex(this._conformIndex(index), tableName));\n\n    this.primaryKeys = {};\n    this._readOnlyAttributes = new Set();\n    this._timestampAttributes = {};\n\n    // setup names of timestamp attributes\n    if (this.options.timestamps) {\n      if (this.options.createdAt !== false) {\n        this._timestampAttributes.createdAt = this.options.createdAt || 'createdAt';\n        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);\n      }\n      if (this.options.updatedAt !== false) {\n        this._timestampAttributes.updatedAt = this.options.updatedAt || 'updatedAt';\n        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);\n      }\n      if (this.options.paranoid && this.options.deletedAt !== false) {\n        this._timestampAttributes.deletedAt = this.options.deletedAt || 'deletedAt';\n        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);\n      }\n    }\n\n    // setup name for version attribute\n    if (this.options.version) {\n      this._versionAttribute = typeof this.options.version === 'string' ? this.options.version : 'version';\n      this._readOnlyAttributes.add(this._versionAttribute);\n    }\n\n    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;\n\n    // Add head and tail default attributes (id, timestamps)\n    this._addDefaultAttributes();\n    this.refreshAttributes();\n    this._findAutoIncrementAttribute();\n\n    this._scope = this.options.defaultScope;\n    this._scopeNames = ['defaultScope'];\n\n    this.sequelize.modelManager.addModel(this);\n    this.sequelize.runHooks('afterDefine', this);\n\n    return this;\n  }\n\n  static refreshAttributes() {\n    const attributeManipulation = {};\n\n    this.prototype._customGetters = {};\n    this.prototype._customSetters = {};\n\n    ['get', 'set'].forEach(type => {\n      const opt = `${type}terMethods`;\n      const funcs = _.clone(_.isObject(this.options[opt]) ? this.options[opt] : {});\n      const _custom = type === 'get' ? this.prototype._customGetters : this.prototype._customSetters;\n\n      _.each(funcs, (method, attribute) => {\n        _custom[attribute] = method;\n\n        if (type === 'get') {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === 'set') {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n\n      _.each(this.rawAttributes, (options, attribute) => {\n        if (Object.prototype.hasOwnProperty.call(options, type)) {\n          _custom[attribute] = options[type];\n        }\n\n        if (type === 'get') {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === 'set') {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n\n      _.each(funcs, (fct, name) => {\n        if (!attributeManipulation[name]) {\n          attributeManipulation[name] = {\n            configurable: true\n          };\n        }\n        attributeManipulation[name][type] = fct;\n      });\n    });\n\n    this._dataTypeChanges = {};\n    this._dataTypeSanitizers = {};\n\n    this._hasBooleanAttributes = false;\n    this._hasDateAttributes = false;\n    this._jsonAttributes = new Set();\n    this._virtualAttributes = new Set();\n    this._defaultValues = {};\n    this.prototype.validators = {};\n\n    this.fieldRawAttributesMap = {};\n\n    this.primaryKeys = {};\n    this.uniqueKeys = {};\n\n    _.each(this.rawAttributes, (definition, name) => {\n      definition.type = this.sequelize.normalizeDataType(definition.type);\n\n      definition.Model = this;\n      definition.fieldName = name;\n      definition._modelAttribute = true;\n\n      if (definition.field === undefined) {\n        definition.field = Utils.underscoredIf(name, this.underscored);\n      }\n\n      if (definition.primaryKey === true) {\n        this.primaryKeys[name] = definition;\n      }\n\n      this.fieldRawAttributesMap[definition.field] = definition;\n\n      if (definition.type._sanitize) {\n        this._dataTypeSanitizers[name] = definition.type._sanitize;\n      }\n\n      if (definition.type._isChanged) {\n        this._dataTypeChanges[name] = definition.type._isChanged;\n      }\n\n      if (definition.type instanceof DataTypes.BOOLEAN) {\n        this._hasBooleanAttributes = true;\n      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {\n        this._hasDateAttributes = true;\n      } else if (definition.type instanceof DataTypes.JSON) {\n        this._jsonAttributes.add(name);\n      } else if (definition.type instanceof DataTypes.VIRTUAL) {\n        this._virtualAttributes.add(name);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(definition, 'defaultValue')) {\n        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(definition, 'unique') && definition.unique) {\n        let idxName;\n        if (\n          typeof definition.unique === 'object' &&\n          Object.prototype.hasOwnProperty.call(definition.unique, 'name')\n        ) {\n          idxName = definition.unique.name;\n        } else if (typeof definition.unique === 'string') {\n          idxName = definition.unique;\n        } else {\n          idxName = `${this.tableName}_${name}_unique`;\n        }\n\n        const idx = this.uniqueKeys[idxName] || { fields: [] };\n\n        idx.fields.push(definition.field);\n        idx.msg = idx.msg || definition.unique.msg || null;\n        idx.name = idxName || false;\n        idx.column = name;\n        idx.customIndex = definition.unique !== true;\n\n        this.uniqueKeys[idxName] = idx;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(definition, 'validate')) {\n        this.prototype.validators[name] = definition.validate;\n      }\n\n      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n        this._indexes.push(\n          Utils.nameIndex(\n            this._conformIndex({\n              fields: [definition.field || name],\n              using: 'gin'\n            }),\n            this.getTableName()\n          )\n        );\n\n        delete definition.index;\n      }\n    });\n\n    // Create a map of field to attribute names\n    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {\n      if (key !== value.fieldName) {\n        map[key] = value.fieldName;\n      }\n      return map;\n    }, {});\n\n    this._hasJsonAttributes = !!this._jsonAttributes.size;\n\n    this._hasVirtualAttributes = !!this._virtualAttributes.size;\n\n    this._hasDefaultValues = !_.isEmpty(this._defaultValues);\n\n    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));\n\n    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;\n    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;\n\n    for (const key of Object.keys(attributeManipulation)) {\n      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {\n        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);\n        continue;\n      }\n      Object.defineProperty(this.prototype, key, attributeManipulation[key]);\n    }\n\n    this.prototype.rawAttributes = this.rawAttributes;\n    this.prototype._isAttribute = key => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);\n\n    // Primary key convenience constiables\n    this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n    this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n    if (this.primaryKeyAttribute) {\n      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n    }\n\n    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;\n    this._isPrimaryKey = key => this.primaryKeyAttributes.includes(key);\n  }\n\n  /**\n   * Remove attribute from model definition\n   *\n   * @param {string} attribute name of attribute to remove\n   */\n  static removeAttribute(attribute) {\n    delete this.rawAttributes[attribute];\n    this.refreshAttributes();\n  }\n\n  /**\n   * Sync this Model to the DB, that is create the table.\n   *\n   * @param {Object} [options] sync options\n   *\n   * @see\n   * {@link Sequelize#sync} for options\n   *\n   * @returns {Promise<Model>}\n   */\n  static sync(options) {\n    options = Object.assign({}, this.options, options);\n    options.hooks = options.hooks === undefined ? true : !!options.hooks;\n\n    const attributes = this.tableAttributes;\n    const rawAttributes = this.fieldRawAttributesMap;\n\n    return Promise.try(() => {\n      if (options.hooks) {\n        return this.runHooks('beforeSync', options);\n      }\n    }).then(() => {\n      if (options.force) {\n        return this.drop(options);\n      }\n    })\n      .then(() => this.QueryInterface.createTable(this.getTableName(options), attributes, options, this))\n      .then(() => {\n        if (!options.alter) {\n          return;\n        }\n        return Promise.all([\n          this.QueryInterface.describeTable(this.getTableName(options)),\n          this.QueryInterface.getForeignKeyReferencesForTable(this.getTableName(options))\n        ])\n          .then(tableInfos => {\n            const columns = tableInfos[0];\n            // Use for alter foreign keys\n            const foreignKeyReferences = tableInfos[1];\n\n            const changes = []; // array of promises to run\n            const removedConstraints = {};\n\n            _.each(attributes, (columnDesc, columnName) => {\n              if (!columns[columnName] && !columns[attributes[columnName].field]) {\n                changes.push(() => this.QueryInterface.addColumn(this.getTableName(options), attributes[columnName].field || columnName, attributes[columnName]));\n              }\n            });\n            _.each(columns, (columnDesc, columnName) => {\n              const currentAttribute = rawAttributes[columnName];\n              if (!currentAttribute) {\n                changes.push(() => this.QueryInterface.removeColumn(this.getTableName(options), columnName, options));\n              } else if (!currentAttribute.primaryKey) {\n                // Check foreign keys. If it's a foreign key, it should remove constraint first.\n                const references = currentAttribute.references;\n                if (currentAttribute.references) {\n                  const database = this.sequelize.config.database;\n                  const schema = this.sequelize.config.schema;\n                  // Find existed foreign keys\n                  _.each(foreignKeyReferences, foreignKeyReference => {\n                    const constraintName = foreignKeyReference.constraintName;\n                    if (!!constraintName\n                      && foreignKeyReference.tableCatalog === database\n                      && (schema ? foreignKeyReference.tableSchema === schema : true)\n                      && foreignKeyReference.referencedTableName === references.model\n                      && foreignKeyReference.referencedColumnName === references.key\n                      && (schema ? foreignKeyReference.referencedTableSchema === schema : true)\n                      && !removedConstraints[constraintName]) {\n                      // Remove constraint on foreign keys.\n                      changes.push(() => this.QueryInterface.removeConstraint(this.getTableName(options), constraintName, options));\n                      removedConstraints[constraintName] = true;\n                    }\n                  });\n                }\n                changes.push(() => this.QueryInterface.changeColumn(this.getTableName(options), columnName, currentAttribute));\n              }\n            });\n            return Promise.each(changes, f => f());\n          });\n      })\n      .then(() => this.QueryInterface.showIndex(this.getTableName(options), options))\n      .then(indexes => {\n        indexes = this._indexes.filter(item1 =>\n          !indexes.some(item2 => item1.name === item2.name)\n        ).sort((index1, index2) => {\n          if (this.sequelize.options.dialect === 'postgres') {\n          // move concurrent indexes to the bottom to avoid weird deadlocks\n            if (index1.concurrently === true) return 1;\n            if (index2.concurrently === true) return -1;\n          }\n\n          return 0;\n        });\n\n        return Promise.each(indexes, index => this.QueryInterface.addIndex(\n          this.getTableName(options),\n          Object.assign({\n            logging: options.logging,\n            benchmark: options.benchmark,\n            transaction: options.transaction,\n            schema: options.schema\n          }, index),\n          this.tableName\n        ));\n      }).then(() => {\n        if (options.hooks) {\n          return this.runHooks('afterSync', options);\n        }\n      }).return(this);\n  }\n\n  /**\n   * Drop the table represented by this Model\n   *\n   * @param {Object}   [options] drop options\n   * @param {boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres\n   * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.\n   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   *\n   * @returns {Promise}\n   */\n  static drop(options) {\n    return this.QueryInterface.dropTable(this.getTableName(options), options);\n  }\n\n  static dropSchema(schema) {\n    return this.QueryInterface.dropSchema(schema);\n  }\n\n  /**\n   * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `\"schema\".\"tableName\"`,\n   * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.\n   *\n   * This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important\n   * to call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.\n   *\n   * If a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call\n   * for the model.\n   *\n   * @param {string}   schema The name of the schema\n   * @param {Object}   [options] schema options\n   * @param {string}   [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   *\n   * @see\n   * {@link Sequelize#define} for more information about setting a default schema.\n   *\n   * @returns {Model}\n   */\n  static schema(schema, options) {\n\n    const clone = class extends this {};\n    Object.defineProperty(clone, 'name', { value: this.name });\n\n    clone._schema = schema;\n\n    if (options) {\n      if (typeof options === 'string') {\n        clone._schemaDelimiter = options;\n      } else if (options.schemaDelimiter) {\n        clone._schemaDelimiter = options.schemaDelimiter;\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema,\n   * or an object with `tableName`, `schema` and `delimiter` properties.\n   *\n   * @returns {string|Object}\n   */\n  static getTableName() {\n    return this.QueryGenerator.addSchema(this);\n  }\n\n  /**\n   * Get un-scoped model\n   *\n   * @returns {Model}\n   */\n  static unscoped() {\n    return this.scope();\n  }\n\n  /**\n   * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.\n   *\n   * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.\n   *\n   * @param {string}          name The name of the scope. Use `defaultScope` to override the default scope\n   * @param {Object|Function} scope scope or options\n   * @param {Object}          [options] scope options\n   * @param {boolean}         [options.override=false] override old scope if already defined\n   */\n  static addScope(name, scope, options) {\n    options = Object.assign({\n      override: false\n    }, options);\n\n    if ((name === 'defaultScope' && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {\n      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);\n    }\n\n    if (name === 'defaultScope') {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n\n  /**\n   * Apply a scope created in `define` to the model.\n   *\n   * @example <caption>how to create scopes</caption>\n   * const Model = sequelize.define('model', attributes, {\n   *   defaultScope: {\n   *     where: {\n   *       username: 'dan'\n   *     },\n   *     limit: 12\n   *   },\n   *   scopes: {\n   *     isALie: {\n   *       where: {\n   *         stuff: 'cake'\n   *       }\n   *     },\n   *     complexFunction: function(email, accessLevel) {\n   *       return {\n   *         where: {\n   *           email: {\n   *             [Op.like]: email\n   *           },\n   *           access_level {\n   *             [Op.gte]: accessLevel\n   *           }\n   *         }\n   *       }\n   *     }\n   *   }\n   * })\n   *\n   * # As you have defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:\n   *\n   * Model.findAll() // WHERE username = 'dan'\n   * Model.findAll({ where: { age: { [Op.gt]: 12 } } }) // WHERE age > 12 AND username = 'dan'\n   *\n   * @example <caption>To invoke scope functions you can do</caption>\n   * Model.scope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()\n   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42\n   *\n   * @param {?Array|Object|string} [option] The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.\n   *\n   * @returns {Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.\n   */\n  static scope(option) {\n    const self = class extends this {};\n    let scope;\n    let scopeName;\n\n    Object.defineProperty(self, 'name', { value: this.name });\n\n    self._scope = {};\n    self._scopeNames = [];\n    self.scoped = true;\n\n    if (!option) {\n      return self;\n    }\n\n    const options = _.flatten(arguments);\n\n    for (const option of options) {\n      scope = null;\n      scopeName = null;\n\n      if (_.isPlainObject(option)) {\n        if (option.method) {\n          if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {\n            scopeName = option.method[0];\n            scope = self.options.scopes[scopeName].apply(self, option.method.slice(1));\n          }\n          else if (self.options.scopes[option.method]) {\n            scopeName = option.method;\n            scope = self.options.scopes[scopeName].apply(self);\n          }\n        } else {\n          scope = option;\n        }\n      } else if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {\n        scope = self.options.defaultScope;\n      } else {\n        scopeName = option;\n        scope = self.options.scopes[scopeName];\n        if (typeof scope === 'function') {\n          scope = scope();\n        }\n      }\n\n      if (scope) {\n        this._conformIncludes(scope, this);\n        this._assignOptions(self._scope, scope);\n        self._scopeNames.push(scopeName ? scopeName : 'defaultScope');\n      } else {\n        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);\n      }\n    }\n\n    return self;\n  }\n\n  /**\n   * Search for multiple instances.\n   *\n   * @example <caption>Simple search using AND and =</caption>\n   * Model.findAll({\n   *   where: {\n   *     attr1: 42,\n   *     attr2: 'cake'\n   *   }\n   * })\n   *\n   * # WHERE attr1 = 42 AND attr2 = 'cake'\n   *\n   * @example <caption>Using greater than, less than etc.</caption>\n   * const {gt, lte, ne, in: opIn} = Sequelize.Op;\n   *\n   * Model.findAll({\n   *   where: {\n   *     attr1: {\n   *       [gt]: 50\n   *     },\n   *     attr2: {\n   *       [lte]: 45\n   *     },\n   *     attr3: {\n   *       [opIn]: [1,2,3]\n   *     },\n   *     attr4: {\n   *       [ne]: 5\n   *     }\n   *   }\n   * })\n   *\n   * # WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5\n   *\n   * @example <caption>Queries using OR</caption>\n   * const {or, and, gt, lt} = Sequelize.Op;\n   *\n   * Model.findAll({\n   *   where: {\n   *     name: 'a project',\n   *     [or]: [\n   *       {id: [1, 2, 3]},\n   *       {\n   *         [and]: [\n   *           {id: {[gt]: 10}},\n   *           {id: {[lt]: 100}}\n   *         ]\n   *       }\n   *     ]\n   *   }\n   * });\n   *\n   * # WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));\n   *\n   * @see\n   * {@link Operators} for possible operators\n   * __Alias__: _all_\n   *\n   * The promise is resolved with an array of Model instances if the query succeeds._\n   *\n   * @param  {Object}                                                    [options] A hash of options to describe the scope of the search\n   * @param  {Object}                                                    [options.where] A hash of attributes to describe your search. See above for examples.\n   * @param  {Array<string>|Object}                                      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance\n   * @param  {Array<string>}                                             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`\n   * @param  {Array<string>}                                             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`\n   * @param  {boolean}                                                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.\n   * @param  {Array<Object|Model|string>}                                [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).\n   * @param  {Model}                                                     [options.include[].model] The model you want to eagerly load\n   * @param  {string}                                                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural\n   * @param  {Association}                                               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)\n   * @param  {Object}                                                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`\n   * @param  {boolean}                                                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.\n   * @param  {Object}                                                    [options.include[].on] Supply your own ON condition for the join.\n   * @param  {Array<string>}                                             [options.include[].attributes] A list of attributes to select from the child model\n   * @param  {boolean}                                                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.\n   * @param  {boolean}                                                   [options.include[].right] If true, converts to a right join if dialect support it. Ignored if `include.required` is true.\n   * @param  {boolean}                                                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations\n   * @param  {number}                                                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true\n   * @param  {Object}                                                    [options.include[].through.where] Filter on the join model for belongsToMany relations\n   * @param  {Array}                                                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations\n   * @param  {Array<Object|Model|string>}                                [options.include[].include] Load further nested related models\n   * @param  {boolean}                                                   [options.include[].duplicating] Mark the include as duplicating, will prevent a subquery from being used.\n   * @param  {Array|Sequelize.fn|Sequelize.col|Sequelize.literal}        [options.order] Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.\n   * @param  {number}                                                    [options.limit] Limit for result\n   * @param  {number}                                                    [options.offset] Offset for result\n   * @param  {Transaction}                                               [options.transaction] Transaction to run query under\n   * @param  {string|Object}                                             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See [transaction.LOCK for an example](transaction#lock)\n   * @param  {boolean}                                                   [options.skipLocked] Skip locked rows. Only supported in Postgres.\n   * @param  {boolean}                                                   [options.raw] Return raw result. See sequelize.query for more information.\n   * @param  {Function}                                                  [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param  {boolean}                                                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Object}                                                    [options.having] Having options\n   * @param  {string}                                                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param  {boolean|Error}                                             [options.rejectOnEmpty=false] Throws an error when no records found\n   *\n   * @see\n   * {@link Sequelize#query}\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  static findAll(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new sequelizeErrors.QueryError('The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value');\n    }\n\n    if (options !== undefined && options.attributes) {\n      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {\n        throw new sequelizeErrors.QueryError('The attributes option must be an array of column names or an object');\n      }\n    }\n\n    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));\n\n    const tableNames = {};\n\n    tableNames[this.getTableName(options)] = true;\n    options = Utils.cloneDeep(options);\n\n    _.defaults(options, { hooks: true });\n\n    // set rejectOnEmpty option, defaults to model options\n    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, 'rejectOnEmpty')\n      ? options.rejectOnEmpty\n      : this.options.rejectOnEmpty;\n\n    return Promise.try(() => {\n      this._injectScope(options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFind', options);\n      }\n    }).then(() => {\n      this._conformIncludes(options, this);\n      this._expandAttributes(options);\n      this._expandIncludeAll(options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFindAfterExpandIncludeAll', options);\n      }\n    }).then(() => {\n      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n\n      if (options.include) {\n        options.hasJoin = true;\n\n        this._validateIncludedElements(options, tableNames);\n\n        // If we're not raw, we have to make sure we include the primary key for de-duplication\n        if (\n          options.attributes\n          && !options.raw\n          && this.primaryKeyAttribute\n          && !options.attributes.includes(this.primaryKeyAttribute)\n          && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)\n        ) {\n          options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n        }\n      }\n\n      if (!options.attributes) {\n        options.attributes = Object.keys(this.rawAttributes);\n        options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n      }\n\n      // whereCollection is used for non-primary key updates\n      this.options.whereCollection = options.where || null;\n\n      Utils.mapFinderOptions(options, this);\n\n      options = this._paranoidClause(this, options);\n\n      if (options.hooks) {\n        return this.runHooks('beforeFindAfterOptions', options);\n      }\n    }).then(() => {\n      const selectOptions = Object.assign({}, options, { tableNames: Object.keys(tableNames) });\n      return this.QueryInterface.select(this, this.getTableName(selectOptions), selectOptions);\n    }).tap(results => {\n      if (options.hooks) {\n        return this.runHooks('afterFind', results, options);\n      }\n    }).then(results => {\n\n      //rejectOnEmpty mode\n      if (_.isEmpty(results) && options.rejectOnEmpty) {\n        if (typeof options.rejectOnEmpty === 'function') {\n          throw new options.rejectOnEmpty();\n        }\n        if (typeof options.rejectOnEmpty === 'object') {\n          throw options.rejectOnEmpty;\n        }\n        throw new sequelizeErrors.EmptyResultError();\n      }\n\n      return Model._findSeparate(results, options);\n    });\n  }\n\n  static warnOnInvalidOptions(options, validColumnNames) {\n    if (!_.isPlainObject(options)) {\n      return;\n    }\n\n    const unrecognizedOptions = Object.keys(options).filter(k => !validQueryKeywords.has(k));\n    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      logger.warn(`Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);\n    }\n  }\n\n  static _injectDependentVirtualAttributes(attributes) {\n    if (!this._hasVirtualAttributes) return attributes;\n    if (!attributes || !Array.isArray(attributes)) return attributes;\n\n    for (const attribute of attributes) {\n      if (\n        this._virtualAttributes.has(attribute)\n        && this.rawAttributes[attribute].type.fields\n      ) {\n        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);\n      }\n    }\n\n    attributes = _.uniq(attributes);\n\n    return attributes;\n  }\n\n  static _findSeparate(results, options) {\n    if (!options.include || options.raw || !results) return Promise.resolve(results);\n\n    const original = results;\n    if (options.plain) results = [results];\n\n    if (!results.length) return original;\n\n    return Promise.map(options.include, include => {\n      if (!include.separate) {\n        return Model._findSeparate(\n          results.reduce((memo, result) => {\n            let associations = result.get(include.association.as);\n\n            // Might be an empty belongsTo relation\n            if (!associations) return memo;\n\n            // Force array so we can concat no matter if it's 1:1 or :M\n            if (!Array.isArray(associations)) associations = [associations];\n\n            for (let i = 0, len = associations.length; i !== len; ++i) {\n              memo.push(associations[i]);\n            }\n            return memo;\n          }, []),\n          Object.assign(\n            {},\n            _.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'offset', 'plain', 'scope'),\n            { include: include.include || [] }\n          )\n        );\n      }\n\n      return include.association.get(results, Object.assign(\n        {},\n        _.omit(options, nonCascadingOptions),\n        _.omit(include, ['parent', 'association', 'as', 'originalAttributes'])\n      )).then(map => {\n        for (const result of results) {\n          result.set(\n            include.association.as,\n            map[result.get(include.association.sourceKey)],\n            { raw: true }\n          );\n        }\n      });\n    }).return(original);\n  }\n\n  /**\n   * Search for a single instance by its primary key._\n   *\n   * @param  {number|string|Buffer}      param The value of the desired instance's primary key.\n   * @param  {Object}                    [options] find options\n   * @param  {Transaction}               [options.transaction] Transaction to run query under\n   * @param  {string}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @see\n   * {@link Model.findAll}           for a full explanation of options, Note that options.where is not supported.\n   *\n   * @returns {Promise<Model>}\n   */\n  static findByPk(param, options) {\n    // return Promise resolved with null if no arguments are passed\n    if ([null, undefined].includes(param)) {\n      return Promise.resolve(null);\n    }\n\n    options = Utils.cloneDeep(options) || {};\n\n    if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {\n      options.where = {\n        [this.primaryKeyAttribute]: param\n      };\n    } else {\n      throw new Error(`Argument passed to findByPk is invalid: ${param}`);\n    }\n\n    // Bypass a possible overloaded findOne\n    return this.findOne(options);\n  }\n\n  /**\n   * Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.\n   *\n   * __Alias__: _find_\n   *\n   * @param  {Object}       [options] A hash of options to describe the scope of the search\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {string}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @see\n   * {@link Model.findAll} for an explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  static findOne(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new Error('The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value');\n    }\n    options = Utils.cloneDeep(options);\n\n    if (options.limit === undefined) {\n      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter(c => c.fields.length === 1).map('column').value();\n\n      // Don't add limit if querying directly on the pk or a unique column\n      if (!options.where || !_.some(options.where, (value, key) =>\n        (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) &&\n          (Utils.isPrimitive(value) || Buffer.isBuffer(value))\n      )) {\n        options.limit = 1;\n      }\n    }\n\n    // Bypass a possible overloaded findAll.\n    return this.findAll(_.defaults(options, {\n      plain: true\n    }));\n  }\n\n  /**\n   * Run an aggregation method on the specified field\n   *\n   * @param {string}          attribute The attribute to aggregate over. Can be a field name or *\n   * @param {string}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.\n   * @param {Object}          [options] Query options. See sequelize.query for full options\n   * @param {Object}          [options.where] A hash of search attributes.\n   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {DataTypes|string} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.\n   * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over\n   * @param {Transaction}     [options.transaction] Transaction to run query under\n   * @param {boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`\n   *\n   * @returns {Promise<DataTypes|Object>} Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.\n   */\n  static aggregate(attribute, aggregateFunction, options) {\n    options = Utils.cloneDeep(options);\n\n    // We need to preserve attributes here as the `injectScope` call would inject non aggregate columns.\n    const prevAttributes = options.attributes;\n    this._injectScope(options);\n    options.attributes = prevAttributes;\n    this._conformIncludes(options, this);\n\n    if (options.include) {\n      this._expandIncludeAll(options);\n      this._validateIncludedElements(options);\n    }\n\n    const attrOptions = this.rawAttributes[attribute];\n    const field = attrOptions && attrOptions.field || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);\n    }\n\n    let { group } = options;\n    if (Array.isArray(group) && Array.isArray(group[0])) {\n      noDoubleNestedGroup();\n      group = _.flatten(group);\n    }\n    options.attributes = _.unionBy(\n      options.attributes,\n      group,\n      [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]],\n      a => Array.isArray(a) ? a[1] : a\n    );\n\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        // Use FLOAT as fallback\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n\n    Utils.mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n\n    return this.QueryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this).then( value => {\n      if (value === null) {\n        return 0;\n      }\n      return value;\n    });\n  }\n\n  /**\n   * Count the number of records matching the provided where clause.\n   *\n   * If you provide an `include` option, the number of matching associations will be counted instead.\n   *\n   * @param {Object}        [options] options\n   * @param {Object}        [options.where] A hash of search attributes.\n   * @param {Object}        [options.include] Include options. See `find` for details\n   * @param {boolean}       [options.paranoid=true] Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled\n   * @param {boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key or on options.col.\n   * @param {string}        [options.col] Column on which COUNT() should be applied\n   * @param {Array}         [options.attributes] Used in conjunction with `group`\n   * @param {Array}         [options.group] For creating complex counts. Will return multiple rows as needed.\n   * @param {Transaction}   [options.transaction] Transaction to run query under\n   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {string}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise<number>}\n   */\n  static count(options) {\n    return Promise.try(() => {\n      options = Utils.cloneDeep(options);\n      options = _.defaults(options, { hooks: true });\n      options.raw = true;\n      if (options.hooks) {\n        return this.runHooks('beforeCount', options);\n      }\n    }).then(() => {\n      let col = options.col || '*';\n      if (options.include) {\n        col = `${this.name}.${options.col || this.primaryKeyField}`;\n      }\n      if (options.distinct && col === '*') {\n        col = this.primaryKeyField;\n      }\n      options.plain = !options.group;\n      options.dataType = new DataTypes.INTEGER();\n      options.includeIgnoreAttributes = false;\n\n      // No limit, offset or order for the options max be given to count()\n      // Set them to null to prevent scopes setting those values\n      options.limit = null;\n      options.offset = null;\n      options.order = null;\n\n      return this.aggregate(col, 'count', options);\n    });\n  }\n\n  /**\n   * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging\n   *\n   * @example\n   * Model.findAndCountAll({\n   *   where: ...,\n   *   limit: 12,\n   *   offset: 12\n   * }).then(result => {\n   *   ...\n   * })\n   *\n   * # In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.\n   *\n   * # When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.\n   *\n   * # Suppose you want to find all users who have a profile attached:\n   *\n   * User.findAndCountAll({\n   *   include: [\n   *      { model: Profile, required: true}\n   *   ],\n   *   limit 3\n   * });\n   *\n   * # Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted\n   *\n   * @param {Object} [options] See findAll options\n   *\n   * @see\n   * {@link Model.findAll} for a specification of find and query options\n   * @see\n   * {@link Model.count} for a specification of count options\n   *\n   * @returns {Promise<{count: number, rows: Model[]}>}\n   */\n  static findAndCountAll(options) {\n    if (options !== undefined && !_.isPlainObject(options)) {\n      throw new Error('The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value');\n    }\n\n    const countOptions = Utils.cloneDeep(options);\n\n    if (countOptions.attributes) {\n      countOptions.attributes = undefined;\n    }\n\n    return Promise.all([\n      this.count(countOptions),\n      this.findAll(options)\n    ])\n      .then(([count, rows]) => ({\n        count,\n        rows: count === 0 ? [] : rows\n      }));\n  }\n\n  /**\n   * Find the maximum value of field\n   *\n   * @param {string} field attribute / field name\n   * @param {Object} [options] See aggregate\n   *\n   * @see\n   * {@link Model.aggregate} for options\n   *\n   * @returns {Promise<*>}\n   */\n  static max(field, options) {\n    return this.aggregate(field, 'max', options);\n  }\n\n  /**\n   * Find the minimum value of field\n   *\n   * @param {string} field attribute / field name\n   * @param {Object} [options] See aggregate\n   *\n   * @see\n   * {@link Model.aggregate} for options\n   *\n   * @returns {Promise<*>}\n   */\n  static min(field, options) {\n    return this.aggregate(field, 'min', options);\n  }\n\n  /**\n   * Find the sum of field\n   *\n   * @param {string} field attribute / field name\n   * @param {Object} [options] See aggregate\n   *\n   * @see\n   * {@link Model.aggregate} for options\n   *\n   * @returns {Promise<number>}\n   */\n  static sum(field, options) {\n    return this.aggregate(field, 'sum', options);\n  }\n\n  /**\n   * Builds a new model instance.\n   *\n   * @param {Object|Array} values An object of key value pairs or an array of such. If an array, the function will return an array of instances.\n   * @param {Object}  [options] Instance build options\n   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {boolean} [options.isNewRecord=true] Is this new record\n   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   *\n   * @returns {Model|Array<Model>}\n   */\n  static build(values, options) {\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n\n    return new this(values, options);\n  }\n\n  static bulkBuild(valueSets, options) {\n    options = Object.assign({\n      isNewRecord: true\n    }, options || {});\n\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n\n    return valueSets.map(values => this.build(values, options));\n  }\n\n  /**\n   * Builds a new model instance and calls save on it.\n\n   * @see\n   * {@link Model.build}\n   * @see\n   * {@link Model.save}\n   *\n   * @param {Object}        values hash of data values to create new record with\n   * @param {Object}        [options] build and query options\n   * @param {boolean}       [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {boolean}       [options.isNewRecord=true] Is this new record\n   * @param {Array}         [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n   * @param {Array}         [options.fields] If set, only columns matching those in fields will be saved\n   * @param {string[]}      [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.\n   * @param {boolean}       [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {boolean}       [options.validate=true] If false, validations won't be run.\n   * @param {boolean}       [options.hooks=true] Run before and after create / update + validate hooks\n   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {Transaction}   [options.transaction] Transaction to run query under\n   * @param {string}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean}       [options.returning=true] Return the affected rows (only for postgres)\n   *\n   * @returns {Promise<Model>}\n   *\n   */\n  static create(values, options) {\n    options = Utils.cloneDeep(options || {});\n\n    return this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent\n    }).save(options);\n  }\n\n  /**\n   * Find a row that matches the query, or build (but don't save) the row if none is found.\n   * The successful result of the promise will be (instance, built)\n   *\n   * @param {Object}   options find options\n   * @param {Object}   options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.\n   * @param {Object}   [options.defaults] Default values to use if building a new instance\n   * @param {Object}   [options.transaction] Transaction to run query under\n   *\n   * @returns {Promise<Model,boolean>}\n   */\n  static findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrBuild. ' +\n        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n      );\n    }\n\n    let values;\n\n    return this.findOne(options).then(instance => {\n      if (instance === null) {\n        values = _.clone(options.defaults) || {};\n        if (_.isPlainObject(options.where)) {\n          values = Utils.defaults(values, options.where);\n        }\n\n        instance = this.build(values, options);\n\n        return Promise.resolve([instance, true]);\n      }\n\n      return Promise.resolve([instance, false]);\n    });\n  }\n\n  /**\n   * Find a row that matches the query, or build and save the row if none is found\n   * The successful result of the promise will be (instance, created)\n   *\n   * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.\n   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.\n   * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.\n   *\n   * @see\n   * {@link Model.findAll} for a full specification of find and options\n   *\n   * @param {Object}      options find and create options\n   * @param {Object}      options.where where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.\n   * @param {Object}      [options.defaults] Default values to use if creating a new instance\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   *\n   * @returns {Promise<Model,boolean>}\n   */\n  static findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrCreate. ' +\n        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n      );\n    }\n\n    options = Object.assign({}, options);\n\n    if (options.defaults) {\n      const defaults = Object.keys(options.defaults);\n      const unknownDefaults = defaults.filter(name => !this.rawAttributes[name]);\n\n      if (unknownDefaults.length) {\n        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);\n      }\n    }\n\n    if (options.transaction === undefined && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get('transaction');\n      if (t) {\n        options.transaction = t;\n      }\n    }\n\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n\n    // Create a transaction or a savepoint, depending on whether a transaction was passed in\n    return this.sequelize.transaction(options).then(t => {\n      transaction = t;\n      options.transaction = t;\n\n      return this.findOne(Utils.defaults({ transaction }, options));\n    }).then(instance => {\n      if (instance !== null) {\n        return [instance, false];\n      }\n\n      values = _.clone(options.defaults) || {};\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n\n      options.exception = true;\n\n      return this.create(values, options).then(instance => {\n        if (instance.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation\n          throw new sequelizeErrors.UniqueConstraintError();\n        }\n\n        return [instance, true];\n      }).catch(sequelizeErrors.UniqueConstraintError, err => {\n        const flattenedWhere = Utils.flattenObjectDeep(options.where);\n        const flattenedWhereKeys = Object.keys(flattenedWhere).map(name => _.last(name.split('.')));\n        const whereFields = flattenedWhereKeys.map(name => _.get(this.rawAttributes, `${name}.field`, name));\n        const defaultFields = options.defaults && Object.keys(options.defaults)\n          .filter(name => this.rawAttributes[name])\n          .map(name => this.rawAttributes[name].field || name);\n\n        const errFieldKeys = Object.keys(err.fields);\n        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);\n        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {\n          throw err;\n        }\n\n        if (errFieldsWhereIntersects) {\n          _.each(err.fields, (value, key) => {\n            const name = this.fieldRawAttributesMap[key].fieldName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);\n            }\n          });\n        }\n\n        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!\n        return this.findOne(Utils.defaults({\n          transaction: internalTransaction ? null : transaction\n        }, options)).then(instance => {\n          // Sanity check, ideally we caught this at the defaultFeilds/err.fields check\n          // But if we didn't and instance is null, we will throw\n          if (instance === null) throw err;\n          return [instance, false];\n        });\n      });\n    }).finally(() => {\n      if (internalTransaction && transaction) {\n        // If we created a transaction internally (and not just a savepoint), we should clean it up\n        return transaction.commit();\n      }\n    });\n  }\n\n  /**\n   * A more performant findOrCreate that will not work under a transaction (at least not in postgres)\n   * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again\n   *\n   * @see\n   * {@link Model.findAll} for a full specification of find and options\n   *\n   * @param {Object} options find options\n   * @param {Object} options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.\n   * @param {Object} [options.defaults] Default values to use if creating a new instance\n   *\n   * @returns {Promise<Model,boolean>}\n   */\n  static findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findCreateFind.'\n      );\n    }\n\n    let values = _.clone(options.defaults) || {};\n    if (_.isPlainObject(options.where)) {\n      values = Utils.defaults(values, options.where);\n    }\n\n\n    return this.findOne(options).then(result => {\n      if (result) return [result, false];\n\n      return this.create(values, options)\n        .then(result => [result, true])\n        .catch(sequelizeErrors.UniqueConstraintError, () => this.findOne(options).then(result => [result, false]));\n    });\n  }\n\n  /**\n   * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.\n   *\n   * **Implementation details:**\n   *\n   * * MySQL - Implemented as a single query `INSERT values ON DUPLICATE KEY UPDATE values`\n   * * PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE\n   * * SQLite - Implemented as two queries `INSERT; UPDATE`. This means that the update is executed regardless of whether the row already existed or not\n   * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`\n   * **Note** that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.\n   *\n   * @param  {Object}       values hash of values to upsert\n   * @param  {Object}       [options] upsert options\n   * @param  {boolean}      [options.validate=true] Run validations before the row is inserted\n   * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all changed fields\n   * @param  {boolean}      [options.hooks=true]  Run before / after upsert hooks?\n   * @param  {boolean}      [options.returning=false] Append RETURNING * to get back auto generated values (Postgres only)\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Function}     [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param  {boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {string}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise<boolean>} Returns a boolean indicating whether the row was created or updated. For MySQL/MariaDB, it returns `true` when inserted and `false` when updated. For Postgres/MSSQL with (options.returning=true), it returns record and created boolean with signature `<Model, created>`.\n   */\n  static upsert(values, options) {\n    options = Object.assign({\n      hooks: true,\n      returning: false,\n      validate: true\n    }, Utils.cloneDeep(options || {}));\n\n    options.model = this;\n\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n\n    if (!options.fields) {\n      options.fields = Object.keys(instance._changed);\n    }\n\n    return Promise.try(() => {\n      if (options.validate) {\n        return instance.validate(options);\n      }\n    }).then(() => {\n      // Map field names\n      const updatedDataValues = _.pick(instance.dataValues, Object.keys(instance._changed));\n      const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);\n      const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);\n      const now = Utils.now(this.sequelize.options.dialect);\n\n      // Attach createdAt\n      if (createdAtAttr && !updateValues[createdAtAttr]) {\n        const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;\n        insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n      }\n      if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n        const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n        insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n      }\n\n      // Build adds a null value for the primary key, if none was given by the user.\n      // We need to remove that because of some Postgres technicalities.\n      if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n        delete insertValues[this.primaryKeyField];\n        delete updateValues[this.primaryKeyField];\n      }\n\n      return Promise.try(() => {\n        if (options.hooks) {\n          return this.runHooks('beforeUpsert', values, options);\n        }\n      })\n        .then(() => {\n          return this.QueryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), this, options);\n        })\n        .then(([created, primaryKey]) => {\n          if (options.returning === true && primaryKey) {\n            return this.findByPk(primaryKey, options).then(record => [record, created]);\n          }\n\n          return created;\n        })\n        .tap(result => {\n          if (options.hooks) {\n            return this.runHooks('afterUpsert', result, options);\n          }\n        });\n    });\n  }\n\n  /**\n   * Create and insert multiple instances in bulk.\n   *\n   * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL\n   * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.\n   * To obtain Instances for the newly created values, you will need to query for them again.\n   *\n   * If validation fails, the promise is rejected with an array-like [AggregateError](http://bluebirdjs.com/docs/api/aggregateerror.html)\n   *\n   * @param  {Array}        records                          List of objects (key/value pairs) to create instances from\n   * @param  {Object}       [options]                        Bulk create options\n   * @param  {Array}        [options.fields]                 Fields to insert (defaults to all fields)\n   * @param  {boolean}      [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n   * @param  {boolean}      [options.hooks=true]             Run before / after bulk create hooks?\n   * @param  {boolean}      [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.\n   * @param  {boolean}      [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres < 9.5)\n   * @param  {Array}        [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite >= 3.24.0 & Postgres >= 9.5). By default, all fields are updated.\n   * @param  {Transaction}  [options.transaction]            Transaction to run query under\n   * @param  {Function}     [options.logging=false]          A function that gets executed while running the query to log the sql.\n   * @param  {boolean}      [options.benchmark=false]        Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {boolean|Array} [options.returning=false]       If true, append RETURNING * to get back all values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)\n   * @param  {string}       [options.searchPath=DEFAULT]     An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  static bulkCreate(records, options = {}) {\n    if (!records.length) {\n      return Promise.resolve([]);\n    }\n\n    const dialect = this.sequelize.options.dialect;\n    const now = Utils.now(this.sequelize.options.dialect);\n\n    options.model = this;\n\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n\n    const instances = records.map(values => this.build(values, { isNewRecord: true, include: options.include }));\n\n    const recursiveBulkCreate = (instances, options) => {\n      options = Object.assign({\n        validate: false,\n        hooks: true,\n        individualHooks: false,\n        ignoreDuplicates: false\n      }, options);\n\n      if (options.returning === undefined) {\n        if (options.association) {\n          options.returning = false;\n        } else {\n          options.returning = true;\n        }\n      }\n\n      if (options.ignoreDuplicates && ['mssql'].includes(dialect)) {\n        return Promise.reject(new Error(`${dialect} does not support the ignoreDuplicates option.`));\n      }\n      if (options.updateOnDuplicate && (dialect !== 'mysql' && dialect !== 'mariadb' && dialect !== 'sqlite' && dialect !== 'postgres')) {\n        return Promise.reject(new Error(`${dialect} does not support the updateOnDuplicate option.`));\n      }\n\n      const model = options.model;\n\n      options.fields = options.fields || Object.keys(model.rawAttributes);\n      const createdAtAttr = model._timestampAttributes.createdAt;\n      const updatedAtAttr = model._timestampAttributes.updatedAt;\n\n      if (options.updateOnDuplicate !== undefined) {\n        if (Array.isArray(options.updateOnDuplicate) && options.updateOnDuplicate.length) {\n          options.updateOnDuplicate = _.intersection(\n            _.without(Object.keys(model.tableAttributes), createdAtAttr),\n            options.updateOnDuplicate\n          );\n        } else {\n          return Promise.reject(new Error('updateOnDuplicate option only supports non-empty array.'));\n        }\n      }\n\n      return Promise.try(() => {\n        // Run before hook\n        if (options.hooks) {\n          return model.runHooks('beforeBulkCreate', instances, options);\n        }\n      }).then(() => {\n        // Validate\n        if (options.validate) {\n          const errors = new Promise.AggregateError();\n          const validateOptions = _.clone(options);\n          validateOptions.hooks = options.individualHooks;\n\n          return Promise.map(instances, instance =>\n            instance.validate(validateOptions).catch(err => {\n              errors.push(new sequelizeErrors.BulkRecordError(err, instance));\n            })\n          ).then(() => {\n            delete options.skip;\n            if (errors.length) {\n              throw errors;\n            }\n          });\n        }\n      }).then(() => {\n        if (options.individualHooks) {\n          // Create each instance individually\n          return Promise.map(instances, instance => {\n            const individualOptions = _.clone(options);\n            delete individualOptions.fields;\n            delete individualOptions.individualHooks;\n            delete individualOptions.ignoreDuplicates;\n            individualOptions.validate = false;\n            individualOptions.hooks = true;\n\n            return instance.save(individualOptions);\n          });\n        }\n\n        return Promise.resolve().then(() => {\n          if (!options.include || !options.include.length) return;\n\n          // Nested creation for BelongsTo relations\n          return Promise.map(options.include.filter(include => include.association instanceof BelongsTo), include => {\n            const associationInstances = [];\n            const associationInstanceIndexToInstanceMap = [];\n\n            for (const instance of instances) {\n              const associationInstance = instance.get(include.as);\n              if (associationInstance) {\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n\n            if (!associationInstances.length) {\n              return;\n            }\n\n            const includeOptions = _(Utils.cloneDeep(include))\n              .omit(['association'])\n              .defaults({\n                transaction: options.transaction,\n                logging: options.logging\n              }).value();\n\n            return recursiveBulkCreate(associationInstances, includeOptions).then(associationInstances => {\n              for (const idx in associationInstances) {\n                const associationInstance = associationInstances[idx];\n                const instance = associationInstanceIndexToInstanceMap[idx];\n\n                instance[include.association.accessors.set](associationInstance, { save: false, logging: options.logging });\n              }\n            });\n          });\n        }).then(() => {\n          // Create all in one query\n          // Recreate records from instances to represent any changes made in hooks or validation\n          records = instances.map(instance => {\n            const values = instance.dataValues;\n\n            // set createdAt/updatedAt attributes\n            if (createdAtAttr && !values[createdAtAttr]) {\n              values[createdAtAttr] = now;\n              if (!options.fields.includes(createdAtAttr)) {\n                options.fields.push(createdAtAttr);\n              }\n            }\n            if (updatedAtAttr && !values[updatedAtAttr]) {\n              values[updatedAtAttr] = now;\n              if (!options.fields.includes(updatedAtAttr)) {\n                options.fields.push(updatedAtAttr);\n              }\n            }\n\n            const out = Object.assign({}, Utils.mapValueFieldNames(values, options.fields, model));\n            for (const key of model._virtualAttributes) {\n              delete out[key];\n            }\n            return out;\n          });\n\n          // Map attributes to fields for serial identification\n          const fieldMappedAttributes = {};\n          for (const attr in model.tableAttributes) {\n            fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];\n          }\n\n          // Map updateOnDuplicate attributes to fields\n          if (options.updateOnDuplicate) {\n            options.updateOnDuplicate = options.updateOnDuplicate.map(attr => model.rawAttributes[attr].field || attr);\n            // Get primary keys for postgres to enable updateOnDuplicate\n            options.upsertKeys = _.chain(model.primaryKeys).values().map('field').value();\n            if (Object.keys(model.uniqueKeys).length > 0) {\n              options.upsertKeys = _.chain(model.uniqueKeys).values().filter(c => c.fields.length === 1).map(c => c.fields[0]).value();\n            }\n          }\n\n          // Map returning attributes to fields\n          if (options.returning && Array.isArray(options.returning)) {\n            options.returning = options.returning.map(attr => model.rawAttributes[attr].field || attr);\n          }\n\n          return model.QueryInterface.bulkInsert(model.getTableName(options), records, options, fieldMappedAttributes).then(results => {\n            if (Array.isArray(results)) {\n              results.forEach((result, i) => {\n                const instance = instances[i];\n\n                for (const key in result) {\n                  if (!instance || key === model.primaryKeyAttribute &&\n                    instance.get(model.primaryKeyAttribute) &&\n                    ['mysql', 'mariadb', 'sqlite'].includes(dialect)) {\n                    // The query.js for these DBs is blind, it autoincrements the\n                    // primarykey value, even if it was set manually. Also, it can\n                    // return more results than instances, bug?.\n                    continue;\n                  }\n                  if (Object.prototype.hasOwnProperty.call(result, key)) {\n                    const record = result[key];\n\n                    const attr = _.find(model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n                    instance.dataValues[attr && attr.fieldName || key] = record;\n                  }\n                }\n              });\n            }\n            return results;\n          });\n        });\n      }).then(() => {\n        if (!options.include || !options.include.length) return;\n\n        // Nested creation for HasOne/HasMany/BelongsToMany relations\n        return Promise.map(options.include.filter(include => !(include.association instanceof BelongsTo ||\n          include.parent && include.parent.association instanceof BelongsToMany)), include => {\n          const associationInstances = [];\n          const associationInstanceIndexToInstanceMap = [];\n\n          for (const instance of instances) {\n            let associated = instance.get(include.as);\n            if (!Array.isArray(associated)) associated = [associated];\n\n            for (const associationInstance of associated) {\n              if (associationInstance) {\n                if (!(include.association instanceof BelongsToMany)) {\n                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n                  Object.assign(associationInstance, include.association.scope);\n                }\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n          }\n\n          if (!associationInstances.length) {\n            return;\n          }\n\n          const includeOptions = _(Utils.cloneDeep(include))\n            .omit(['association'])\n            .defaults({\n              transaction: options.transaction,\n              logging: options.logging\n            }).value();\n\n          return recursiveBulkCreate(associationInstances, includeOptions).then(associationInstances => {\n            if (include.association instanceof BelongsToMany) {\n              const valueSets = [];\n\n              for (const idx in associationInstances) {\n                const associationInstance = associationInstances[idx];\n                const instance = associationInstanceIndexToInstanceMap[idx];\n\n                const values = {};\n                values[include.association.foreignKey] = instance.get(instance.constructor.primaryKeyAttribute, { raw: true });\n                values[include.association.otherKey] = associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true });\n\n                // Include values defined in the association\n                Object.assign(values, include.association.through.scope);\n                if (associationInstance[include.association.through.model.name]) {\n                  for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                    if (include.association.through.model.rawAttributes[attr]._autoGenerated ||\n                      attr === include.association.foreignKey ||\n                      attr === include.association.otherKey ||\n                      typeof associationInstance[include.association.through.model.name][attr] === undefined) {\n                      continue;\n                    }\n                    values[attr] = associationInstance[include.association.through.model.name][attr];\n                  }\n                }\n\n                valueSets.push(values);\n              }\n\n              const throughOptions = _(Utils.cloneDeep(include))\n                .omit(['association', 'attributes'])\n                .defaults({\n                  transaction: options.transaction,\n                  logging: options.logging\n                }).value();\n              throughOptions.model = include.association.throughModel;\n              const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);\n\n              return recursiveBulkCreate(throughInstances, throughOptions);\n            }\n          });\n        });\n      }).then(() => {\n        // map fields back to attributes\n        instances.forEach(instance => {\n          for (const attr in model.rawAttributes) {\n            if (model.rawAttributes[attr].field &&\n                instance.dataValues[model.rawAttributes[attr].field] !== undefined &&\n                model.rawAttributes[attr].field !== attr\n            ) {\n              instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];\n              delete instance.dataValues[model.rawAttributes[attr].field];\n            }\n            instance._previousDataValues[attr] = instance.dataValues[attr];\n            instance.changed(attr, false);\n          }\n          instance.isNewRecord = false;\n        });\n\n        // Run after hook\n        if (options.hooks) {\n          return model.runHooks('afterBulkCreate', instances, options);\n        }\n      }).then(() => instances);\n    };\n\n    return recursiveBulkCreate(instances, options);\n  }\n\n  /**\n   * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).\n   *\n   * @param {Object}           [options] The options passed to Model.destroy in addition to truncate\n   * @param {boolean|Function} [options.cascade = false] Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean}          [options.restartIdentity=false] Automatically restart sequences owned by columns of the truncated table.\n   * @param {Transaction}      [options.transaction] Transaction to run query under\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   * @param {boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {string}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise}\n   *\n   * @see\n   * {@link Model.destroy} for more information\n   */\n  static truncate(options) {\n    options = Utils.cloneDeep(options) || {};\n    options.truncate = true;\n    return this.destroy(options);\n  }\n\n  /**\n   * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.\n   *\n   * @param  {Object}       options                         destroy options\n   * @param  {Object}       [options.where]                 Filter the destroy\n   * @param  {boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?\n   * @param  {boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row\n   * @param  {number}       [options.limit]                 How many rows to delete\n   * @param  {boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)\n   * @param  {boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored\n   * @param  {boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param  {boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param  {Transaction}  [options.transaction] Transaction to run query under\n   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   *\n   * @returns {Promise<number>} The number of destroyed rows\n   */\n  static destroy(options) {\n    options = Utils.cloneDeep(options);\n\n    this._injectScope(options);\n\n    if (!options || !(options.where || options.truncate)) {\n      throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');\n    }\n\n    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {\n      throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');\n    }\n\n    options = _.defaults(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n      cascade: false,\n      restartIdentity: false\n    });\n\n    options.type = QueryTypes.BULKDELETE;\n\n    Utils.mapOptionFieldNames(options, this);\n    options.model = this;\n\n    let instances;\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.runHooks('beforeBulkDestroy', options);\n      }\n    }).then(() => {\n      // Get daos and run beforeDestroy hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark })\n          .map(instance => this.runHooks('beforeDestroy', instance, options).then(() => instance))\n          .then(_instances => {\n            instances = _instances;\n          });\n      }\n    }).then(() => {\n      // Run delete query (or update if paranoid)\n      if (this._timestampAttributes.deletedAt && !options.force) {\n        // Set query type appropriately when running soft delete\n        options.type = QueryTypes.BULKUPDATE;\n\n        const attrValueHash = {};\n        const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];\n        const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;\n        const where = {\n          [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null\n        };\n\n\n        attrValueHash[field] = Utils.now(this.sequelize.options.dialect);\n        return this.QueryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);\n      }\n      return this.QueryInterface.bulkDelete(this.getTableName(options), options.where, options, this);\n    }).tap(() => {\n      // Run afterDestroy hook on each record individually\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => this.runHooks('afterDestroy', instance, options));\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.runHooks('afterBulkDestroy', options);\n      }\n    });\n  }\n\n  /**\n   * Restore multiple instances if `paranoid` is enabled.\n   *\n   * @param  {Object}       options                         restore options\n   * @param  {Object}       [options.where]                 Filter the restore\n   * @param  {boolean}      [options.hooks=true]            Run before / after bulk restore hooks?\n   * @param  {boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row\n   * @param  {number}       [options.limit]                 How many rows to undelete (only for mysql)\n   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Transaction}  [options.transaction]           Transaction to run query under\n   *\n   * @returns {Promise}\n   */\n  static restore(options) {\n    if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n    options = Object.assign({\n      hooks: true,\n      individualHooks: false\n    }, options || {});\n\n    options.type = QueryTypes.RAW;\n    options.model = this;\n\n    let instances;\n\n    Utils.mapOptionFieldNames(options, this);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.runHooks('beforeBulkRestore', options);\n      }\n    }).then(() => {\n      // Get daos and run beforeRestore hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false })\n          .map(instance => this.runHooks('beforeRestore', instance, options).then(() => instance))\n          .then(_instances => {\n            instances = _instances;\n          });\n      }\n    }).then(() => {\n      // Run undelete query\n      const attrValueHash = {};\n      const deletedAtCol = this._timestampAttributes.deletedAt;\n      const deletedAtAttribute = this.rawAttributes[deletedAtCol];\n      const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n      attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n      options.omitNull = false;\n      return this.QueryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);\n    }).tap(() => {\n      // Run afterDestroy hook on each record individually\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => this.runHooks('afterRestore', instance, options));\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.runHooks('afterBulkRestore', options);\n      }\n    });\n  }\n\n  /**\n   * Update multiple instances that match the where options.\n   *\n   * @param  {Object}       values                          hash of values to update\n   * @param  {Object}       options                         update options\n   * @param  {Object}       options.where                   Options to describe the scope of the search.\n   * @param  {boolean}      [options.paranoid=true]         If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if `options.paranoid` is true for the model.\n   * @param  {Array}        [options.fields]                Fields to update (defaults to all fields)\n   * @param  {boolean}      [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n   * @param  {boolean}      [options.hooks=true]            Run before / after bulk update hooks?\n   * @param  {boolean}      [options.sideEffects=true]      Whether or not to update the side effects of any virtual setters.\n   * @param  {boolean}      [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks\n   * @param  {boolean}      [options.returning=false]       Return the affected rows (only for postgres)\n   * @param  {number}       [options.limit]                 How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)\n   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param  {Transaction}  [options.transaction]           Transaction to run query under\n   * @param  {boolean}      [options.silent=false]          If true, the updatedAt timestamp will not be updated.\n   *\n   * @returns {Promise<Array<number,number>>}  The promise returns an array with one or two elements. The first element is always the number\n   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)\n   *\n   */\n  static update(values, options) {\n    options = Utils.cloneDeep(options);\n\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n\n    options = this._paranoidClause(this, _.defaults(options, {\n      validate: true,\n      hooks: true,\n      individualHooks: false,\n      returning: false,\n      force: false,\n      sideEffects: true\n    }));\n\n    options.type = QueryTypes.BULKUPDATE;\n\n    // Clone values so it doesn't get modified for caller scope and ignore undefined values\n    values = _.omitBy(values, value => value === undefined);\n\n    // Remove values that are not in the options.fields\n    if (options.fields && options.fields instanceof Array) {\n      for (const key of Object.keys(values)) {\n        if (!options.fields.includes(key)) {\n          delete values[key];\n        }\n      }\n    } else {\n      const updatedAtAttr = this._timestampAttributes.updatedAt;\n      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {\n        options.fields.push(updatedAtAttr);\n      }\n    }\n\n    if (this._timestampAttributes.updatedAt && !options.silent) {\n      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n    }\n\n    options.model = this;\n\n    let instances;\n    let valuesUse;\n\n    return Promise.try(() => {\n      // Validate\n      if (options.validate) {\n        const build = this.build(values);\n        build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });\n\n        if (options.sideEffects) {\n          values = Object.assign(values, _.pick(build.get(), build.changed()));\n          options.fields = _.union(options.fields, Object.keys(values));\n        }\n\n        // We want to skip validations for all other fields\n        options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));\n        return build.validate(options).then(attributes => {\n          options.skip = undefined;\n          if (attributes && attributes.dataValues) {\n            values = _.pick(attributes.dataValues, Object.keys(values));\n          }\n        });\n      }\n      return null;\n    }).then(() => {\n      // Run before hook\n      if (options.hooks) {\n        options.attributes = values;\n        return this.runHooks('beforeBulkUpdate', options).then(() => {\n          values = options.attributes;\n          delete options.attributes;\n        });\n      }\n      return null;\n    }).then(() => {\n      valuesUse = values;\n\n      // Get instances and run beforeUpdate hook on each record individually\n      if (options.individualHooks) {\n        return this.findAll({\n          where: options.where,\n          transaction: options.transaction,\n          logging: options.logging,\n          benchmark: options.benchmark,\n          paranoid: options.paranoid\n        }).then(_instances => {\n          instances = _instances;\n          if (!instances.length) {\n            return [];\n          }\n\n          // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly\n          // i.e. whether they change values for each record in the same way\n          let changedValues;\n          let different = false;\n\n          return Promise.map(instances, instance => {\n            // Record updates in instances dataValues\n            Object.assign(instance.dataValues, values);\n            // Set the changed fields on the instance\n            _.forIn(valuesUse, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                instance.setDataValue(attr, newValue);\n              }\n            });\n\n            // Run beforeUpdate hook\n            return this.runHooks('beforeUpdate', instance, options).then(() => {\n              if (!different) {\n                const thisChangedValues = {};\n                _.forIn(instance.dataValues, (newValue, attr) => {\n                  if (newValue !== instance._previousDataValues[attr]) {\n                    thisChangedValues[attr] = newValue;\n                  }\n                });\n\n                if (!changedValues) {\n                  changedValues = thisChangedValues;\n                } else {\n                  different = !_.isEqual(changedValues, thisChangedValues);\n                }\n              }\n\n              return instance;\n            });\n          }).then(_instances => {\n            instances = _instances;\n\n            if (!different) {\n              const keys = Object.keys(changedValues);\n              // Hooks do not change values or change them uniformly\n              if (keys.length) {\n                // Hooks change values - record changes in valuesUse so they are executed\n                valuesUse = changedValues;\n                options.fields = _.union(options.fields, keys);\n              }\n              return;\n            }\n            // Hooks change values in a different way for each record\n            // Do not run original query but save each record individually\n            return Promise.map(instances, instance => {\n              const individualOptions = _.clone(options);\n              delete individualOptions.individualHooks;\n              individualOptions.hooks = false;\n              individualOptions.validate = false;\n\n              return instance.save(individualOptions);\n            }).tap(_instances => {\n              instances = _instances;\n            });\n          });\n        });\n      }\n    }).then(results => {\n      // Update already done row-by-row - exit\n      if (results) {\n        return [results.length, results];\n      }\n\n      // only updatedAt is being passed, then skip update\n      if (\n        _.isEmpty(valuesUse)\n         || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]\n      ) {\n        return [0];\n      }\n\n      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);\n      options = Utils.mapOptionFieldNames(options, this);\n      options.hasTrigger = this.options ? this.options.hasTrigger : false;\n\n      // Run query to update all rows\n      return this.QueryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes).then(affectedRows => {\n        if (options.returning) {\n          instances = affectedRows;\n          return [affectedRows.length, affectedRows];\n        }\n\n        return [affectedRows];\n      });\n    }).tap(result => {\n      if (options.individualHooks) {\n        return Promise.map(instances, instance => {\n          return this.runHooks('afterUpdate', instance, options);\n        }).then(() => {\n          result[1] = instances;\n        });\n      }\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        options.attributes = values;\n        return this.runHooks('afterBulkUpdate', options).then(() => {\n          delete options.attributes;\n        });\n      }\n    });\n  }\n\n  /**\n   * Run a describe query on the table.\n   *\n   * @param {string} [schema] schema name to search table in\n   * @param {Object} [options] query options\n   *\n   * @returns {Promise} hash of attributes and their types\n   */\n  static describe(schema, options) {\n    return this.QueryInterface.describeTable(this.tableName, Object.assign({ schema: schema || this._schema || undefined }, options));\n  }\n\n  static _getDefaultTimestamp(attr) {\n    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);\n    }\n    return undefined;\n  }\n\n  static _expandAttributes(options) {\n    if (!_.isPlainObject(options.attributes)) {\n      return;\n    }\n    let attributes = Object.keys(this.rawAttributes);\n\n    if (options.attributes.exclude) {\n      attributes = attributes.filter(elem => !options.attributes.exclude.includes(elem));\n    }\n\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n\n    options.attributes = attributes;\n  }\n\n  // Inject _scope into options.\n  static _injectScope(options) {\n    const scope = Utils.cloneDeep(this._scope);\n    this._defaultsOptions(options, scope);\n  }\n\n  static [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.name;\n  }\n\n  static inspect() {\n    return this.name;\n  }\n\n  static hasAlias(alias) {\n    return Object.prototype.hasOwnProperty.call(this.associations, alias);\n  }\n\n  /**\n   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n   * ``` SET column = column + X WHERE foo = 'bar' ``` query. To get the correct value after an increment into the Instance you should do a reload.\n   *\n   * @example <caption>increment number by 1</caption>\n   * Model.increment('number', { where: { foo: 'bar' });\n   *\n   * @example <caption>increment number and count by 2</caption>\n   * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });\n   *\n   * @example <caption>increment answer by 42, and decrement tries by 1</caption>\n   * // `by` is ignored, as each column has its own value\n   * Model.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });\n   *\n   * @see\n   * {@link Model#reload}\n   *\n   * @param {string|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n   * @param {Object} options increment options\n   * @param {Object} options.where conditions hash\n   * @param {number} [options.by=1] The number to increment by\n   * @param {boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect\n   */\n  static increment(fields, options) {\n    options = options || {};\n\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const versionAttr = this._versionAttribute;\n    const updatedAtAttribute = this.rawAttributes[updatedAtAttr];\n    options = Utils.defaults({}, options, {\n      by: 1,\n      attributes: {},\n      where: {},\n      increment: true\n    });\n\n    Utils.mapOptionFieldNames(options, this);\n\n    const where = Object.assign({}, options.where);\n    let values = {};\n\n    if (typeof fields === 'string') {\n      values[fields] = options.by;\n    } else if (Array.isArray(fields)) {\n      fields.forEach(field => {\n        values[field] = options.by;\n      });\n    } else { // Assume fields is key-value pairs\n      values = fields;\n    }\n\n    if (!options.silent && updatedAtAttr && !values[updatedAtAttr]) {\n      options.attributes[updatedAtAttribute.field || updatedAtAttr] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n    }\n    if (versionAttr) {\n      values[versionAttr] = options.increment ? 1 : -1;\n    }\n\n    for (const attr of Object.keys(values)) {\n      // Field name mapping\n      if (this.rawAttributes[attr] && this.rawAttributes[attr].field && this.rawAttributes[attr].field !== attr) {\n        values[this.rawAttributes[attr].field] = values[attr];\n        delete values[attr];\n      }\n    }\n\n    let promise;\n    if (!options.increment) {\n      promise = this.QueryInterface.decrement(this, this.getTableName(options), values, where, options);\n    } else {\n      promise = this.QueryInterface.increment(this, this.getTableName(options), values, where, options);\n    }\n\n    return promise.then(affectedRows => {\n      if (options.returning) {\n        return [affectedRows, affectedRows.length];\n      }\n\n      return [affectedRows];\n    });\n  }\n\n  /**\n   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n   * ```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance you should do a reload.\n   *\n   * @example <caption>decrement number by 1</caption>\n   * Model.decrement('number', { where: { foo: 'bar' });\n   *\n   * @example <caption>decrement number and count by 2</caption>\n   * Model.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });\n   *\n   * @example <caption>decrement answer by 42, and decrement tries by -1</caption>\n   * // `by` is ignored, since each column has its own value\n   * Model.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });\n   *\n   * @param {string|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n   * @param {Object} options decrement options, similar to increment\n   *\n   * @see\n   * {@link Model.increment}\n   * @see\n   * {@link Model#reload}\n   * @since 4.36.0\n\n   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect\n   */\n  static decrement(fields, options) {\n    options = _.defaults({ increment: false }, options, {\n      by: 1\n    });\n\n    return this.increment(fields, options);\n  }\n\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, 'Missing where attribute in the options parameter');\n    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod,\n      'Expected plain object, array or sequelize method in the options.where parameter');\n  }\n\n  /**\n   * Get an object representing the query for this instance, use with `options.where`\n   *\n   * @param {boolean} [checkVersion=false] include version attribute in where hash\n   *\n   * @returns {Object}\n   */\n  where(checkVersion) {\n    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {\n      result[attribute] = this.get(attribute, { raw: true });\n      return result;\n    }, {});\n\n    if (_.size(where) === 0) {\n      return this._modelOptions.whereCollection;\n    }\n    const versionAttr = this.constructor._versionAttribute;\n    if (checkVersion && versionAttr) {\n      where[versionAttr] = this.get(versionAttr, { raw: true });\n    }\n    return Utils.mapWhereFieldNames(where, this.constructor);\n  }\n\n  toString() {\n    return `[object SequelizeInstance:${this.constructor.name}]`;\n  }\n\n  /**\n   * Get the value of the underlying data value\n   *\n   * @param {string} key key to look in instance data store\n   *\n   * @returns {any}\n   */\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n\n  /**\n   * Update the underlying data value\n   *\n   * @param {string} key key to set in instance data store\n   * @param {any} value new value for given key\n   *\n   */\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n\n    if (!Utils.isPrimitive(value) && value !== null || value !== originalValue) {\n      this.changed(key, true);\n    }\n\n    this.dataValues[key] = value;\n  }\n\n  /**\n   * If no key is given, returns all values of the instance, also invoking virtual getters.\n   *\n   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.\n   *\n   * @param {string}  [key] key to get value of\n   * @param {Object}  [options] get options\n   * @param {boolean} [options.plain=false] If set to true, included instances will be returned as plain objects\n   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored\n   *\n   * @returns {Object|any}\n   */\n  get(key, options) {\n    if (options === undefined && typeof key === 'object') {\n      options = key;\n      key = undefined;\n    }\n\n    options = options || {};\n\n    if (key) {\n      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {\n        return this._customGetters[key].call(this, key, options);\n      }\n\n      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {\n        if (Array.isArray(this.dataValues[key])) {\n          return this.dataValues[key].map(instance => instance.get(options));\n        }\n        if (this.dataValues[key] instanceof Model) {\n          return this.dataValues[key].get(options);\n        }\n        return this.dataValues[key];\n      }\n\n      return this.dataValues[key];\n    }\n\n    if (\n      this._hasCustomGetters\n      || options.plain && this._options.include\n      || options.clone\n    ) {\n      const values = {};\n      let _key;\n\n      if (this._hasCustomGetters) {\n        for (_key in this._customGetters) {\n          if (\n            this._options.attributes\n            && !this._options.attributes.includes(_key)\n          ) {\n            continue;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {\n            values[_key] = this.get(_key, options);\n          }\n        }\n      }\n\n      for (_key in this.dataValues) {\n        if (\n          !Object.prototype.hasOwnProperty.call(values, _key)\n          && Object.prototype.hasOwnProperty.call(this.dataValues, _key)\n        ) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n\n      return values;\n    }\n\n    return this.dataValues;\n  }\n\n  /**\n   * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).\n   * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function\n   * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.\n   *\n   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be\n   * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.\n   *\n   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).\n   *\n   * Set can also be used to build instances for associations, if you have values for those.\n   * When using set with associations you need to make sure the property key matches the alias of the association\n   * while also making sure that the proper include options have been set (from .build() or .findOne())\n   *\n   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.\n   *\n   * @see\n   * {@link Model.findAll} for more information about includes\n   *\n   * @param {string|Object} key key to set, it can be string or object. When string it will set that key, for object it will loop over all object properties nd set them.\n   * @param {any} value value to set\n   * @param {Object} [options] set options\n   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored\n   * @param {boolean} [options.reset=false] Clear all previously set data values\n   *\n   * @returns {Model}\n   */\n  set(key, value, options) {\n    let values;\n    let originalValue;\n\n    if (typeof key === 'object' && key !== null) {\n      values = key;\n      options = value || {};\n\n      if (options.reset) {\n        this.dataValues = {};\n        for (const key in values) {\n          this.changed(key, false);\n        }\n      }\n\n      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object\n      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {\n        if (Object.keys(this.dataValues).length) {\n          this.dataValues = Object.assign(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n        // If raw, .changed() shouldn't be true\n        this._previousDataValues = _.clone(this.dataValues);\n      } else {\n        // Loop and call set\n        if (options.attributes) {\n          const setKeys = data => {\n            for (const k of data) {\n              if (values[k] === undefined) {\n                continue;\n              }\n              this.set(k, values[k], options);\n            }\n          };\n          setKeys(options.attributes);\n          if (this.constructor._hasVirtualAttributes) {\n            setKeys(this.constructor._virtualAttributes);\n          }\n          if (this._options.includeNames) {\n            setKeys(this._options.includeNames);\n          }\n        } else {\n          for (const key in values) {\n            this.set(key, values[key], options);\n          }\n        }\n\n        if (options.raw) {\n          // If raw, .changed() shouldn't be true\n          this._previousDataValues = _.clone(this.dataValues);\n        }\n      }\n      return this;\n    }\n    if (!options)\n      options = {};\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n\n    // If not raw, and there's a custom setter\n    if (!options.raw && this._customSetters[key]) {\n      this._customSetters[key].call(this, value, key);\n      // custom setter should have changed value, get that changed value\n      // TODO: v5 make setters return new value instead of changing internal store\n      const newValue = this.dataValues[key];\n      if (!Utils.isPrimitive(newValue) && newValue !== null || newValue !== originalValue) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      // Check if we have included models, and if this key matches the include model names/aliases\n      if (this._options && this._options.include && this._options.includeNames.includes(key)) {\n        // Pass it on to the include handler\n        this._setInclude(key, value, options);\n        return this;\n      }\n      // Bunch of stuff we won't do when it's raw\n      if (!options.raw) {\n        // If attribute is not in model definition, return\n        if (!this._isAttribute(key)) {\n          if (key.includes('.') && this.constructor._jsonAttributes.has(key.split('.')[0])) {\n            const previousNestedValue = Dottie.get(this.dataValues, key);\n            if (!_.isEqual(previousNestedValue, value)) {\n              Dottie.set(this.dataValues, key, value);\n              this.changed(key.split('.')[0], true);\n            }\n          }\n          return this;\n        }\n\n        // If attempting to set primary key and primary key is already defined, return\n        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {\n          return this;\n        }\n\n        // If attempting to set read only attributes, return\n        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {\n          return this;\n        }\n      }\n\n      // If there's a data type sanitizer\n      if (\n        !(value instanceof Utils.SequelizeMethod)\n        && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)\n      ) {\n        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);\n      }\n\n      // Set when the value has changed and not raw\n      if (\n        !options.raw &&\n        (\n          // True when sequelize method\n          value instanceof Utils.SequelizeMethod ||\n          // Check for data type type comparators\n          !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) ||\n          // Check default\n          !this.constructor._dataTypeChanges[key] && (!Utils.isPrimitive(value) && value !== null || value !== originalValue)\n        )\n      ) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n\n      // set data value\n      this.dataValues[key] = value;\n    }\n    return this;\n  }\n\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n\n  /**\n   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.\n   *\n   * If changed is called without an argument, it will return an array of keys that have changed.\n   *\n   * If changed is called without an argument and no keys have changed, it will return `false`.\n   *\n   * @param {string} [key] key to check or change status of\n   * @param {any} [value] value to set\n   *\n   * @returns {boolean|Array}\n   */\n  changed(key, value) {\n    if (key) {\n      if (value !== undefined) {\n        this._changed[key] = value;\n        return this;\n      }\n      return this._changed[key] || false;\n    }\n\n    const changed = Object.keys(this.dataValues).filter(key => this.changed(key));\n\n    return changed.length ? changed : false;\n  }\n\n  /**\n   * Returns the previous value for key from `_previousDataValues`.\n   *\n   * If called without a key, returns the previous values for all values which have changed\n   *\n   * @param {string} [key] key to get previous value of\n   *\n   * @returns {any|Array<any>}\n   */\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n\n    return _.pickBy(this._previousDataValues, (value, key) => this.changed(key));\n  }\n\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value)) value = [value];\n    if (value[0] instanceof Model) {\n      value = value.map(instance => instance.dataValues);\n    }\n\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const accessor = key;\n    const primaryKeyAttribute = include.model.primaryKeyAttribute;\n    const childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes\n    };\n    let isEmpty;\n\n    if (include.originalAttributes === undefined || include.originalAttributes.length) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n        isEmpty = value && value[primaryKeyAttribute] === null || value === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n\n  /**\n   * Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed.\n   *\n   * On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of `Sequelize.ValidationError`.\n   * This error will have a property for each of the fields for which validation failed, with the error message for that field.\n   *\n   * @param {Object}      [options] save options\n   * @param {string[]}    [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.\n   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {boolean}     [options.validate=true] If false, validations won't be run.\n   * @param {boolean}     [options.hooks=true] Run before and after create / update + validate hooks\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean}     [options.returning] Append RETURNING * to get back auto generated values (Postgres only)\n   *\n   * @returns {Promise<Model>}\n   */\n  save(options) {\n    if (arguments.length > 1) {\n      throw new Error('The second argument was removed in favor of the options object.');\n    }\n\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      hooks: true,\n      validate: true\n    });\n\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Object.keys(this.constructor.rawAttributes);\n      } else {\n        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));\n      }\n\n      options.defaultFields = options.fields;\n    }\n\n    if (options.returning === undefined) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];\n    const createdAtAttr = this.constructor._timestampAttributes.createdAt;\n    const versionAttr = this.constructor._versionAttribute;\n    const hook = this.isNewRecord ? 'Create' : 'Update';\n    const wasNewRecord = this.isNewRecord;\n    const now = Utils.now(this.sequelize.options.dialect);\n    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;\n\n    if (updatedAtAttr && options.fields.length >= 1 && !options.fields.includes(updatedAtAttr)) {\n      options.fields.push(updatedAtAttr);\n    }\n    if (versionAttr && options.fields.length >= 1 && !options.fields.includes(versionAttr)) {\n      options.fields.push(versionAttr);\n    }\n\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {\n      // UpdateAtAttr might have been added as a result of Object.keys(Model.rawAttributes). In that case we have to remove it again\n      _.remove(options.fields, val => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {\n        options.fields.push(createdAtAttr);\n      }\n\n      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n\n    if (this.isNewRecord === false) {\n      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === undefined) {\n        throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');\n      }\n    }\n\n    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n\n    return Promise.try(() => {\n      // Validate\n      if (options.validate) {\n        return this.validate(options);\n      }\n    }).then(() => {\n      // Run before hook\n      if (options.hooks) {\n        const beforeHookValues = _.pick(this.dataValues, options.fields);\n        let ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values\n        let hookChanged;\n        let afterHookValues;\n\n        if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {\n          ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n        }\n\n        return this.constructor.runHooks(`before${hook}`, this, options)\n          .then(() => {\n            if (options.defaultFields && !this.isNewRecord) {\n              afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n\n              hookChanged = [];\n              for (const key of Object.keys(afterHookValues)) {\n                if (afterHookValues[key] !== beforeHookValues[key]) {\n                  hookChanged.push(key);\n                }\n              }\n\n              options.fields = _.uniq(options.fields.concat(hookChanged));\n            }\n\n            if (hookChanged) {\n              if (options.validate) {\n              // Validate again\n\n                options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);\n                return this.validate(options).then(() => {\n                  delete options.skip;\n                });\n              }\n            }\n          });\n      }\n    }).then(() => {\n      if (!options.fields.length) return this;\n      if (!this.isNewRecord) return this;\n      if (!this._options.include || !this._options.include.length) return this;\n\n      // Nested creation for BelongsTo relations\n      return Promise.map(this._options.include.filter(include => include.association instanceof BelongsTo), include => {\n        const instance = this.get(include.as);\n        if (!instance) return Promise.resolve();\n\n        const includeOptions = _(Utils.cloneDeep(include))\n          .omit(['association'])\n          .defaults({\n            transaction: options.transaction,\n            logging: options.logging,\n            parentRecord: this\n          }).value();\n\n        return instance.save(includeOptions).then(() => this[include.association.accessors.set](instance, { save: false, logging: options.logging }));\n      });\n    }).then(() => {\n      const realFields = options.fields.filter(field => !this.constructor._virtualAttributes.has(field));\n      if (!realFields.length) return this;\n      if (!this.changed() && !this.isNewRecord) return this;\n\n      const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], 'field') || versionAttr;\n      let values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n      let query = null;\n      let args = [];\n      let where;\n\n      if (this.isNewRecord) {\n        query = 'insert';\n        args = [this, this.constructor.getTableName(options), values, options];\n      } else {\n        where = this.where(true);\n        if (versionAttr) {\n          values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;\n        }\n        query = 'update';\n        args = [this, this.constructor.getTableName(options), values, where, options];\n      }\n\n      return this.constructor.QueryInterface[query](...args)\n        .then(([result, rowsUpdated])=> {\n          if (versionAttr) {\n            // Check to see that a row was updated, otherwise it's an optimistic locking error.\n            if (rowsUpdated < 1) {\n              throw new sequelizeErrors.OptimisticLockError({\n                modelName: this.constructor.name,\n                values,\n                where\n              });\n            } else {\n              result.dataValues[versionAttr] = values[versionFieldName];\n            }\n          }\n\n          // Transfer database generated values (defaults, autoincrement, etc)\n          for (const attr of Object.keys(this.constructor.rawAttributes)) {\n            if (this.constructor.rawAttributes[attr].field &&\n                values[this.constructor.rawAttributes[attr].field] !== undefined &&\n                this.constructor.rawAttributes[attr].field !== attr\n            ) {\n              values[attr] = values[this.constructor.rawAttributes[attr].field];\n              delete values[this.constructor.rawAttributes[attr].field];\n            }\n          }\n          values = Object.assign(values, result.dataValues);\n\n          result.dataValues = Object.assign(result.dataValues, values);\n          return result;\n        })\n        .tap(() => {\n          if (!wasNewRecord) return this;\n          if (!this._options.include || !this._options.include.length) return this;\n\n          // Nested creation for HasOne/HasMany/BelongsToMany relations\n          return Promise.map(this._options.include.filter(include => !(include.association instanceof BelongsTo ||\n            include.parent && include.parent.association instanceof BelongsToMany)), include => {\n            let instances = this.get(include.as);\n\n            if (!instances) return Promise.resolve();\n            if (!Array.isArray(instances)) instances = [instances];\n            if (!instances.length) return Promise.resolve();\n\n            const includeOptions = _(Utils.cloneDeep(include))\n              .omit(['association'])\n              .defaults({\n                transaction: options.transaction,\n                logging: options.logging,\n                parentRecord: this\n              }).value();\n\n            // Instances will be updated in place so we can safely treat HasOne like a HasMany\n            return Promise.map(instances, instance => {\n              if (include.association instanceof BelongsToMany) {\n                return instance.save(includeOptions).then(() => {\n                  const values = {};\n                  values[include.association.foreignKey] = this.get(this.constructor.primaryKeyAttribute, { raw: true });\n                  values[include.association.otherKey] = instance.get(instance.constructor.primaryKeyAttribute, { raw: true });\n\n                  // Include values defined in the association\n                  Object.assign(values, include.association.through.scope);\n                  if (instance[include.association.through.model.name]) {\n                    for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                      if (include.association.through.model.rawAttributes[attr]._autoGenerated ||\n                        attr === include.association.foreignKey ||\n                        attr === include.association.otherKey ||\n                        typeof instance[include.association.through.model.name][attr] === undefined) {\n                        continue;\n                      }\n                      values[attr] = instance[include.association.through.model.name][attr];\n                    }\n                  }\n\n                  return include.association.throughModel.create(values, includeOptions);\n                });\n              }\n              instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n              Object.assign(instance, include.association.scope);\n              return instance.save(includeOptions);\n            });\n          });\n        })\n        .tap(result => {\n          // Run after hook\n          if (options.hooks) {\n            return this.constructor.runHooks(`after${hook}`, result, options);\n          }\n        })\n        .then(result => {\n          for (const field of options.fields) {\n            result._previousDataValues[field] = result.dataValues[field];\n            this.changed(field, false);\n          }\n          this.isNewRecord = false;\n          return result;\n        });\n    });\n  }\n\n  /**\n   * Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.\n   * This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,\n   * all references to the Instance are updated with the new data and no new objects are created.\n   *\n   * @see\n   * {@link Model.findAll}\n   *\n   * @param {Object} [options] Options that are passed on to `Model.find`\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   *\n   * @returns {Promise<Model>}\n   */\n  reload(options) {\n    options = Utils.defaults({}, options, {\n      where: this.where(),\n      include: this._options.include || null\n    });\n\n    return this.constructor.findOne(options)\n      .tap(reload => {\n        if (!reload) {\n          throw new sequelizeErrors.InstanceError(\n            'Instance could not be reloaded because it does not exist anymore (find call returned null)'\n          );\n        }\n      })\n      .then(reload => {\n      // update the internal options of the instance\n        this._options = reload._options;\n        // re-set instance values\n        this.set(reload.dataValues, {\n          raw: true,\n          reset: true && !options.attributes\n        });\n        return this;\n      });\n  }\n\n  /**\n  * Validate the attributes of this instance according to validation rules set in the model definition.\n  *\n  * The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.\n  *\n  * @param {Object} [options] Options that are passed to the validator\n  * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated\n  * @param {Array} [options.fields] An array of strings. Only the properties that are in this array will be validated\n  * @param {boolean} [options.hooks=true] Run before and after validate hooks\n  *\n  * @returns {Promise}\n  */\n  validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n\n  /**\n   * This is the same as calling `set` and then calling `save` but it only saves the\n   * exact values passed to it, making it more atomic and safer.\n   *\n   * @see\n   * {@link Model#set}\n   * @see\n   * {@link Model#save}\n   *\n   * @param {Object} values See `set`\n   * @param {Object} options See `save`\n   *\n   * @returns {Promise<Model>}\n   */\n  update(values, options) {\n    // Clone values so it doesn't get modified for caller scope and ignore undefined values\n    values = _.omitBy(values, value => value === undefined);\n\n    const changedBefore = this.changed() || [];\n\n    options = options || {};\n    if (Array.isArray(options)) options = { fields: options };\n\n    options = Utils.cloneDeep(options);\n    const setOptions = Utils.cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n\n    // Now we need to figure out which fields were actually affected by the setter.\n    const sideEffects = _.without(this.changed(), ...changedBefore);\n    const fields = _.union(Object.keys(values), sideEffects);\n\n    if (!options.fields) {\n      options.fields = _.intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n\n    return this.save(options);\n  }\n\n  /**\n   * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.\n   *\n   * @param {Object}      [options={}] destroy options\n   * @param {boolean}     [options.force=false] If set to true, paranoid models will actually be deleted\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   *\n   * @returns {Promise}\n   */\n  destroy(options) {\n    options = Object.assign({\n      hooks: true,\n      force: false\n    }, options);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.constructor.runHooks('beforeDestroy', this, options);\n      }\n    }).then(() => {\n      const where = this.where(true);\n\n      if (this.constructor._timestampAttributes.deletedAt && options.force === false) {\n        const attributeName = this.constructor._timestampAttributes.deletedAt;\n        const attribute = this.constructor.rawAttributes[attributeName];\n        const defaultValue = Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')\n          ? attribute.defaultValue\n          : null;\n        const currentValue = this.getDataValue(attributeName);\n        const undefinedOrNull = currentValue == null && defaultValue == null;\n        if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {\n          // only update timestamp if it wasn't already set\n          this.setDataValue(attributeName, new Date());\n        }\n\n        return this.save(_.defaults({ hooks: false }, options));\n      }\n      return this.constructor.QueryInterface.delete(this, this.constructor.getTableName(options), where, Object.assign({ type: QueryTypes.DELETE, limit: null }, options));\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.constructor.runHooks('afterDestroy', this, options);\n      }\n    });\n  }\n\n  /**\n   * Helper method to determine if a instance is \"soft deleted\".  This is\n   * particularly useful if the implementer renamed the `deletedAt` attribute\n   * to something different.  This method requires `paranoid` to be enabled.\n   *\n   * @returns {boolean}\n   */\n  isSoftDeleted() {\n    if (!this.constructor._timestampAttributes.deletedAt) {\n      throw new Error('Model is not paranoid');\n    }\n\n    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;\n    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;\n    const isSet = deletedAt !== defaultValue;\n\n    return isSet;\n  }\n\n  /**\n   * Restore the row corresponding to this instance. Only available for paranoid models.\n   *\n   * @param {Object}      [options={}] restore options\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   *\n   * @returns {Promise}\n   */\n  restore(options) {\n    if (!this.constructor._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n    options = Object.assign({\n      hooks: true,\n      force: false\n    }, options);\n\n    return Promise.try(() => {\n      // Run before hook\n      if (options.hooks) {\n        return this.constructor.runHooks('beforeRestore', this, options);\n      }\n    }).then(() => {\n      const deletedAtCol = this.constructor._timestampAttributes.deletedAt;\n      const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];\n      const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n      this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n      return this.save(Object.assign({}, options, { hooks: false, omitNull: false }));\n    }).tap(() => {\n      // Run after hook\n      if (options.hooks) {\n        return this.constructor.runHooks('afterRestore', this, options);\n      }\n    });\n  }\n\n  /**\n   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n   * ```sql\n   * SET column = column + X\n   * ```\n   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.\n   *\n   * @example\n   * instance.increment('number') // increment number by 1\n   *\n   * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2\n   *\n   * // increment answer by 42, and tries by 1.\n   * // `by` is ignored, since each column has its own value\n   * instance.increment({ answer: 42, tries: 1}, { by: 2 })\n   *\n   * @see\n   * {@link Model#reload}\n   *\n   * @param {string|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n   * @param {Object} [options] options\n   * @param {number} [options.by=1] The number to increment by\n   * @param {boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean} [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)\n   *\n   * @returns {Promise<Model>}\n   * @since 4.0.0\n   */\n  increment(fields, options) {\n    const identifier = this.where();\n\n    options = Utils.cloneDeep(options);\n    options.where = Object.assign({}, options.where, identifier);\n    options.instance = this;\n\n    return this.constructor.increment(fields, options).return(this);\n  }\n\n  /**\n   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n   * ```sql\n   * SET column = column - X\n   * ```\n   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.\n   *\n   * @example\n   * instance.decrement('number') // decrement number by 1\n   *\n   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2\n   *\n   * // decrement answer by 42, and tries by 1.\n   * // `by` is ignored, since each column has its own value\n   * instance.decrement({ answer: 42, tries: 1}, { by: 2 })\n   *\n   * @see\n   * {@link Model#reload}\n   * @param {string|Array|Object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given\n   * @param {Object}      [options] decrement options\n   * @param {number}      [options.by=1] The number to decrement by\n   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.\n   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Transaction} [options.transaction] Transaction to run query under\n   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean}     [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)\n   *\n   * @returns {Promise}\n   */\n  decrement(fields, options) {\n    options = _.defaults({ increment: false }, options, {\n      by: 1\n    });\n\n    return this.increment(fields, options);\n  }\n\n  /**\n   * Check whether this and `other` Instance refer to the same row\n   *\n   * @param {Model} other Other instance to compare against\n   *\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!other || !other.constructor) {\n      return false;\n    }\n\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n\n    return this.constructor.primaryKeyAttributes.every(attribute => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));\n  }\n\n  /**\n   * Check if this is equal to one of `others` by calling equals\n   *\n   * @param {Array<Model>} others An array of instances to check against\n   *\n   * @returns {boolean}\n   */\n  equalsOneOf(others) {\n    return others.some(other => this.equals(other));\n  }\n\n  setValidators(attribute, validators) {\n    this.validators[attribute] = validators;\n  }\n\n  /**\n   * Convert the instance to a JSON representation.\n   * Proxies to calling `get` with no keys.\n   * This means get all values gotten from the DB, and apply all custom getters.\n   *\n   * @see\n   * {@link Model#get}\n   *\n   * @returns {Object}\n   */\n  toJSON() {\n    return _.cloneDeep(\n      this.get({\n        plain: true\n      })\n    );\n  }\n\n  /**\n   * Creates a 1:m association between this (the source) and the provided target.\n   * The foreign key is added on the target.\n   *\n   * @param {Model}               target Target model\n   * @param {Object}              [options] hasMany association options\n   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string|Object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n   * @param {string|Object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table\n   * @param {Object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n   * @param {string}              [options.onUpdate='CASCADE'] Set `ON UPDATE`\n   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   *\n   * @returns {HasMany}\n   *\n   * @example\n   * User.hasMany(Profile) // This will add userId to the profile table\n   */\n  static hasMany(target, options) {} // eslint-disable-line\n\n  /**\n   * Create an N:M association with a join table. Defining `through` is required.\n   *\n   * @param {Model}               target Target model\n   * @param {Object}              options belongsToMany association options\n   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {Model|string|Object} options.through The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.\n   * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.\n   * @param {Object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)\n   * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)\n   * @param {string|Object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n   * @param {string|Object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string|Object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n   * @param {Object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n   * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps\n   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m\n   * @param {string}              [options.onUpdate='CASCADE'] Sets `ON UPDATE`\n   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   *\n   * @returns {BelongsToMany}\n   *\n   * @example\n   * // Automagically generated join model\n   * User.belongsToMany(Project, { through: 'UserProjects' })\n   * Project.belongsToMany(User, { through: 'UserProjects' })\n   *\n   * // Join model with additional attributes\n   * const UserProjects = sequelize.define('UserProjects', {\n   *   started: Sequelize.BOOLEAN\n   * })\n   * User.belongsToMany(Project, { through: UserProjects })\n   * Project.belongsToMany(User, { through: UserProjects })\n   */\n  static belongsToMany(target, options) {} // eslint-disable-line\n\n  /**\n   * Creates an association between this (the source) and the provided target. The foreign key is added on the target.\n   *\n   * @param {Model}           target Target model\n   * @param {Object}          [options] hasOne association options\n   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n   * @param {string|Object}   [options.foreignKey] The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n   * @param {string}          [options.sourceKey] The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table\n   * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'\n   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   * @param {string}          [options.uniqueKey] The custom name for unique constraint.\n   *\n   * @returns {HasOne}\n   *\n   * @example\n   * User.hasOne(Profile) // This will add userId to the profile table\n   */\n  static hasOne(target, options) {} // eslint-disable-line\n\n  /**\n   * Creates an association between this (the source) and the provided target. The foreign key is added on the source.\n   *\n   * @param {Model}           target The target model\n   * @param {Object}          [options] belongsTo association options\n   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n   * @param {string|Object}   [options.foreignKey] The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n   * @param {string}          [options.targetKey] The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table\n   * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise\n   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'\n   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n   *\n   * @returns {BelongsTo}\n   *\n   * @example\n   * Profile.belongsTo(User) // This will add userId to the profile table\n   */\n  static belongsTo(target, options) {} // eslint-disable-line\n}\n\nObject.assign(Model, associationsMixin);\nHooks.applyTo(Model, true);\n\nmodule.exports = Model;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1751,
    "kind": "variable",
    "name": "assert",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~assert",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1752,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1753,
    "kind": "variable",
    "name": "Dottie",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Dottie",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1754,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1755,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1756,
    "kind": "variable",
    "name": "BelongsTo",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~BelongsTo",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1757,
    "kind": "variable",
    "name": "BelongsToMany",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~BelongsToMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1758,
    "kind": "variable",
    "name": "InstanceValidator",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~InstanceValidator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1759,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1760,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1761,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1762,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1763,
    "kind": "variable",
    "name": "HasMany",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~HasMany",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1764,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1765,
    "kind": "variable",
    "name": "Hooks",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Hooks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1766,
    "kind": "variable",
    "name": "associationsMixin",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~associationsMixin",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1767,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1768,
    "kind": "variable",
    "name": "noDoubleNestedGroup",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~noDoubleNestedGroup",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1769,
    "kind": "variable",
    "name": "validQueryKeywords",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~validQueryKeywords",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1770,
    "kind": "variable",
    "name": "nonCascadingOptions",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~nonCascadingOptions",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1771,
    "kind": "class",
    "name": "Model",
    "memberof": "lib/model.js",
    "static": true,
    "longname": "lib/model.js~Model",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/model.js",
    "importStyle": null,
    "description": "A Model represents a table in the database. Instances of this class represent a database row.\n\nModel instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.\nBy default, the values from dataValues can also be accessed directly from the Instance, that is:\n```js\ninstance.field\n// is the same as\ninstance.get('field')\n// is the same as\ninstance.getDataValue('field')\n```\nHowever, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.\nAccessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.",
    "see": [
      "{@link Sequelize#define} for more information about getters and setters"
    ],
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@mixes",
        "tagValue": "Hooks"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 1772,
    "kind": "get",
    "name": "QueryInterface",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.QueryInterface",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1773,
    "kind": "get",
    "name": "QueryGenerator",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1774,
    "kind": "get",
    "name": "sequelize",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#sequelize",
    "access": "public",
    "description": "A reference to the sequelize instance",
    "see": [
      "{@link Sequelize}"
    ],
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize}"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "sequelize",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1775,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#constructor",
    "access": "public",
    "description": "Builds a new model instance.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "values",
        "description": "an object of key value pairs"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "instance construction options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.raw",
        "description": "If set to true, values will ignore field and virtual setters."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.isNewRecord",
        "description": "Is this a new record"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include",
        "description": "an array of include options - Used to build prefetched/included model instances. See `set`"
      }
    ]
  },
  {
    "__docId__": 1776,
    "kind": "member",
    "name": "dataValues",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#dataValues",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1777,
    "kind": "member",
    "name": "_previousDataValues",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#_previousDataValues",
    "access": "private",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1778,
    "kind": "member",
    "name": "_changed",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#_changed",
    "access": "private",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1779,
    "kind": "member",
    "name": "_modelOptions",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#_modelOptions",
    "access": "private",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1780,
    "kind": "member",
    "name": "_options",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#_options",
    "access": "private",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1781,
    "kind": "member",
    "name": "isNewRecord",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#isNewRecord",
    "access": "public",
    "description": "Returns true if this instance has not yet been persisted to the database",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "isNewRecord",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1782,
    "kind": "method",
    "name": "_initValues",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#_initValues",
    "access": "private",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1783,
    "kind": "method",
    "name": "_paranoidClause",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._paranoidClause",
    "access": "private",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1784,
    "kind": "method",
    "name": "_addDefaultAttributes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._addDefaultAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1785,
    "kind": "member",
    "name": "rawAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.rawAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 277,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1786,
    "kind": "method",
    "name": "_findAutoIncrementAttribute",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._findAutoIncrementAttribute",
    "access": "private",
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1787,
    "kind": "member",
    "name": "autoIncrementAttribute",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.autoIncrementAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 299,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1789,
    "kind": "method",
    "name": "_conformIncludes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._conformIncludes",
    "access": "private",
    "description": null,
    "lineNumber": 314,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "self",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1790,
    "kind": "method",
    "name": "_transformStringAssociation",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._transformStringAssociation",
    "access": "private",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "self",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1791,
    "kind": "method",
    "name": "_conformInclude",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._conformInclude",
    "access": "private",
    "description": null,
    "lineNumber": 339,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "self",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1792,
    "kind": "method",
    "name": "_expandIncludeAllElement",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._expandIncludeAllElement",
    "access": "private",
    "description": null,
    "lineNumber": 393,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "includes",
        "types": [
          "*"
        ]
      },
      {
        "name": "include",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1793,
    "kind": "method",
    "name": "_validateIncludedElements",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._validateIncludedElements",
    "access": "private",
    "description": null,
    "lineNumber": 495,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableNames",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1794,
    "kind": "method",
    "name": "_validateIncludedElement",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._validateIncludedElement",
    "access": "private",
    "description": null,
    "lineNumber": 585,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "include",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1795,
    "kind": "method",
    "name": "_getIncludedAssociation",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._getIncludedAssociation",
    "access": "private",
    "description": null,
    "lineNumber": 713,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "targetModel",
        "types": [
          "*"
        ]
      },
      {
        "name": "targetAlias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1796,
    "kind": "method",
    "name": "_expandIncludeAll",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._expandIncludeAll",
    "access": "private",
    "description": null,
    "lineNumber": 741,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1797,
    "kind": "method",
    "name": "_conformIndex",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._conformIndex",
    "access": "private",
    "description": null,
    "lineNumber": 763,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1798,
    "kind": "method",
    "name": "_uniqIncludes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._uniqIncludes",
    "access": "private",
    "description": null,
    "lineNumber": 782,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1799,
    "kind": "method",
    "name": "_baseMerge",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._baseMerge",
    "access": "private",
    "description": null,
    "lineNumber": 791,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1800,
    "kind": "method",
    "name": "_mergeFunction",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._mergeFunction",
    "access": "private",
    "description": null,
    "lineNumber": 798,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "objValue",
        "types": [
          "*"
        ]
      },
      {
        "name": "srcValue",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1801,
    "kind": "method",
    "name": "_assignOptions",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._assignOptions",
    "access": "private",
    "description": null,
    "lineNumber": 825,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1802,
    "kind": "method",
    "name": "_defaultsOptions",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._defaultsOptions",
    "access": "private",
    "description": null,
    "lineNumber": 829,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "opts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1803,
    "kind": "method",
    "name": "init",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.init",
    "access": "public",
    "description": "Initialize a model, representing a table in the DB, with attributes and options.\n\nThe table columns are defined by the hash that is given as the first argument.\nEach attribute of the hash represents a column.\n\nFor more about <a href=\"/manual/tutorial/models-definition.html#validations\"/>Validations</a>\n\nMore examples, <a href=\"/manual/tutorial/models-definition.html\"/>Model Definition</a>",
    "examples": [
      "Project.init({\n  columnA: {\n    type: Sequelize.BOOLEAN,\n    validate: {\n      is: ['[a-z]','i'],        // will only allow letters\n      max: 23,                  // only allow values <= 23\n      isIn: {\n        args: [['en', 'zh']],\n        msg: \"Must be English or Chinese\"\n      }\n    },\n    field: 'column_a'\n    // Other attributes here\n  },\n  columnB: Sequelize.STRING,\n  columnC: 'MY VERY OWN COLUMN TYPE'\n}, {sequelize})\n\nsequelize.models.modelName // The model will now be available in models under the class name"
    ],
    "see": [
      "{@link DataTypes}",
      "{@link Hooks}"
    ],
    "lineNumber": 926,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "DataTypes",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes.column",
        "description": "The description of a database column"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "DataTypes"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes.column.type",
        "description": "A string or a data type"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "attributes.column.allowNull",
        "description": "If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved."
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "attributes.column.defaultValue",
        "description": "A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "attributes.column.unique",
        "description": "If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "attributes.column.primaryKey",
        "description": "If true, this attribute will be marked as primary key"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "attributes.column.field",
        "description": "If set, sequelize will map the attribute name to a different name in the database"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "attributes.column.autoIncrement",
        "description": "If true, this column will be set to auto increment"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "attributes.column.autoIncrementIdentity",
        "description": "If true, combined with autoIncrement=true, will use Postgres `GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL`. Postgres 10+ only."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "attributes.column.comment",
        "description": "Comment for this column"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Model"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "attributes.column.references",
        "description": "An object with reference configurations"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.references.model",
        "description": "If this column references another table, provide it here as a Model, or a string"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'id'",
        "defaultRaw": "'id'",
        "name": "attributes.column.references.key",
        "description": "The column of the foreign table that this column references"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.onUpdate",
        "description": "What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.onDelete",
        "description": "What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.get",
        "description": "Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.set",
        "description": "Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes.column.validate",
        "description": "An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field and the instance itself as the `this` binding, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation; if it is async, the callback should be called with the error text."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "These options are merged with the default define options provided to the Sequelize constructor"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.sequelize",
        "description": "Define the sequelize instance to attach to the new Model. Throw error if none is provided."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.modelName",
        "description": "Set name of the model. By default its same as Class name."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.defaultScope",
        "description": "Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scopes",
        "description": "More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.omitNull",
        "description": "Don't persist null values. This means that all columns with null values will not be saved"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.timestamps",
        "description": "Adds createdAt and updatedAt timestamps to the model."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.paranoid",
        "description": "Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.underscored",
        "description": "Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set `field` option"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.freezeTableName",
        "description": "If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.name",
        "description": "An object with two attributes, `singular` and `plural`, which are used when this model is associated to others."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Utils.singularize(modelName)",
        "defaultRaw": "Utils.singularize(modelName)",
        "name": "options.name.singular",
        "description": "Singular name for model"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Utils.pluralize(modelName)",
        "defaultRaw": "Utils.pluralize(modelName)",
        "name": "options.name.plural",
        "description": "Plural name for model"
      },
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes",
        "description": "indexes definitions"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes[].name",
        "description": "The name of the index. Defaults to model name + _ + fields concatenated"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes[].type",
        "description": "Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes[].using",
        "description": "The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes[].operator",
        "description": "Specify index operator."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.indexes[].unique",
        "description": "Should the index by unique? Can also be triggered by setting type to `UNIQUE`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.indexes[].concurrently",
        "description": "PostgresSQL will build the index without taking any write locks. Postgres only"
      },
      {
        "nullable": null,
        "types": [
          "Array<string|Object>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.indexes[].fields",
        "description": "An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.createdAt",
        "description": "Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.updatedAt",
        "description": "Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.deletedAt",
        "description": "Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.tableName",
        "description": "Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'public'",
        "defaultRaw": "'public'",
        "name": "options.schema",
        "description": "schema"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.engine",
        "description": "Specify engine for model's table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.charset",
        "description": "Specify charset for model's table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.comment",
        "description": "Specify comment for model's table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.collate",
        "description": "Specify collation for model's table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.initialAutoIncrement",
        "description": "Set the initial AUTO_INCREMENT value for the table in MySQL."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.hooks",
        "description": "An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, beforeSave, afterDestroy, afterUpdate, afterBulkCreate, afterSave, afterBulkDestroy and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.validate",
        "description": "An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1804,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 931,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1805,
    "kind": "member",
    "name": "options",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.options",
    "access": "public",
    "description": null,
    "lineNumber": 958,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1806,
    "kind": "member",
    "name": "associations",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.associations",
    "access": "public",
    "description": null,
    "lineNumber": 978,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1807,
    "kind": "member",
    "name": "underscored",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.underscored",
    "access": "public",
    "description": null,
    "lineNumber": 981,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1808,
    "kind": "member",
    "name": "tableName",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.tableName",
    "access": "public",
    "description": null,
    "lineNumber": 984,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1810,
    "kind": "member",
    "name": "_schema",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._schema",
    "access": "private",
    "description": null,
    "lineNumber": 989,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1811,
    "kind": "member",
    "name": "_schemaDelimiter",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._schemaDelimiter",
    "access": "private",
    "description": null,
    "lineNumber": 990,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1813,
    "kind": "member",
    "name": "_indexes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._indexes",
    "access": "private",
    "description": null,
    "lineNumber": 1022,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1814,
    "kind": "member",
    "name": "primaryKeys",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.primaryKeys",
    "access": "public",
    "description": null,
    "lineNumber": 1025,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1815,
    "kind": "member",
    "name": "_readOnlyAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._readOnlyAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1026,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1816,
    "kind": "member",
    "name": "_timestampAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._timestampAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1027,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1817,
    "kind": "member",
    "name": "_versionAttribute",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._versionAttribute",
    "access": "private",
    "description": null,
    "lineNumber": 1047,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1818,
    "kind": "member",
    "name": "_hasReadOnlyAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasReadOnlyAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1051,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1819,
    "kind": "member",
    "name": "_scope",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._scope",
    "access": "private",
    "description": null,
    "lineNumber": 1058,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1820,
    "kind": "member",
    "name": "_scopeNames",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._scopeNames",
    "access": "private",
    "description": null,
    "lineNumber": 1059,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "string[]"
      ]
    }
  },
  {
    "__docId__": 1821,
    "kind": "method",
    "name": "refreshAttributes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.refreshAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 1067,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1822,
    "kind": "member",
    "name": "_dataTypeChanges",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._dataTypeChanges",
    "access": "private",
    "description": null,
    "lineNumber": 1120,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1823,
    "kind": "member",
    "name": "_dataTypeSanitizers",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._dataTypeSanitizers",
    "access": "private",
    "description": null,
    "lineNumber": 1121,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1824,
    "kind": "member",
    "name": "_hasBooleanAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasBooleanAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1123,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1825,
    "kind": "member",
    "name": "_hasDateAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasDateAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1124,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1826,
    "kind": "member",
    "name": "_jsonAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._jsonAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1125,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1827,
    "kind": "member",
    "name": "_virtualAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._virtualAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1126,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1828,
    "kind": "member",
    "name": "_defaultValues",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._defaultValues",
    "access": "private",
    "description": null,
    "lineNumber": 1127,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1829,
    "kind": "member",
    "name": "fieldRawAttributesMap",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.fieldRawAttributesMap",
    "access": "public",
    "description": null,
    "lineNumber": 1130,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1831,
    "kind": "member",
    "name": "uniqueKeys",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.uniqueKeys",
    "access": "public",
    "description": null,
    "lineNumber": 1133,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1834,
    "kind": "member",
    "name": "fieldAttributeMap",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.fieldAttributeMap",
    "access": "public",
    "description": null,
    "lineNumber": 1218,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1835,
    "kind": "member",
    "name": "_hasJsonAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasJsonAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1225,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1836,
    "kind": "member",
    "name": "_hasVirtualAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasVirtualAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1227,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1837,
    "kind": "member",
    "name": "_hasDefaultValues",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasDefaultValues",
    "access": "private",
    "description": null,
    "lineNumber": 1229,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1838,
    "kind": "member",
    "name": "tableAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.tableAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 1231,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1839,
    "kind": "member",
    "name": "primaryKeyAttributes",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.primaryKeyAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 1248,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1840,
    "kind": "member",
    "name": "primaryKeyAttribute",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.primaryKeyAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 1249,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1841,
    "kind": "member",
    "name": "primaryKeyField",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model.primaryKeyField",
    "access": "public",
    "description": null,
    "lineNumber": 1251,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1842,
    "kind": "member",
    "name": "_hasPrimaryKeys",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._hasPrimaryKeys",
    "access": "private",
    "description": null,
    "lineNumber": 1254,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1843,
    "kind": "member",
    "name": "_isPrimaryKey",
    "memberof": "lib/model.js~Model",
    "static": true,
    "longname": "lib/model.js~Model._isPrimaryKey",
    "access": "private",
    "description": null,
    "lineNumber": 1255,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1844,
    "kind": "method",
    "name": "removeAttribute",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.removeAttribute",
    "access": "public",
    "description": "Remove attribute from model definition",
    "lineNumber": 1263,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attribute",
        "description": "name of attribute to remove"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1845,
    "kind": "method",
    "name": "sync",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.sync",
    "access": "public",
    "description": "Sync this Model to the DB, that is create the table.",
    "see": [
      "{@link Sequelize#sync} for options"
    ],
    "lineNumber": 1278,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "sync options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1846,
    "kind": "method",
    "name": "drop",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.drop",
    "access": "public",
    "description": "Drop the table represented by this Model",
    "lineNumber": 1389,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "drop options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.cascade",
        "description": "Also drop all objects depending on this table, such as views. Only works in postgres"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1847,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.dropSchema",
    "access": "public",
    "description": null,
    "lineNumber": 1393,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1848,
    "kind": "method",
    "name": "schema",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.schema",
    "access": "public",
    "description": "Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `\"schema\".\"tableName\"`,\nwhile the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.\n\nThis method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important\nto call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.\n\nIf a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call\nfor the model.",
    "see": [
      "{@link Sequelize#define} for more information about setting a default schema."
    ],
    "lineNumber": 1418,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "The name of the schema"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "schema options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'.'",
        "defaultRaw": "'.'",
        "name": "options.schemaDelimiter",
        "description": "The character(s) that separates the schema name from the table name"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1849,
    "kind": "method",
    "name": "getTableName",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.getTableName",
    "access": "public",
    "description": "Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema,\nor an object with `tableName`, `schema` and `delimiter` properties.",
    "lineNumber": 1442,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string|Object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1850,
    "kind": "method",
    "name": "unscoped",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.unscoped",
    "access": "public",
    "description": "Get un-scoped model",
    "lineNumber": 1451,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1851,
    "kind": "method",
    "name": "addScope",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.addScope",
    "access": "public",
    "description": "Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.\n\nBy default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.",
    "lineNumber": 1465,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the scope. Use `defaultScope` to override the default scope"
      },
      {
        "nullable": null,
        "types": [
          "Object",
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "scope",
        "description": "scope or options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "scope options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.override",
        "description": "override old scope if already defined"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1852,
    "kind": "method",
    "name": "scope",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.scope",
    "access": "public",
    "description": "Apply a scope created in `define` to the model.",
    "examples": [
      "<caption>how to create scopes</caption>\nconst Model = sequelize.define('model', attributes, {\n  defaultScope: {\n    where: {\n      username: 'dan'\n    },\n    limit: 12\n  },\n  scopes: {\n    isALie: {\n      where: {\n        stuff: 'cake'\n      }\n    },\n    complexFunction: function(email, accessLevel) {\n      return {\n        where: {\n          email: {\n            [Op.like]: email\n          },\n          access_level {\n            [Op.gte]: accessLevel\n          }\n        }\n      }\n    }\n  }\n})\n\n# As you have defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:\n\nModel.findAll() // WHERE username = 'dan'\nModel.findAll({ where: { age: { [Op.gt]: 12 } } }) // WHERE age > 12 AND username = 'dan'",
      "<caption>To invoke scope functions you can do</caption>\nModel.scope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()\n// WHERE email like 'dan@sequelize.com%' AND access_level >= 42"
    ],
    "lineNumber": 1526,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope."
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "Array",
          "Object",
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "option",
        "description": "The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope."
    }
  },
  {
    "__docId__": 1853,
    "kind": "method",
    "name": "findAll",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findAll",
    "access": "public",
    "description": "Search for multiple instances.",
    "examples": [
      "<caption>Simple search using AND and =</caption>\nModel.findAll({\n  where: {\n    attr1: 42,\n    attr2: 'cake'\n  }\n})\n\n# WHERE attr1 = 42 AND attr2 = 'cake'",
      "<caption>Using greater than, less than etc.</caption>\nconst {gt, lte, ne, in: opIn} = Sequelize.Op;\n\nModel.findAll({\n  where: {\n    attr1: {\n      [gt]: 50\n    },\n    attr2: {\n      [lte]: 45\n    },\n    attr3: {\n      [opIn]: [1,2,3]\n    },\n    attr4: {\n      [ne]: 5\n    }\n  }\n})\n\n# WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5",
      "<caption>Queries using OR</caption>\nconst {or, and, gt, lt} = Sequelize.Op;\n\nModel.findAll({\n  where: {\n    name: 'a project',\n    [or]: [\n      {id: [1, 2, 3]},\n      {\n        [and]: [\n          {id: {[gt]: 10}},\n          {id: {[lt]: 100}}\n        ]\n      }\n    ]\n  }\n});\n\n# WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));"
    ],
    "see": [
      "{@link Operators} for possible operators\n__Alias__: _all_\n\nThe promise is resolved with an array of Model instances if the query succeeds._",
      "{@link Sequelize#query}"
    ],
    "lineNumber": 1683,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<Model>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "A hash of options to describe the scope of the search"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "A hash of attributes to describe your search. See above for examples."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.attributes",
        "description": "A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.attributes.include",
        "description": "Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.attributes.exclude",
        "description": "Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.paranoid",
        "description": "If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model."
      },
      {
        "nullable": null,
        "types": [
          "Array<Object|Model|string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include",
        "description": "A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y)."
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].model",
        "description": "The model you want to eagerly load"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].as",
        "description": "The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural"
      },
      {
        "nullable": null,
        "types": [
          "Association"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].association",
        "description": "The association you want to eagerly load. (This can be used instead of providing a model/as pair)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].where",
        "description": "Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.include[].or",
        "description": "Whether to bind the ON and WHERE clause together by OR instead of AND."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].on",
        "description": "Supply your own ON condition for the join."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].attributes",
        "description": "A list of attributes to select from the child model"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].required",
        "description": "If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].right",
        "description": "If true, converts to a right join if dialect support it. Ignored if `include.required` is true."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].separate",
        "description": "If true, runs a separate query to fetch the associated instances, only supported for hasMany associations"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].limit",
        "description": "Limit the joined rows, only supported with include.separate=true"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].through.where",
        "description": "Filter on the join model for belongsToMany relations"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].through.attributes",
        "description": "A list of attributes to select from the join model for belongsToMany relations"
      },
      {
        "nullable": null,
        "types": [
          "Array<Object|Model|string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].include",
        "description": "Load further nested related models"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include[].duplicating",
        "description": "Mark the include as duplicating, will prevent a subquery from being used."
      },
      {
        "nullable": null,
        "types": [
          "Array",
          "Sequelize.fn",
          "Sequelize.col",
          "Sequelize.literal"
        ],
        "spread": false,
        "optional": true,
        "name": "options.order",
        "description": "Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.limit",
        "description": "Limit for result"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.offset",
        "description": "Offset for result"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.lock",
        "description": "Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See [transaction.LOCK for an example](transaction#lock)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.skipLocked",
        "description": "Skip locked rows. Only supported in Postgres."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.raw",
        "description": "Return raw result. See sequelize.query for more information."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.having",
        "description": "Having options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Error"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.rejectOnEmpty",
        "description": "Throws an error when no records found"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<Model>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1854,
    "kind": "method",
    "name": "warnOnInvalidOptions",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.warnOnInvalidOptions",
    "access": "public",
    "description": null,
    "lineNumber": 1781,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "validColumnNames",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1855,
    "kind": "method",
    "name": "_injectDependentVirtualAttributes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._injectDependentVirtualAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 1793,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1856,
    "kind": "method",
    "name": "_findSeparate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._findSeparate",
    "access": "private",
    "description": null,
    "lineNumber": 1811,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1857,
    "kind": "method",
    "name": "findByPk",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findByPk",
    "access": "public",
    "description": "Search for a single instance by its primary key._",
    "see": [
      "{@link Model.findAll}           for a full explanation of options, Note that options.where is not supported."
    ],
    "lineNumber": 1873,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "The value of the desired instance's primary key."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1858,
    "kind": "method",
    "name": "findOne",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findOne",
    "access": "public",
    "description": "Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.\n\n__Alias__: _find_",
    "see": [
      "{@link Model.findAll} for an explanation of options"
    ],
    "lineNumber": 1907,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "A hash of options to describe the scope of the search"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1859,
    "kind": "method",
    "name": "aggregate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.aggregate",
    "access": "public",
    "description": "Run an aggregation method on the specified field",
    "lineNumber": 1947,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<DataTypes|Object>} Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attribute",
        "description": "The attribute to aggregate over. Can be a field name or *"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "aggregateFunction",
        "description": "The function to use for aggregation, e.g. sum, max etc."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options. See sequelize.query for full options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "A hash of search attributes."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "DataTypes",
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.dataType",
        "description": "The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.distinct",
        "description": "Applies DISTINCT to the field being aggregated over"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.plain",
        "description": "When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataTypes|Object>"
      ],
      "spread": false,
      "description": "Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned."
    }
  },
  {
    "__docId__": 1860,
    "kind": "method",
    "name": "count",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.count",
    "access": "public",
    "description": "Count the number of records matching the provided where clause.\n\nIf you provide an `include` option, the number of matching associations will be counted instead.",
    "lineNumber": 2023,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "A hash of search attributes."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include",
        "description": "Include options. See `find` for details"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.paranoid",
        "description": "Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.distinct",
        "description": "Apply COUNT(DISTINCT(col)) on primary key or on options.col."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.col",
        "description": "Column on which COUNT() should be applied"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.attributes",
        "description": "Used in conjunction with `group`"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.group",
        "description": "For creating complex counts. Will return multiple rows as needed."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1861,
    "kind": "method",
    "name": "findAndCountAll",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findAndCountAll",
    "access": "public",
    "description": "Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging",
    "examples": [
      "Model.findAndCountAll({\n  where: ...,\n  limit: 12,\n  offset: 12\n}).then(result => {\n  ...\n})\n\n# In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.\n\n# When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.\n\n# Suppose you want to find all users who have a profile attached:\n\nUser.findAndCountAll({\n  include: [\n     { model: Profile, required: true}\n  ],\n  limit 3\n});\n\n# Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted"
    ],
    "see": [
      "{@link Model.findAll} for a specification of find and query options",
      "{@link Model.count} for a specification of count options"
    ],
    "lineNumber": 2089,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<{count: number, rows: Model[]}>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "See findAll options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{count: number, rows: Model[]}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1862,
    "kind": "method",
    "name": "max",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.max",
    "access": "public",
    "description": "Find the maximum value of field",
    "see": [
      "{@link Model.aggregate} for options"
    ],
    "lineNumber": 2121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "attribute / field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "See aggregate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1863,
    "kind": "method",
    "name": "min",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.min",
    "access": "public",
    "description": "Find the minimum value of field",
    "see": [
      "{@link Model.aggregate} for options"
    ],
    "lineNumber": 2136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "attribute / field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "See aggregate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1864,
    "kind": "method",
    "name": "sum",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.sum",
    "access": "public",
    "description": "Find the sum of field",
    "see": [
      "{@link Model.aggregate} for options"
    ],
    "lineNumber": 2151,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "attribute / field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "See aggregate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1865,
    "kind": "method",
    "name": "build",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.build",
    "access": "public",
    "description": "Builds a new model instance.",
    "lineNumber": 2166,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model|Array<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "An object of key value pairs or an array of such. If an array, the function will return an array of instances."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Instance build options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.raw",
        "description": "If set to true, values will ignore field and virtual setters."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.isNewRecord",
        "description": "Is this new record"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include",
        "description": "an array of include options - Used to build prefetched/included model instances. See `set`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model",
        "Array<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1866,
    "kind": "method",
    "name": "bulkBuild",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.bulkBuild",
    "access": "public",
    "description": null,
    "lineNumber": 2174,
    "undocument": true,
    "params": [
      {
        "name": "valueSets",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1867,
    "kind": "method",
    "name": "create",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.create",
    "access": "public",
    "description": "Builds a new model instance and calls save on it.",
    "see": [
      "{@link Model.build}",
      "{@link Model.save}"
    ],
    "lineNumber": 2221,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "hash of data values to create new record with"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "build and query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.raw",
        "description": "If set to true, values will ignore field and virtual setters."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.isNewRecord",
        "description": "Is this new record"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.include",
        "description": "an array of include options - Used to build prefetched/included model instances. See `set`"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "If set, only columns matching those in fields will be saved"
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.validate",
        "description": "If false, validations won't be run."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before and after create / update + validate hooks"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.returning",
        "description": "Return the affected rows (only for postgres)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1868,
    "kind": "method",
    "name": "findOrBuild",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findOrBuild",
    "access": "public",
    "description": "Find a row that matches the query, or build (but don't save) the row if none is found.\nThe successful result of the promise will be (instance, built)",
    "lineNumber": 2244,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model,boolean>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.where",
        "description": "A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.defaults",
        "description": "Default values to use if building a new instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model,boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1869,
    "kind": "method",
    "name": "findOrCreate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findOrCreate",
    "access": "public",
    "description": "Find a row that matches the query, or build and save the row if none is found\nThe successful result of the promise will be (instance, created)\n\nIf no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.\nHowever, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.\nIf a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.",
    "see": [
      "{@link Model.findAll} for a full specification of find and options"
    ],
    "lineNumber": 2288,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model,boolean>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "find and create options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.where",
        "description": "where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.defaults",
        "description": "Default values to use if creating a new instance"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model,boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1870,
    "kind": "method",
    "name": "findCreateFind",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.findCreateFind",
    "access": "public",
    "description": "A more performant findOrCreate that will not work under a transaction (at least not in postgres)\nWill execute a find call, if empty then attempt to create, if unique constraint then attempt to find again",
    "see": [
      "{@link Model.findAll} for a full specification of find and options"
    ],
    "lineNumber": 2397,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model,boolean>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "find options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.where",
        "description": "A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.defaults",
        "description": "Default values to use if creating a new instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model,boolean>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1871,
    "kind": "method",
    "name": "upsert",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.upsert",
    "access": "public",
    "description": "Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.\n\n**Implementation details:**\n\n* MySQL - Implemented as a single query `INSERT values ON DUPLICATE KEY UPDATE values`\n* PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE\n* SQLite - Implemented as two queries `INSERT; UPDATE`. This means that the update is executed regardless of whether the row already existed or not\n* MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`\n**Note** that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.",
    "lineNumber": 2443,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<boolean>} Returns a boolean indicating whether the row was created or updated. For MySQL/MariaDB, it returns `true` when inserted and `false` when updated. For Postgres/MSSQL with (options.returning=true), it returns record and created boolean with signature `<Model, created>`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "hash of values to upsert"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "upsert options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.validate",
        "description": "Run validations before the row is inserted"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Object.keys(this.attributes)",
        "defaultRaw": "Object.keys(this.attributes)",
        "name": "options.fields",
        "description": "The fields to insert / update. Defaults to all changed fields"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before / after upsert hooks?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.returning",
        "description": "Append RETURNING * to get back auto generated values (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Returns a boolean indicating whether the row was created or updated. For MySQL/MariaDB, it returns `true` when inserted and `false` when updated. For Postgres/MSSQL with (options.returning=true), it returns record and created boolean with signature `<Model, created>`."
    }
  },
  {
    "__docId__": 1872,
    "kind": "method",
    "name": "bulkCreate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.bulkCreate",
    "access": "public",
    "description": "Create and insert multiple instances in bulk.\n\nThe success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL\nand SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.\nTo obtain Instances for the newly created values, you will need to query for them again.\n\nIf validation fails, the promise is rejected with an array-like [AggregateError](http://bluebirdjs.com/docs/api/aggregateerror.html)",
    "lineNumber": 2537,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<Model>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "records",
        "description": "List of objects (key/value pairs) to create instances from"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Bulk create options"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "Fields to insert (defaults to all fields)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.validate",
        "description": "Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before / after bulk create hooks?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.individualHooks",
        "description": "Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.ignoreDuplicates",
        "description": "Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres < 9.5)"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.updateOnDuplicate",
        "description": "Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite >= 3.24.0 & Postgres >= 9.5). By default, all fields are updated."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.returning",
        "description": "If true, append RETURNING * to get back all values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<Model>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1873,
    "kind": "method",
    "name": "truncate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.truncate",
    "access": "public",
    "description": "Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).",
    "see": [
      "{@link Model.destroy} for more information"
    ],
    "lineNumber": 2867,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options passed to Model.destroy in addition to truncate"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " false",
        "defaultRaw": false,
        "name": "options.cascade",
        "description": "Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.restartIdentity",
        "description": "Automatically restart sequences owned by columns of the truncated table."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1874,
    "kind": "method",
    "name": "destroy",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.destroy",
    "access": "public",
    "description": "Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.",
    "lineNumber": 2891,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>} The number of destroyed rows"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "destroy options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "Filter the destroy"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before / after bulk destroy hooks?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.individualHooks",
        "description": "If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.limit",
        "description": "How many rows to delete"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.force",
        "description": "Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.truncate",
        "description": "If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.cascade",
        "description": "Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.restartIdentity",
        "description": "Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": "The number of destroyed rows"
    }
  },
  {
    "__docId__": 1875,
    "kind": "method",
    "name": "restore",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.restore",
    "access": "public",
    "description": "Restore multiple instances if `paranoid` is enabled.",
    "lineNumber": 2978,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "restore options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "Filter the restore"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before / after bulk restore hooks?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.individualHooks",
        "description": "If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.limit",
        "description": "How many rows to undelete (only for mysql)"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1876,
    "kind": "method",
    "name": "update",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.update",
    "access": "public",
    "description": "Update multiple instances that match the where options.",
    "lineNumber": 3053,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<number,number>>}  The promise returns an array with one or two elements. The first element is always the number\nof affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "hash of values to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "update options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.where",
        "description": "Options to describe the scope of the search."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.paranoid",
        "description": "If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if `options.paranoid` is true for the model."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "Fields to update (defaults to all fields)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.validate",
        "description": "Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before / after bulk update hooks?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.sideEffects",
        "description": "Whether or not to update the side effects of any virtual setters."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.individualHooks",
        "description": "Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.returning",
        "description": "Return the affected rows (only for postgres)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.limit",
        "description": "How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<number,number>>"
      ],
      "spread": false,
      "description": "The promise returns an array with one or two elements. The first element is always the number\nof affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)"
    }
  },
  {
    "__docId__": 1877,
    "kind": "method",
    "name": "describe",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.describe",
    "access": "public",
    "description": "Run a describe query on the table.",
    "lineNumber": 3261,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} hash of attributes and their types"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "schema",
        "description": "schema name to search table in"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "hash of attributes and their types"
    }
  },
  {
    "__docId__": 1878,
    "kind": "method",
    "name": "_getDefaultTimestamp",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._getDefaultTimestamp",
    "access": "private",
    "description": null,
    "lineNumber": 3265,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "attr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1879,
    "kind": "method",
    "name": "_expandAttributes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._expandAttributes",
    "access": "private",
    "description": null,
    "lineNumber": 3272,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1880,
    "kind": "method",
    "name": "_injectScope",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._injectScope",
    "access": "private",
    "description": null,
    "lineNumber": 3290,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1881,
    "kind": "method",
    "name": "[Symbol.for('nodejs.util.inspect.custom')]",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.[Symbol.for('nodejs.util.inspect.custom')]",
    "access": "public",
    "description": null,
    "lineNumber": 3295,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1882,
    "kind": "method",
    "name": "inspect",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.inspect",
    "access": "public",
    "description": null,
    "lineNumber": 3299,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1883,
    "kind": "method",
    "name": "hasAlias",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.hasAlias",
    "access": "public",
    "description": null,
    "lineNumber": 3303,
    "undocument": true,
    "params": [
      {
        "name": "alias",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1884,
    "kind": "method",
    "name": "increment",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.increment",
    "access": "public",
    "description": "Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n``` SET column = column + X WHERE foo = 'bar' ``` query. To get the correct value after an increment into the Instance you should do a reload.",
    "examples": [
      "<caption>increment number by 1</caption>\nModel.increment('number', { where: { foo: 'bar' });",
      "<caption>increment number and count by 2</caption>\nModel.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });",
      "<caption>increment answer by 42, and decrement tries by 1</caption>\n// `by` is ignored, as each column has its own value\nModel.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });"
    ],
    "see": [
      "{@link Model#reload}"
    ],
    "lineNumber": 3335,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "increment options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.where",
        "description": "conditions hash"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "options.by",
        "description": "The number to increment by"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model[],?number>"
      ],
      "spread": false,
      "description": "returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect"
    }
  },
  {
    "__docId__": 1885,
    "kind": "method",
    "name": "decrement",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.decrement",
    "access": "public",
    "description": "Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance you should do a reload.",
    "examples": [
      "<caption>decrement number by 1</caption>\nModel.decrement('number', { where: { foo: 'bar' });",
      "<caption>decrement number and count by 2</caption>\nModel.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });",
      "<caption>decrement answer by 42, and decrement tries by -1</caption>\n// `by` is ignored, since each column has its own value\nModel.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });"
    ],
    "see": [
      "{@link Model.increment}",
      "{@link Model#reload}"
    ],
    "lineNumber": 3422,
    "since": "4.36.0",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "decrement options, similar to increment"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model[],?number>"
      ],
      "spread": false,
      "description": "returns an array of affected rows and affected count with `options.returning: true`, whenever supported by dialect"
    }
  },
  {
    "__docId__": 1886,
    "kind": "method",
    "name": "_optionsMustContainWhere",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model._optionsMustContainWhere",
    "access": "private",
    "description": null,
    "lineNumber": 3430,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1887,
    "kind": "method",
    "name": "where",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#where",
    "access": "public",
    "description": "Get an object representing the query for this instance, use with `options.where`",
    "lineNumber": 3443,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "checkVersion",
        "description": "include version attribute in where hash"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1888,
    "kind": "method",
    "name": "toString",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#toString",
    "access": "public",
    "description": null,
    "lineNumber": 3459,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1889,
    "kind": "method",
    "name": "getDataValue",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#getDataValue",
    "access": "public",
    "description": "Get the value of the underlying data value",
    "lineNumber": 3470,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{any}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to look in instance data store"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1890,
    "kind": "method",
    "name": "setDataValue",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#setDataValue",
    "access": "public",
    "description": "Update the underlying data value",
    "lineNumber": 3481,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to set in instance data store"
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "new value for given key"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1891,
    "kind": "method",
    "name": "get",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#get",
    "access": "public",
    "description": "If no key is given, returns all values of the instance, also invoking virtual getters.\n\nIf key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.",
    "lineNumber": 3503,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object|any}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "key to get value of"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "get options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.plain",
        "description": "If set to true, included instances will be returned as plain objects"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.raw",
        "description": "If set to true, field and virtual setters will be ignored"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "any"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1892,
    "kind": "method",
    "name": "set",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#set",
    "access": "public",
    "description": "Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).\nIn its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function\nwill be called instead. To bypass the setter, you can pass `raw: true` in the options object.\n\nIf set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be\nset directly to the object passed, or used to extend dataValues, if dataValues already contain values.\n\nWhen set is called, the previous value of the field is stored and sets a changed flag(see `changed`).\n\nSet can also be used to build instances for associations, if you have values for those.\nWhen using set with associations you need to make sure the property key matches the alias of the association\nwhile also making sure that the proper include options have been set (from .build() or .findOne())\n\nIf called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.",
    "see": [
      "{@link Model.findAll} for more information about includes"
    ],
    "lineNumber": 3594,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to set, it can be string or object. When string it will set that key, for object it will loop over all object properties nd set them."
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value to set"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "set options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.raw",
        "description": "If set to true, field and virtual setters will be ignored"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.reset",
        "description": "Clear all previously set data values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1898,
    "kind": "method",
    "name": "setAttributes",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#setAttributes",
    "access": "public",
    "description": null,
    "lineNumber": 3727,
    "undocument": true,
    "params": [
      {
        "name": "updates",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1899,
    "kind": "method",
    "name": "changed",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#changed",
    "access": "public",
    "description": "If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.\n\nIf changed is called without an argument, it will return an array of keys that have changed.\n\nIf changed is called without an argument and no keys have changed, it will return `false`.",
    "lineNumber": 3743,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean|Array}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "key to check or change status of"
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": true,
        "name": "value",
        "description": "value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean",
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1900,
    "kind": "method",
    "name": "previous",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#previous",
    "access": "public",
    "description": "Returns the previous value for key from `_previousDataValues`.\n\nIf called without a key, returns the previous values for all values which have changed",
    "lineNumber": 3766,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{any|Array<any>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "key to get previous value of"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any",
        "Array<any>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1901,
    "kind": "method",
    "name": "_setInclude",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#_setInclude",
    "access": "private",
    "description": null,
    "lineNumber": 3774,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1902,
    "kind": "member",
    "name": "[accessor]",
    "memberof": "lib/model.js~Model",
    "static": false,
    "longname": "lib/model.js~Model#[accessor]",
    "access": "public",
    "description": null,
    "lineNumber": 3801,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1904,
    "kind": "method",
    "name": "save",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#save",
    "access": "public",
    "description": "Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed.\n\nOn success, the callback will be called with this instance. On validation error, the callback will be called with an instance of `Sequelize.ValidationError`.\nThis error will have a property for each of the fields for which validation failed, with the error message for that field.",
    "lineNumber": 3827,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "save options"
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.validate",
        "description": "If false, validations won't be run."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before and after create / update + validate hooks"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.returning",
        "description": "Append RETURNING * to get back auto generated values (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1906,
    "kind": "method",
    "name": "reload",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#reload",
    "access": "public",
    "description": "Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.\nThis is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,\nall references to the Instance are updated with the new data and no new objects are created.",
    "see": [
      "{@link Model.findAll}"
    ],
    "lineNumber": 4101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options that are passed on to `Model.find`"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1908,
    "kind": "method",
    "name": "validate",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#validate",
    "access": "public",
    "description": "Validate the attributes of this instance according to validation rules set in the model definition.\n\nThe promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.",
    "lineNumber": 4139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options that are passed to the validator"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.skip",
        "description": "An array of strings. All properties that are in this array will not be validated"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "An array of strings. Only the properties that are in this array will be validated"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "Run before and after validate hooks"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1909,
    "kind": "method",
    "name": "update",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#update",
    "access": "public",
    "description": "This is the same as calling `set` and then calling `save` but it only saves the\nexact values passed to it, making it more atomic and safer.",
    "see": [
      "{@link Model#set}",
      "{@link Model#save}"
    ],
    "lineNumber": 4157,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "See `set`"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "See `save`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1910,
    "kind": "method",
    "name": "destroy",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#destroy",
    "access": "public",
    "description": "Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.",
    "lineNumber": 4194,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "destroy options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.force",
        "description": "If set to true, paranoid models will actually be deleted"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1911,
    "kind": "method",
    "name": "isSoftDeleted",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#isSoftDeleted",
    "access": "public",
    "description": "Helper method to determine if a instance is \"soft deleted\".  This is\nparticularly useful if the implementer renamed the `deletedAt` attribute\nto something different.  This method requires `paranoid` to be enabled.",
    "lineNumber": 4239,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1912,
    "kind": "method",
    "name": "restore",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#restore",
    "access": "public",
    "description": "Restore the row corresponding to this instance. Only available for paranoid models.",
    "lineNumber": 4261,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "restore options"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1913,
    "kind": "method",
    "name": "increment",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#increment",
    "access": "public",
    "description": "Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n```sql\nSET column = column + X\n```\nquery. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.",
    "examples": [
      "instance.increment('number') // increment number by 1\n\ninstance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2\n\n// increment answer by 42, and tries by 1.\n// `by` is ignored, since each column has its own value\ninstance.increment({ answer: 42, tries: 1}, { by: 2 })"
    ],
    "see": [
      "{@link Model#reload}"
    ],
    "lineNumber": 4320,
    "since": "4.0.0",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Model>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "options.by",
        "description": "The number to increment by"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.returning",
        "description": "Append RETURNING * to get back auto generated values (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Model>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1914,
    "kind": "method",
    "name": "decrement",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#decrement",
    "access": "public",
    "description": "Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n```sql\nSET column = column - X\n```\nquery. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.",
    "examples": [
      "instance.decrement('number') // decrement number by 1\n\ninstance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2\n\n// decrement answer by 42, and tries by 1.\n// `by` is ignored, since each column has its own value\ninstance.decrement({ answer: 42, tries: 1}, { by: 2 })"
    ],
    "see": [
      "{@link Model#reload}"
    ],
    "lineNumber": 4359,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "decrement options"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "options.by",
        "description": "The number to decrement by"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.silent",
        "description": "If true, the updatedAt timestamp will not be updated."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "Transaction to run query under"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.returning",
        "description": "Append RETURNING * to get back auto generated values (Postgres only)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1915,
    "kind": "method",
    "name": "equals",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#equals",
    "access": "public",
    "description": "Check whether this and `other` Instance refer to the same row",
    "lineNumber": 4374,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "Other instance to compare against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1916,
    "kind": "method",
    "name": "equalsOneOf",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#equalsOneOf",
    "access": "public",
    "description": "Check if this is equal to one of `others` by calling equals",
    "lineNumber": 4393,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Model>"
        ],
        "spread": false,
        "optional": false,
        "name": "others",
        "description": "An array of instances to check against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1917,
    "kind": "method",
    "name": "setValidators",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#setValidators",
    "access": "public",
    "description": null,
    "lineNumber": 4397,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "validators",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1918,
    "kind": "method",
    "name": "toJSON",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/model.js~Model#toJSON",
    "access": "public",
    "description": "Convert the instance to a JSON representation.\nProxies to calling `get` with no keys.\nThis means get all values gotten from the DB, and apply all custom getters.",
    "see": [
      "{@link Model#get}"
    ],
    "lineNumber": 4411,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1919,
    "kind": "method",
    "name": "hasMany",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.hasMany",
    "access": "public",
    "description": "Creates a 1:m association between this (the source) and the provided target.\nThe foreign key is added on the target.",
    "examples": [
      "User.hasMany(Profile) // This will add userId to the profile table"
    ],
    "lineNumber": 4439,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{HasMany}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "Target model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "hasMany association options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.hooks",
        "description": "Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.as",
        "description": "The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.foreignKey",
        "description": "The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.sourceKey",
        "description": "The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SET&nbsp;NULL|CASCADE'",
        "defaultRaw": "'SET&nbsp;NULL|CASCADE'",
        "name": "options.onDelete",
        "description": "SET NULL if foreignKey allows nulls, CASCADE if otherwise"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'CASCADE'",
        "defaultRaw": "'CASCADE'",
        "name": "options.onUpdate",
        "description": "Set `ON UPDATE`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.constraints",
        "description": "Should on update and on delete constraints be enabled on the foreign key."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HasMany"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1920,
    "kind": "method",
    "name": "belongsToMany",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.belongsToMany",
    "access": "public",
    "description": "Create an N:M association with a join table. Defining `through` is required.",
    "examples": [
      "// Automagically generated join model\nUser.belongsToMany(Project, { through: 'UserProjects' })\nProject.belongsToMany(User, { through: 'UserProjects' })\n\n// Join model with additional attributes\nconst UserProjects = sequelize.define('UserProjects', {\n  started: Sequelize.BOOLEAN\n})\nUser.belongsToMany(Project, { through: UserProjects })\nProject.belongsToMany(User, { through: UserProjects })"
    ],
    "lineNumber": 4474,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{BelongsToMany}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "Target model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "belongsToMany association options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.hooks",
        "description": "Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks"
      },
      {
        "nullable": null,
        "types": [
          "Model",
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options.through",
        "description": "The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it."
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "options.through.model",
        "description": "The model used to join both sides of the N:M association."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.through.scope",
        "description": "A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.through.unique",
        "description": "If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.as",
        "description": "The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.foreignKey",
        "description": "The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.otherKey",
        "description": "The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.scope",
        "description": "A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "sequelize.options.timestamps",
        "defaultRaw": "sequelize.options.timestamps",
        "name": "options.timestamps",
        "description": "Should the join model have timestamps"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SET&nbsp;NULL|CASCADE'",
        "defaultRaw": "'SET&nbsp;NULL|CASCADE'",
        "name": "options.onDelete",
        "description": "Cascade if this is a n:m, and set null if it is a 1:m"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'CASCADE'",
        "defaultRaw": "'CASCADE'",
        "name": "options.onUpdate",
        "description": "Sets `ON UPDATE`"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.constraints",
        "description": "Should on update and on delete constraints be enabled on the foreign key."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BelongsToMany"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1921,
    "kind": "method",
    "name": "hasOne",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.hasOne",
    "access": "public",
    "description": "Creates an association between this (the source) and the provided target. The foreign key is added on the target.",
    "examples": [
      "User.hasOne(Profile) // This will add userId to the profile table"
    ],
    "lineNumber": 4495,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{HasOne}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "Target model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "hasOne association options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.hooks",
        "description": "Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.as",
        "description": "The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.foreignKey",
        "description": "The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.sourceKey",
        "description": "The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SET&nbsp;NULL|CASCADE'",
        "defaultRaw": "'SET&nbsp;NULL|CASCADE'",
        "name": "options.onDelete",
        "description": "SET NULL if foreignKey allows nulls, CASCADE if otherwise"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'CASCADE'",
        "defaultRaw": "'CASCADE'",
        "name": "options.onUpdate",
        "description": "Sets 'ON UPDATE'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.constraints",
        "description": "Should on update and on delete constraints be enabled on the foreign key."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.uniqueKey",
        "description": "The custom name for unique constraint."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HasOne"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1922,
    "kind": "method",
    "name": "belongsTo",
    "memberof": "lib/model.js~Model",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/model.js~Model.belongsTo",
    "access": "public",
    "description": "Creates an association between this (the source) and the provided target. The foreign key is added on the source.",
    "examples": [
      "Profile.belongsTo(User) // This will add userId to the profile table"
    ],
    "lineNumber": 4515,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{BelongsTo}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target model"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "belongsTo association options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.hooks",
        "description": "Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.as",
        "description": "The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.foreignKey",
        "description": "The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.targetKey",
        "description": "The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'SET&nbsp;NULL|NO&nbsp;ACTION'",
        "defaultRaw": "'SET&nbsp;NULL|NO&nbsp;ACTION'",
        "name": "options.onDelete",
        "description": "SET NULL if foreignKey allows nulls, NO ACTION if otherwise"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'CASCADE'",
        "defaultRaw": "'CASCADE'",
        "name": "options.onUpdate",
        "description": "Sets 'ON UPDATE'"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.constraints",
        "description": "Should on update and on delete constraints be enabled on the foreign key."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BelongsTo"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1923,
    "kind": "file",
    "name": "lib/operators.js",
    "content": "\n'use strict';\n/**\n * Operator symbols to be used when querying data\n *\n * @see {@link Model#where}\n *\n * @property eq\n * @property ne\n * @property gte\n * @property gt\n * @property lte\n * @property lt\n * @property not\n * @property is\n * @property in\n * @property notIn\n * @property like\n * @property notLike\n * @property iLike\n * @property notILike\n * @property startsWith\n * @property endsWith\n * @property substring\n * @property regexp\n * @property notRegexp\n * @property iRegexp\n * @property notIRegexp\n * @property between\n * @property notBetween\n * @property overlap\n * @property contains\n * @property contained\n * @property adjacent\n * @property strictLeft\n * @property strictRight\n * @property noExtendRight\n * @property noExtendLeft\n * @property and\n * @property or\n * @property any\n * @property all\n * @property values\n * @property col\n * @property placeholder\n * @property join\n */\nconst Op = {\n  eq: Symbol.for('eq'),\n  ne: Symbol.for('ne'),\n  gte: Symbol.for('gte'),\n  gt: Symbol.for('gt'),\n  lte: Symbol.for('lte'),\n  lt: Symbol.for('lt'),\n  not: Symbol.for('not'),\n  is: Symbol.for('is'),\n  in: Symbol.for('in'),\n  notIn: Symbol.for('notIn'),\n  like: Symbol.for('like'),\n  notLike: Symbol.for('notLike'),\n  iLike: Symbol.for('iLike'),\n  notILike: Symbol.for('notILike'),\n  startsWith: Symbol.for('startsWith'),\n  endsWith: Symbol.for('endsWith'),\n  substring: Symbol.for('substring'),\n  regexp: Symbol.for('regexp'),\n  notRegexp: Symbol.for('notRegexp'),\n  iRegexp: Symbol.for('iRegexp'),\n  notIRegexp: Symbol.for('notIRegexp'),\n  between: Symbol.for('between'),\n  notBetween: Symbol.for('notBetween'),\n  overlap: Symbol.for('overlap'),\n  contains: Symbol.for('contains'),\n  contained: Symbol.for('contained'),\n  adjacent: Symbol.for('adjacent'),\n  strictLeft: Symbol.for('strictLeft'),\n  strictRight: Symbol.for('strictRight'),\n  noExtendRight: Symbol.for('noExtendRight'),\n  noExtendLeft: Symbol.for('noExtendLeft'),\n  and: Symbol.for('and'),\n  or: Symbol.for('or'),\n  any: Symbol.for('any'),\n  all: Symbol.for('all'),\n  values: Symbol.for('values'),\n  col: Symbol.for('col'),\n  placeholder: Symbol.for('placeholder'),\n  join: Symbol.for('join')\n};\n\nmodule.exports = Op;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/operators.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1924,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/operators.js",
    "static": true,
    "longname": "lib/operators.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/operators.js",
    "importStyle": null,
    "description": "Operator symbols to be used when querying data",
    "see": [
      "{@link Model#where}"
    ],
    "lineNumber": 48,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "eq",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ne",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "gte",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "gt",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "lte",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "lt",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "not",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "is",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "in",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notIn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "like",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notLike",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "iLike",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notILike",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "startsWith",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "endsWith",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "substring",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "regexp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notRegexp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "iRegexp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notIRegexp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "between",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "notBetween",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "overlap",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "contains",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "contained",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "adjacent",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "strictLeft",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "strictRight",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "noExtendRight",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "noExtendLeft",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "and",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "or",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "any",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "all",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "placeholder",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "join",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "{\"eq\": *, \"ne\": *, \"gte\": *, \"gt\": *, \"lte\": *, \"lt\": *, \"not\": *, \"is\": *, \"in\": *, \"notIn\": *, \"like\": *, \"notLike\": *, \"iLike\": *, \"notILike\": *, \"startsWith\": *, \"endsWith\": *, \"substring\": *, \"regexp\": *, \"notRegexp\": *, \"iRegexp\": *, \"notIRegexp\": *, \"between\": *, \"notBetween\": *, \"overlap\": *, \"contains\": *, \"contained\": *, \"adjacent\": *, \"strictLeft\": *, \"strictRight\": *, \"noExtendRight\": *, \"noExtendLeft\": *, \"and\": *, \"or\": *, \"any\": *, \"all\": *, \"values\": *, \"col\": *, \"placeholder\": *, \"join\": *}"
      ]
    }
  },
  {
    "__docId__": 1925,
    "kind": "file",
    "name": "lib/promise.js",
    "content": "'use strict';\n\nconst Promise = require('bluebird').getNewLibraryCopy();\n\nmodule.exports = Promise;\nmodule.exports.Promise = Promise;\nmodule.exports.default = Promise;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/promise.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1926,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/promise.js",
    "static": true,
    "longname": "lib/promise.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/promise.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1927,
    "kind": "file",
    "name": "lib/query-interface.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('./utils');\nconst DataTypes = require('./data-types');\nconst SQLiteQueryInterface = require('./dialects/sqlite/query-interface');\nconst MSSQLQueryInterface = require('./dialects/mssql/query-interface');\nconst MySQLQueryInterface = require('./dialects/mysql/query-interface');\nconst PostgresQueryInterface = require('./dialects/postgres/query-interface');\nconst Transaction = require('./transaction');\nconst Promise = require('./promise');\nconst QueryTypes = require('./query-types');\nconst Op = require('./operators');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n *\n * @class QueryInterface\n */\nclass QueryInterface {\n  constructor(sequelize) {\n    this.sequelize = sequelize;\n    this.QueryGenerator = this.sequelize.dialect.QueryGenerator;\n  }\n\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {Object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n  createDatabase(database, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.createDatabaseQuery(database, options);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.dropDatabaseQuery(database);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  createSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.createSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.dropSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.QueryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    return this.showAllSchemas(options).map(schemaName => this.dropSchema(schemaName, options));\n  }\n\n  /**\n   * Show all schemas\n   *\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n  showAllSchemas(options) {\n    options = Object.assign({}, options, {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n\n    const showSchemasSql = this.QueryGenerator.showSchemasQuery(options);\n\n    return this.sequelize.query(showSchemasSql, options).then(schemaNames => _.flatten(\n      schemaNames.map(value => value.schema_name ? value.schema_name : value)\n    ));\n  }\n\n  /**\n   * Return database version\n   *\n   * @param {Object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n  databaseVersion(options) {\n    return this.sequelize.query(\n      this.QueryGenerator.versionQuery(),\n      Object.assign({}, options, { type: QueryTypes.VERSION })\n    );\n  }\n\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of table attributes to create\n   * @param {Object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  createTable(tableName, attributes, options, model) {\n    let sql = '';\n    let promise;\n\n    options = _.clone(options) || {};\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    if (this.sequelize.options.dialect === 'postgres') {\n      promise = PostgresQueryInterface.ensureEnums(this, tableName, attributes, options, model);\n    } else {\n      promise = Promise.resolve();\n    }\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.QueryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.QueryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n    return promise.then(() => this.sequelize.query(sql, options));\n  }\n\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {Object} options   Query options\n   *\n   * @returns {Promise}\n   */\n  dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = _.clone(options) || {};\n    options.cascade = options.cascade || options.force || false;\n\n    let sql = this.QueryGenerator.dropTableQuery(tableName, options);\n\n    return this.sequelize.query(sql, options).then(() => {\n      const promises = [];\n\n      // Since postgres has a special case for enums, we should drop the related\n      // enum type within the table and attribute\n      if (this.sequelize.options.dialect === 'postgres') {\n        const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n        if (instanceTable) {\n          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n          const keys = Object.keys(instanceTable.rawAttributes);\n          const keyLen = keys.length;\n\n          for (let i = 0; i < keyLen; i++) {\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n              options.supportsSearchPath = false;\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));\n            }\n          }\n        }\n      }\n\n      return Promise.all(promises).get(0);\n    });\n  }\n\n  /**\n   * Drop all tables from database\n   *\n   * @param {Object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n  dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const dropAllTables = tableNames => Promise.each(tableNames, tableName => {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        return this.dropTable(tableName, Object.assign({}, options, { cascade: true }) );\n      }\n    });\n\n    return this.showAllTables(options).then(tableNames => {\n      if (this.sequelize.options.dialect === 'sqlite') {\n        return this.sequelize.query('PRAGMA foreign_keys;', options).then(result => {\n          const foreignKeysAreEnabled = result.foreign_keys === 1;\n\n          if (foreignKeysAreEnabled) {\n            return this.sequelize.query('PRAGMA foreign_keys = OFF', options)\n              .then(() => dropAllTables(tableNames))\n              .then(() => this.sequelize.query('PRAGMA foreign_keys = ON', options));\n          }\n          return dropAllTables(tableNames);\n        });\n      }\n      return this.getForeignKeysForTables(tableNames, options).then(foreignKeys => {\n        const queries = [];\n\n        tableNames.forEach(tableName => {\n          let normalizedTableName = tableName;\n          if (_.isObject(tableName)) {\n            normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n          }\n\n          foreignKeys[normalizedTableName].forEach(foreignKey => {\n            queries.push(this.QueryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n          });\n        });\n\n        return Promise.each(queries, q => this.sequelize.query(q, options))\n          .then(() => dropAllTables(tableNames));\n      });\n    });\n  }\n\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {Object} options Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n  dropEnum(enumName, options) {\n    if (this.sequelize.getDialect() !== 'postgres') {\n      return Promise.resolve();\n    }\n\n    options = options || {};\n\n    return this.sequelize.query(\n      this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(enumName)),\n      Object.assign({}, options, { raw: true })\n    );\n  }\n\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {Object} options Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n  dropAllEnums(options) {\n    if (this.sequelize.getDialect() !== 'postgres') {\n      return Promise.resolve();\n    }\n\n    options = options || {};\n\n    return this.pgListEnums(null, options).map(result => this.sequelize.query(\n      this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(result.enum_name)),\n      Object.assign({}, options, { raw: true })\n    ));\n  }\n\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {Object} [options]    Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n  pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, Object.assign({}, options, { plain: false, raw: true, type: QueryTypes.SELECT }));\n  }\n\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.renameTableQuery(before, after);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Get all tables in current database\n   *\n   * @param {Object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  showAllTables(options) {\n    options = Object.assign({}, options, {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n\n    const showTablesSql = this.QueryGenerator.showTablesQuery(this.sequelize.config.database);\n    return this.sequelize.query(showTablesSql, options).then(tableNames => _.flatten(tableNames));\n  }\n\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise<Object>}\n   */\n  describeTable(tableName, options) {\n    if (this.sequelize.options.dialect === 'sqlite') {\n      // sqlite needs some special treatment as it cannot rename a column\n      return SQLiteQueryInterface.describeTable(this, tableName, options);\n    }\n\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = Object.assign({}, options, { type: QueryTypes.DESCRIBE });\n\n    return this.sequelize.query(sql, options).then(data => {\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    }).catch(e => {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    });\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {Object} attribute Attribute definition\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {Object} [options]      Query options\n   *\n   * @returns {Promise}\n   */\n  removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    switch (this.sequelize.options.dialect) {\n      case 'sqlite':\n        // sqlite needs some special treatment as it cannot drop a column\n        return SQLiteQueryInterface.removeColumn(this, tableName, attributeName, options);\n      case 'mssql':\n        // mssql needs special treatment as it cannot drop a column with a default or foreign key constraint\n        return MSSQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n      case 'mysql':\n      case 'mariadb':\n        // mysql/mariadb need special treatment as it cannot drop a column with a foreign key constraint\n        return MySQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n      default:\n        return this.sequelize.query(this.QueryGenerator.removeColumnQuery(tableName, attributeName), options);\n    }\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {Object} dataTypeOrOptions  Attribute definition for new column\n   * @param {Object} [options]          Query options\n   *\n   * @returns {Promise}\n   */\n  changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    const attributes = {};\n    options = options || {};\n\n    if (_.values(DataTypes).includes(dataTypeOrOptions)) {\n      attributes[attributeName] = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attributes[attributeName] = dataTypeOrOptions;\n    }\n\n    attributes[attributeName] = this.sequelize.normalizeAttribute(attributes[attributeName]);\n\n    if (this.sequelize.options.dialect === 'sqlite') {\n      // sqlite needs some special treatment as it cannot change a column\n      return SQLiteQueryInterface.changeColumn(this, tableName, attributes, options);\n    }\n    const query = this.QueryGenerator.attributesToSQL(attributes, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {Object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    return this.describeTable(tableName, options).then(data => {\n      if (!data[attrNameBefore]) {\n        throw new Error(`Table ${tableName} doesn't have the column ${attrNameBefore}`);\n      }\n\n      data = data[attrNameBefore] || {};\n\n      const _options = {};\n\n      _options[attrNameAfter] = {\n        attribute: attrNameAfter,\n        type: data.type,\n        allowNull: data.allowNull,\n        defaultValue: data.defaultValue\n      };\n\n      // fix: a not-null column cannot have null as default value\n      if (data.defaultValue === null && !data.allowNull) {\n        delete _options[attrNameAfter].defaultValue;\n      }\n\n      if (this.sequelize.options.dialect === 'sqlite') {\n        // sqlite needs some special treatment as it cannot rename a column\n        return SQLiteQueryInterface.renameColumn(this, tableName, attrNameBefore, attrNameAfter, options);\n      }\n      const sql = this.QueryGenerator.renameColumnQuery(\n        tableName,\n        attrNameBefore,\n        this.QueryGenerator.attributesToSQL(_options)\n      );\n      return this.sequelize.query(sql, options);\n    });\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|Object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {Object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {Object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return this.sequelize.query(sql, Object.assign({}, options, { supportsSearchPath: false }));\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  showIndex(tableName, options) {\n    const sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n    return this.sequelize.query(sql, Object.assign({}, options, { type: QueryTypes.SHOWINDEXES }));\n  }\n\n  getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return Promise.resolve({});\n    }\n\n    options = Object.assign({}, options || {}, { type: QueryTypes.FOREIGNKEYS });\n\n    return Promise.map(tableNames, tableName =>\n      this.sequelize.query(this.QueryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)\n    ).then(results => {\n      const result = {};\n\n      tableNames.forEach((tableName, i) => {\n        if (_.isObject(tableName)) {\n          tableName = `${tableName.schema}.${tableName.tableName}`;\n        }\n\n        result[tableName] = Array.isArray(results[i])\n          ? results[i].map(r => r.constraint_name)\n          : [results[i] && results[i].constraint_name];\n\n        result[tableName] = result[tableName].filter(_.identity);\n      });\n\n      return result;\n    });\n  }\n\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options]  Query options\n   *\n   * @returns {Promise}\n   */\n  getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = Object.assign({}, options, {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const catalogName = this.sequelize.config.database;\n    switch (this.sequelize.options.dialect) {\n      case 'sqlite':\n        // sqlite needs some special treatment.\n        return SQLiteQueryInterface.getForeignKeyReferencesForTable(this, tableName, queryOptions);\n      case 'postgres':\n      {\n        // postgres needs some special treatment as those field names returned are all lowercase\n        // in order to keep same result with other dialects.\n        const query = this.QueryGenerator.getForeignKeyReferencesQuery(tableName, catalogName);\n        return this.sequelize.query(query, queryOptions)\n          .then(result => result.map(Utils.camelizeObjectKeys));\n      }\n      case 'mssql':\n      case 'mysql':\n      case 'mariadb':\n      default: {\n        const query = this.QueryGenerator.getForeignKeysQuery(tableName, catalogName);\n        return this.sequelize.query(query, queryOptions);\n      }\n    }\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName             Table name to drop index from\n   * @param {string} indexNameOrAttributes Index name\n   * @param {Object} [options]             Query options\n   *\n   * @returns {Promise}\n   */\n  removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', ['email'], {\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', ['roles'], {\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', ['roles'], {\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', ['username'], {\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', ['username'], {\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                  Table name where you want to add a constraint\n   * @param {Array}  attributes                 Array of column names to apply the constraint over\n   * @param {Object} options                    An object to define the constraint name, type etc\n   * @param {string} options.type               Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {string} [options.name]             Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]     The value for the default constraint\n   * @param {Object} [options.where]            Where clause/expression for the CHECK constraint\n   * @param {Object} [options.references]       Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table] Target table name\n   * @param {string} [options.references.field] Target column name\n   * @param {string} [rawTablename]             Table name, for backward compatibility\n   *\n   * @returns {Promise}\n   */\n  addConstraint(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n\n    if (this.sequelize.dialect.name === 'sqlite') {\n      return SQLiteQueryInterface.addConstraint(this, tableName, options, rawTablename);\n    }\n    const sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n    return this.sequelize.query(sql, options);\n  }\n\n  showConstraint(tableName, constraintName, options) {\n    const sql = this.QueryGenerator.showConstraintsQuery(tableName, constraintName);\n    return this.sequelize.query(sql, Object.assign({}, options, { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {Object} options         Query options\n   *\n   * @returns {Promise}\n   */\n  removeConstraint(tableName, constraintName, options) {\n    options = options || {};\n\n    switch (this.sequelize.options.dialect) {\n      case 'mysql':\n      case 'mariadb':\n        //does not support DROP CONSTRAINT. Instead DROP PRIMARY, FOREIGN KEY, INDEX should be used\n        return MySQLQueryInterface.removeConstraint(this, tableName, constraintName, options);\n      case 'sqlite':\n        return SQLiteQueryInterface.removeConstraint(this, tableName, constraintName, options);\n      default:\n        const sql = this.QueryGenerator.removeConstraintQuery(tableName, constraintName);\n        return this.sequelize.query(sql, options);\n    }\n  }\n\n  insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    return this.sequelize.query(sql, options).then(results => {\n      if (instance) results[0].isNewRecord = false;\n      return results;\n    });\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {Object} insertValues values to be inserted, mapped to field name\n   * @param {Object} updateValues values to be updated, mapped to field name\n   * @param {Object} where        various conditions\n   * @param {Model}  model        Model to upsert on\n   * @param {Object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  upsert(tableName, insertValues, updateValues, where, model, options) {\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.QueryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return this.sequelize.query(sql, options).then(result => {\n      switch (this.sequelize.options.dialect) {\n        case 'postgres':\n          return [result.created, result.primary_key];\n\n        case 'mssql':\n          return [\n            result.$action === 'INSERT',\n            result[model.primaryKeyField]\n          ];\n\n        // MySQL returns 1 for inserted, 2 for updated\n        // http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html.\n        case 'mysql':\n        case 'mariadb':\n          return [result === 1, undefined];\n\n        default:\n          return [result, undefined];\n      }\n    });\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {Object} options     Various options, please see Model.bulkCreate options\n   * @param {Object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  bulkInsert(tableName, records, options, attributes) {\n    options = _.clone(options) || {};\n    options.type = QueryTypes.INSERT;\n\n    return this.sequelize.query(\n      this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n      options\n    ).then(results => results[0]);\n  }\n\n  update(instance, tableName, values, identifier, options) {\n    options = _.clone(options || {});\n    options.hasTrigger = !!(instance && instance._modelOptions && instance._modelOptions.hasTrigger);\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {Object} values        Values to be inserted, mapped to field name\n   * @param {Object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {Object} [options]     Various options, please see Model.bulkCreate options\n   * @param {Object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return this.sequelize.query(sql, options);\n  }\n\n  delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.QueryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n    options = _.clone(options) || {};\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    return Promise.each(cascades, cascade => {\n      return instance[cascade](options).then(instances => {\n        // Check for hasOne relationship with non-existing associate (\"has zero\")\n        if (!instances) {\n          return Promise.resolve();\n        }\n\n        if (!Array.isArray(instances)) instances = [instances];\n\n        return Promise.each(instances, instance => instance.destroy(options));\n      });\n    }).then(() => {\n      options.instance = instance;\n      return this.sequelize.query(sql, options);\n    });\n  }\n\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {Object}  where                where conditions to find records to delete\n   * @param {Object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command   \n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n  bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(\n        this.QueryGenerator.truncateTableQuery(tableName, options),\n        options\n      );\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n    return this.sequelize.query(\n      this.QueryGenerator.deleteQuery(tableName, where, options, model),\n      options\n    );\n  }\n\n  select(model, tableName, optionsArg) {\n    const options = Object.assign({}, optionsArg, { type: QueryTypes.SELECT, model });\n\n    return this.sequelize.query(\n      this.QueryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  increment(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return this.sequelize.query(sql, options);\n  }\n\n  decrement(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return this.sequelize.query(sql, options);\n  }\n\n  rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    return this.sequelize.query(sql, options).then(data => {\n      if (!options.plain) {\n        return data;\n      }\n\n      const result = data ? data[attributeSelector] : null;\n\n      if (!options || !options.dataType) {\n        return result;\n      }\n\n      const dataType = options.dataType;\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n        if (result !== null) {\n          return parseFloat(result);\n        }\n      }\n      if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n        return parseInt(result, 10);\n      }\n      if (dataType instanceof DataTypes.DATE) {\n        if (result !== null && !(result instanceof Date)) {\n          return new Date(result);\n        }\n      }\n      return result;\n    });\n  }\n\n  createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  dropTrigger(tableName, triggerName, options) {\n    const sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {Object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<Object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {Object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  dropFunction(functionName, params, options) {\n    const sql = this.QueryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {Object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n    return Promise.resolve();\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * Escape an identifier (e.g. a table or attribute name)\n   *\n   * @param {string} identifier identifier to quote\n   * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n   *\n   * @private\n   */\n  quoteIdentifier(identifier, force) {\n    return this.QueryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  quoteTable(identifier) {\n    return this.QueryGenerator.quoteTable(identifier);\n  }\n\n  /**\n   * Quote array of identifiers at once\n   *\n   * @param {string[]} identifiers array of identifiers to quote\n   * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n   *\n   * @private\n   */\n  quoteIdentifiers(identifiers, force) {\n    return this.QueryGenerator.quoteIdentifiers(identifiers, force);\n  }\n\n  /**\n   * Escape a value (e.g. a string, number or date)\n   *\n   * @param {string} value string to escape\n   *\n   * @private\n   */\n  escape(value) {\n    return this.QueryGenerator.escape(value);\n  }\n\n  setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return Promise.resolve();\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n\n    const sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return Promise.resolve();\n\n    return this.sequelize.query(sql, options);\n  }\n\n  startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.startTransactionQuery(transaction);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  deferConstraints(transaction, options) {\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n\n    const sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n\n  commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return Promise.resolve();\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n\n    const sql = this.QueryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return promise;\n  }\n\n  rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return promise;\n  }\n}\n\nmodule.exports = QueryInterface;\nmodule.exports.QueryInterface = QueryInterface;\nmodule.exports.default = QueryInterface;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/query-interface.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1928,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1929,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1930,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1931,
    "kind": "variable",
    "name": "SQLiteQueryInterface",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~SQLiteQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1932,
    "kind": "variable",
    "name": "MSSQLQueryInterface",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~MSSQLQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1933,
    "kind": "variable",
    "name": "MySQLQueryInterface",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~MySQLQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1934,
    "kind": "variable",
    "name": "PostgresQueryInterface",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~PostgresQueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1935,
    "kind": "variable",
    "name": "Transaction",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~Transaction",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1936,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1937,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1938,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1939,
    "kind": "class",
    "name": "QueryInterface",
    "memberof": "lib/query-interface.js",
    "static": true,
    "longname": "lib/query-interface.js~QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-interface.js",
    "importStyle": null,
    "description": "The interface that Sequelize uses to talk to all databases",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "QueryInterface"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 1940,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1941,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/query-interface.js~QueryInterface",
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1942,
    "kind": "member",
    "name": "QueryGenerator",
    "memberof": "lib/query-interface.js~QueryInterface",
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#QueryGenerator",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1943,
    "kind": "method",
    "name": "createDatabase",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#createDatabase",
    "access": "public",
    "description": "Create a database",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "database",
        "description": "Database name to create"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.charset",
        "description": "Database default character set, MYSQL only"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.collate",
        "description": "Database default collation"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.encoding",
        "description": "Database default character set, PostgreSQL only"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.ctype",
        "description": "Database character classification, PostgreSQL only"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.template",
        "description": "The name of the template from which to create the new database, PostgreSQL only"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1944,
    "kind": "method",
    "name": "dropDatabase",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropDatabase",
    "access": "public",
    "description": "Drop a database",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "database",
        "description": "Database name to drop"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1945,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#createSchema",
    "access": "public",
    "description": "Create a schema",
    "lineNumber": 68,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Schema name to create"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1946,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropSchema",
    "access": "public",
    "description": "Drop a schema",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Schema name to drop"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1947,
    "kind": "method",
    "name": "dropAllSchemas",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropAllSchemas",
    "access": "public",
    "description": "Drop all schemas",
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1948,
    "kind": "method",
    "name": "showAllSchemas",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#showAllSchemas",
    "access": "public",
    "description": "Show all schemas",
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1949,
    "kind": "method",
    "name": "databaseVersion",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#databaseVersion",
    "access": "private",
    "description": "Return database version",
    "lineNumber": 133,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      },
      {
        "nullable": null,
        "types": [
          "QueryType"
        ],
        "spread": false,
        "optional": true,
        "name": "options.type",
        "description": "Query type"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1950,
    "kind": "method",
    "name": "createTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#createTable",
    "access": "public",
    "description": "Create a table with given set of attributes\n\n```js\nqueryInterface.createTable(\n  'nameOfTheNewTable',\n  {\n    id: {\n      type: Sequelize.INTEGER,\n      primaryKey: true,\n      autoIncrement: true\n    },\n    createdAt: {\n      type: Sequelize.DATE\n    },\n    updatedAt: {\n      type: Sequelize.DATE\n    },\n    attr1: Sequelize.STRING,\n    attr2: Sequelize.INTEGER,\n    attr3: {\n      type: Sequelize.BOOLEAN,\n      defaultValue: false,\n      allowNull: false\n    },\n    //foreign key usage\n    attr4: {\n      type: Sequelize.INTEGER,\n      references: {\n        model: 'another_table_name',\n        key: 'id'\n      },\n      onUpdate: 'cascade',\n      onDelete: 'cascade'\n    }\n  },\n  {\n    engine: 'MYISAM',    // default: 'InnoDB'\n    charset: 'latin1',   // default: null\n    schema: 'public',    // default: public, PostgreSQL only.\n    comment: 'my table', // comment for table\n    collate: 'latin1_danish_ci' // collation, MYSQL only\n  }\n)\n```",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Name of table to create"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "Object representing a list of table attributes to create"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "create table and query options"
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "model",
        "description": "model class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1951,
    "kind": "method",
    "name": "dropTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropTable",
    "access": "public",
    "description": "Drop a table from database",
    "lineNumber": 247,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to drop"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1952,
    "kind": "method",
    "name": "dropAllTables",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropAllTables",
    "access": "public",
    "description": "Drop all tables from database",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.skip",
        "description": "List of table to skip"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1953,
    "kind": "method",
    "name": "dropEnum",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropEnum",
    "access": "private",
    "description": "Drop specified enum from database (Postgres only)",
    "lineNumber": 343,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "enumName",
        "description": "Enum name to drop"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1954,
    "kind": "method",
    "name": "dropAllEnums",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropAllEnums",
    "access": "private",
    "description": "Drop all enums from database (Postgres only)",
    "lineNumber": 364,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1955,
    "kind": "method",
    "name": "pgListEnums",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#pgListEnums",
    "access": "private",
    "description": "List all enums (Postgres only)",
    "lineNumber": 386,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "tableName",
        "description": "Table whose enum to list"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1956,
    "kind": "method",
    "name": "renameTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#renameTable",
    "access": "public",
    "description": "Rename a table",
    "lineNumber": 401,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "before",
        "description": "Current name of table"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "after",
        "description": "New name from table"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1957,
    "kind": "method",
    "name": "showAllTables",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#showAllTables",
    "access": "private",
    "description": "Get all tables in current database",
    "lineNumber": 417,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.raw",
        "description": "Run query in raw mode"
      },
      {
        "nullable": null,
        "types": [
          "QueryType"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "QueryType.SHOWTABLE",
        "defaultRaw": "QueryType.SHOWTABLE",
        "name": "options.type",
        "description": "query type"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1958,
    "kind": "method",
    "name": "describeTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#describeTable",
    "access": "public",
    "description": "Describe a table structure\n\nThis method returns an array of hashes containing information about all attributes in the table.\n\n```js\n{\n   name: {\n     type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n     allowNull:    true,\n     defaultValue: null\n   },\n   isBetaMember: {\n     type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n     allowNull:    false,\n     defaultValue: false\n   }\n}\n```",
    "lineNumber": 452,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1959,
    "kind": "method",
    "name": "addColumn",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#addColumn",
    "access": "public",
    "description": "Add a new column to a table\n\n```js\nqueryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   after: 'columnB' // after option is only supported by MySQL\n});\n```",
    "lineNumber": 512,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": "Table to add column to"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Column name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attribute",
        "description": "Attribute definition"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1960,
    "kind": "method",
    "name": "removeColumn",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#removeColumn",
    "access": "public",
    "description": "Remove a column from a table",
    "lineNumber": 531,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table to remove column from"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attributeName",
        "description": "Column name to remove"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1961,
    "kind": "method",
    "name": "changeColumn",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#changeColumn",
    "access": "public",
    "description": "Change a column definition",
    "lineNumber": 559,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to change from"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attributeName",
        "description": "Column name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "dataTypeOrOptions",
        "description": "Attribute definition for new column"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1962,
    "kind": "method",
    "name": "renameColumn",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#renameColumn",
    "access": "public",
    "description": "Rename a column",
    "lineNumber": 594,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name whose column to rename"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attrNameBefore",
        "description": "Current column name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attrNameAfter",
        "description": "New column name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query option"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1963,
    "kind": "method",
    "name": "addIndex",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#addIndex",
    "access": "public",
    "description": "Add an index to a column",
    "lineNumber": 648,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to add index on, can be a object with schema"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes",
        "description": "Use options.fields instead, List of attributes to add index on"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "indexes options"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "options.fields",
        "description": "List of attributes to add index on"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.concurrently",
        "description": "Pass CONCURRENT so other operations run while the index is created"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.unique",
        "description": "Create a unique index"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.using",
        "description": "Useful for GIN indexes"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.operator",
        "description": "Index operator"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.type",
        "description": "Type of index, available options are UNIQUE|FULLTEXT|SPATIAL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.name",
        "description": "Name of the index. Default is <table>_<attr1>_<attr2>"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "Where condition on index, for partial indexes"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "rawTablename",
        "description": "table name, this is just for backward compatibiity"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1964,
    "kind": "method",
    "name": "showIndex",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#showIndex",
    "access": "private",
    "description": "Show indexes on a table",
    "lineNumber": 676,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1965,
    "kind": "method",
    "name": "getForeignKeysForTables",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#getForeignKeysForTables",
    "access": "public",
    "description": null,
    "lineNumber": 681,
    "undocument": true,
    "params": [
      {
        "name": "tableNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1966,
    "kind": "method",
    "name": "getForeignKeyReferencesForTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#getForeignKeyReferencesForTable",
    "access": "public",
    "description": "Get foreign key references details for the table\n\nThose details contains constraintSchema, constraintName, constraintCatalog\ntableCatalog, tableSchema, tableName, columnName,\nreferencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\nRemind: constraint informations won't return if it's sqlite.",
    "lineNumber": 722,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1967,
    "kind": "method",
    "name": "removeIndex",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#removeIndex",
    "access": "public",
    "description": "Remove an already existing index from a table",
    "lineNumber": 758,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to drop index from"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "indexNameOrAttributes",
        "description": "Index name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1968,
    "kind": "method",
    "name": "addConstraint",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#addConstraint",
    "access": "public",
    "description": "Add a constraint to a table\n\nAvailable constraints:\n- UNIQUE\n- DEFAULT (MSSQL only)\n- CHECK (MySQL - Ignored by the database engine )\n- FOREIGN KEY\n- PRIMARY KEY",
    "examples": [
      "<caption>UNIQUE</caption>\nqueryInterface.addConstraint('Users', ['email'], {\n  type: 'unique',\n  name: 'custom_unique_constraint_name'\n});",
      "<caption>CHECK</caption>\nqueryInterface.addConstraint('Users', ['roles'], {\n  type: 'check',\n  where: {\n     roles: ['user', 'admin', 'moderator', 'guest']\n  }\n});",
      "<caption>Default - MSSQL only</caption>\nqueryInterface.addConstraint('Users', ['roles'], {\n   type: 'default',\n   defaultValue: 'guest'\n});",
      "<caption>Primary Key</caption>\nqueryInterface.addConstraint('Users', ['username'], {\n   type: 'primary key',\n   name: 'custom_primary_constraint_name'\n});",
      "<caption>Foreign Key</caption>\nqueryInterface.addConstraint('Posts', ['username'], {\n  type: 'foreign key',\n  name: 'custom_fkey_constraint_name',\n  references: { //Required field\n    table: 'target_table_name',\n    field: 'target_column_name'\n  },\n  onDelete: 'cascade',\n  onUpdate: 'cascade'\n});"
    ],
    "lineNumber": 826,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name where you want to add a constraint"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "Array of column names to apply the constraint over"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object to define the constraint name, type etc"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.type",
        "description": "Type of constraint. One of the values in available constraints(case insensitive)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.name",
        "description": "Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.defaultValue",
        "description": "The value for the default constraint"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.where",
        "description": "Where clause/expression for the CHECK constraint"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.references",
        "description": "Object specifying target table, column name to create foreign key constraint"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.references.table",
        "description": "Target table name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.references.field",
        "description": "Target column name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "rawTablename",
        "description": "Table name, for backward compatibility"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1969,
    "kind": "method",
    "name": "showConstraint",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#showConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 852,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1970,
    "kind": "method",
    "name": "removeConstraint",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#removeConstraint",
    "access": "public",
    "description": "Remove a constraint from a table",
    "lineNumber": 866,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to drop constraint from"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "constraintName",
        "description": "Constraint name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1971,
    "kind": "method",
    "name": "insert",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#insert",
    "access": "public",
    "description": null,
    "lineNumber": 882,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1972,
    "kind": "method",
    "name": "upsert",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#upsert",
    "access": "public",
    "description": "Upsert",
    "lineNumber": 908,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<boolean,?number>} Resolves an array with <created, primaryKey>"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table to upsert on"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "insertValues",
        "description": "values to be inserted, mapped to field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "updateValues",
        "description": "values to be updated, mapped to field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "various conditions"
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "Model to upsert on"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean,?number>"
      ],
      "spread": false,
      "description": "Resolves an array with <created, primaryKey>"
    }
  },
  {
    "__docId__": 1973,
    "kind": "method",
    "name": "bulkInsert",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#bulkInsert",
    "access": "public",
    "description": "Insert multiple records into a table",
    "examples": [
      "queryInterface.bulkInsert('roles', [{\n   label: 'user',\n   createdAt: new Date(),\n   updatedAt: new Date()\n }, {\n   label: 'admin',\n   createdAt: new Date(),\n   updatedAt: new Date()\n }]);"
    ],
    "lineNumber": 998,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to insert record to"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "records",
        "description": "List of records to insert"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Various options, please see Model.bulkCreate options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "Various attributes mapped by field name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1974,
    "kind": "method",
    "name": "update",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#update",
    "access": "public",
    "description": null,
    "lineNumber": 1008,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1975,
    "kind": "method",
    "name": "bulkUpdate",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#bulkUpdate",
    "access": "public",
    "description": "Update multiple records of a table",
    "examples": [
      "queryInterface.bulkUpdate('roles', {\n    label: 'admin',\n  }, {\n    userType: 3,\n  },\n);"
    ],
    "lineNumber": 1039,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "Table name to update"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "Values to be inserted, mapped to field name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "A hash with conditions OR an ID as integer OR a string with conditions"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Various options, please see Model.bulkCreate options"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "attributes",
        "description": "Attributes on return objects if supported by SQL dialect"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1976,
    "kind": "method",
    "name": "delete",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#delete",
    "access": "public",
    "description": null,
    "lineNumber": 1052,
    "undocument": true,
    "params": [
      {
        "name": "instance",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1977,
    "kind": "method",
    "name": "bulkDelete",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#bulkDelete",
    "access": "public",
    "description": "Delete multiple records from a table",
    "lineNumber": 1104,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": "table name from where to delete records"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "where conditions to find records to delete"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.truncate",
        "description": "Use truncate table command"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.cascade",
        "description": "Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.restartIdentity",
        "description": "Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table."
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "model",
        "description": "Model"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1978,
    "kind": "method",
    "name": "select",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#select",
    "access": "public",
    "description": null,
    "lineNumber": 1123,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1979,
    "kind": "method",
    "name": "increment",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#increment",
    "access": "public",
    "description": null,
    "lineNumber": 1132,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1980,
    "kind": "method",
    "name": "decrement",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#decrement",
    "access": "public",
    "description": null,
    "lineNumber": 1143,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1981,
    "kind": "method",
    "name": "rawSelect",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#rawSelect",
    "access": "public",
    "description": null,
    "lineNumber": 1154,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeSelector",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1982,
    "kind": "method",
    "name": "createTrigger",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#createTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 1198,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "timingType",
        "types": [
          "*"
        ]
      },
      {
        "name": "fireOnArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionName",
        "types": [
          "*"
        ]
      },
      {
        "name": "functionParams",
        "types": [
          "*"
        ]
      },
      {
        "name": "optionsArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1983,
    "kind": "method",
    "name": "dropTrigger",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 1207,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "triggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1984,
    "kind": "method",
    "name": "renameTrigger",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#renameTrigger",
    "access": "public",
    "description": null,
    "lineNumber": 1217,
    "undocument": true,
    "params": [
      {
        "name": "tableName",
        "types": [
          "*"
        ]
      },
      {
        "name": "oldTriggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "newTriggerName",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1985,
    "kind": "method",
    "name": "createFunction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#createFunction",
    "access": "public",
    "description": "Create an SQL function",
    "examples": [
      "queryInterface.createFunction(\n  'someFunction',\n  [\n    {type: 'integer', name: 'param', direction: 'IN'}\n  ],\n  'integer',\n  'plpgsql',\n  'RETURN param + 1;',\n  [\n    'IMMUTABLE',\n    'LEAKPROOF'\n  ],\n  {\n   variables:\n     [\n       {type: 'integer', name: 'myVar', default: 100}\n     ],\n     force: true\n  };\n);"
    ],
    "lineNumber": 1264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": "Name of SQL function to create"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "List of parameters declared for SQL function"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "returnType",
        "description": "SQL type of function returned value"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "language",
        "description": "The name of the language that the function is implemented in"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "body",
        "description": "Source code of function"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "optionsArray",
        "description": "Extra-options for creation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "options.force",
        "description": "If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false"
      },
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "options.variables",
        "description": "List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1986,
    "kind": "method",
    "name": "dropFunction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#dropFunction",
    "access": "public",
    "description": "Drop an SQL function",
    "examples": [
      "queryInterface.dropFunction(\n  'someFunction',\n  [\n    {type: 'varchar', name: 'param1', direction: 'IN'},\n    {type: 'integer', name: 'param2', direction: 'INOUT'}\n  ]\n);"
    ],
    "lineNumber": 1292,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": "Name of SQL function to drop"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "List of parameters declared for SQL function"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1987,
    "kind": "method",
    "name": "renameFunction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#renameFunction",
    "access": "public",
    "description": "Rename an SQL function",
    "examples": [
      "queryInterface.renameFunction(\n  'fooFunction',\n  [\n    {type: 'varchar', name: 'param1', direction: 'IN'},\n    {type: 'integer', name: 'param2', direction: 'INOUT'}\n  ],\n  'barFunction'\n);"
    ],
    "lineNumber": 1322,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "oldFunctionName",
        "description": "Current name of function"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "List of parameters declared for SQL function"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newFunctionName",
        "description": "New name of function"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1988,
    "kind": "method",
    "name": "quoteIdentifier",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#quoteIdentifier",
    "access": "private",
    "description": "Escape an identifier (e.g. a table or attribute name)",
    "lineNumber": 1342,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "identifier to quote"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "force",
        "description": "If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false."
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1989,
    "kind": "method",
    "name": "quoteTable",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#quoteTable",
    "access": "public",
    "description": null,
    "lineNumber": 1346,
    "undocument": true,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1990,
    "kind": "method",
    "name": "quoteIdentifiers",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#quoteIdentifiers",
    "access": "private",
    "description": "Quote array of identifiers at once",
    "lineNumber": 1358,
    "params": [
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "identifiers",
        "description": "array of identifiers to quote"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "force",
        "description": "If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false."
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1991,
    "kind": "method",
    "name": "escape",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#escape",
    "access": "private",
    "description": "Escape a value (e.g. a string, number or date)",
    "lineNumber": 1369,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string to escape"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1992,
    "kind": "method",
    "name": "setIsolationLevel",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#setIsolationLevel",
    "access": "public",
    "description": null,
    "lineNumber": 1373,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1993,
    "kind": "method",
    "name": "startTransaction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#startTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 1396,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1994,
    "kind": "method",
    "name": "deferConstraints",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#deferConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 1410,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1995,
    "kind": "method",
    "name": "commitTransaction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#commitTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 1424,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1996,
    "kind": "method",
    "name": "rollbackTransaction",
    "memberof": "lib/query-interface.js~QueryInterface",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/query-interface.js~QueryInterface#rollbackTransaction",
    "access": "public",
    "description": null,
    "lineNumber": 1447,
    "undocument": true,
    "params": [
      {
        "name": "transaction",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1997,
    "kind": "file",
    "name": "lib/query-types.js",
    "content": "'use strict';\n\n/**\n * An enum of query types used by `sequelize.query`\n *\n * @see {@link Sequelize#query}\n *\n * @property SELECT\n * @property INSERT\n * @property UPDATE\n * @property BULKUPDATE\n * @property BULKDELETE\n * @property DELETE\n * @property UPSERT\n * @property VERSION\n * @property SHOWTABLES\n * @property SHOWINDEXES\n * @property DESCRIBE\n * @property RAW\n * @property FOREIGNKEYS\n * @property SHOWCONSTRAINTS\n */\nconst QueryTypes = module.exports = { // eslint-disable-line\n  SELECT: 'SELECT',\n  INSERT: 'INSERT',\n  UPDATE: 'UPDATE',\n  BULKUPDATE: 'BULKUPDATE',\n  BULKDELETE: 'BULKDELETE',\n  DELETE: 'DELETE',\n  UPSERT: 'UPSERT',\n  VERSION: 'VERSION',\n  SHOWTABLES: 'SHOWTABLES',\n  SHOWINDEXES: 'SHOWINDEXES',\n  DESCRIBE: 'DESCRIBE',\n  RAW: 'RAW',\n  FOREIGNKEYS: 'FOREIGNKEYS',\n  SHOWCONSTRAINTS: 'SHOWCONSTRAINTS'\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/query-types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1998,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/query-types.js",
    "static": true,
    "longname": "lib/query-types.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/query-types.js",
    "importStyle": null,
    "description": "An enum of query types used by `sequelize.query`",
    "see": [
      "{@link Sequelize#query}"
    ],
    "lineNumber": 23,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SELECT",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "INSERT",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "UPDATE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "BULKUPDATE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "BULKDELETE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "DELETE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "UPSERT",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "VERSION",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SHOWTABLES",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SHOWINDEXES",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "DESCRIBE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "RAW",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "FOREIGNKEYS",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SHOWCONSTRAINTS",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1999,
    "kind": "file",
    "name": "lib/sequelize.js",
    "content": "'use strict';\n\nconst url = require('url');\nconst path = require('path');\nconst retry = require('retry-as-promised');\nconst clsBluebird = require('cls-bluebird');\nconst _ = require('lodash');\n\nconst Utils = require('./utils');\nconst Model = require('./model');\nconst DataTypes = require('./data-types');\nconst Deferrable = require('./deferrable');\nconst ModelManager = require('./model-manager');\nconst QueryInterface = require('./query-interface');\nconst Transaction = require('./transaction');\nconst QueryTypes = require('./query-types');\nconst TableHints = require('./table-hints');\nconst IndexHints = require('./index-hints');\nconst sequelizeErrors = require('./errors');\nconst Promise = require('./promise');\nconst Hooks = require('./hooks');\nconst Association = require('./associations/index');\nconst Validator = require('./utils/validator-extras').validator;\nconst Op = require('./operators');\nconst deprecations = require('./utils/deprecations');\n\n/**\n * This is the main class, the entry point to sequelize.\n */\nclass Sequelize {\n  /**\n   * Instantiate sequelize with name of database, username and password.\n   *\n   * @example\n   * // without password / with blank password\n   * const sequelize = new Sequelize('database', 'username', null, {\n   *   dialect: 'mysql'\n   * })\n   *\n   * // with password and options\n   * const sequelize = new Sequelize('my_database', 'john', 'doe', {\n   *   dialect: 'postgres'\n   * })\n   *\n   * // with database, username, and password in the options object\n   * const sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });\n   *\n   * // with uri\n   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})\n   *\n   * // option examples\n   * const sequelize = new Sequelize('database', 'username', 'password', {\n   *   // the sql dialect of the database\n   *   // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'\n   *   dialect: 'mysql',\n   *\n   *   // custom host; default: localhost\n   *   host: 'my.server.tld',\n   *   // for postgres, you can also specify an absolute path to a directory\n   *   // containing a UNIX socket to connect over\n   *   // host: '/sockets/psql_sockets'.\n   *\n   *   // custom port; default: dialect default\n   *   port: 12345,\n   *\n   *   // custom protocol; default: 'tcp'\n   *   // postgres only, useful for Heroku\n   *   protocol: null,\n   *\n   *   // disable logging or provide a custom logging function; default: console.log\n   *   logging: false,\n   *\n   *   // you can also pass any dialect options to the underlying dialect library\n   *   // - default is empty\n   *   // - currently supported: 'mysql', 'postgres', 'mssql'\n   *   dialectOptions: {\n   *     socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',\n   *     supportBigNumbers: true,\n   *     bigNumberStrings: true\n   *   },\n   *\n   *   // the storage engine for sqlite\n   *   // - default ':memory:'\n   *   storage: 'path/to/database.sqlite',\n   *\n   *   // disable inserting undefined values as NULL\n   *   // - default: false\n   *   omitNull: true,\n   *\n   *   // a flag for using a native library or not.\n   *   // in the case of 'pg' -- set this to true will allow SSL support\n   *   // - default: false\n   *   native: true,\n   *\n   *   // Specify options, which are used when sequelize.define is called.\n   *   // The following example:\n   *   //   define: { timestamps: false }\n   *   // is basically the same as:\n   *   //   Model.init(attributes, { timestamps: false });\n   *   //   sequelize.define(name, attributes, { timestamps: false });\n   *   // so defining the timestamps for each model will be not necessary\n   *   define: {\n   *     underscored: false,\n   *     freezeTableName: false,\n   *     charset: 'utf8',\n   *     dialectOptions: {\n   *       collate: 'utf8_general_ci'\n   *     },\n   *     timestamps: true\n   *   },\n   *\n   *   // similar for sync: you can define this to always force sync for models\n   *   sync: { force: true },\n   *\n   *   // pool configuration used to pool database connections\n   *   pool: {\n   *     max: 5,\n   *     idle: 30000,\n   *     acquire: 60000,\n   *   },\n   *\n   *   // isolation level of each transaction\n   *   // defaults to dialect default\n   *   isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ\n   * })\n   *\n   * @param {string}   [database] The name of the database\n   * @param {string}   [username=null] The username which is used to authenticate against the database.\n   * @param {string}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.\n   * @param {Object}   [options={}] An object with options.\n   * @param {string}   [options.host='localhost'] The host of the relational database.\n   * @param {number}   [options.port=] The port of the relational database.\n   * @param {string}   [options.username=null] The username which is used to authenticate against the database.\n   * @param {string}   [options.password=null] The password which is used to authenticate against the database.\n   * @param {string}   [options.database=null] The name of the database\n   * @param {string}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.\n   * @param {string}   [options.dialectModule=null] If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(\"pg.js\")' here\n   * @param {string}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here\n   * @param {Object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library\n   * @param {string}   [options.storage] Only used by sqlite. Defaults to ':memory:'\n   * @param {string}   [options.protocol='tcp'] The protocol of the relational database.\n   * @param {Object}   [options.define={}] Default options for model definitions. See {@link Model.init}.\n   * @param {Object}   [options.query={}] Default options for sequelize.query\n   * @param {string}   [options.schema=null] A schema to use\n   * @param {Object}   [options.set={}] Default options for sequelize.set\n   * @param {Object}   [options.sync={}] Default options for sequelize.sync\n   * @param {string}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.\n   * @param {string|boolean} [options.clientMinMessages='warning'] The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default.\n   * @param {boolean}  [options.standardConformingStrings=true] The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!\n   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something.\n   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n   * @param {boolean}  [options.omitNull=false] A flag that defines if null values should be passed to SQL queries or not.\n   * @param {boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres\n   * @param {boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`\n   * @param {Object}   [options.pool] sequelize connection pool configuration\n   * @param {number}   [options.pool.max=5] Maximum number of connection in pool\n   * @param {number}   [options.pool.min=0] Minimum number of connection in pool\n   * @param {number}   [options.pool.idle=10000] The maximum time, in milliseconds, that a connection can be idle before being released.\n   * @param {number}   [options.pool.acquire=60000] The maximum time, in milliseconds, that pool will try to get connection before throwing error\n   * @param {number}   [options.pool.evict=1000] The time interval, in milliseconds, after which sequelize-pool will remove idle connections.\n   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected\n   * @param {boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!\n   * @param {string}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n   * @param {string}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.\n   * @param {Object}   [options.retry] Set of flags that control when a query is automatically retried.\n   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.\n   * @param {number}   [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.\n   * @param {boolean}  [options.typeValidation=false] Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.\n   * @param {Object}   [options.operatorsAliases] String based operator alias. Pass object to limit set of aliased operators.\n   * @param {Object}   [options.hooks] An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here.\n   * @param {boolean}  [options.minifyAliases=false] A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)\n   * @param {boolean}  [options.logQueryParameters=false] A flag that defines if show bind patameters in log.\n   */\n  constructor(database, username, password, options) {\n    let config;\n\n    if (arguments.length === 1 && typeof database === 'object') {\n      // new Sequelize({ ... options })\n      options = database;\n      config = _.pick(options, 'host', 'port', 'database', 'username', 'password');\n    } else if (arguments.length === 1 && typeof database === 'string' || arguments.length === 2 && typeof username === 'object') {\n      // new Sequelize(URI, { ... options })\n\n      config = {};\n      options = username || {};\n\n      const urlParts = url.parse(arguments[0], true);\n\n      options.dialect = urlParts.protocol.replace(/:$/, '');\n      options.host = urlParts.hostname;\n\n      if (options.dialect === 'sqlite' && urlParts.pathname && !urlParts.pathname.startsWith('/:memory')) {\n        const storagePath = path.join(options.host, urlParts.pathname);\n        options.storage = path.resolve(options.storage || storagePath);\n      }\n\n      if (urlParts.pathname) {\n        config.database = urlParts.pathname.replace(/^\\//, '');\n      }\n\n      if (urlParts.port) {\n        options.port = urlParts.port;\n      }\n\n      if (urlParts.auth) {\n        const authParts = urlParts.auth.split(':');\n\n        config.username = authParts[0];\n\n        if (authParts.length > 1)\n          config.password = authParts.slice(1).join(':');\n      }\n\n      if (urlParts.query) {\n        if (options.dialectOptions) {\n          Object.assign(options.dialectOptions, urlParts.query);\n        } else {\n          options.dialectOptions = urlParts.query;\n          if (urlParts.query.options) {\n            try {\n              const o = JSON.parse(urlParts.query.options);\n              options.dialectOptions.options = o;\n            } catch (e) {\n              // Nothing to do, string is not a valid JSON\n              // an thus does not need any further processing\n            }\n          }\n        }\n      }\n    } else {\n      // new Sequelize(database, username, password, { ... options })\n      options = options || {};\n      config = { database, username, password };\n    }\n\n    Sequelize.runHooks('beforeInit', config, options);\n\n    this.options = Object.assign({\n      dialect: null,\n      dialectModule: null,\n      dialectModulePath: null,\n      host: 'localhost',\n      protocol: 'tcp',\n      define: {},\n      query: {},\n      sync: {},\n      timezone: '+00:00',\n      clientMinMessages: 'warning',\n      standardConformingStrings: true,\n      // eslint-disable-next-line no-console\n      logging: console.log,\n      omitNull: false,\n      native: false,\n      replication: false,\n      ssl: undefined,\n      pool: {},\n      quoteIdentifiers: true,\n      hooks: {},\n      retry: {\n        max: 5,\n        match: [\n          'SQLITE_BUSY: database is locked'\n        ]\n      },\n      transactionType: Transaction.TYPES.DEFERRED,\n      isolationLevel: null,\n      databaseVersion: 0,\n      typeValidation: false,\n      benchmark: false,\n      minifyAliases: false,\n      logQueryParameters: false\n    }, options || {});\n\n    if (!this.options.dialect) {\n      throw new Error('Dialect needs to be explicitly supplied as of v4.0.0');\n    }\n\n    if (this.options.dialect === 'postgresql') {\n      this.options.dialect = 'postgres';\n    }\n\n    if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {\n      throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');\n    }\n\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      // eslint-disable-next-line no-console\n      this.options.logging = console.log;\n    }\n\n    this._setupHooks(options.hooks);\n\n    this.config = {\n      database: config.database || this.options.database,\n      username: config.username || this.options.username,\n      password: config.password || this.options.password || null,\n      host: config.host || this.options.host,\n      port: config.port || this.options.port,\n      pool: this.options.pool,\n      protocol: this.options.protocol,\n      native: this.options.native,\n      ssl: this.options.ssl,\n      replication: this.options.replication,\n      dialectModule: this.options.dialectModule,\n      dialectModulePath: this.options.dialectModulePath,\n      keepDefaultTimezone: this.options.keepDefaultTimezone,\n      dialectOptions: this.options.dialectOptions\n    };\n\n    let Dialect;\n    // Requiring the dialect in a switch-case to keep the\n    // require calls static. (Browserify fix)\n    switch (this.getDialect()) {\n      case 'mariadb':\n        Dialect = require('./dialects/mariadb');\n        break;\n      case 'mssql':\n        Dialect = require('./dialects/mssql');\n        break;\n      case 'mysql':\n        Dialect = require('./dialects/mysql');\n        break;\n      case 'postgres':\n        Dialect = require('./dialects/postgres');\n        break;\n      case 'sqlite':\n        Dialect = require('./dialects/sqlite');\n        break;\n      default:\n        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, postgres, and sqlite.`);\n    }\n\n    this.dialect = new Dialect(this);\n    this.dialect.QueryGenerator.typeValidation = options.typeValidation;\n\n    if (_.isPlainObject(this.options.operatorsAliases)) {\n      deprecations.noStringOperators();\n      this.dialect.QueryGenerator.setOperatorsAliases(this.options.operatorsAliases);\n    } else if (typeof this.options.operatorsAliases === 'boolean') {\n      deprecations.noBoolOperatorAliases();\n    }\n\n    this.queryInterface = new QueryInterface(this);\n\n    /**\n     * Models are stored here under the name given to `sequelize.define`\n     */\n    this.models = {};\n    this.modelManager = new ModelManager(this);\n    this.connectionManager = this.dialect.connectionManager;\n\n    this.importCache = {};\n\n    Sequelize.runHooks('afterInit', this);\n  }\n\n  /**\n   * Refresh data types and parsers.\n   *\n   * @private\n   */\n  refreshTypes() {\n    this.connectionManager.refreshTypeParser(DataTypes);\n  }\n\n  /**\n   * Returns the specified dialect.\n   *\n   * @returns {string} The specified dialect.\n   */\n  getDialect() {\n    return this.options.dialect;\n  }\n\n  /**\n   * Returns the database name.\n   *\n   * @returns {string} The database name.\n   */\n  getDatabaseName() {\n    return this.config.database;\n  }\n\n  /**\n   * Returns an instance of QueryInterface.\n   *\n   * @returns {QueryInterface} An instance (singleton) of QueryInterface.\n   */\n  getQueryInterface() {\n    this.queryInterface = this.queryInterface || new QueryInterface(this);\n    return this.queryInterface;\n  }\n\n  /**\n   * Define a new model, representing a table in the database.\n   *\n   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column\n   *\n   * @param {string} modelName The name of the model. The model will be stored in `sequelize.models` under this name\n   * @param {Object} attributes An object, where each attribute is a column of the table. See {@link Model.init}\n   * @param {Object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()\n   *\n   * @see\n   * {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.\n   * @see <a href=\"/manual/tutorial/models-definition.html\">Model definition</a> Manual related to model definition\n   * @see\n   * {@link DataTypes} For a list of possible data types\n   *\n   * @returns {Model} Newly defined model\n   *\n   * @example\n   * sequelize.define('modelName', {\n   *   columnA: {\n   *       type: Sequelize.BOOLEAN,\n   *       validate: {\n   *         is: [\"[a-z]\",'i'],        // will only allow letters\n   *         max: 23,                  // only allow values <= 23\n   *         isIn: {\n   *           args: [['en', 'zh']],\n   *           msg: \"Must be English or Chinese\"\n   *         }\n   *       },\n   *       field: 'column_a'\n   *   },\n   *   columnB: Sequelize.STRING,\n   *   columnC: 'MY VERY OWN COLUMN TYPE'\n   * });\n   *\n   * sequelize.models.modelName // The model will now be available in models under the name given to define\n   */\n  define(modelName, attributes, options = {}) {\n    options.modelName = modelName;\n    options.sequelize = this;\n\n    const model = class extends Model {};\n\n    model.init(attributes, options);\n\n    return model;\n  }\n\n  /**\n   * Fetch a Model which is already defined\n   *\n   * @param {string} modelName The name of a model defined with Sequelize.define\n   *\n   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)\n   * @returns {Model} Specified model\n   */\n  model(modelName) {\n    if (!this.isDefined(modelName)) {\n      throw new Error(`${modelName} has not been defined`);\n    }\n\n    return this.modelManager.getModel(modelName);\n  }\n\n  /**\n   * Checks whether a model with the given name is defined\n   *\n   * @param {string} modelName The name of a model defined with Sequelize.define\n   *\n   * @returns {boolean} Returns true if model is already defined, otherwise false\n   */\n  isDefined(modelName) {\n    return !!this.modelManager.models.find(model => model.name === modelName);\n  }\n\n  /**\n   * Imports a model defined in another file. Imported models are cached, so multiple\n   * calls to import with the same path will not load the file multiple times.\n   *\n   * @tutorial https://github.com/sequelize/express-example\n   *\n   * @param {string} importPath The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file\n   *\n   * @returns {Model} Imported model, returned from cache if was already imported\n   */\n  import(importPath) {\n    // is it a relative path?\n    if (path.normalize(importPath) !== path.resolve(importPath)) {\n      // make path relative to the caller\n      const callerFilename = Utils.stack()[1].getFileName();\n      const callerPath = path.dirname(callerFilename);\n\n      importPath = path.resolve(callerPath, importPath);\n    }\n\n    if (!this.importCache[importPath]) {\n      let defineCall = arguments.length > 1 ? arguments[1] : require(importPath);\n      if (typeof defineCall === 'object') {\n        // ES6 module compatibility\n        defineCall = defineCall.default;\n      }\n      this.importCache[importPath] = defineCall(this, DataTypes);\n    }\n\n    return this.importCache[importPath];\n  }\n\n  /**\n   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.\n   *\n   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.\n   *\n   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:\n   *\n   * ```js\n   * sequelize.query('SELECT...').then(([results, metadata]) => {\n   *   // Raw query - use then plus array spread\n   * });\n   *\n   * sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(results => {\n   *   // SELECT query - use then\n   * })\n   * ```\n   *\n   * @param {string}          sql\n   * @param {Object}          [options={}] Query options.\n   * @param {boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result\n   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under\n   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.\n   * @param {boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified\n   * @param {boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row\n   * @param {Object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.\n   * @param {Object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.\n   * @param {boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.\n   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {new Model()}     [options.instance] A sequelize instance used to build the return instance\n   * @param {Model}           [options.model] A sequelize model used to build the returned model instances (used to be called callee)\n   * @param {Object}          [options.retry] Set of flags that control when a query is automatically retried.\n   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.\n   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.\n   * @param {string}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)\n   * @param {boolean}         [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.\n   * @param {Object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.\n   *\n   * @returns {Promise}\n   *\n   * @see {@link Model.build} for more information about instance option.\n   */\n\n  query(sql, options) {\n    options = Object.assign({}, this.options.query, options);\n\n    if (options.instance && !options.model) {\n      options.model = options.instance.constructor;\n    }\n\n    if (!options.instance && !options.model) {\n      options.raw = true;\n    }\n\n    // map raw fields to model attributes\n    if (options.mapToModel) {\n      options.fieldMap = _.get(options, 'model.fieldAttributeMap', {});\n    }\n\n    options = _.defaults(options, {\n      // eslint-disable-next-line no-console\n      logging: Object.prototype.hasOwnProperty.call(this.options, 'logging') ? this.options.logging : console.log,\n      searchPath: Object.prototype.hasOwnProperty.call(this.options, 'searchPath') ? this.options.searchPath : 'DEFAULT'\n    });\n\n    if (!options.type) {\n      if (options.model || options.nest || options.plain) {\n        options.type = QueryTypes.SELECT;\n      } else {\n        options.type = QueryTypes.RAW;\n      }\n    }\n\n    //if dialect doesn't support search_path or dialect option\n    //to prepend searchPath is not true delete the searchPath option\n    if (\n      !this.dialect.supports.searchPath ||\n      !this.options.dialectOptions ||\n      !this.options.dialectOptions.prependSearchPath ||\n      options.supportsSearchPath === false\n    ) {\n      delete options.searchPath;\n    } else if (!options.searchPath) {\n      //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)\n      //then set to DEFAULT if none is provided\n      options.searchPath = 'DEFAULT';\n    }\n\n    return Promise.try(() => {\n      if (typeof sql === 'object') {\n        if (sql.values !== undefined) {\n          if (options.replacements !== undefined) {\n            throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');\n          }\n          options.replacements = sql.values;\n        }\n\n        if (sql.bind !== undefined) {\n          if (options.bind !== undefined) {\n            throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');\n          }\n          options.bind = sql.bind;\n        }\n\n        if (sql.query !== undefined) {\n          sql = sql.query;\n        }\n      }\n\n      sql = sql.trim();\n\n      if (options.replacements && options.bind) {\n        throw new Error('Both `replacements` and `bind` cannot be set at the same time');\n      }\n\n      if (options.replacements) {\n        if (Array.isArray(options.replacements)) {\n          sql = Utils.format([sql].concat(options.replacements), this.options.dialect);\n        } else {\n          sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);\n        }\n      }\n\n      let bindParameters;\n\n      if (options.bind) {\n        [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n      }\n\n      const checkTransaction = () => {\n        if (options.transaction && options.transaction.finished && !options.completesTransaction) {\n          const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);\n          error.sql = sql;\n          throw error;\n        }\n      };\n\n      const retryOptions = Object.assign({}, this.options.retry, options.retry || {});\n\n      return Promise.resolve(retry(() => Promise.try(() => {\n        if (options.transaction === undefined && Sequelize._cls) {\n          options.transaction = Sequelize._cls.get('transaction');\n        }\n\n        checkTransaction();\n\n        return options.transaction\n          ? options.transaction.connection\n          : this.connectionManager.getConnection(options);\n      }).then(connection => {\n        const query = new this.dialect.Query(connection, this, options);\n        return this.runHooks('beforeQuery', options, query)\n          .then(() => checkTransaction())\n          .then(() => query.run(sql, bindParameters))\n          .finally(() => this.runHooks('afterQuery', options, query))\n          .finally(() => {\n            if (!options.transaction) {\n              return this.connectionManager.releaseConnection(connection);\n            }\n          });\n      }), retryOptions));\n    });\n  }\n\n  /**\n   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.\n   * Only works for MySQL.\n   *\n   * @param {Object}        variables Object with multiple variables.\n   * @param {Object}        [options] query options.\n   * @param {Transaction}   [options.transaction] The transaction that the query should be executed under\n   *\n   * @memberof Sequelize\n   *\n   * @returns {Promise}\n   */\n  set(variables, options) {\n\n    // Prepare options\n    options = Object.assign({}, this.options.set, typeof options === 'object' && options);\n\n    if (this.options.dialect !== 'mysql') {\n      throw new Error('sequelize.set is only supported for mysql');\n    }\n    if (!options.transaction || !(options.transaction instanceof Transaction) ) {\n      throw new TypeError('options.transaction is required');\n    }\n\n    // Override some options, since this isn't a SELECT\n    options.raw = true;\n    options.plain = true;\n    options.type = 'SET';\n\n    // Generate SQL Query\n    const query =\n      `SET ${\n        _.map(variables, (v, k) => `@${k} := ${typeof v === 'string' ? `\"${v}\"` : v}`).join(', ')}`;\n\n    return this.query(query, options);\n  }\n\n  /**\n   * Escape value.\n   *\n   * @param {string} value string value to escape\n   *\n   * @returns {string}\n   */\n  escape(value) {\n    return this.getQueryInterface().escape(value);\n  }\n\n  /**\n   * Create a new database schema.\n   *\n   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this command will do nothing.\n   *\n   * @see\n   * {@link Model.schema}\n   *\n   * @param {string} schema Name of the schema\n   * @param {Object} [options={}] query options\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   *\n   * @returns {Promise}\n   */\n  createSchema(schema, options) {\n    return this.getQueryInterface().createSchema(schema, options);\n  }\n\n  /**\n   * Show all defined schemas\n   *\n   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this will show all tables.\n   *\n   * @param {Object} [options={}] query options\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   *\n   * @returns {Promise}\n   */\n  showAllSchemas(options) {\n    return this.getQueryInterface().showAllSchemas(options);\n  }\n\n  /**\n   * Drop a single schema\n   *\n   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this drop a table matching the schema name\n   *\n   * @param {string} schema Name of the schema\n   * @param {Object} [options={}] query options\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   *\n   * @returns {Promise}\n   */\n  dropSchema(schema, options) {\n    return this.getQueryInterface().dropSchema(schema, options);\n  }\n\n  /**\n   * Drop all schemas.\n   *\n   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.\n   *\n   * @param {Object} [options={}] query options\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   *\n   * @returns {Promise}\n   */\n  dropAllSchemas(options) {\n    return this.getQueryInterface().dropAllSchemas(options);\n  }\n\n  /**\n   * Sync all defined models to the DB.\n   *\n   * @param {Object} [options={}] sync options\n   * @param {boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table\n   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code\n   * @param {boolean|Function} [options.logging=console.log] A function that logs sql queries, or false for no logging\n   * @param {string} [options.schema='public'] The schema that the tables should be created in. This can be overridden for each table in sequelize.define\n   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n   * @param {boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called\n   * @param {boolean} [options.alter=false] Alters tables to fit models. Not recommended for production use. Deletes data in columns that were removed or had their type changed in the model.\n   *\n   * @returns {Promise}\n   */\n  sync(options) {\n    options = _.clone(options) || {};\n    options.hooks = options.hooks === undefined ? true : !!options.hooks;\n    options = _.defaults(options, this.options.sync, this.options);\n\n    if (options.match) {\n      if (!options.match.test(this.config.database)) {\n        return Promise.reject(new Error(`Database \"${this.config.database}\" does not match sync match parameter \"${options.match}\"`));\n      }\n    }\n\n    return Promise.try(() => {\n      if (options.hooks) {\n        return this.runHooks('beforeBulkSync', options);\n      }\n    }).then(() => {\n      if (options.force) {\n        return this.drop(options);\n      }\n    }).then(() => {\n      const models = [];\n\n      // Topologically sort by foreign key constraints to give us an appropriate\n      // creation order\n      this.modelManager.forEachModel(model => {\n        if (model) {\n          models.push(model);\n        } else {\n          // DB should throw an SQL error if referencing non-existent table\n        }\n      });\n\n      // no models defined, just authenticate\n      if (!models.length) return this.authenticate(options);\n\n      return Promise.each(models, model => model.sync(options));\n    }).then(() => {\n      if (options.hooks) {\n        return this.runHooks('afterBulkSync', options);\n      }\n    }).return(this);\n  }\n\n  /**\n   * Truncate all tables defined through the sequelize models.\n   * This is done by calling `Model.truncate()` on each model.\n   *\n   * @param {Object} [options] The options passed to Model.destroy in addition to truncate\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   * @returns {Promise}\n   *\n   * @see\n   * {@link Model.truncate} for more information\n   */\n  truncate(options) {\n    const models = [];\n\n    this.modelManager.forEachModel(model => {\n      if (model) {\n        models.push(model);\n      }\n    }, { reverse: false });\n\n    const truncateModel = model => model.truncate(options);\n\n    if (options && options.cascade) {\n      return Promise.each(models, truncateModel);\n    }\n    return Promise.map(models, truncateModel);\n  }\n\n  /**\n   * Drop all tables defined through this sequelize instance.\n   * This is done by calling Model.drop on each model.\n   *\n   * @see\n   * {@link Model.drop} for options\n   *\n   * @param {Object} [options] The options passed to each call to Model.drop\n   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging\n   *\n   * @returns {Promise}\n   */\n  drop(options) {\n    const models = [];\n\n    this.modelManager.forEachModel(model => {\n      if (model) {\n        models.push(model);\n      }\n    }, { reverse: false });\n\n    return Promise.each(models, model => model.drop(options));\n  }\n\n  /**\n   * Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.\n   *\n   * @param {Object} [options={}] query options\n   *\n   * @returns {Promise}\n   */\n  authenticate(options) {\n    options = Object.assign({\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    }, options);\n\n    return this.query('SELECT 1+1 AS result', options).return();\n  }\n\n  databaseVersion(options) {\n    return this.getQueryInterface().databaseVersion(options);\n  }\n\n  /**\n   * Get the fn for random based on the dialect\n   *\n   * @returns {Sequelize.fn}\n   */\n  random() {\n    const dia = this.getDialect();\n    if (dia === 'postgres' || dia === 'sqlite') {\n      return this.fn('RANDOM');\n    }\n    return this.fn('RAND');\n  }\n\n  /**\n   * Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.\n   * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.\n   *\n   * @see\n   * {@link Model.findAll}\n   * @see\n   * {@link Sequelize.define}\n   * @see\n   * {@link Sequelize.col}\n   *\n   * @param {string} fn The function you want to call\n   * @param {any} args All further arguments will be passed as arguments to the function\n   *\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   * @returns {Sequelize.fn}\n   *\n   * @example <caption>Convert a user's username to upper case</caption>\n   * instance.update({\n   *   username: sequelize.fn('upper', sequelize.col('username'))\n   * });\n   */\n  static fn(fn, ...args) {\n    return new Utils.Fn(fn, args);\n  }\n\n  /**\n   * Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.\n   *\n   * @see\n   * {@link Sequelize#fn}\n   *\n   * @param {string} col The name of the column\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.col}\n   */\n  static col(col) {\n    return new Utils.Col(col);\n  }\n\n  /**\n   * Creates an object representing a call to the cast function.\n   *\n   * @param {any} val The value to cast\n   * @param {string} type The type to cast it to\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.cast}\n   */\n  static cast(val, type) {\n    return new Utils.Cast(val, type);\n  }\n\n  /**\n   * Creates an object representing a literal, i.e. something that will not be escaped.\n   *\n   * @param {any} val literal value\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.literal}\n   */\n  static literal(val) {\n    return new Utils.Literal(val);\n  }\n\n  /**\n   * An AND query\n   *\n   * @see\n   * {@link Model.findAll}\n   *\n   * @param {...string|Object} args Each argument will be joined by AND\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.and}\n   */\n  static and(...args) {\n    return { [Op.and]: args };\n  }\n\n  /**\n   * An OR query\n   *\n   * @see\n   * {@link Model.findAll}\n   *\n   * @param {...string|Object} args Each argument will be joined by OR\n   * @since v2.0.0-dev3\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.or}\n   */\n  static or(...args) {\n    return { [Op.or]: args };\n  }\n\n  /**\n   * Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.\n   *\n   * @see\n   * {@link Model.findAll}\n   *\n   * @param {string|Object} conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres/sqlite/mysql json syntax.\n   * @param {string|number|boolean} [value] An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\".\n   * @memberof Sequelize\n   *\n   * @returns {Sequelize.json}\n   */\n  static json(conditionsOrPath, value) {\n    return new Utils.Json(conditionsOrPath, value);\n  }\n\n  /**\n   * A way of specifying attr = condition.\n   *\n   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The\n   * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)\n   *\n   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.\n   *\n   * @see\n   * {@link Model.findAll}\n   *\n   * @param {Object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax\n   * @param {Symbol} [comparator='Op.eq'] operator\n   * @param {string|Object} logic The condition. Can be both a simply type, or a further condition (`or`, `and`, `.literal` etc.)\n   * @since v2.0.0-dev3\n   */\n  static where(attr, comparator, logic) {\n    return new Utils.Where(attr, comparator, logic);\n  }\n\n  /**\n   * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see {@link Transaction}\n   *\n   * If you have [CLS](https://github.com/othiym23/node-continuation-local-storage) enabled, the transaction will automatically be passed to any query that runs within the callback\n   *\n   * @example\n   * sequelize.transaction().then(transaction => {\n   *   return User.findOne(..., {transaction})\n   *     .then(user => user.update(..., {transaction}))\n   *     .then(() => transaction.commit())\n   *     .catch(() => transaction.rollback());\n   * })\n   *\n   * @example <caption>A syntax for automatically committing or rolling back based on the promise chain resolution is also supported</caption>\n   *\n   * sequelize.transaction(transaction => { // Note that we use a callback rather than a promise.then()\n   *   return User.findOne(..., {transaction})\n   *     .then(user => user.update(..., {transaction}))\n   * }).then(() => {\n   *   // Committed\n   * }).catch(err => {\n   *   // Rolled back\n   *   console.error(err);\n   * });\n   *\n   * @example <caption>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</caption>\n   *\n   * const cls = require('continuation-local-storage');\n   * const ns = cls.createNamespace('....');\n   * const Sequelize = require('sequelize');\n   * Sequelize.useCLS(ns);\n   *\n   * // Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace\n   *\n   * @param {Object}   [options] Transaction options\n   * @param {string}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n   * @param {string}   [options.isolationLevel] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options\n   * @param {string}   [options.deferrable] Sets the constraints to be deferred or immediately checked. See `Sequelize.Deferrable`. PostgreSQL Only\n   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n   * @param {Function} [autoCallback] The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back\n   *\n   * @returns {Promise}\n   */\n  transaction(options, autoCallback) {\n    if (typeof options === 'function') {\n      autoCallback = options;\n      options = undefined;\n    }\n\n    const transaction = new Transaction(this, options);\n\n    if (!autoCallback) return transaction.prepareEnvironment(false).return(transaction);\n\n    // autoCallback provided\n    return Sequelize._clsRun(() => {\n      return transaction.prepareEnvironment()\n        .then(() => autoCallback(transaction))\n        .tap(() => transaction.commit())\n        .catch(err => {\n          // Rollback transaction if not already finished (commit, rollback, etc)\n          // and reject with original error (ignore any error in rollback)\n          return Promise.try(() => {\n            if (!transaction.finished) return transaction.rollback().catch(() => {});\n          }).throw(err);\n        });\n    });\n  }\n\n  /**\n   * Use CLS with Sequelize.\n   * CLS namespace provided is stored as `Sequelize._cls`\n   * and bluebird Promise is patched to use the namespace, using `cls-bluebird` module.\n   *\n   * @param {Object} ns CLS namespace\n   * @returns {Object} Sequelize constructor\n   */\n  static useCLS(ns) {\n    // check `ns` is valid CLS namespace\n    if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new Error('Must provide CLS namespace');\n\n    // save namespace as `Sequelize._cls`\n    this._cls = ns;\n\n    // patch bluebird to bind all promise callbacks to CLS namespace\n    clsBluebird(ns, Promise);\n\n    // return Sequelize for chaining\n    return this;\n  }\n\n  /**\n   * Run function in CLS context.\n   * If no CLS context in use, just runs the function normally\n   *\n   * @private\n   * @param {Function} fn Function to run\n   * @returns {*} Return value of function\n   */\n  static _clsRun(fn) {\n    const ns = Sequelize._cls;\n    if (!ns) return fn();\n\n    let res;\n    ns.run(context => res = fn(context));\n    return res;\n  }\n\n  log(...args) {\n    let options;\n\n    const last = _.last(args);\n\n    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, 'logging')) {\n      options = last;\n\n      // remove options from set of logged arguments if options.logging is equal to console.log\n      // eslint-disable-next-line no-console\n      if (options.logging === console.log) {\n        args.splice(args.length - 1, 1);\n      }\n    } else {\n      options = this.options;\n    }\n\n    if (options.logging) {\n      if (options.logging === true) {\n        deprecations.noTrueLogging();\n        // eslint-disable-next-line no-console\n        options.logging = console.log;\n      }\n\n      // second argument is sql-timings, when benchmarking option enabled\n      // eslint-disable-next-line no-console\n      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n        args = [`${args[0]} Elapsed time: ${args[1]}ms`];\n      }\n\n      options.logging(...args);\n    }\n  }\n\n  /**\n   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.\n   *\n   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want\n   * to garbage collect some of them.\n   *\n   * @returns {Promise}\n   */\n  close() {\n    return this.connectionManager.close();\n  }\n\n  normalizeDataType(Type) {\n    let type = typeof Type === 'function' ? new Type() : Type;\n    const dialectTypes = this.dialect.DataTypes || {};\n\n    if (dialectTypes[type.key]) {\n      type = dialectTypes[type.key].extend(type);\n    }\n\n    if (type instanceof DataTypes.ARRAY) {\n      if (!type.type) {\n        throw new Error('ARRAY is missing type definition for its values.');\n      }\n      if (dialectTypes[type.type.key]) {\n        type.type = dialectTypes[type.type.key].extend(type.type);\n      }\n    }\n\n    return type;\n  }\n\n  normalizeAttribute(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = { type: attribute };\n    }\n\n    if (!attribute.type) return attribute;\n\n    attribute.type = this.normalizeDataType(attribute.type);\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')) {\n      if (typeof attribute.defaultValue === 'function' && (\n        attribute.defaultValue === DataTypes.NOW ||\n          attribute.defaultValue === DataTypes.UUIDV1 ||\n          attribute.defaultValue === DataTypes.UUIDV4\n      )) {\n        attribute.defaultValue = new attribute.defaultValue();\n      }\n    }\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      // The ENUM is a special case where the type is an object containing the values\n      if (attribute.values) {\n        attribute.type.values = attribute.type.options.values = attribute.values;\n      } else {\n        attribute.values = attribute.type.values;\n      }\n\n      if (!attribute.values.length) {\n        throw new Error('Values for ENUM have not been defined.');\n      }\n    }\n\n    return attribute;\n  }\n}\n\n// Aliases\nSequelize.prototype.fn = Sequelize.fn;\nSequelize.prototype.col = Sequelize.col;\nSequelize.prototype.cast = Sequelize.cast;\nSequelize.prototype.literal = Sequelize.literal;\nSequelize.prototype.and = Sequelize.and;\nSequelize.prototype.or = Sequelize.or;\nSequelize.prototype.json = Sequelize.json;\nSequelize.prototype.where = Sequelize.where;\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\n\n/**\n * Sequelize version number.\n */\nSequelize.version = require('../package.json').version;\n\nSequelize.options = { hooks: {} };\n\n/**\n * @private\n */\nSequelize.Utils = Utils;\n\n/**\n * Operators symbols to be used for querying data\n * @see  {@link Operators}\n */\nSequelize.Op = Op;\n\n/**\n * A handy reference to the bluebird Promise class\n */\nSequelize.Promise = Promise;\n\n/**\n * Available table hints to be used for querying data in mssql for table hints\n * @see {@link TableHints}\n */\nSequelize.TableHints = TableHints;\n\n/**\n * Available index hints to be used for querying data in mysql for index hints\n * @see {@link IndexHints}\n */\nSequelize.IndexHints = IndexHints;\n\n/**\n * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction\n * @see {@link Transaction}\n * @see {@link Sequelize.transaction}\n */\nSequelize.Transaction = Transaction;\n\n/**\n * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.\n * @see {@link Sequelize}\n */\nSequelize.prototype.Sequelize = Sequelize;\n\n/**\n * Available query types for use with `sequelize.query`\n * @see {@link QueryTypes}\n */\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\n\n/**\n * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.\n * @see https://github.com/chriso/validator.js\n */\nSequelize.prototype.Validator = Sequelize.Validator = Validator;\n\nSequelize.Model = Model;\n\nSequelize.DataTypes = DataTypes;\nfor (const dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\n\n/**\n * A reference to the deferrable collection. Use this to access the different deferrable options.\n * @see {@link Transaction.Deferrable}\n * @see {@link Sequelize#transaction}\n */\nSequelize.Deferrable = Deferrable;\n\n/**\n * A reference to the sequelize association class.\n * @see {@link Association}\n */\nSequelize.prototype.Association = Sequelize.Association = Association;\n\n/**\n * Provide alternative version of `inflection` module to be used by `Utils.pluralize` etc.\n * @param {Object} _inflection - `inflection` module\n */\nSequelize.useInflection = Utils.useInflection;\n\n/**\n * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models\n * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()\n */\nHooks.applyTo(Sequelize);\nHooks.applyTo(Sequelize.prototype);\n\n/**\n * Expose various errors available\n */\n\n// expose alias to BaseError\nSequelize.Error = sequelizeErrors.BaseError;\n\nfor (const error of Object.keys(sequelizeErrors)) {\n  Sequelize[error] = sequelizeErrors[error];\n}\n\nmodule.exports = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports.default = Sequelize;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/sequelize.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2000,
    "kind": "variable",
    "name": "url",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~url",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2001,
    "kind": "variable",
    "name": "path",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~path",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2002,
    "kind": "variable",
    "name": "retry",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~retry",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2003,
    "kind": "variable",
    "name": "clsBluebird",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~clsBluebird",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2004,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2005,
    "kind": "variable",
    "name": "Utils",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Utils",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2006,
    "kind": "variable",
    "name": "Model",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Model",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2007,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2008,
    "kind": "variable",
    "name": "Deferrable",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Deferrable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2009,
    "kind": "variable",
    "name": "ModelManager",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~ModelManager",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2010,
    "kind": "variable",
    "name": "QueryInterface",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~QueryInterface",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2011,
    "kind": "variable",
    "name": "Transaction",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Transaction",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2012,
    "kind": "variable",
    "name": "QueryTypes",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~QueryTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2013,
    "kind": "variable",
    "name": "TableHints",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~TableHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2014,
    "kind": "variable",
    "name": "IndexHints",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~IndexHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2015,
    "kind": "variable",
    "name": "sequelizeErrors",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~sequelizeErrors",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2016,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2017,
    "kind": "variable",
    "name": "Hooks",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Hooks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2018,
    "kind": "variable",
    "name": "Association",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Association",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2019,
    "kind": "variable",
    "name": "Validator",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Validator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2020,
    "kind": "variable",
    "name": "Op",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Op",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2021,
    "kind": "variable",
    "name": "deprecations",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~deprecations",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2022,
    "kind": "class",
    "name": "Sequelize",
    "memberof": "lib/sequelize.js",
    "static": true,
    "longname": "lib/sequelize.js~Sequelize",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sequelize.js",
    "importStyle": null,
    "description": "This is the main class, the entry point to sequelize.",
    "lineNumber": 30,
    "interface": false
  },
  {
    "__docId__": 2023,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#constructor",
    "access": "public",
    "description": "Instantiate sequelize with name of database, username and password.",
    "examples": [
      "// without password / with blank password\nconst sequelize = new Sequelize('database', 'username', null, {\n  dialect: 'mysql'\n})\n\n// with password and options\nconst sequelize = new Sequelize('my_database', 'john', 'doe', {\n  dialect: 'postgres'\n})\n\n// with database, username, and password in the options object\nconst sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });\n\n// with uri\nconst sequelize = new Sequelize('mysql://localhost:3306/database', {})\n\n// option examples\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  // the sql dialect of the database\n  // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'\n  dialect: 'mysql',\n\n  // custom host; default: localhost\n  host: 'my.server.tld',\n  // for postgres, you can also specify an absolute path to a directory\n  // containing a UNIX socket to connect over\n  // host: '/sockets/psql_sockets'.\n\n  // custom port; default: dialect default\n  port: 12345,\n\n  // custom protocol; default: 'tcp'\n  // postgres only, useful for Heroku\n  protocol: null,\n\n  // disable logging or provide a custom logging function; default: console.log\n  logging: false,\n\n  // you can also pass any dialect options to the underlying dialect library\n  // - default is empty\n  // - currently supported: 'mysql', 'postgres', 'mssql'\n  dialectOptions: {\n    socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',\n    supportBigNumbers: true,\n    bigNumberStrings: true\n  },\n\n  // the storage engine for sqlite\n  // - default ':memory:'\n  storage: 'path/to/database.sqlite',\n\n  // disable inserting undefined values as NULL\n  // - default: false\n  omitNull: true,\n\n  // a flag for using a native library or not.\n  // in the case of 'pg' -- set this to true will allow SSL support\n  // - default: false\n  native: true,\n\n  // Specify options, which are used when sequelize.define is called.\n  // The following example:\n  //   define: { timestamps: false }\n  // is basically the same as:\n  //   Model.init(attributes, { timestamps: false });\n  //   sequelize.define(name, attributes, { timestamps: false });\n  // so defining the timestamps for each model will be not necessary\n  define: {\n    underscored: false,\n    freezeTableName: false,\n    charset: 'utf8',\n    dialectOptions: {\n      collate: 'utf8_general_ci'\n    },\n    timestamps: true\n  },\n\n  // similar for sync: you can define this to always force sync for models\n  sync: { force: true },\n\n  // pool configuration used to pool database connections\n  pool: {\n    max: 5,\n    idle: 30000,\n    acquire: 60000,\n  },\n\n  // isolation level of each transaction\n  // defaults to dialect default\n  isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ\n})"
    ],
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The name of the database"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "username",
        "description": "The username which is used to authenticate against the database."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "password",
        "description": "The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "An object with options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'localhost'",
        "defaultRaw": "'localhost'",
        "name": "options.host",
        "description": "The host of the relational database."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "",
        "defaultRaw": "",
        "name": "options.port",
        "description": "The port of the relational database."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.username",
        "description": "The username which is used to authenticate against the database."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.password",
        "description": "The password which is used to authenticate against the database."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.database",
        "description": "The name of the database"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.dialect",
        "description": "The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.dialectModule",
        "description": "If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(\"pg.js\")' here"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.dialectModulePath",
        "description": "If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.dialectOptions",
        "description": "An object of additional options, which are passed directly to the connection library"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.storage",
        "description": "Only used by sqlite. Defaults to ':memory:'"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'tcp'",
        "defaultRaw": "'tcp'",
        "name": "options.protocol",
        "description": "The protocol of the relational database."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.define",
        "description": "Default options for model definitions. See {@link Model.init}."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.query",
        "description": "Default options for sequelize.query"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.schema",
        "description": "A schema to use"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.set",
        "description": "Default options for sequelize.set"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.sync",
        "description": "Default options for sequelize.sync"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'+00:00'",
        "defaultRaw": "'+00:00'",
        "name": "options.timezone",
        "description": "The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'warning'",
        "defaultRaw": "'warning'",
        "name": "options.clientMinMessages",
        "description": "The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.standardConformingStrings",
        "description": "The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "console.log",
        "defaultRaw": "console.log",
        "name": "options.logging",
        "description": "A function that gets executed every time Sequelize would log something."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.benchmark",
        "description": "Pass query execution time in milliseconds as second argument to logging function (options.logging)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.omitNull",
        "description": "A flag that defines if null values should be passed to SQL queries or not."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.native",
        "description": "A flag that defines if native library shall be used or not. Currently only has an effect for postgres"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.replication",
        "description": "Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.pool",
        "description": "sequelize connection pool configuration"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "5",
        "defaultRaw": 5,
        "name": "options.pool.max",
        "description": "Maximum number of connection in pool"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "options.pool.min",
        "description": "Minimum number of connection in pool"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10000",
        "defaultRaw": 10000,
        "name": "options.pool.idle",
        "description": "The maximum time, in milliseconds, that a connection can be idle before being released."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "60000",
        "defaultRaw": 60000,
        "name": "options.pool.acquire",
        "description": "The maximum time, in milliseconds, that pool will try to get connection before throwing error"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1000",
        "defaultRaw": 1000,
        "name": "options.pool.evict",
        "description": "The time interval, in milliseconds, after which sequelize-pool will remove idle connections."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.pool.validate",
        "description": "A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.quoteIdentifiers",
        "description": "Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'DEFERRED'",
        "defaultRaw": "'DEFERRED'",
        "name": "options.transactionType",
        "description": "Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.isolationLevel",
        "description": "Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry",
        "description": "Set of flags that control when a query is automatically retried."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry.match",
        "description": "Only retry a query if the error matches one of these strings."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry.max",
        "description": "How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.typeValidation",
        "description": "Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.operatorsAliases",
        "description": "String based operator alias. Pass object to limit set of aliased operators."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.hooks",
        "description": "An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.minifyAliases",
        "description": "A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logQueryParameters",
        "description": "A flag that defines if show bind patameters in log."
      }
    ]
  },
  {
    "__docId__": 2024,
    "kind": "member",
    "name": "options",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#options",
    "access": "public",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2025,
    "kind": "member",
    "name": "config",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#config",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true,
    "type": {
      "types": [
        "{\"database\": *, \"username\": *, \"password\": *, \"host\": *, \"port\": *, \"pool\": *, \"protocol\": *, \"native\": *, \"ssl\": *, \"replication\": *, \"dialectModule\": *, \"dialectModulePath\": *, \"keepDefaultTimezone\": *, \"dialectOptions\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2026,
    "kind": "member",
    "name": "dialect",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#dialect",
    "access": "public",
    "description": null,
    "lineNumber": 334,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2027,
    "kind": "member",
    "name": "queryInterface",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#queryInterface",
    "access": "public",
    "description": null,
    "lineNumber": 344,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2028,
    "kind": "member",
    "name": "models",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#models",
    "access": "public",
    "description": "Models are stored here under the name given to `sequelize.define`",
    "lineNumber": 349,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 2029,
    "kind": "member",
    "name": "modelManager",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#modelManager",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2030,
    "kind": "member",
    "name": "connectionManager",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#connectionManager",
    "access": "public",
    "description": null,
    "lineNumber": 351,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2031,
    "kind": "member",
    "name": "importCache",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#importCache",
    "access": "public",
    "description": null,
    "lineNumber": 353,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2032,
    "kind": "method",
    "name": "refreshTypes",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#refreshTypes",
    "access": "private",
    "description": "Refresh data types and parsers.",
    "lineNumber": 363,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2033,
    "kind": "method",
    "name": "getDialect",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#getDialect",
    "access": "public",
    "description": "Returns the specified dialect.",
    "lineNumber": 372,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The specified dialect."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The specified dialect."
    },
    "params": []
  },
  {
    "__docId__": 2034,
    "kind": "method",
    "name": "getDatabaseName",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#getDatabaseName",
    "access": "public",
    "description": "Returns the database name.",
    "lineNumber": 381,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The database name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The database name."
    },
    "params": []
  },
  {
    "__docId__": 2035,
    "kind": "method",
    "name": "getQueryInterface",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#getQueryInterface",
    "access": "public",
    "description": "Returns an instance of QueryInterface.",
    "lineNumber": 390,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{QueryInterface} An instance (singleton) of QueryInterface."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QueryInterface"
      ],
      "spread": false,
      "description": "An instance (singleton) of QueryInterface."
    },
    "params": []
  },
  {
    "__docId__": 2037,
    "kind": "method",
    "name": "define",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#define",
    "access": "public",
    "description": "Define a new model, representing a table in the database.\n\nThe table columns are defined by the object that is given as the second argument. Each key of the object represents a column",
    "examples": [
      "sequelize.define('modelName', {\n  columnA: {\n      type: Sequelize.BOOLEAN,\n      validate: {\n        is: [\"[a-z]\",'i'],        // will only allow letters\n        max: 23,                  // only allow values <= 23\n        isIn: {\n          args: [['en', 'zh']],\n          msg: \"Must be English or Chinese\"\n        }\n      },\n      field: 'column_a'\n  },\n  columnB: Sequelize.STRING,\n  columnC: 'MY VERY OWN COLUMN TYPE'\n});\n\nsequelize.models.modelName // The model will now be available in models under the name given to define"
    ],
    "see": [
      "{@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.",
      "<a href=\"/manual/tutorial/models-definition.html\">Model definition</a> Manual related to model definition",
      "{@link DataTypes} For a list of possible data types"
    ],
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} Newly defined model"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "modelName",
        "description": "The name of the model. The model will be stored in `sequelize.models` under this name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attributes",
        "description": "An object, where each attribute is a column of the table. See {@link Model.init}"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "Newly defined model"
    }
  },
  {
    "__docId__": 2038,
    "kind": "method",
    "name": "model",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#model",
    "access": "public",
    "description": "Fetch a Model which is already defined",
    "lineNumber": 451,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Model} Specified model"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "modelName",
        "description": "The name of a model defined with Sequelize.define"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "Specified model"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)"
      }
    ]
  },
  {
    "__docId__": 2039,
    "kind": "method",
    "name": "isDefined",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#isDefined",
    "access": "public",
    "description": "Checks whether a model with the given name is defined",
    "lineNumber": 466,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} Returns true if model is already defined, otherwise false"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "modelName",
        "description": "The name of a model defined with Sequelize.define"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Returns true if model is already defined, otherwise false"
    }
  },
  {
    "__docId__": 2040,
    "kind": "method",
    "name": "import",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#import",
    "access": "public",
    "description": "Imports a model defined in another file. Imported models are cached, so multiple\ncalls to import with the same path will not load the file multiple times.",
    "lineNumber": 480,
    "unknown": [
      {
        "tagName": "@tutorial",
        "tagValue": "https://github.com/sequelize/express-example"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Model} Imported model, returned from cache if was already imported"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "importPath",
        "description": "The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Model"
      ],
      "spread": false,
      "description": "Imported model, returned from cache if was already imported"
    }
  },
  {
    "__docId__": 2041,
    "kind": "method",
    "name": "query",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#query",
    "access": "public",
    "description": "Execute a query on the DB, optionally bypassing all the Sequelize goodness.\n\nBy default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.\n\nIf you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:\n\n```js\nsequelize.query('SELECT...').then(([results, metadata]) => {\n  // Raw query - use then plus array spread\n});\n\nsequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(results => {\n  // SELECT query - use then\n})\n```",
    "see": [
      "{@link Model.build} for more information about instance option."
    ],
    "lineNumber": 545,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "Query options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.raw",
        "description": "If true, sequelize will not try to format the results of the query, or build an instance of a model from the result"
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.transaction",
        "description": "The transaction that the query should be executed under"
      },
      {
        "nullable": null,
        "types": [
          "QueryTypes"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'RAW'",
        "defaultRaw": "'RAW'",
        "name": "options.type",
        "description": "The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.nest",
        "description": "If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.plain",
        "description": "Sets the query type to `SELECT` and return a single row"
      },
      {
        "nullable": null,
        "types": [
          "Object",
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.replacements",
        "description": "Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL."
      },
      {
        "nullable": null,
        "types": [
          "Object",
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.bind",
        "description": "Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.useMaster",
        "description": "Force the query to use the write pool, regardless of the query type."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "new Model()"
        ],
        "spread": false,
        "optional": true,
        "name": "options.instance",
        "description": "A sequelize instance used to build the return instance"
      },
      {
        "nullable": null,
        "types": [
          "Model"
        ],
        "spread": false,
        "optional": true,
        "name": "options.model",
        "description": "A sequelize model used to build the returned model instances (used to be called callee)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry",
        "description": "Set of flags that control when a query is automatically retried."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry.match",
        "description": "Only retry a query if the error matches one of these strings."
      },
      {
        "nullable": null,
        "types": [
          "Integer"
        ],
        "spread": false,
        "optional": true,
        "name": "options.retry.max",
        "description": "How many times a failing query is automatically retried."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.supportsSearchPath",
        "description": "If false do not prepend the query with the search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.mapToModel",
        "description": "Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fieldMap",
        "description": "Map returned fields to arbitrary names for `SELECT` query type."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2042,
    "kind": "method",
    "name": "set",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#set",
    "access": "public",
    "description": "Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.\nOnly works for MySQL.",
    "lineNumber": 678,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "variables",
        "description": "Object with multiple variables."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "query options."
      },
      {
        "nullable": null,
        "types": [
          "Transaction"
        ],
        "spread": false,
        "optional": true,
        "name": "options.transaction",
        "description": "The transaction that the query should be executed under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2043,
    "kind": "method",
    "name": "escape",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#escape",
    "access": "public",
    "description": "Escape value.",
    "lineNumber": 710,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string value to escape"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2044,
    "kind": "method",
    "name": "createSchema",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#createSchema",
    "access": "public",
    "description": "Create a new database schema.\n\n**Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\nnot a database table. In mysql and sqlite, this command will do nothing.",
    "see": [
      "{@link Model.schema}"
    ],
    "lineNumber": 729,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Name of the schema"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2045,
    "kind": "method",
    "name": "showAllSchemas",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#showAllSchemas",
    "access": "public",
    "description": "Show all defined schemas\n\n**Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\nnot a database table. In mysql and sqlite, this will show all tables.",
    "lineNumber": 744,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2046,
    "kind": "method",
    "name": "dropSchema",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#dropSchema",
    "access": "public",
    "description": "Drop a single schema\n\n**Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\nnot a database table. In mysql and sqlite, this drop a table matching the schema name",
    "lineNumber": 760,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Name of the schema"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2047,
    "kind": "method",
    "name": "dropAllSchemas",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#dropAllSchemas",
    "access": "public",
    "description": "Drop all schemas.\n\n**Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\nnot a database table. In mysql and sqlite, this is the equivalent of drop all tables.",
    "lineNumber": 775,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "query options"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2048,
    "kind": "method",
    "name": "sync",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#sync",
    "access": "public",
    "description": "Sync all defined models to the DB.",
    "lineNumber": 793,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "sync options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.force",
        "description": "If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": true,
        "name": "options.match",
        "description": "Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "console.log",
        "defaultRaw": "console.log",
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'public'",
        "defaultRaw": "'public'",
        "name": "options.schema",
        "description": "The schema that the tables should be created in. This can be overridden for each table in sequelize.define"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT",
        "defaultRaw": "DEFAULT",
        "name": "options.searchPath",
        "description": "An optional parameter to specify the schema search_path (Postgres only)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.hooks",
        "description": "If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.alter",
        "description": "Alters tables to fit models. Not recommended for production use. Deletes data in columns that were removed or had their type changed in the model."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2049,
    "kind": "method",
    "name": "truncate",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#truncate",
    "access": "public",
    "description": "Truncate all tables defined through the sequelize models.\nThis is done by calling `Model.truncate()` on each model.",
    "see": [
      "{@link Model.truncate} for more information"
    ],
    "lineNumber": 847,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options passed to Model.destroy in addition to truncate"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2050,
    "kind": "method",
    "name": "drop",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#drop",
    "access": "public",
    "description": "Drop all tables defined through this sequelize instance.\nThis is done by calling Model.drop on each model.",
    "see": [
      "{@link Model.drop} for options"
    ],
    "lineNumber": 876,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options passed to each call to Model.drop"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.logging",
        "description": "A function that logs sql queries, or false for no logging"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2051,
    "kind": "method",
    "name": "authenticate",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#authenticate",
    "access": "public",
    "description": "Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.",
    "lineNumber": 895,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "query options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2052,
    "kind": "method",
    "name": "databaseVersion",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#databaseVersion",
    "access": "public",
    "description": null,
    "lineNumber": 905,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2053,
    "kind": "method",
    "name": "random",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#random",
    "access": "public",
    "description": "Get the fn for random based on the dialect",
    "lineNumber": 914,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.fn}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.fn"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 2054,
    "kind": "method",
    "name": "fn",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.fn",
    "access": "public",
    "description": "Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.\nIf you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.",
    "examples": [
      "<caption>Convert a user's username to upper case</caption>\ninstance.update({\n  username: sequelize.fn('upper', sequelize.col('username'))\n});"
    ],
    "see": [
      "{@link Model.findAll}",
      "{@link Sequelize.define}",
      "{@link Sequelize.col}"
    ],
    "lineNumber": 945,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.fn}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "The function you want to call"
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "All further arguments will be passed as arguments to the function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.fn"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2055,
    "kind": "method",
    "name": "col",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.col",
    "access": "public",
    "description": "Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.",
    "see": [
      "{@link Sequelize#fn}"
    ],
    "lineNumber": 961,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.col}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "The name of the column"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.col"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2056,
    "kind": "method",
    "name": "cast",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.cast",
    "access": "public",
    "description": "Creates an object representing a call to the cast function.",
    "lineNumber": 975,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.cast}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "val",
        "description": "The value to cast"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type to cast it to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.cast"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2057,
    "kind": "method",
    "name": "literal",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.literal",
    "access": "public",
    "description": "Creates an object representing a literal, i.e. something that will not be escaped.",
    "lineNumber": 988,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.literal}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "val",
        "description": "literal value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.literal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2058,
    "kind": "method",
    "name": "and",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.and",
    "access": "public",
    "description": "An AND query",
    "see": [
      "{@link Model.findAll}"
    ],
    "lineNumber": 1004,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.and}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...string",
          "Object"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Each argument will be joined by AND"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.and"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2059,
    "kind": "method",
    "name": "or",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.or",
    "access": "public",
    "description": "An OR query",
    "see": [
      "{@link Model.findAll}"
    ],
    "lineNumber": 1020,
    "since": "v2.0.0-dev3",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.or}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...string",
          "Object"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Each argument will be joined by OR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.or"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2060,
    "kind": "method",
    "name": "json",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.json",
    "access": "public",
    "description": "Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.",
    "see": [
      "{@link Model.findAll}"
    ],
    "lineNumber": 1036,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Sequelize.json}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "conditionsOrPath",
        "description": "A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres/sqlite/mysql json syntax."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "number",
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "value",
        "description": "An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\"."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sequelize.json"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2061,
    "kind": "method",
    "name": "where",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.where",
    "access": "public",
    "description": "A way of specifying attr = condition.\n\nThe attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The\nattribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)\n\nFor string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.",
    "see": [
      "{@link Model.findAll}"
    ],
    "lineNumber": 1056,
    "since": "v2.0.0-dev3",
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "attr",
        "description": "The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax"
      },
      {
        "nullable": null,
        "types": [
          "Symbol"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'Op.eq'",
        "defaultRaw": "'Op.eq'",
        "name": "comparator",
        "description": "operator"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "logic",
        "description": "The condition. Can be both a simply type, or a further condition (`or`, `and`, `.literal` etc.)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2062,
    "kind": "method",
    "name": "transaction",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#transaction",
    "access": "public",
    "description": "Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see {@link Transaction}\n\nIf you have [CLS](https://github.com/othiym23/node-continuation-local-storage) enabled, the transaction will automatically be passed to any query that runs within the callback",
    "examples": [
      "sequelize.transaction().then(transaction => {\n  return User.findOne(..., {transaction})\n    .then(user => user.update(..., {transaction}))\n    .then(() => transaction.commit())\n    .catch(() => transaction.rollback());\n})",
      "<caption>A syntax for automatically committing or rolling back based on the promise chain resolution is also supported</caption>\n\nsequelize.transaction(transaction => { // Note that we use a callback rather than a promise.then()\n  return User.findOne(..., {transaction})\n    .then(user => user.update(..., {transaction}))\n}).then(() => {\n  // Committed\n}).catch(err => {\n  // Rolled back\n  console.error(err);\n});",
      "<caption>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</caption>\n\nconst cls = require('continuation-local-storage');\nconst ns = cls.createNamespace('....');\nconst Sequelize = require('sequelize');\nSequelize.useCLS(ns);\n\n// Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace"
    ],
    "lineNumber": 1103,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Transaction options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'DEFERRED'",
        "defaultRaw": "'DEFERRED'",
        "name": "options.type",
        "description": "See `Sequelize.Transaction.TYPES` for possible options. Sqlite only."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.isolationLevel",
        "description": "See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.deferrable",
        "description": "Sets the constraints to be deferred or immediately checked. See `Sequelize.Deferrable`. PostgreSQL Only"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.logging",
        "description": "A function that gets executed while running the query to log the sql."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "autoCallback",
        "description": "The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2063,
    "kind": "method",
    "name": "useCLS",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize.useCLS",
    "access": "public",
    "description": "Use CLS with Sequelize.\nCLS namespace provided is stored as `Sequelize._cls`\nand bluebird Promise is patched to use the namespace, using `cls-bluebird` module.",
    "lineNumber": 1136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Sequelize constructor"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "ns",
        "description": "CLS namespace"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Sequelize constructor"
    }
  },
  {
    "__docId__": 2064,
    "kind": "member",
    "name": "_cls",
    "memberof": "lib/sequelize.js~Sequelize",
    "static": true,
    "longname": "lib/sequelize.js~Sequelize._cls",
    "access": "private",
    "description": null,
    "lineNumber": 1141,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2065,
    "kind": "method",
    "name": "_clsRun",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sequelize.js~Sequelize._clsRun",
    "access": "private",
    "description": "Run function in CLS context.\nIf no CLS context in use, just runs the function normally",
    "lineNumber": 1158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*} Return value of function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Function to run"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Return value of function"
    },
    "ignore": true
  },
  {
    "__docId__": 2066,
    "kind": "method",
    "name": "log",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#log",
    "access": "public",
    "description": null,
    "lineNumber": 1167,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2067,
    "kind": "method",
    "name": "close",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#close",
    "access": "public",
    "description": "Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.\n\nNormally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want\nto garbage collect some of them.",
    "lineNumber": 1209,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 2068,
    "kind": "method",
    "name": "normalizeDataType",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#normalizeDataType",
    "access": "public",
    "description": null,
    "lineNumber": 1213,
    "undocument": true,
    "params": [
      {
        "name": "Type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2069,
    "kind": "method",
    "name": "normalizeAttribute",
    "memberof": "lib/sequelize.js~Sequelize",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/sequelize.js~Sequelize#normalizeAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 1233,
    "undocument": true,
    "params": [
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2070,
    "kind": "file",
    "name": "lib/sql-string.js",
    "content": "'use strict';\n\nconst dataTypes = require('./data-types');\nconst { logger } = require('./utils/logger');\n\nfunction arrayToList(array, timeZone, dialect, format) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += ', ';\n    }\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format);\n    }\n    return sql;\n  }, '');\n}\nexports.arrayToList = arrayToList;\n\nfunction escape(val, timeZone, dialect, format) {\n  let prependN = false;\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n  switch (typeof val) {\n    case 'boolean':\n    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0\n    // for us. Postgres actually has a boolean type with true/false literals,\n    // but sequelize doesn't use it yet.\n      if (dialect === 'sqlite' || dialect === 'mssql') {\n        return +!!val;\n      }\n      return (!!val).toString();\n    case 'number':\n      return val.toString();\n    case 'string':\n    // In mssql, prepend N to all quoted vals which are originally a string (for\n    // unicode compatibility)\n      prependN = dialect === 'mssql';\n      break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);\n    if (dialect === 'postgres' && !format) {\n      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });\n    }\n    return arrayToList(val, timeZone, dialect, format);\n  }\n\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n\n  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n\n    if (dialect === 'postgres') {\n      // null character is not allowed in Postgres\n      val = val.replace(/\\0/g, '\\\\0');\n    }\n  } else {\n    // eslint-disable-next-line no-control-regex\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, s => {\n      switch (s) {\n        case '\\0': return '\\\\0';\n        case '\\n': return '\\\\n';\n        case '\\r': return '\\\\r';\n        case '\\b': return '\\\\b';\n        case '\\t': return '\\\\t';\n        case '\\x1a': return '\\\\Z';\n        default: return `\\\\${s}`;\n      }\n    });\n  }\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\nexports.escape = escape;\n\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  if (typeof sql !== 'string') {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n\n  return sql.replace(/\\?/g, match => {\n    if (!values.length) {\n      return match;\n    }\n\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if ('postgres' === dialect && '::' === value.slice(0, 2)) {\n      return value;\n    }\n\n    if (values[key] !== undefined) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/sql-string.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2071,
    "kind": "variable",
    "name": "dataTypes",
    "memberof": "lib/sql-string.js",
    "static": true,
    "longname": "lib/sql-string.js~dataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2072,
    "kind": "variable",
    "name": "logger",
    "memberof": "lib/sql-string.js",
    "static": true,
    "longname": "lib/sql-string.js~logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2073,
    "kind": "function",
    "name": "arrayToList",
    "memberof": "lib/sql-string.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sql-string.js~arrayToList",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "timeZone",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2074,
    "kind": "function",
    "name": "escape",
    "memberof": "lib/sql-string.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sql-string.js~escape",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      },
      {
        "name": "timeZone",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2075,
    "kind": "function",
    "name": "format",
    "memberof": "lib/sql-string.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sql-string.js~format",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "timeZone",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2076,
    "kind": "function",
    "name": "formatNamedParameters",
    "memberof": "lib/sql-string.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/sql-string.js~formatNamedParameters",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/sql-string.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "timeZone",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2077,
    "kind": "file",
    "name": "lib/table-hints.js",
    "content": "'use strict';\n\n/**\n * An enum of table hints to be used in mssql for querying with table hints\n *\n * @property NOLOCK\n * @property READUNCOMMITTED\n * @property UPDLOCK\n * @property REPEATABLEREAD\n * @property SERIALIZABLE\n * @property READCOMMITTED\n * @property TABLOCK\n * @property TABLOCKX\n * @property PAGLOCK\n * @property ROWLOCK\n * @property NOWAIT\n * @property READPAST\n * @property XLOCK\n * @property SNAPSHOT\n * @property NOEXPAND\n */\nconst TableHints = module.exports = { // eslint-disable-line\n  NOLOCK: 'NOLOCK',\n  READUNCOMMITTED: 'READUNCOMMITTED',\n  UPDLOCK: 'UPDLOCK',\n  REPEATABLEREAD: 'REPEATABLEREAD',\n  SERIALIZABLE: 'SERIALIZABLE',\n  READCOMMITTED: 'READCOMMITTED',\n  TABLOCK: 'TABLOCK',\n  TABLOCKX: 'TABLOCKX',\n  PAGLOCK: 'PAGLOCK',\n  ROWLOCK: 'ROWLOCK',\n  NOWAIT: 'NOWAIT',\n  READPAST: 'READPAST',\n  XLOCK: 'XLOCK',\n  SNAPSHOT: 'SNAPSHOT',\n  NOEXPAND: 'NOEXPAND'\n};\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/table-hints.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2078,
    "kind": "variable",
    "name": "TableHints",
    "memberof": "lib/table-hints.js",
    "static": true,
    "longname": "lib/table-hints.js~TableHints",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/table-hints.js",
    "importStyle": null,
    "description": "An enum of table hints to be used in mssql for querying with table hints",
    "lineNumber": 22,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "NOLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "READUNCOMMITTED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "UPDLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "REPEATABLEREAD",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SERIALIZABLE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "READCOMMITTED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "TABLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "TABLOCKX",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "PAGLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ROWLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "NOWAIT",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "READPAST",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "XLOCK",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SNAPSHOT",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "NOEXPAND",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2079,
    "kind": "file",
    "name": "lib/transaction.js",
    "content": "'use strict';\n\nconst Promise = require('./promise');\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n\n    this.options = Object.assign({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n  commit() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .commitTransaction(this, this.options)\n      .finally(() => {\n        this.finished = 'commit';\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return null;\n      }).tap(\n        () => Promise.each(\n          this._afterCommitHooks,\n          hook => Promise.resolve(hook.apply(this, [this])))\n      );\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n  rollback() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`));\n    }\n\n    if (!this.connection) {\n      return Promise.reject(new Error('Transaction cannot be rolled back because it never started'));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .rollbackTransaction(this, this.options)\n      .finally(() => {\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return this;\n      });\n  }\n\n  prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise\n      .then(connection => {\n        this.connection = connection;\n        this.connection.uuid = this.id;\n      })\n      .then(() => {\n        return this.begin()\n          .then(() => this.setDeferrable())\n          .catch(setupErr => this.rollback().finally(() => {\n            throw setupErr;\n          }));\n      })\n      .tap(() => {\n        if (useCLS && this.sequelize.constructor._cls) {\n          this.sequelize.constructor._cls.set('transaction', this);\n        }\n        return null;\n      });\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {\n      return queryInterface.startTransaction(this, this.options).then(() => {\n        return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n      });\n    }\n\n    return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options).then(() => {\n      return queryInterface.startTransaction(this, this.options);\n    });\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/transaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2080,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/transaction.js",
    "static": true,
    "longname": "lib/transaction.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/transaction.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2081,
    "kind": "class",
    "name": "Transaction",
    "memberof": "lib/transaction.js",
    "static": true,
    "longname": "lib/transaction.js~Transaction",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/transaction.js",
    "importStyle": null,
    "description": "The transaction object is used to identify a running transaction.\nIt is created by calling `Sequelize.transaction()`.\nTo run a query under a transaction, you should pass the transaction in the options object.",
    "see": [
      "{@link Sequelize.transaction}"
    ],
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Transaction"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 2082,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#constructor",
    "access": "public",
    "description": "Creates a new transaction instance",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Sequelize"
        ],
        "spread": false,
        "optional": false,
        "name": "sequelize",
        "description": "A configured sequelize Instance"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object with options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.type",
        "description": "Sets the type of the transaction. Sqlite only"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.isolationLevel",
        "description": "Sets the isolation level of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.deferrable",
        "description": "Sets the constraints to be deferred or immediately checked. PostgreSQL only"
      }
    ]
  },
  {
    "__docId__": 2083,
    "kind": "member",
    "name": "sequelize",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#sequelize",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2084,
    "kind": "member",
    "name": "savepoints",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#savepoints",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2085,
    "kind": "member",
    "name": "_afterCommitHooks",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#_afterCommitHooks",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 2086,
    "kind": "member",
    "name": "options",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#options",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2087,
    "kind": "member",
    "name": "parent",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#parent",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2088,
    "kind": "member",
    "name": "id",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#id",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2089,
    "kind": "member",
    "name": "name",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#name",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2091,
    "kind": "method",
    "name": "commit",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#commit",
    "access": "public",
    "description": "Commit the transaction",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 2092,
    "kind": "member",
    "name": "finished",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#finished",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2093,
    "kind": "method",
    "name": "rollback",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#rollback",
    "access": "public",
    "description": "Rollback (abort) the transaction",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 2094,
    "kind": "method",
    "name": "prepareEnvironment",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#prepareEnvironment",
    "access": "public",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [
      {
        "name": "useCLS",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2095,
    "kind": "member",
    "name": "connection",
    "memberof": "lib/transaction.js~Transaction",
    "static": false,
    "longname": "lib/transaction.js~Transaction#connection",
    "access": "public",
    "description": null,
    "lineNumber": 126,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2096,
    "kind": "method",
    "name": "setDeferrable",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#setDeferrable",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2097,
    "kind": "method",
    "name": "begin",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#begin",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2098,
    "kind": "method",
    "name": "cleanup",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#cleanup",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2099,
    "kind": "method",
    "name": "_clearCls",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#_clearCls",
    "access": "private",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2100,
    "kind": "method",
    "name": "afterCommit",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#afterCommit",
    "access": "public",
    "description": "A hook that is run after a transaction is committed",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A callback function that is called with the committed transaction"
      }
    ],
    "return": null
  },
  {
    "__docId__": 2101,
    "kind": "get",
    "name": "TYPES",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/transaction.js~Transaction.TYPES",
    "access": "public",
    "description": "Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\nDefault to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\nSqlite only.\n\nPass in the desired level as the first argument:",
    "examples": [
      "return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n  // your transactions\n}).then(result => {\n  // transaction has been committed. Do something after the commit if required.\n}).catch(err => {\n  // do something with the err.\n});"
    ],
    "lineNumber": 217,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "DEFERRED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "IMMEDIATE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "EXCLUSIVE",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "{\"DEFERRED\": string, \"IMMEDIATE\": string, \"EXCLUSIVE\": string}"
      ]
    }
  },
  {
    "__docId__": 2102,
    "kind": "get",
    "name": "ISOLATION_LEVELS",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/transaction.js~Transaction.ISOLATION_LEVELS",
    "access": "public",
    "description": "Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\nSequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n\nPass in the desired level as the first argument:",
    "examples": [
      "return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n  // your transactions\n}).then(result => {\n  // transaction has been committed. Do something after the commit if required.\n}).catch(err => {\n  // do something with the err.\n});"
    ],
    "lineNumber": 245,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "READ_UNCOMMITTED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "READ_COMMITTED",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "REPEATABLE_READ",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SERIALIZABLE",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "{\"READ_UNCOMMITTED\": string, \"READ_COMMITTED\": string, \"REPEATABLE_READ\": string, \"SERIALIZABLE\": string}"
      ]
    }
  },
  {
    "__docId__": 2103,
    "kind": "get",
    "name": "LOCK",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/transaction.js~Transaction.LOCK",
    "access": "public",
    "description": "Possible options for row locking. Used in conjunction with `find` calls:",
    "examples": [
      "// t1 is a transaction\nModel.findAll({\n  where: ...,\n  transaction: t1,\n  lock: t1.LOCK...\n});",
      "<caption>Postgres also supports specific locks while eager loading by using OF:</caption>\nUserModel.findAll({\n  where: ...,\n  include: [TaskModel, ...],\n  transaction: t1,\n  lock: {\n    level: t1.LOCK...,\n    of: UserModel\n  }\n});\n\n# UserModel will be locked but TaskModel won't!",
      "<caption>You can also skip locked rows:</caption>\n// t1 is a transaction\nModel.findAll({\n  where: ...,\n  transaction: t1,\n  lock: true,\n  skipLocked: true\n});\n# The query will now return any rows that aren't locked by another transaction"
    ],
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "UPDATE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "SHARE",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "KEY_SHARE",
        "description": "Postgres 9.3+ only"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "NO_KEY_UPDATE",
        "description": "Postgres 9.3+ only"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "{\"UPDATE\": string, \"SHARE\": string, \"KEY_SHARE\": string, \"NO_KEY_UPDATE\": string}"
      ]
    }
  },
  {
    "__docId__": 2104,
    "kind": "get",
    "name": "LOCK",
    "memberof": "lib/transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/transaction.js~Transaction#LOCK",
    "access": "public",
    "description": "Please see {@link Transaction.LOCK}",
    "lineNumber": 307,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2105,
    "kind": "file",
    "name": "lib/utils/class-to-invokable.js",
    "content": "var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  classToInvokable: () => classToInvokable\n});\nfunction classToInvokable(Class) {\n  return new Proxy(Class, {\n    apply(_target, _thisArg, args) {\n      return new Class(...args);\n    },\n    construct(_target, args) {\n      return new Class(...args);\n    }\n  });\n}\n//# sourceMappingURL=class-to-invokable.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/class-to-invokable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2106,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/utils/class-to-invokable.js",
    "static": true,
    "longname": "lib/utils/class-to-invokable.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/class-to-invokable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2107,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/utils/class-to-invokable.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/class-to-invokable.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/class-to-invokable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2108,
    "kind": "function",
    "name": "__export",
    "memberof": "lib/utils/class-to-invokable.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/class-to-invokable.js~__export",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/class-to-invokable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "all",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2109,
    "kind": "function",
    "name": "classToInvokable",
    "memberof": "lib/utils/class-to-invokable.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/class-to-invokable.js~classToInvokable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/class-to-invokable.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "Class",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2110,
    "kind": "file",
    "name": "lib/utils/classToInvokable.js",
    "content": "'use strict';\n\n/**\n * Wraps a constructor to not need the `new` keyword using a proxy.\n * Only used for data types.\n *\n * @param {Function} Class The class instance to wrap as invocable.\n * @returns {Proxy} Wrapped class instance.\n * @private\n */\nfunction classToInvokable(Class) {\n  return new Proxy(Class, {\n    apply(Target, thisArg, args) {\n      return new Target(...args);\n    },\n    construct(Target, args) {\n      return new Target(...args);\n    },\n    get(target, p) {\n      return target[p];\n    }\n  });\n}\nexports.classToInvokable = classToInvokable;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/classToInvokable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2111,
    "kind": "function",
    "name": "classToInvokable",
    "memberof": "lib/utils/classToInvokable.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/classToInvokable.js~classToInvokable",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/classToInvokable.js",
    "importStyle": null,
    "description": "Wraps a constructor to not need the `new` keyword using a proxy.\nOnly used for data types.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Proxy} Wrapped class instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "Class",
        "description": "The class instance to wrap as invocable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Proxy"
      ],
      "spread": false,
      "description": "Wrapped class instance."
    },
    "ignore": true
  },
  {
    "__docId__": 2112,
    "kind": "file",
    "name": "lib/utils/deprecations.js",
    "content": "'use strict';\n\nconst { deprecate } = require('util');\n\nconst noop = () => {};\n\nexports.noRawAttributes = deprecate(noop, 'Use sequelize.fn / sequelize.literal to construct attributes', 'SEQUELIZE0001');\nexports.noTrueLogging = deprecate(noop, 'The logging-option should be either a function or false. Default: console.log', 'SEQUELIZE0002');\nexports.noStringOperators = deprecate(noop, 'String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators', 'SEQUELIZE0003');\nexports.noBoolOperatorAliases = deprecate(noop, 'A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.', 'SEQUELIZE0004');\nexports.noDoubleNestedGroup = deprecate(noop, 'Passing a double nested nested array to `group` is unsupported and will be removed in v6.', 'SEQUELIZE0005');\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/deprecations.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2113,
    "kind": "variable",
    "name": "deprecate",
    "memberof": "lib/utils/deprecations.js",
    "static": true,
    "longname": "lib/utils/deprecations.js~deprecate",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/deprecations.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2114,
    "kind": "function",
    "name": "noop",
    "memberof": "lib/utils/deprecations.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/deprecations.js~noop",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/deprecations.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2115,
    "kind": "file",
    "name": "lib/utils/join-sql-fragments.js",
    "content": "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  JoinSQLFragmentsError: () => JoinSQLFragmentsError,\n  joinSQLFragments: () => joinSQLFragments\n});\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: \"\"\n  }).result;\n}\nfunction joinSQLFragments(array) {\n  if (array.length === 0)\n    return \"\";\n  const truthyArray = array.filter((x) => !!x);\n  const flattenedArray = truthyArray.map((fragment) => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n    return fragment;\n  });\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== \"string\") {\n      throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n    }\n  }\n  const trimmedArray = flattenedArray.map((x) => x.trim());\n  const nonEmptyStringArray = trimmedArray.filter((x) => x !== \"\");\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\nclass JoinSQLFragmentsError extends TypeError {\n  constructor(args, fragment, message) {\n    super(message);\n    __publicField(this, \"args\");\n    __publicField(this, \"fragment\");\n    this.args = args;\n    this.fragment = fragment;\n    this.name = \"JoinSQLFragmentsError\";\n  }\n}\n//# sourceMappingURL=join-sql-fragments.js.map\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/join-sql-fragments.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2116,
    "kind": "variable",
    "name": "__defProp",
    "memberof": "lib/utils/join-sql-fragments.js",
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~__defProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2117,
    "kind": "function",
    "name": "__defNormalProp",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~__defNormalProp",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2118,
    "kind": "function",
    "name": "__markAsModule",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~__markAsModule",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2119,
    "kind": "function",
    "name": "__export",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~__export",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "all",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2120,
    "kind": "function",
    "name": "__publicField",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~__publicField",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2121,
    "kind": "function",
    "name": "doesNotWantLeadingSpace",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~doesNotWantLeadingSpace",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2122,
    "kind": "function",
    "name": "doesNotWantTrailingSpace",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~doesNotWantTrailingSpace",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2123,
    "kind": "function",
    "name": "singleSpaceJoinHelper",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~singleSpaceJoinHelper",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "parts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2124,
    "kind": "function",
    "name": "joinSQLFragments",
    "memberof": "lib/utils/join-sql-fragments.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~joinSQLFragments",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2125,
    "kind": "class",
    "name": "JoinSQLFragmentsError",
    "memberof": "lib/utils/join-sql-fragments.js",
    "static": true,
    "longname": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/join-sql-fragments.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "interface": false,
    "extends": [
      "TypeError"
    ],
    "ignore": true
  },
  {
    "__docId__": 2126,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2127,
    "kind": "member",
    "name": "args",
    "memberof": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError",
    "static": false,
    "longname": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError#args",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2128,
    "kind": "member",
    "name": "fragment",
    "memberof": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError",
    "static": false,
    "longname": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError#fragment",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2129,
    "kind": "member",
    "name": "name",
    "memberof": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError",
    "static": false,
    "longname": "lib/utils/join-sql-fragments.js~JoinSQLFragmentsError#name",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2130,
    "kind": "file",
    "name": "lib/utils/logger.js",
    "content": "'use strict';\n\n/**\n * Sequelize module for debug and deprecation messages.\n * It require a `context` for which messages will be printed.\n *\n * @module logging\n * @private\n */\n\nconst debug = require('debug');\nconst util = require('util');\n\nclass Logger {\n  constructor(config) {\n\n    this.config = Object.assign({\n      context: 'sequelize',\n      debug: true\n    }, config);\n  }\n\n  warn(message) {\n    // eslint-disable-next-line no-console\n    console.warn(`(${this.config.context}) Warning: ${message}`);\n  }\n\n  inspect(value) {\n    return util.inspect(value, false, 3);\n  }\n\n  debugContext(name) {\n    return debug(`${this.config.context}:${name}`);\n  }\n}\n\nexports.logger = new Logger();\n\nexports.Logger = Logger;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/logger.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2131,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/utils/logger.js",
    "static": true,
    "longname": "lib/utils/logger.js~debug",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/logger.js",
    "importStyle": null,
    "description": "Sequelize module for debug and deprecation messages.\nIt require a `context` for which messages will be printed.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@module",
        "tagValue": "logging"
      }
    ],
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2132,
    "kind": "variable",
    "name": "util",
    "memberof": "lib/utils/logger.js",
    "static": true,
    "longname": "lib/utils/logger.js~util",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/logger.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2133,
    "kind": "class",
    "name": "Logger",
    "memberof": "lib/utils/logger.js",
    "static": true,
    "longname": "lib/utils/logger.js~Logger",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/logger.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2134,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils/logger.js~Logger",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/logger.js~Logger#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2135,
    "kind": "member",
    "name": "config",
    "memberof": "lib/utils/logger.js~Logger",
    "static": false,
    "longname": "lib/utils/logger.js~Logger#config",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2136,
    "kind": "method",
    "name": "warn",
    "memberof": "lib/utils/logger.js~Logger",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/logger.js~Logger#warn",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2137,
    "kind": "method",
    "name": "inspect",
    "memberof": "lib/utils/logger.js~Logger",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/logger.js~Logger#inspect",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2138,
    "kind": "method",
    "name": "debugContext",
    "memberof": "lib/utils/logger.js~Logger",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/logger.js~Logger#debugContext",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2139,
    "kind": "file",
    "name": "lib/utils/validator-extras.js",
    "content": "'use strict';\n\nconst _ = require('lodash');\nconst validator = _.cloneDeep(require('validator'));\nconst moment = require('moment');\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\n\n// instance based validators\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\n\n// extra validators\nvalidator.notNull = function(val) {\n  return val !== null && val !== undefined;\n};\n\n// https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\n// map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\nvalidator.isNull = validator.isEmpty;\n\n// isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\nvalidator.isDate = function(dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  }\n  // otherwise convert to ISO 8601 as moment prefers\n  // http://momentjs.com/docs/#/parsing/string/\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils/validator-extras.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2140,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/utils/validator-extras.js",
    "static": true,
    "longname": "lib/utils/validator-extras.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2141,
    "kind": "variable",
    "name": "validator",
    "memberof": "lib/utils/validator-extras.js",
    "static": true,
    "longname": "lib/utils/validator-extras.js~validator",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2142,
    "kind": "variable",
    "name": "moment",
    "memberof": "lib/utils/validator-extras.js",
    "static": true,
    "longname": "lib/utils/validator-extras.js~moment",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2143,
    "kind": "variable",
    "name": "extensions",
    "memberof": "lib/utils/validator-extras.js",
    "static": true,
    "longname": "lib/utils/validator-extras.js~extensions",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"extend\": function, \"notEmpty\": function, \"len\": function, \"isUrl\": function, \"isIPv6\": function, \"isIPv4\": function, \"notIn\": function, \"regex\": function, \"notRegex\": function, \"isDecimal\": function, \"min\": function, \"max\": function, \"not\": function, \"contains\": function, \"notContains\": function, \"is\": function}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2144,
    "kind": "function",
    "name": "isImmutable",
    "memberof": "lib/utils/validator-extras.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/validator-extras.js~isImmutable",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "validatorArgs",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "modelInstance",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2145,
    "kind": "function",
    "name": "notNull",
    "memberof": "lib/utils/validator-extras.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/validator-extras.js~notNull",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2146,
    "kind": "function",
    "name": "isDate",
    "memberof": "lib/utils/validator-extras.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/validator-extras.js~isDate",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils/validator-extras.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "dateString",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2147,
    "kind": "file",
    "name": "lib/utils.js",
    "content": "'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst Promise = require('./promise');\nconst operators = require('./operators');\nconst operatorsSet = new Set(_.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/classToInvokable').classToInvokable;\n\nexports.Promise = Promise;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (_.isPlainObject(value) || Array.isArray(value)) {\n    return _.clone(value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  return typeof value !== 'function';\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = (_, stack) => stack;\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\nexports.stack = stack;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {Object} value an Object\n * @returns {Object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {Object} obj\n * @returns {Array<Symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {Object} obj\n * @returns {Array<string|Symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {Object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {Object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {Object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = Object(object);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined ||\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n/**\n *\n * @param {Object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|Object} tableName\n *\n * @returns {Object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => typeof field === 'string' ? field : field.name || field.attribute\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\n",
    "static": true,
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/lib/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2148,
    "kind": "variable",
    "name": "DataTypes",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~DataTypes",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2149,
    "kind": "variable",
    "name": "SqlString",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~SqlString",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2150,
    "kind": "variable",
    "name": "_",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~_",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2151,
    "kind": "variable",
    "name": "uuidv1",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~uuidv1",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2152,
    "kind": "variable",
    "name": "uuidv4",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~uuidv4",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2153,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Promise",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2154,
    "kind": "variable",
    "name": "operators",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~operators",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2155,
    "kind": "variable",
    "name": "operatorsSet",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~operatorsSet",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2156,
    "kind": "variable",
    "name": "inflection",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~inflection",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2157,
    "kind": "function",
    "name": "useInflection",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~useInflection",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "_inflection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2158,
    "kind": "function",
    "name": "camelizeIf",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~camelizeIf",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2159,
    "kind": "function",
    "name": "underscoredIf",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~underscoredIf",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2160,
    "kind": "function",
    "name": "isPrimitive",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~isPrimitive",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2161,
    "kind": "function",
    "name": "mergeDefaults",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~mergeDefaults",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2162,
    "kind": "function",
    "name": "merge",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~merge",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2163,
    "kind": "function",
    "name": "spliceStr",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~spliceStr",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "types": [
          "*"
        ]
      },
      {
        "name": "count",
        "types": [
          "*"
        ]
      },
      {
        "name": "add",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2164,
    "kind": "function",
    "name": "camelize",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~camelize",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2165,
    "kind": "function",
    "name": "underscore",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~underscore",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2166,
    "kind": "function",
    "name": "singularize",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~singularize",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2167,
    "kind": "function",
    "name": "pluralize",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~pluralize",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2168,
    "kind": "function",
    "name": "format",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~format",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "arr",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2169,
    "kind": "function",
    "name": "formatNamedParameters",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~formatNamedParameters",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2170,
    "kind": "function",
    "name": "cloneDeep",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~cloneDeep",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 126,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "onlyPlain",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2171,
    "kind": "function",
    "name": "mapFinderOptions",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~mapFinderOptions",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2172,
    "kind": "function",
    "name": "mapOptionFieldNames",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~mapOptionFieldNames",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 162,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2173,
    "kind": "function",
    "name": "mapWhereFieldNames",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~mapWhereFieldNames",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "params": [
      {
        "name": "attributes",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2174,
    "kind": "function",
    "name": "mapValueFieldNames",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~mapValueFieldNames",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "params": [
      {
        "name": "dataValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "fields",
        "types": [
          "*"
        ]
      },
      {
        "name": "Model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2175,
    "kind": "function",
    "name": "isColString",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~isColString",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2176,
    "kind": "function",
    "name": "canTreatArrayAsAnd",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~canTreatArrayAsAnd",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [
      {
        "name": "arr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2177,
    "kind": "function",
    "name": "combineTableNames",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~combineTableNames",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "tableName1",
        "types": [
          "*"
        ]
      },
      {
        "name": "tableName2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2178,
    "kind": "function",
    "name": "toDefaultValue",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~toDefaultValue",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 251,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2179,
    "kind": "function",
    "name": "defaultValueSchemable",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~defaultValueSchemable",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Determine if the default value provided exists and can be described\nin a db schema using the DEFAULT directive.",
    "lineNumber": 283,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} yes / no."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Any default value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "yes / no."
    },
    "ignore": true
  },
  {
    "__docId__": 2180,
    "kind": "function",
    "name": "removeNullValuesFromHash",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~removeNullValuesFromHash",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "params": [
      {
        "name": "hash",
        "types": [
          "*"
        ]
      },
      {
        "name": "omitNull",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2181,
    "kind": "function",
    "name": "stack",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~stack",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 318,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2182,
    "kind": "variable",
    "name": "dialects",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~dialects",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2183,
    "kind": "function",
    "name": "now",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~now",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 331,
    "undocument": true,
    "params": [
      {
        "name": "dialect",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2184,
    "kind": "variable",
    "name": "TICK_CHAR",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~TICK_CHAR",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2185,
    "kind": "function",
    "name": "addTicks",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~addTicks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      },
      {
        "name": "tickChar",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2186,
    "kind": "function",
    "name": "removeTicks",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~removeTicks",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 352,
    "undocument": true,
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      },
      {
        "name": "tickChar",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2187,
    "kind": "function",
    "name": "flattenObjectDeep",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~flattenObjectDeep",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Receives a tree-like object and returns a plain object which depth is 1.\n\n- Input:\n\n {\n   name: 'John',\n   address: {\n     street: 'Fake St. 123',\n     coordinates: {\n       longitude: 55.6779627,\n       latitude: 12.5964313\n     }\n   }\n }\n\n- Output:\n\n {\n   name: 'John',\n   address.street: 'Fake St. 123',\n   address.coordinates.latitude: 55.6779627,\n   address.coordinates.longitude: 12.5964313\n }",
    "lineNumber": 387,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} a flattened object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "an Object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a flattened object"
    },
    "ignore": true
  },
  {
    "__docId__": 2188,
    "kind": "class",
    "name": "SequelizeMethod",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~SequelizeMethod",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Utility functions for representing SQL functions, and columns that should be escaped.\nPlease do not use these functions directly, use Sequelize.fn and Sequelize.col instead.",
    "lineNumber": 412,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2189,
    "kind": "class",
    "name": "Fn",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Fn",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2190,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Fn",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Fn#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 416,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2191,
    "kind": "member",
    "name": "fn",
    "memberof": "lib/utils.js~Fn",
    "static": false,
    "longname": "lib/utils.js~Fn#fn",
    "access": "public",
    "description": null,
    "lineNumber": 418,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2192,
    "kind": "member",
    "name": "args",
    "memberof": "lib/utils.js~Fn",
    "static": false,
    "longname": "lib/utils.js~Fn#args",
    "access": "public",
    "description": null,
    "lineNumber": 419,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2193,
    "kind": "method",
    "name": "clone",
    "memberof": "lib/utils.js~Fn",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Fn#clone",
    "access": "public",
    "description": null,
    "lineNumber": 421,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2194,
    "kind": "class",
    "name": "Col",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Col",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 427,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2195,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Col",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Col#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2196,
    "kind": "member",
    "name": "col",
    "memberof": "lib/utils.js~Col",
    "static": false,
    "longname": "lib/utils.js~Col#col",
    "access": "public",
    "description": null,
    "lineNumber": 433,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2197,
    "kind": "class",
    "name": "Cast",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Cast",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 438,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2198,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Cast",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Cast#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 439,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2199,
    "kind": "member",
    "name": "val",
    "memberof": "lib/utils.js~Cast",
    "static": false,
    "longname": "lib/utils.js~Cast#val",
    "access": "public",
    "description": null,
    "lineNumber": 441,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2200,
    "kind": "member",
    "name": "type",
    "memberof": "lib/utils.js~Cast",
    "static": false,
    "longname": "lib/utils.js~Cast#type",
    "access": "public",
    "description": null,
    "lineNumber": 442,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2201,
    "kind": "member",
    "name": "json",
    "memberof": "lib/utils.js~Cast",
    "static": false,
    "longname": "lib/utils.js~Cast#json",
    "access": "public",
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2202,
    "kind": "class",
    "name": "Literal",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Literal",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 448,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2203,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Literal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Literal#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 449,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2204,
    "kind": "member",
    "name": "val",
    "memberof": "lib/utils.js~Literal",
    "static": false,
    "longname": "lib/utils.js~Literal#val",
    "access": "public",
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2205,
    "kind": "class",
    "name": "Json",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Json",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2206,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Json",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Json#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 457,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2207,
    "kind": "member",
    "name": "conditions",
    "memberof": "lib/utils.js~Json",
    "static": false,
    "longname": "lib/utils.js~Json#conditions",
    "access": "public",
    "description": null,
    "lineNumber": 460,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2208,
    "kind": "member",
    "name": "path",
    "memberof": "lib/utils.js~Json",
    "static": false,
    "longname": "lib/utils.js~Json#path",
    "access": "public",
    "description": null,
    "lineNumber": 462,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2209,
    "kind": "member",
    "name": "value",
    "memberof": "lib/utils.js~Json",
    "static": false,
    "longname": "lib/utils.js~Json#value",
    "access": "public",
    "description": null,
    "lineNumber": 464,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2210,
    "kind": "class",
    "name": "Where",
    "memberof": "lib/utils.js",
    "static": true,
    "longname": "lib/utils.js~Where",
    "access": "public",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 471,
    "undocument": true,
    "interface": false,
    "extends": [
      "SequelizeMethod"
    ],
    "ignore": true
  },
  {
    "__docId__": 2211,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils.js~Where#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 2212,
    "kind": "member",
    "name": "attribute",
    "memberof": "lib/utils.js~Where",
    "static": false,
    "longname": "lib/utils.js~Where#attribute",
    "access": "public",
    "description": null,
    "lineNumber": 479,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2213,
    "kind": "member",
    "name": "comparator",
    "memberof": "lib/utils.js~Where",
    "static": false,
    "longname": "lib/utils.js~Where#comparator",
    "access": "public",
    "description": null,
    "lineNumber": 480,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2214,
    "kind": "member",
    "name": "logic",
    "memberof": "lib/utils.js~Where",
    "static": false,
    "longname": "lib/utils.js~Where#logic",
    "access": "public",
    "description": null,
    "lineNumber": 481,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2215,
    "kind": "function",
    "name": "getOperators",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~getOperators",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "getOperators",
    "lineNumber": 495,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Symbol>} All operators properties of obj"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Symbol>"
      ],
      "spread": false,
      "description": "All operators properties of obj"
    },
    "ignore": true
  },
  {
    "__docId__": 2216,
    "kind": "function",
    "name": "getComplexKeys",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~getComplexKeys",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "getComplexKeys",
    "lineNumber": 507,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string|Symbol>} All keys including operators"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string|Symbol>"
      ],
      "spread": false,
      "description": "All keys including operators"
    },
    "ignore": true
  },
  {
    "__docId__": 2217,
    "kind": "function",
    "name": "getComplexSize",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~getComplexSize",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "getComplexSize",
    "lineNumber": 519,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}      Length of object properties including operators if obj is array returns its length"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Length of object properties including operators if obj is array returns its length"
    },
    "ignore": true
  },
  {
    "__docId__": 2218,
    "kind": "function",
    "name": "isWhereEmpty",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~isWhereEmpty",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Returns true if a where clause is empty, even with Symbols",
    "lineNumber": 531,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2219,
    "kind": "function",
    "name": "generateEnumName",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~generateEnumName",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Returns ENUM name by joining table and column name",
    "lineNumber": 544,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "columnName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2220,
    "kind": "function",
    "name": "camelizeObjectKeys",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~camelizeObjectKeys",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Returns an new Object which keys are camelized",
    "lineNumber": 556,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2221,
    "kind": "function",
    "name": "defaults",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~defaults",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Assigns own and inherited enumerable string and symbol keyed properties of source\nobjects to the destination object.\n\nhttps://lodash.com/docs/4.17.4#defaults\n\n**Note:** This method mutates `object`.",
    "lineNumber": 578,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Returns `object`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "The destination object."
      },
      {
        "nullable": null,
        "types": [
          "...Object"
        ],
        "spread": true,
        "optional": true,
        "name": "sources",
        "description": "The source objects."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Returns `object`."
    },
    "ignore": true
  },
  {
    "__docId__": 2222,
    "kind": "function",
    "name": "nameIndex",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~nameIndex",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 613,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "index.fields",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "index.name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tableName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2223,
    "kind": "function",
    "name": "intersects",
    "memberof": "lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils.js~intersects",
    "access": "private",
    "export": false,
    "importPath": "sequelize/lib/utils.js",
    "importStyle": null,
    "description": "Checks if 2 arrays intersect.",
    "lineNumber": 634,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "arr1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "arr2",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# Sequelize\n\n[![npm version](https://badgen.net/npm/v/sequelize)](https://www.npmjs.com/package/sequelize)\n[![Travis Build Status](https://badgen.net/travis/sequelize/sequelize?icon=travis)](https://travis-ci.org/sequelize/sequelize)\n[![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/9l1ypgwsp5ij46m3/branch/master?svg=true)](https://ci.appveyor.com/project/sushantdhiman/sequelize/branch/master)\n[![npm downloads](https://badgen.net/npm/dm/sequelize)](https://www.npmjs.com/package/sequelize)\n[![codecov](https://badgen.net/codecov/c/github/sequelize/sequelize?icon=codecov)](https://codecov.io/gh/sequelize/sequelize)\n[![Last commit](https://badgen.net/github/last-commit/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![Merged PRs](https://badgen.net/github/merged-prs/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![GitHub stars](https://badgen.net/github/stars/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![Slack Status](https://img.shields.io/badge/Slack-4A154B?logo=slack&logoColor=white)](https://sequelize.org/slack)\n[![node](https://badgen.net/npm/node/sequelize)](https://www.npmjs.com/package/sequelize)\n[![License](https://badgen.net/github/license/sequelize/sequelize)](https://github.com/sequelize/sequelize/blob/master/LICENSE)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n\nSequelize is a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, eager and lazy loading, read replication and more.\n\nSequelize follows [SEMVER](http://semver.org). Supports Node v6 and above to use ES6 features.\n\nNew to Sequelize? Take a look at the [Tutorials and Guides](https://sequelize.org/master). You might also be interested in the [API Reference](https://sequelize.org/master/identifiers).\n\n## Table of Contents\n- [Installation](#installation)\n- [Documentation](#documentation)\n- [Responsible disclosure](#responsible-disclosure)\n- [Resources](#resources)\n\n## Installation\n\n```bash\n$ npm install --save sequelize # This will install v5\n\n# And one of the following:\n$ npm install --save pg pg-hstore # Postgres\n$ npm install --save mysql2\n$ npm install --save mariadb\n$ npm install --save sqlite3\n$ npm install --save tedious # Microsoft SQL Server\n```\n\n## Documentation\n- [v5 Documentation](https://sequelize.org/master)\n- [v4 Documentation](https://sequelize.org/v4)\n- [v3 Documentation](https://sequelize.org/v3)\n- [Contributing](https://github.com/sequelize/sequelize/blob/master/CONTRIBUTING.md)\n\n## Responsible disclosure\nIf you have security issues to report please refer to our [Responsible Disclosure Policy](./SECURITY.md) for more details.\n\n## Resources\n- [Changelog](https://github.com/sequelize/sequelize/releases)\n- [Slack](https://sequelize.org/slack)\n- [Stack Overflow](https://stackoverflow.com/questions/tagged/sequelize.js)\n\n### Tools\n- [Sequelize CLI](https://github.com/sequelize/cli)\n- [Sequelize & TypeScript](https://sequelize.org/master/manual/typescript.html)\n- [Enhanced TypeScript with decorators](https://github.com/RobinBuschmann/sequelize-typescript)\n- [Sequelize & GraphQL](https://github.com/mickhansen/graphql-sequelize)\n- [Add-ons & Plugins](https://sequelize.org/master/manual/resources.html)\n- [Sequelize & CockroachDB](https://github.com/cockroachdb/sequelize-cockroachdb)\n\n### Learning\n- [Getting Started](https://sequelize.org/master/manual/getting-started)\n- [Express Example](https://github.com/sequelize/express-example)\n\n### Translations\n- [English v3/v4/v5](https://sequelize.org) (OFFICIAL)\n- [ v4/v5](https://github.com/demopark/sequelize-docs-Zh-CN) (UNOFFICIAL)\n",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"sequelize\",\n  \"description\": \"Multi dialect ORM for Node.JS\",\n  \"version\": \"0.0.0-development\",\n  \"author\": \"Sascha Depold <sascha@depold.com>\",\n  \"contributors\": [\n    \"Sascha Depold <sascha@depold.com>\",\n    \"Jan Aagaard Meier <janzeh@gmail.com>\",\n    \"Daniel Durante <me@danieldurante.com>\",\n    \"Mick Hansen <mick.kasper.hansen@gmail.com>\",\n    \"Sushant Dhiman <sushantdhiman@outlook.com>\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sequelize/sequelize.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/sequelize/sequelize/issues\"\n  },\n  \"homepage\": \"https://sequelize.org/\",\n  \"main\": \"index.js\",\n  \"types\": \"types\",\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  },\n  \"files\": [\n    \"lib\",\n    \"types/index.d.ts\",\n    \"types/lib\"\n  ],\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"bluebird\": \"^3.5.0\",\n    \"cls-bluebird\": \"^2.1.0\",\n    \"debug\": \"^4.1.1\",\n    \"dottie\": \"^2.0.0\",\n    \"inflection\": \"1.12.0\",\n    \"lodash\": \"^4.17.15\",\n    \"moment\": \"^2.24.0\",\n    \"moment-timezone\": \"^0.5.21\",\n    \"retry-as-promised\": \"^3.2.0\",\n    \"semver\": \"^6.3.0\",\n    \"sequelize-pool\": \"^2.3.0\",\n    \"toposort-class\": \"^1.0.1\",\n    \"uuid\": \"^8.3.2\",\n    \"validator\": \"^13.7.0\",\n    \"wkx\": \"^0.4.8\"\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"^8.2.0\",\n    \"@commitlint/config-angular\": \"^8.2.0\",\n    \"@types/bluebird\": \"^3.5.26\",\n    \"@types/node\": \"^12.7.8\",\n    \"@types/validator\": \"^13.7.0\",\n    \"big-integer\": \"^1.6.45\",\n    \"chai\": \"^4.x\",\n    \"chai-as-promised\": \"^7.x\",\n    \"chai-datetime\": \"^1.x\",\n    \"chai-spies\": \"^1.x\",\n    \"continuation-local-storage\": \"^3.x\",\n    \"cross-env\": \"^5.2.1\",\n    \"env-cmd\": \"^8.0.2\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-inject-style-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^6.4.0\",\n    \"eslint-plugin-jsdoc\": \"^4.1.1\",\n    \"eslint-plugin-mocha\": \"^5.2.1\",\n    \"fs-jetpack\": \"^2.2.2\",\n    \"husky\": \"^1.3.1\",\n    \"js-combinatorics\": \"^0.5.4\",\n    \"lcov-result-merger\": \"^3.0.0\",\n    \"lint-staged\": \"^8.1.5\",\n    \"mariadb\": \"2.2.0\",\n    \"markdownlint-cli\": \"^0.18.0\",\n    \"mocha\": \"^6.1.4\",\n    \"mysql2\": \"^1.6.5\",\n    \"nyc\": \"^14.1.1\",\n    \"pg\": \"^7.8.1\",\n    \"pg-hstore\": \"^2.x\",\n    \"pg-types\": \"^2.0.0\",\n    \"rimraf\": \"^2.6.3\",\n    \"semantic-release\": \"^15.13.16\",\n    \"sinon\": \"^7.5.0\",\n    \"sinon-chai\": \"^3.3.0\",\n    \"sqlite3\": \"^4.0.6\",\n    \"tedious\": \"6.0.0\",\n    \"typescript\": \"^3.6.3\"\n  },\n  \"keywords\": [\n    \"mysql\",\n    \"mariadb\",\n    \"sqlite\",\n    \"postgresql\",\n    \"postgres\",\n    \"mssql\",\n    \"orm\",\n    \"nodejs\",\n    \"object relational mapper\"\n  ],\n  \"options\": {\n    \"env_cmd\": \"./test/config/.docker.env\"\n  },\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-angular\"\n    ]\n  },\n  \"lint-staged\": {\n    \"*.js\": \"eslint\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\",\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  },\n  \"release\": {\n    \"branch\": \"v5\",\n    \"verifyConditions\": [\n      \"@semantic-release/npm\",\n      \"@semantic-release/github\"\n    ]\n  },\n  \"publishConfig\": {\n    \"tag\": \"v5\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint lib test --quiet\",\n    \"lint-docs\": \"markdownlint docs\",\n    \"test\": \"npm run teaser && npm run test-unit && npm run test-integration\",\n    \"test-docker\": \"npm run test-docker-unit && npm run test-docker-integration\",\n    \"test-docker-unit\": \"npm run test-unit\",\n    \"test-docker-integration\": \"env-cmd $npm_package_options_env_cmd npm run test-integration\",\n    \"docs\": \"esdoc -c docs/esdoc-config.js && node docs/run-docs-transforms.js && cp docs/favicon.ico esdoc/favicon.ico && cp docs/ROUTER.txt esdoc/ROUTER\",\n    \"teaser\": \"node scripts/teaser\",\n    \"test-unit\": \"mocha --require scripts/mocha-bootload --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\\"test/unit/**/*.js\\\"\",\n    \"test-unit-mariadb\": \"cross-env DIALECT=mariadb npm run test-unit\",\n    \"test-unit-mysql\": \"cross-env DIALECT=mysql npm run test-unit\",\n    \"test-unit-postgres\": \"cross-env DIALECT=postgres npm run test-unit\",\n    \"test-unit-postgres-native\": \"cross-env DIALECT=postgres-native npm run test-unit\",\n    \"test-unit-sqlite\": \"cross-env DIALECT=sqlite npm run test-unit\",\n    \"test-unit-mssql\": \"cross-env DIALECT=mssql npm run test-unit\",\n    \"test-unit-all\": \"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite\",\n    \"test-integration\": \"mocha --require scripts/mocha-bootload --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\\"test/integration/**/*.test.js\\\"\",\n    \"test-integration-mariadb\": \"cross-env DIALECT=mariadb npm run test-integration\",\n    \"test-integration-mysql\": \"cross-env DIALECT=mysql npm run test-integration\",\n    \"test-integration-postgres\": \"cross-env DIALECT=postgres npm run test-integration\",\n    \"test-integration-postgres-native\": \"cross-env DIALECT=postgres-native npm run test-integration\",\n    \"test-integration-sqlite\": \"cross-env DIALECT=sqlite npm run test-integration\",\n    \"test-integration-mssql\": \"cross-env DIALECT=mssql npm run test-integration\",\n    \"test-integration-all\": \"npm run test-integration-mariadb && npm run test-integration-mysql && npm run test-integration-postgres && npm run test-integration-postgres-native && npm run test-integration-mssql && npm run test-integration-sqlite\",\n    \"test-mariadb\": \"cross-env DIALECT=mariadb npm test\",\n    \"test-mysql\": \"cross-env DIALECT=mysql npm test\",\n    \"test-sqlite\": \"cross-env DIALECT=sqlite npm test\",\n    \"test-postgres\": \"cross-env DIALECT=postgres npm test\",\n    \"test-pgsql\": \"npm run test-postgres\",\n    \"test-postgres-native\": \"cross-env DIALECT=postgres-native npm test\",\n    \"test-postgresn\": \"npm run test-postgres-native\",\n    \"test-mssql\": \"cross-env DIALECT=mssql npm test\",\n    \"test-all\": \"npm run test-mariadb && npm run test-mysql && npm run test-sqlite && npm run test-postgres && npm run test-postgres-native && npm run test-mssql\",\n    \"test-typings\": \"tsc -b types/tsconfig.json && tsc -b types/test/tsconfig.json\",\n    \"cover\": \"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage\",\n    \"cover-integration\": \"cross-env COVERAGE=true nyc --reporter=lcovonly mocha --require scripts/mocha-bootload -t 30000 --exit \\\"test/integration/**/*.test.js\\\" && node -e \\\"require('fs').renameSync('coverage/lcov.info', 'coverage/integration.info')\\\"\",\n    \"cover-unit\": \"cross-env COVERAGE=true nyc --reporter=lcovonly mocha --require scripts/mocha-bootload -t 30000 --exit \\\"test/unit/**/*.test.js\\\" && node -e \\\"require('fs').renameSync('coverage/lcov.info', 'coverage/unit.info')\\\"\",\n    \"merge-coverage\": \"lcov-result-merger \\\"coverage/*.info\\\" \\\"coverage/lcov.info\\\"\",\n    \"sscce\": \"env-cmd $npm_package_options_env_cmd node sscce.js\",\n    \"sscce-mariadb\": \"cross-env DIALECT=mariadb npm run sscce\",\n    \"sscce-mysql\": \"cross-env DIALECT=mysql npm run sscce\",\n    \"sscce-postgres\": \"cross-env DIALECT=postgres npm run sscce\",\n    \"sscce-sqlite\": \"cross-env DIALECT=sqlite npm run sscce\",\n    \"sscce-mssql\": \"cross-env DIALECT=mssql npm run sscce\",\n    \"setup-mssql\": \"env-cmd $npm_package_options_env_cmd ./scripts/setup-mssql\",\n    \"semantic-release\": \"semantic-release\"\n  }\n}\n",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "<div>\n  <div class=\"center logo\">\n    ![logo](manual/asset/logo-small.png)\n  </div>\n  <div class=\"center sequelize\">Sequelize</div>\n</div>\n\n[![npm version](https://badgen.net/npm/v/sequelize)](https://www.npmjs.com/package/sequelize)\n[![Travis Build Status](https://badgen.net/travis/sequelize/sequelize?icon=travis)](https://travis-ci.org/sequelize/sequelize)\n[![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/9l1ypgwsp5ij46m3/branch/master?svg=true)](https://ci.appveyor.com/project/sushantdhiman/sequelize/branch/master)\n[![npm downloads](https://badgen.net/npm/dm/sequelize)](https://www.npmjs.com/package/sequelize)\n[![codecov](https://badgen.net/codecov/c/github/sequelize/sequelize?icon=codecov)](https://codecov.io/gh/sequelize/sequelize)\n[![Last commit](https://badgen.net/github/last-commit/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![Merged PRs](https://badgen.net/github/merged-prs/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![GitHub stars](https://badgen.net/github/stars/sequelize/sequelize)](https://github.com/sequelize/sequelize)\n[![Slack Status](https://img.shields.io/badge/Slack-4A154B?logo=slack&logoColor=white)](https://sequelize.org/slack)\n[![node](https://badgen.net/npm/node/sequelize)](https://www.npmjs.com/package/sequelize)\n[![License](https://badgen.net/github/license/sequelize/sequelize)](https://github.com/sequelize/sequelize/blob/master/LICENSE)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n\nSequelize is a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, eager and lazy loading, read replication and more.\n\nSequelize follows [SEMVER](http://semver.org). Supports Node v6 and above to use ES6 features.\n\n**Sequelize v5** was released on March 13, 2019. [Official TypeScript typings are now included](manual/typescript).\n\nYou are currently looking at the **Tutorials and Guides** for Sequelize. You might also be interested in the [API Reference](identifiers).\n\n## Quick example\n\n```js\nconst { Sequelize, Model, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('sqlite::memory:');\n\nclass User extends Model {}\nUser.init({\n  username: DataTypes.STRING,\n  birthday: DataTypes.DATE\n}, { sequelize, modelName: 'user' });\n\nsequelize.sync()\n  .then(() => User.create({\n    username: 'janedoe',\n    birthday: new Date(1980, 6, 20)\n  }))\n  .then(jane => {\n    console.log(jane.toJSON());\n  });\n```\n\nTo learn more about how to use Sequelize, read the tutorials available in the left menu. Begin with [Getting Started](manual/getting-started).\n",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/index.md",
    "name": "./docs/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/images",
    "name": "./docs/images",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/getting-started.md",
    "name": "./docs/manual/getting-started.md",
    "content": "# Getting started\n\nIn this tutorial you will learn to make a simple setup of Sequelize to learn the basics.\n\n## Installing\n\nSequelize is available via [npm](https://www.npmjs.com/package/sequelize) (or [yarn](https://yarnpkg.com/package/sequelize)).\n\n```sh\nnpm install --save sequelize\n```\n\nYou'll also have to manually install the driver for your database of choice:\n\n```sh\n# One of the following:\n$ npm install --save pg pg-hstore # Postgres\n$ npm install --save mysql2\n$ npm install --save mariadb\n$ npm install --save sqlite3\n$ npm install --save tedious # Microsoft SQL Server\n```\n\n## Setting up a connection\n\nTo connect to the database, you must create a Sequelize instance. This can be done by either passing the connection parameters separately to the Sequelize constructor or by passing a single connection URI:\n\n```js\nconst Sequelize = require('sequelize');\n\n// Option 1: Passing parameters separately\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: /* one of 'mysql' | 'mariadb' | 'postgres' | 'mssql' */\n});\n\n// Option 2: Passing a connection URI\nconst sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname');\n```\n\nThe Sequelize constructor takes a whole slew of options that are documented in the [API Reference for the Sequelize constructor](../class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor).\n\n### Note: setting up SQLite\n\nIf you're using SQLite, you should use the following instead:\n\n```js\nconst sequelize = new Sequelize({\n  dialect: 'sqlite',\n  storage: 'path/to/database.sqlite'\n});\n```\n\n### Note: connection pool (production)\n\nIf you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's `options` parameter (using `options.pool`), as is shown in the following example:\n\n```js\nconst sequelize = new Sequelize(/* ... */, {\n  // ...\n  pool: {\n    max: 5,\n    min: 0,\n    acquire: 30000,\n    idle: 10000\n  }\n});\n```\n\nLearn more in the [API Reference for the Sequelize constructor](../class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor). If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.\n\n### Testing the connection\n\nYou can use the `.authenticate()` function to test if the connection is OK:\n\n```js\nsequelize\n  .authenticate()\n  .then(() => {\n    console.log('Connection has been established successfully.');\n  })\n  .catch(err => {\n    console.error('Unable to connect to the database:', err);\n  });\n```\n\n### Closing the connection\n\nSequelize will keep the connection open by default, and use the same connection for all queries. If you need to close the connection, call `sequelize.close()` (which is asynchronous and returns a Promise).\n\n## Modeling a table\n\nA model is a class that extends `Sequelize.Model`. Models can be defined in two equivalent ways. The first, with `Sequelize.Model.init(attributes, options)`:\n\n```js\nconst Model = Sequelize.Model;\nclass User extends Model {}\nUser.init({\n  // attributes\n  firstName: {\n    type: Sequelize.STRING,\n    allowNull: false\n  },\n  lastName: {\n    type: Sequelize.STRING\n    // allowNull defaults to true\n  }\n}, {\n  sequelize,\n  modelName: 'user'\n  // options\n});\n```\n\nAlternatively, using `sequelize.define`:\n\n```js\nconst User = sequelize.define('user', {\n  // attributes\n  firstName: {\n    type: Sequelize.STRING,\n    allowNull: false\n  },\n  lastName: {\n    type: Sequelize.STRING\n    // allowNull defaults to true\n  }\n}, {\n  // options\n});\n```\n\nInternally, `sequelize.define` calls `Model.init`.\n\nThe above code tells Sequelize to expect a table named `users` in the database with the fields `firstName` and `lastName`. The table name is automatically pluralized by default (a library called [inflection](https://www.npmjs.com/package/inflection) is used under the hood to do this). This behavior can be stopped for a specific model by using the `freezeTableName: true` option, or for all models by using the `define` option from the [Sequelize constructor](../class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor).\n\nSequelize also defines by default the fields `id` (primary key), `createdAt` and `updatedAt` to every model. This behavior can also be changed, of course (check the API Reference to learn more about the available options).\n\n### Changing the default model options\n\nThe Sequelize constructor takes a `define` option which will change the default options for all defined models.\n\n```js\nconst sequelize = new Sequelize(connectionURI, {\n  define: {\n    // The `timestamps` field specify whether or not the `createdAt` and `updatedAt` fields will be created.\n    // This was true by default, but now is false by default\n    timestamps: false\n  }\n});\n\n// Here `timestamps` will be false, so the `createdAt` and `updatedAt` fields will not be created.\nclass Foo extends Model {}\nFoo.init({ /* ... */ }, { sequelize });\n\n// Here `timestamps` is directly set to true, so the `createdAt` and `updatedAt` fields will be created.\nclass Bar extends Model {}\nBar.init({ /* ... */ }, { sequelize, timestamps: true });\n```\n\nYou can read more about creating models in the [Model.init API Reference](../class/lib/model.js~Model.html#static-method-init), or in the [sequelize.define API reference](../class/lib/sequelize.js~Sequelize.html#instance-method-define).\n\n## Synchronizing the model with the database\n\nIf you want Sequelize to automatically create the table (or modify it as needed) according to your model definition, you can use the `sync` method, as follows:\n\n```js\n// Note: using `force: true` will drop the table if it already exists\nUser.sync({ force: true }).then(() => {\n  // Now the `users` table in the database corresponds to the model definition\n  return User.create({\n    firstName: 'John',\n    lastName: 'Hancock'\n  });\n});\n```\n\n### Synchronizing all models at once\n\nInstead of calling `sync()` for every model, you can call `sequelize.sync()` which will automatically sync all models.\n\n### Note for production\n\nIn production, you might want to consider using Migrations instead of calling `sync()` in your code. Learn more in the [Migrations](migrations.html) guide.\n\n## Querying\n\nA few simple queries are shown below:\n\n```js\n// Find all users\nUser.findAll().then(users => {\n  console.log(\"All users:\", JSON.stringify(users, null, 4));\n});\n\n// Create a new user\nUser.create({ firstName: \"Jane\", lastName: \"Doe\" }).then(jane => {\n  console.log(\"Jane's auto-generated ID:\", jane.id);\n});\n\n// Delete everyone named \"Jane\"\nUser.destroy({\n  where: {\n    firstName: \"Jane\"\n  }\n}).then(() => {\n  console.log(\"Done\");\n});\n\n// Change everyone without a last name to \"Doe\"\nUser.update({ lastName: \"Doe\" }, {\n  where: {\n    lastName: null\n  }\n}).then(() => {\n  console.log(\"Done\");\n});\n```\n\nSequelize has a lot of options for querying. You will learn more about those in the next tutorials. It is also possible to make raw SQL queries, if you really need them.\n\n## Promises and async/await\n\nAs shown above by the extensive usage of `.then` calls, Sequelize uses Promises extensively. This means that, if your Node version supports it, you can use ES2017 `async/await` syntax for all asynchronous calls made with Sequelize.\n\nAlso, all Sequelize promises are in fact [Bluebird](http://bluebirdjs.com) promises, so you have the rich Bluebird API to use as well (for example, using `finally`, `tap`, `tapCatch`, `map`, `mapSeries`, etc). You can access the Bluebird constructor used internally by Sequelize with `Sequelize.Promise`, if you want to set any Bluebird specific options.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/dialects.md",
    "name": "./docs/manual/dialects.md",
    "content": "# Dialects\n\nSequelize is independent from specific dialects. This means that you'll have to install the respective connector library to your project yourself.\n\n## MySQL\n\nIn order to get Sequelize working nicely together with MySQL, you'll need to install`mysql2@^1.5.2`or higher. Once that's done you can use it like this:\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  dialect: 'mysql'\n})\n```\n\n**Note:** You can pass options directly to dialect library by setting the\n`dialectOptions` parameter.\n\n## MariaDB\n\nLibrary for MariaDB is `mariadb`.\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  dialect: 'mariadb',\n  dialectOptions: {connectTimeout: 1000} // mariadb connector option\n})\n```\n\nor using connection String:\n\n```js\nconst sequelize = new Sequelize('mariadb://user:password@example.com:9821/database')\n```\n\n## SQLite\n\nFor SQLite compatibility you'll need`sqlite3@^4.0.0`. Configure Sequelize like this:\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  // sqlite! now!\n  dialect: 'sqlite',\n\n  // the storage engine for sqlite\n  // - default ':memory:'\n  storage: 'path/to/database.sqlite'\n})\n```\n\nOr you can use a connection string as well with a path:\n\n```js\nconst sequelize = new Sequelize('sqlite:/home/abs/path/dbname.db')\nconst sequelize = new Sequelize('sqlite:relativePath/dbname.db')\n```\n\n## PostgreSQL\n\nFor PostgreSQL, two libraries are needed, `pg@^7.0.0` and `pg-hstore`. You'll just need to define the dialect:\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  // gimme postgres, please!\n  dialect: 'postgres'\n})\n```\n\nTo connect over a unix domain socket, specify the path to the socket directory\nin the `host` option.\n\nThe socket path must start with `/`.\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  // gimme postgres, please!\n  dialect: 'postgres',\n  host: '/path/to/socket_directory'\n})\n```\n\n## MSSQL\n\nThe library for MSSQL is`tedious@^6.0.0` You'll just need to define the dialect.\nPlease note: `tedious@^6.0.0` requires you to nest MSSQL specific options inside an additional `options`-object inside the `dialectOptions`-object.\n\n```js\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  dialect: 'mssql',\n  dialectOptions: {\n    options: {\n      useUTC: false,\n      dateFirst: 1,\n    }\n  }\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/data-types.md",
    "name": "./docs/manual/data-types.md",
    "content": "# Datatypes\n\nBelow are some of the datatypes supported by sequelize. For a full and updated list, see [DataTypes](/master/variable/index.html#static-variable-DataTypes).\n\n```js\nSequelize.STRING                      // VARCHAR(255)\nSequelize.STRING(1234)                // VARCHAR(1234)\nSequelize.STRING.BINARY               // VARCHAR BINARY\nSequelize.TEXT                        // TEXT\nSequelize.TEXT('tiny')                // TINYTEXT\nSequelize.CITEXT                      // CITEXT      PostgreSQL and SQLite only.\n\nSequelize.INTEGER                     // INTEGER\nSequelize.BIGINT                      // BIGINT\nSequelize.BIGINT(11)                  // BIGINT(11)\n\nSequelize.FLOAT                       // FLOAT\nSequelize.FLOAT(11)                   // FLOAT(11)\nSequelize.FLOAT(11, 10)               // FLOAT(11,10)\n\nSequelize.REAL                        // REAL        PostgreSQL only.\nSequelize.REAL(11)                    // REAL(11)    PostgreSQL only.\nSequelize.REAL(11, 12)                // REAL(11,12) PostgreSQL only.\n\nSequelize.DOUBLE                      // DOUBLE\nSequelize.DOUBLE(11)                  // DOUBLE(11)\nSequelize.DOUBLE(11, 10)              // DOUBLE(11,10)\n\nSequelize.DECIMAL                     // DECIMAL\nSequelize.DECIMAL(10, 2)              // DECIMAL(10,2)\n\nSequelize.DATE                        // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres\nSequelize.DATE(6)                     // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision\nSequelize.DATEONLY                    // DATE without time.\nSequelize.BOOLEAN                     // TINYINT(1)\n\nSequelize.ENUM('value 1', 'value 2')  // An ENUM with allowed values 'value 1' and 'value 2'\nSequelize.ARRAY(Sequelize.TEXT)       // Defines an array. PostgreSQL only.\nSequelize.ARRAY(Sequelize.ENUM)       // Defines an array of ENUM. PostgreSQL only.\n\nSequelize.JSON                        // JSON column. PostgreSQL, SQLite and MySQL only.\nSequelize.JSONB                       // JSONB column. PostgreSQL only.\n\nSequelize.BLOB                        // BLOB (bytea for PostgreSQL)\nSequelize.BLOB('tiny')                // TINYBLOB (bytea for PostgreSQL. Other options are medium and long)\n\nSequelize.UUID                        // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically)\n\nSequelize.CIDR                        // CIDR datatype for PostgreSQL\nSequelize.INET                        // INET datatype for PostgreSQL\nSequelize.MACADDR                     // MACADDR datatype for PostgreSQL\n\nSequelize.RANGE(Sequelize.INTEGER)    // Defines int4range range. PostgreSQL only.\nSequelize.RANGE(Sequelize.BIGINT)     // Defined int8range range. PostgreSQL only.\nSequelize.RANGE(Sequelize.DATE)       // Defines tstzrange range. PostgreSQL only.\nSequelize.RANGE(Sequelize.DATEONLY)   // Defines daterange range. PostgreSQL only.\nSequelize.RANGE(Sequelize.DECIMAL)    // Defines numrange range. PostgreSQL only.\n\nSequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only.\n\nSequelize.GEOMETRY                    // Spatial column.  PostgreSQL (with PostGIS) or MySQL only.\nSequelize.GEOMETRY('POINT')           // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only.\nSequelize.GEOMETRY('POINT', 4326)     // Spatial column with geometry type and SRID.  PostgreSQL (with PostGIS) or MySQL only.\n```\n\nThe BLOB datatype allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer.\n\nIf you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser:\n\n```js\nrequire('pg').types.setTypeParser(1114, stringValue => {\n  return new Date(stringValue + '+0000');\n  // e.g., UTC offset. Use any offset that you would like.\n});\n```\n\nIn addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order:\nBe aware that this does not apply for PostgreSQL!\n\n```js\nSequelize.INTEGER.UNSIGNED              // INTEGER UNSIGNED\nSequelize.INTEGER(11).UNSIGNED          // INTEGER(11) UNSIGNED\nSequelize.INTEGER(11).ZEROFILL          // INTEGER(11) ZEROFILL\nSequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL\nSequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL\n```\n\n_The examples above only show integer, but the same can be done with bigint and float_\n\nUsage in object notation:\n\n```js\n// for enums:\nclass MyModel extends Model {}\nMyModel.init({\n  states: {\n    type: Sequelize.ENUM,\n    values: ['active', 'pending', 'deleted']\n  }\n}, { sequelize })\n```\n\n### Array(ENUM)\n\nIts only supported with PostgreSQL.\n\nArray(Enum) type require special treatment. Whenever Sequelize will talk to database it has to typecast Array values with ENUM name.\n\nSo this enum name must follow this pattern `enum_<table_name>_<col_name>`. If you are using `sync` then correct name will automatically be generated.\n\n### Range types\n\nSince range types have extra information for their bound inclusion/exclusion it's not\nvery straightforward to just use a tuple to represent them in javascript.\n\nWhen supplying ranges as values you can choose from the following APIs:\n\n```js\n// defaults to '[\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\")'\n// inclusive lower bound, exclusive upper bound\nTimeline.create({ range: [new Date(Date.UTC(2016, 0, 1)), new Date(Date.UTC(2016, 1, 1))] });\n\n// control inclusion\nconst range = [\n  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },\n  { value: new Date(Date.UTC(2016, 1, 1)), inclusive: true },\n];\n// '(\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\"]'\n\n// composite form\nconst range = [\n  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },\n  new Date(Date.UTC(2016, 1, 1)),\n];\n// '(\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\")'\n\nTimeline.create({ range });\n```\n\nHowever, please note that whenever you get back a value that is range you will\nreceive:\n\n```js\n// stored value: (\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\"]\nrange // [{ value: Date, inclusive: false }, { value: Date, inclusive: true }]\n```\n\nYou will need to call reload after updating an instance with a range type or use `returning: true` option.\n\n#### Special Cases\n\n```js\n// empty range:\nTimeline.create({ range: [] }); // range = 'empty'\n\n// Unbounded range:\nTimeline.create({ range: [null, null] }); // range = '[,)'\n// range = '[,\"2016-01-01 00:00:00+00:00\")'\nTimeline.create({ range: [null, new Date(Date.UTC(2016, 0, 1))] });\n\n// Infinite range:\n// range = '[-infinity,\"2016-01-01 00:00:00+00:00\")'\nTimeline.create({ range: [-Infinity, new Date(Date.UTC(2016, 0, 1))] });\n```\n\n## Extending datatypes\n\nMost likely the type you are trying to implement is already included in [DataTypes](data-types.html). If a new datatype is not included, this manual will show how to write it yourself.\n\nSequelize doesn't create new datatypes in the database. This tutorial explains how to make Sequelize recognize new datatypes and assumes that those new datatypes are already created in the database.\n\nTo extend Sequelize datatypes, do it before any instance is created. This example creates a dummy `NEWTYPE` that replicates the built-in datatype `Sequelize.INTEGER(11).ZEROFILL.UNSIGNED`.\n\n```js\n// myproject/lib/sequelize.js\n\nconst Sequelize = require('Sequelize');\nconst sequelizeConfig = require('../config/sequelize')\nconst sequelizeAdditions = require('./sequelize-additions')\n\n// Function that adds new datatypes\nsequelizeAdditions(Sequelize)\n\n// In this exmaple a Sequelize instance is created and exported\nconst sequelize = new Sequelize(sequelizeConfig)\n\nmodule.exports = sequelize\n```\n\n```js\n// myproject/lib/sequelize-additions.js\n\nmodule.exports = function sequelizeAdditions(Sequelize) {\n\n  DataTypes = Sequelize.DataTypes\n\n  /*\n   * Create new types\n   */\n  class NEWTYPE extends DataTypes.ABSTRACT {\n    // Mandatory, complete definition of the new type in the database\n    toSql() {\n      return 'INTEGER(11) UNSIGNED ZEROFILL'\n    }\n\n    // Optional, validator function\n    validate(value, options) {\n      return (typeof value === 'number') && (! Number.isNaN(value))\n    }\n\n    // Optional, sanitizer\n    _sanitize(value) {\n      // Force all numbers to be positive\n      if (value < 0) {\n        value = 0\n      }\n\n      return Math.round(value)\n    }\n\n    // Optional, value stringifier before sending to database\n    _stringify(value) {\n      return value.toString()\n    }\n\n    // Optional, parser for values received from the database\n    static parse(value) {\n      return Number.parseInt(value)\n    }\n  }\n\n  DataTypes.NEWTYPE = NEWTYPE;\n\n  // Mandatory, set key\n  DataTypes.NEWTYPE.prototype.key = DataTypes.NEWTYPE.key = 'NEWTYPE'\n\n  // Optional, disable escaping after stringifier. Not recommended.\n  // Warning: disables Sequelize protection against SQL injections\n  // DataTypes.NEWTYPE.escape = false\n\n  // For convenience\n  // `classToInvokable` allows you to use the datatype without `new`\n  Sequelize.NEWTYPE = Sequelize.Utils.classToInvokable(DataTypes.NEWTYPE)\n\n}\n```\n\nAfter creating this new datatype, you need to map this datatype in each database dialect and make some adjustments.\n\n## PostgreSQL\n\nLet's say the name of the new datatype is `pg_new_type` in the postgres database. That name has to be mapped to `DataTypes.NEWTYPE`. Additionally, it is required to create a child postgres-specific datatype.\n\n```js\n// myproject/lib/sequelize-additions.js\n\nmodule.exports = function sequelizeAdditions(Sequelize) {\n\n  DataTypes = Sequelize.DataTypes\n\n  /*\n   * Create new types\n   */\n\n  ...\n\n  /*\n   * Map new types\n   */\n\n  // Mandatory, map postgres datatype name\n  DataTypes.NEWTYPE.types.postgres = ['pg_new_type']\n\n  // Mandatory, create a postgres-specific child datatype with its own parse\n  // method. The parser will be dynamically mapped to the OID of pg_new_type.\n  PgTypes = DataTypes.postgres\n\n  PgTypes.NEWTYPE = function NEWTYPE() {\n    if (!(this instanceof PgTypes.NEWTYPE)) return new PgTypes.NEWTYPE();\n    DataTypes.NEWTYPE.apply(this, arguments);\n  }\n  inherits(PgTypes.NEWTYPE, DataTypes.NEWTYPE);\n\n  // Mandatory, create, override or reassign a postgres-specific parser\n  //PgTypes.NEWTYPE.parse = value => value;\n  PgTypes.NEWTYPE.parse = DataTypes.NEWTYPE.parse;\n\n  // Optional, add or override methods of the postgres-specific datatype\n  // like toSql, escape, validate, _stringify, _sanitize...\n\n}\n```\n\n### Ranges\n\nAfter a new range type has been [defined in postgres](https://www.postgresql.org/docs/current/static/rangetypes.html#RANGETYPES-DEFINING), it is trivial to add it to Sequelize.\n\nIn this example the name of the postgres range type is `newtype_range` and the name of the underlying postgres datatype is `pg_new_type`. The key of `subtypes` and `castTypes` is the key of the Sequelize datatype `DataTypes.NEWTYPE.key`, in lower case.\n\n```js\n// myproject/lib/sequelize-additions.js\n\nmodule.exports = function sequelizeAdditions(Sequelize) {\n\n  DataTypes = Sequelize.DataTypes\n\n  /*\n   * Create new types\n   */\n\n  ...\n\n  /*\n   * Map new types\n   */\n\n  ...\n\n  /*\n   * Add suport for ranges\n   */\n\n  // Add postgresql range, newtype comes from DataType.NEWTYPE.key in lower case\n  DataTypes.RANGE.types.postgres.subtypes.newtype = 'newtype_range';\n  DataTypes.RANGE.types.postgres.castTypes.newtype = 'pg_new_type';\n\n}\n```\n\nThe new range can be used in model definitions as `Sequelize.RANGE(Sequelize.NEWTYPE)` or `DataTypes.RANGE(DataTypes.NEWTYPE)`.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/models-definition.md",
    "name": "./docs/manual/models-definition.md",
    "content": "# Model definition\n\nTo define mappings between a model and a table, use the `define` method. Each column must have a datatype, see more about [datatypes][1].\n\n```js\nclass Project extends Model {}\nProject.init({\n  title: Sequelize.STRING,\n  description: Sequelize.TEXT\n}, { sequelize, modelName: 'project' });\n\nclass Task extends Model {}\nTask.init({\n  title: Sequelize.STRING,\n  description: Sequelize.TEXT,\n  deadline: Sequelize.DATE\n}, { sequelize, modelName: 'task' })\n```\n\nApart from [datatypes][1], there are plenty of options that you can set on each column.\n\n```js\nclass Foo extends Model {}\nFoo.init({\n // instantiating will automatically set the flag to true if not set\n flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true },\n\n // default values for dates => current time\n myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW },\n\n // setting allowNull to false will add NOT NULL to the column, which means an error will be\n // thrown from the DB when the query is executed if the column is null. If you want to check that a value\n // is not null before querying the DB, look at the validations section below.\n title: { type: Sequelize.STRING, allowNull: false },\n\n // Creating two objects with the same value will throw an error. The unique property can be either a\n // boolean, or a string. If you provide the same string for multiple columns, they will form a\n // composite unique key.\n uniqueOne: { type: Sequelize.STRING,  unique: 'compositeIndex' },\n uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex' },\n\n // The unique property is simply a shorthand to create a unique constraint.\n someUnique: { type: Sequelize.STRING, unique: true },\n\n // It's exactly the same as creating the index in the model's options.\n { someUnique: { type: Sequelize.STRING } },\n { indexes: [ { unique: true, fields: [ 'someUnique' ] } ] },\n\n // Go on reading for further information about primary keys\n identifier: { type: Sequelize.STRING, primaryKey: true },\n\n // autoIncrement can be used to create auto_incrementing integer columns\n incrementMe: { type: Sequelize.INTEGER, autoIncrement: true },\n\n // You can specify a custom column name via the 'field' attribute:\n fieldWithUnderscores: { type: Sequelize.STRING, field: 'field_with_underscores' },\n\n // It is possible to create foreign keys:\n bar_id: {\n   type: Sequelize.INTEGER,\n\n   references: {\n     // This is a reference to another model\n     model: Bar,\n\n     // This is the column name of the referenced model\n     key: 'id',\n\n     // This declares when to check the foreign key constraint. PostgreSQL only.\n     deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE\n   }\n },\n\n // It is possible to add comments on columns for MySQL, PostgreSQL and MSSQL only\n commentMe: {\n   type: Sequelize.INTEGER,\n\n   comment: 'This is a column name that has a comment'\n }\n}, {\n  sequelize,\n  modelName: 'foo'\n});\n```\n\nThe comment option can also be used on a table, see [model configuration][0].\n\n## Timestamps\n\nBy default, Sequelize will add the attributes `createdAt` and `updatedAt` to your model so you will be able to know when the database entry went into the db and when it was updated last.\n\nNote that if you are using Sequelize migrations you will need to add the `createdAt` and `updatedAt` fields to your migration definition:\n\n```js\nmodule.exports = {\n  up(queryInterface, Sequelize) {\n    return queryInterface.createTable('my-table', {\n      id: {\n        type: Sequelize.INTEGER,\n        primaryKey: true,\n        autoIncrement: true,\n      },\n\n      // Timestamps\n      createdAt: Sequelize.DATE,\n      updatedAt: Sequelize.DATE,\n    })\n  },\n  down(queryInterface, Sequelize) {\n    return queryInterface.dropTable('my-table');\n  },\n}\n\n```\n\nIf you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to [configuration][0] to see how to do that.\n\n## Deferrable\n\nWhen you specify a foreign key column it is optionally possible to declare the deferrable\ntype in PostgreSQL. The following options are available:\n\n```js\n// Defer all foreign key constraint check to the end of a transaction\nSequelize.Deferrable.INITIALLY_DEFERRED\n\n// Immediately check the foreign key constraints\nSequelize.Deferrable.INITIALLY_IMMEDIATE\n\n// Don't defer the checks at all\nSequelize.Deferrable.NOT\n```\n\nThe last option is the default in PostgreSQL and won't allow you to dynamically change\nthe rule in a transaction. See [the transaction section](transactions.html#options) for further information.\n\n## Getters & setters\n\nIt is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.\n\nGetters and Setters can be defined in 2 ways (you can mix and match these 2 approaches):\n\n* as part of a single property definition\n* as part of a model options\n\n**N.B:** If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence.\n\n### Defining as part of a property\n\n```js\nclass Employee extends Model {}\nEmployee.init({\n  name: {\n    type: Sequelize.STRING,\n    allowNull: false,\n    get() {\n      const title = this.getDataValue('title');\n      // 'this' allows you to access attributes of the instance\n      return this.getDataValue('name') + ' (' + title + ')';\n    },\n  },\n  title: {\n    type: Sequelize.STRING,\n    allowNull: false,\n    set(val) {\n      this.setDataValue('title', val.toUpperCase());\n    }\n  }\n}, { sequelize, modelName: 'employee' });\n\nEmployee\n  .create({ name: 'John Doe', title: 'senior engineer' })\n  .then(employee => {\n    console.log(employee.get('name')); // John Doe (SENIOR ENGINEER)\n    console.log(employee.get('title')); // SENIOR ENGINEER\n  })\n```\n\n### Defining as part of the model options\n\nBelow is an example of defining the getters and setters in the model options.\n\nThe `fullName` getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the [`VIRTUAL` datatype](/variable/index.html#static-variable-DataTypes). Virtual datatypes can have validations, while getters for virtual attributes cannot.\n\nNote that the `this.firstname` and `this.lastname` references in the `fullName` getter function will trigger a call to the respective getter functions. If you do not want that then use the `getDataValue()` method to access the raw value (see below).\n\n```js\nclass Foo extends Model {\n  get fullName() {\n    return this.firstname + ' ' + this.lastname;\n  }\n\n  set fullName(value) {\n    const names = value.split(' ');\n    this.setDataValue('firstname', names.slice(0, -1).join(' '));\n    this.setDataValue('lastname', names.slice(-1).join(' '));\n  }\n}\nFoo.init({\n  firstname: Sequelize.STRING,\n  lastname: Sequelize.STRING\n}, {\n  sequelize,\n  modelName: 'foo'\n});\n\n// Or with `sequelize.define`\nsequelize.define('Foo', {\n  firstname: Sequelize.STRING,\n  lastname: Sequelize.STRING\n}, {\n  getterMethods: {\n    fullName() {\n      return this.firstname + ' ' + this.lastname;\n    }\n  },\n\n  setterMethods: {\n    fullName(value) {\n      const names = value.split(' ');\n\n      this.setDataValue('firstname', names.slice(0, -1).join(' '));\n      this.setDataValue('lastname', names.slice(-1).join(' '));\n    }\n  }\n});\n```\n\n### Helper functions for use inside getter and setter definitions\n\n* retrieving an underlying property value - always use `this.getDataValue()`\n\n```js\n/* a getter for 'title' property */\nget() {\n  return this.getDataValue('title')\n}\n```\n\n* setting an underlying property value - always use `this.setDataValue()`\n\n```js\n/* a setter for 'title' property */\nset(title) {\n  this.setDataValue('title', title.toString().toLowerCase());\n}\n```\n\n**N.B:** It is important to stick to using the `setDataValue()` and `getDataValue()` functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations.\n\n## Validations\n\nModel validations allow you to specify format/content/inheritance validations for each attribute of the model.\n\nValidations are automatically run on `create`, `update` and `save`. You can also call `validate()` to manually validate an instance.\n\n### Per-attribute validations\n\nYou can define your custom validators or use several built-in validators, implemented by [validator.js][3], as shown below.\n\n```js\nclass ValidateMe extends Model {}\nValidateMe.init({\n  bar: {\n    type: Sequelize.STRING,\n    validate: {\n      is: [\"^[a-z]+$\",'i'],     // will only allow letters\n      is: /^[a-z]+$/i,          // same as the previous example using real RegExp\n      not: [\"[a-z]\",'i'],       // will not allow letters\n      isEmail: true,            // checks for email format (foo@bar.com)\n      isUrl: true,              // checks for url format (http://foo.com)\n      isIP: true,               // checks for IPv4 (129.89.23.1) or IPv6 format\n      isIPv4: true,             // checks for IPv4 (129.89.23.1)\n      isIPv6: true,             // checks for IPv6 format\n      isAlpha: true,            // will only allow letters\n      isAlphanumeric: true,     // will only allow alphanumeric characters, so \"_abc\" will fail\n      isNumeric: true,          // will only allow numbers\n      isInt: true,              // checks for valid integers\n      isFloat: true,            // checks for valid floating point numbers\n      isDecimal: true,          // checks for any numbers\n      isLowercase: true,        // checks for lowercase\n      isUppercase: true,        // checks for uppercase\n      notNull: true,            // won't allow null\n      isNull: true,             // only allows null\n      notEmpty: true,           // don't allow empty strings\n      equals: 'specific value', // only allow a specific value\n      contains: 'foo',          // force specific substrings\n      notIn: [['foo', 'bar']],  // check the value is not one of these\n      isIn: [['foo', 'bar']],   // check the value is one of these\n      notContains: 'bar',       // don't allow specific substrings\n      len: [2,10],              // only allow values with length between 2 and 10\n      isUUID: 4,                // only allow uuids\n      isDate: true,             // only allow date strings\n      isAfter: \"2011-11-05\",    // only allow date strings after a specific date\n      isBefore: \"2011-11-05\",   // only allow date strings before a specific date\n      max: 23,                  // only allow values <= 23\n      min: 23,                  // only allow values >= 23\n      isCreditCard: true,       // check for valid credit card numbers\n\n      // Examples of custom validators:\n      isEven(value) {\n        if (parseInt(value) % 2 !== 0) {\n          throw new Error('Only even values are allowed!');\n        }\n      }\n      isGreaterThanOtherField(value) {\n        if (parseInt(value) <= parseInt(this.otherField)) {\n          throw new Error('Bar must be greater than otherField.');\n        }\n      }\n    }\n  }\n}, { sequelize });\n```\n\nNote that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for `isIn`, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as `[['one', 'two']]` as shown above.\n\nTo use a custom error message instead of that provided by [validator.js][3], use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with\n\n```js\nisInt: {\n  msg: \"Must be an integer number of pennies\"\n}\n```\n\nor if arguments need to also be passed add an `args` property:\n\n```js\nisIn: {\n  args: [['en', 'zh']],\n  msg: \"Must be English or Chinese\"\n}\n```\n\nWhen using custom validator functions the error message will be whatever message the thrown `Error` object holds.\n\nSee [the validator.js project][3] for more details on the built in validation methods.\n\n**Hint:** You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.\n\n### Per-attribute validators and `allowNull`\n\nIf a particular field of a model is set to not allow null (with `allowNull: false`) and that value has been set to `null`, all validators will be skipped and a `ValidationError` will be thrown.\n\nOn the other hand, if it is set to allow null (with `allowNull: true`) and that value has been set to `null`, only the built-in validators will be skipped, while the custom validators will still run.\n\nThis means you can, for instance, have a string field which validates its length to be between 5 and 10 characters, but which also allows `null` (since the length validator will be skipped automatically when the value is `null`):\n\n```js\nclass User extends Model {}\nUser.init({\n  username: {\n    type: Sequelize.STRING,\n    allowNull: true,\n    validate: {\n      len: [5, 10]\n    }\n  }\n}, { sequelize });\n```\n\nYou also can conditionally allow `null` values, with a custom validator, since it won't be skipped:\n\n```js\nclass User extends Model {}\nUser.init({\n  age: Sequelize.INTEGER,\n  name: {\n    type: Sequelize.STRING,\n    allowNull: true,\n    validate: {\n      customValidator(value) {\n        if (value === null && this.age !== 10) {\n          throw new Error(\"name can't be null unless age is 10\");\n        }\n      })\n    }\n  }\n}, { sequelize });\n```\n\nYou can customize `allowNull` error message by setting the `notNull` validator:\n\n```js\nclass User extends Model {}\nUser.init({\n  name: {\n    type: Sequelize.STRING,\n    allowNull: false,\n    validate: {\n      notNull: {\n        msg: 'Please enter your name'\n      }\n    }\n  }\n}, { sequelize });\n```\n\n### Model-wide validations\n\nValidations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of `latitude` and `longitude` are set or both, and fail if one but not the other is set.\n\nModel validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.\n\nAny error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the `validate` option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors.\n\nAn example:\n\n```js\nclass Pub extends Model {}\nPub.init({\n  name: { type: Sequelize.STRING },\n  address: { type: Sequelize.STRING },\n  latitude: {\n    type: Sequelize.INTEGER,\n    allowNull: true,\n    defaultValue: null,\n    validate: { min: -90, max: 90 }\n  },\n  longitude: {\n    type: Sequelize.INTEGER,\n    allowNull: true,\n    defaultValue: null,\n    validate: { min: -180, max: 180 }\n  },\n}, {\n  validate: {\n    bothCoordsOrNone() {\n      if ((this.latitude === null) !== (this.longitude === null)) {\n        throw new Error('Require either both latitude and longitude or neither')\n      }\n    }\n  },\n  sequelize,\n})\n```\n\nIn this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, `raging_bullock_arms.validate()` might return\n\n```js\n{\n  'latitude': ['Invalid number: latitude'],\n  'bothCoordsOrNone': ['Require either both latitude and longitude or neither']\n}\n```\n\nSuch validation could have also been done with a custom validator defined on a single attribute (such as the `latitude` attribute, by checking `(value === null) !== (this.longitude === null)`), but the model-wide validation approach is cleaner.\n\n## Configuration\n\nYou can also influence the way Sequelize handles your column names:\n\n```js\nclass Bar extends Model {}\nBar.init({ /* bla */ }, {\n  // The name of the model. The model will be stored in `sequelize.models` under this name.\n  // This defaults to class name i.e. Bar in this case. This will control name of auto-generated\n  // foreignKey and association naming\n  modelName: 'bar',\n\n  // don't add the timestamp attributes (updatedAt, createdAt)\n  timestamps: false,\n\n  // don't delete database entries but set the newly added attribute deletedAt\n  // to the current date (when deletion was done). paranoid will only work if\n  // timestamps are enabled\n  paranoid: true,\n\n  // Will automatically set field option for all attributes to snake cased name.\n  // Does not override attribute with field option already defined\n  underscored: true,\n\n  // disable the modification of table names; By default, sequelize will automatically\n  // transform all passed model names (first parameter of define) into plural.\n  // if you don't want that, set the following\n  freezeTableName: true,\n\n  // define the table's name\n  tableName: 'my_very_custom_table_name',\n\n  // Enable optimistic locking.  When enabled, sequelize will add a version count attribute\n  // to the model and throw an OptimisticLockingError error when stale instances are saved.\n  // Set to true or a string with the attribute name you want to use to enable.\n  version: true,\n\n  // Sequelize instance\n  sequelize,\n})\n```\n\nIf you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually:\n\n```js\nclass Foo extends Model {}\nFoo.init({ /* bla */ }, {\n  // don't forget to enable timestamps!\n  timestamps: true,\n\n  // I don't want createdAt\n  createdAt: false,\n\n  // I want updatedAt to actually be called updateTimestamp\n  updatedAt: 'updateTimestamp',\n\n  // And deletedAt to be called destroyTime (remember to enable paranoid for this to work)\n  deletedAt: 'destroyTime',\n  paranoid: true,\n\n  sequelize,\n})\n```\n\nYou can also change the database engine, e.g. to MyISAM. InnoDB is the default.\n\n```js\nclass Person extends Model {}\nPerson.init({ /* attributes */ }, {\n  engine: 'MYISAM',\n  sequelize\n})\n\n// or globally\nconst sequelize = new Sequelize(db, user, pw, {\n  define: { engine: 'MYISAM' }\n})\n```\n\nFinally you can specify a comment for the table in MySQL and PG\n\n```js\nclass Person extends Model {}\nPerson.init({ /* attributes */ }, {\n  comment: \"I'm a table comment!\",\n  sequelize\n})\n```\n\n## Import\n\nYou can also store your model definitions in a single file using the `import` method. The returned object is exactly the same as defined in the imported file's function. Since `v1:5.0` of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often.\n\n```js\n// in your server file - e.g. app.js\nconst Project = sequelize.import(__dirname + \"/path/to/models/project\")\n\n// The model definition is done in /path/to/models/project.js\n// As you might notice, the DataTypes are the very same as explained above\nmodule.exports = (sequelize, DataTypes) => {\n  class Project extends sequelize.Model { }\n  Project.init({\n    name: DataTypes.STRING,\n    description: DataTypes.TEXT\n  }, { sequelize });\n  return Project;\n}\n```\n\nThe `import` method can also accept a callback as an argument.\n\n```js\nsequelize.import('project', (sequelize, DataTypes) => {\n  class Project extends sequelize.Model {}\n  Project.init({\n    name: DataTypes.STRING,\n    description: DataTypes.TEXT\n  }, { sequelize })\n  return Project;\n})\n```\n\nThis extra capability is useful when, for example, `Error: Cannot find module` is thrown even though `/path/to/models/project` seems to be correct.  Some frameworks, such as Meteor, overload `require`, and spit out \"surprise\" results like :\n\n```text\nError: Cannot find module '/home/you/meteorApp/.meteor/local/build/programs/server/app/path/to/models/project.js'\n```\n\nThis is solved by passing in Meteor's version of `require`. So, while this probably fails ...\n\n```js\nconst AuthorModel = db.import('./path/to/models/project');\n```\n\n... this should succeed ...\n\n```js\nconst AuthorModel = db.import('project', require('./path/to/models/project'));\n```\n\n## Optimistic Locking\n\nSequelize has built-in support for optimistic locking through a model instance version count.\nOptimistic locking is disabled by default and can be enabled by setting the `version` property to true in a specific model definition or global model configuration.  See [model configuration][0] for more details.\n\nOptimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data.  It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.\n\n## Database synchronization\n\nWhen starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables:\n\n```js\n// Create the tables:\nProject.sync()\nTask.sync()\n\n// Force the creation!\nProject.sync({force: true}) // this will drop the table first and re-create it afterwards\n\n// drop the tables:\nProject.drop()\nTask.drop()\n\n// event handling:\nProject.[sync|drop]().then(() => {\n  // ok ... everything is nice!\n}).catch(error => {\n  // oooh, did you enter wrong database credentials?\n})\n```\n\nBecause synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you:\n\n```js\n// Sync all models that aren't already in the database\nsequelize.sync()\n\n// Force sync all models\nsequelize.sync({force: true})\n\n// Drop all tables\nsequelize.drop()\n\n// emit handling:\nsequelize.[sync|drop]().then(() => {\n  // woot woot\n}).catch(error => {\n  // whooops\n})\n```\n\nBecause `.sync({ force: true })` is destructive operation, you can use `match` option as an additional safety check.\n`match` option tells sequelize to match a regex against the database name before syncing - a safety check for cases\nwhere `force: true` is used in tests but not live code.\n\n```js\n// This will run .sync() only if database name ends with '_test'\nsequelize.sync({ force: true, match: /_test$/ });\n```\n\n## Expansion of models\n\nSequelize Models are ES6 classes. You can very easily add custom instance or class level methods.\n\n```js\nclass User extends Model {\n  // Adding a class level method\n  static classLevelMethod() {\n    return 'foo';\n  }\n\n  // Adding an instance level method\n  instanceLevelMethod() {\n    return 'bar';\n  }\n}\nUser.init({ firstname: Sequelize.STRING }, { sequelize });\n```\n\nOf course you can also access the instance's data and generate virtual getters:\n\n```js\nclass User extends Model {\n  getFullname() {\n    return [this.firstname, this.lastname].join(' ');\n  }\n}\nUser.init({ firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { sequelize });\n\n// Example:\nUser.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar'\n```\n\n### Indexes\n\nSequelize supports adding indexes to the model definition which will be created during `Model.sync()` or `sequelize.sync`.\n\n```js\nclass User extends Model {}\nUser.init({}, {\n  indexes: [\n    // Create a unique index on email\n    {\n      unique: true,\n      fields: ['email']\n    },\n\n    // Creates a gin index on data with the jsonb_path_ops operator\n    {\n      fields: ['data'],\n      using: 'gin',\n      operator: 'jsonb_path_ops'\n    },\n\n    // By default index name will be [table]_[fields]\n    // Creates a multi column partial index\n    {\n      name: 'public_by_author',\n      fields: ['author', 'status'],\n      where: {\n        status: 'public'\n      }\n    },\n\n    // A BTREE index with an ordered field\n    {\n      name: 'title_index',\n      using: 'BTREE',\n      fields: ['author', {attribute: 'title', collate: 'en_US', order: 'DESC', length: 5}]\n    }\n  ],\n  sequelize\n});\n```\n\n[0]: models-definition.html#configuration\n[1]: data-types.html\n[3]: https://github.com/chriso/validator.js\n[5]: /docs/final/misc#asynchronicity\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/models-usage.md",
    "name": "./docs/manual/models-usage.md",
    "content": "# Model usage\n\n## Data retrieval / Finders\n\nFinder methods are intended to query data from the database. They do *not* return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for [*instances*](instances.html).\n\nIn this document we'll explore what finder methods can do:\n\n### `find` - Search for one specific element in the database\n\n```js\n// search for known ids\nProject.findByPk(123).then(project => {\n  // project will be an instance of Project and stores the content of the table entry\n  // with id 123. if such an entry is not defined you will get null\n})\n\n// search for attributes\nProject.findOne({ where: {title: 'aProject'} }).then(project => {\n  // project will be the first entry of the Projects table with the title 'aProject' || null\n})\n\n\nProject.findOne({\n  where: {title: 'aProject'},\n  attributes: ['id', ['name', 'title']]\n}).then(project => {\n  // project will be the first entry of the Projects table with the title 'aProject' || null\n  // project.get('title') will contain the name of the project\n})\n```\n\n### `findOrCreate` - Search for a specific element or create it if not available\n\nThe method `findOrCreate` can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created.\n\nLet's assume we have an empty database with a `User` model which has a `username` and a `job`.\n\n`where` option will be appended to `defaults` for create case.\n\n```js\nUser\n  .findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}})\n  .then(([user, created]) => {\n    console.log(user.get({\n      plain: true\n    }))\n    console.log(created)\n\n    /*\n     findOrCreate returns an array containing the object that was found or created and a boolean that\n     will be true if a new object was created and false if not, like so:\n\n    [ {\n        username: 'sdepold',\n        job: 'Technical Lead JavaScript',\n        id: 1,\n        createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET),\n        updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)\n      },\n      true ]\n\n In the example above, the array spread on line 3 divides the array into its 2 parts and passes them\n  as arguments to the callback function defined beginning at line 39, which treats them as \"user\" and\n  \"created\" in this case. (So \"user\" will be the object from index 0 of the returned array and\n  \"created\" will equal \"true\".)\n    */\n  })\n```\n\nThe code created a new instance. So when we already have an instance ...\n\n```js\nUser.create({ username: 'fnord', job: 'omnomnom' })\n  .then(() => User.findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}}))\n  .then(([user, created]) => {\n    console.log(user.get({\n      plain: true\n    }))\n    console.log(created)\n\n    /*\n    In this example, findOrCreate returns an array like this:\n    [ {\n        username: 'fnord',\n        job: 'omnomnom',\n        id: 2,\n        createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET),\n        updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)\n      },\n      false\n    ]\n    The array returned by findOrCreate gets spread into its 2 parts by the array spread on line 3, and\n    the parts will be passed as 2 arguments to the callback function beginning on line 69, which will\n    then treat them as \"user\" and \"created\" in this case. (So \"user\" will be the object from index 0\n    of the returned array and \"created\" will equal \"false\".)\n    */\n  })\n```\n\n... the existing entry will not be changed. See the `job` of the second user, and the fact that created was false.\n\n### `findAndCountAll` - Search for multiple elements in the database, returns both data and total count\n\nThis is a convenience method that combines`findAll` and `count` (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a `limit` and `offset` but also need to know the total number of records that match the query:\n\nThe success handler will always receive an object with two properties:\n\n* `count` - an integer, total number records matching the where clause and other filters due to associations\n* `rows` - an array of objects, the records matching the where clause and other filters due to associations, within the limit and offset range\n\n```js\nProject\n  .findAndCountAll({\n     where: {\n        title: {\n          [Op.like]: 'foo%'\n        }\n     },\n     offset: 10,\n     limit: 2\n  })\n  .then(result => {\n    console.log(result.count);\n    console.log(result.rows);\n  });\n```\n\nIt support includes. Only the includes that are marked as `required` will be added to the count part:\n\nSuppose you want to find all users who have a profile attached:\n\n```js\nUser.findAndCountAll({\n  include: [\n     { model: Profile, required: true }\n  ],\n  limit: 3\n});\n```\n\nBecause the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted. Adding a `where` clause to the include automatically makes it required:\n\n```js\nUser.findAndCountAll({\n  include: [\n     { model: Profile, where: { active: true }}\n  ],\n  limit: 3\n});\n```\n\nThe query above will only count users who have an active profile, because `required` is implicitly set to true when you add a where clause to the include.\n\nThe options object that you pass to `findAndCountAll` is the same as for `findAll` (described below).\n\n### `findAll` - Search for multiple elements in the database\n\n```js\n// find multiple entries\nProject.findAll().then(projects => {\n  // projects will be an array of all Project instances\n})\n\n// search for specific attributes - hash usage\nProject.findAll({ where: { name: 'A Project' } }).then(projects => {\n  // projects will be an array of Project instances with the specified name\n})\n\n// search within a specific range\nProject.findAll({ where: { id: [1,2,3] } }).then(projects => {\n  // projects will be an array of Projects having the id 1, 2 or 3\n  // this is actually doing an IN query\n})\n\nProject.findAll({\n  where: {\n    id: {\n      [Op.and]: {a: 5},           // AND (a = 5)\n      [Op.or]: [{a: 5}, {a: 6}],  // (a = 5 OR a = 6)\n      [Op.gt]: 6,                // id > 6\n      [Op.gte]: 6,               // id >= 6\n      [Op.lt]: 10,               // id < 10\n      [Op.lte]: 10,              // id <= 10\n      [Op.ne]: 20,               // id != 20\n      [Op.between]: [6, 10],     // BETWEEN 6 AND 10\n      [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15\n      [Op.in]: [1, 2],           // IN [1, 2]\n      [Op.notIn]: [1, 2],        // NOT IN [1, 2]\n      [Op.like]: '%hat',         // LIKE '%hat'\n      [Op.notLike]: '%hat',       // NOT LIKE '%hat'\n      [Op.iLike]: '%hat',         // ILIKE '%hat' (case insensitive)  (PG only)\n      [Op.notILike]: '%hat',      // NOT ILIKE '%hat'  (PG only)\n      [Op.overlap]: [1, 2],       // && [1, 2] (PG array overlap operator)\n      [Op.contains]: [1, 2],      // @> [1, 2] (PG array contains operator)\n      [Op.contained]: [1, 2],     // <@ [1, 2] (PG array contained by operator)\n      [Op.any]: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)\n    },\n    status: {\n      [Op.not]: false           // status NOT FALSE\n    }\n  }\n})\n```\n\n### Complex filtering / OR / NOT queries\n\nIt's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use `or`, `and` or `not` `Operators`:\n\n```js\nProject.findOne({\n  where: {\n    name: 'a project',\n    [Op.or]: [\n      { id: [1,2,3] },\n      { id: { [Op.gt]: 10 } }\n    ]\n  }\n})\n\nProject.findOne({\n  where: {\n    name: 'a project',\n    id: {\n      [Op.or]: [\n        [1,2,3],\n        { [Op.gt]: 10 }\n      ]\n    }\n  }\n})\n```\n\nBoth pieces of code will generate the following:\n\n```sql\nSELECT *\nFROM `Projects`\nWHERE (\n  `Projects`.`name` = 'a project'\n   AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` > 10)\n)\nLIMIT 1;\n```\n\n`not` example:\n\n```js\nProject.findOne({\n  where: {\n    name: 'a project',\n    [Op.not]: [\n      { id: [1,2,3] },\n      { array: { [Op.contains]: [3,4,5] } }\n    ]\n  }\n});\n```\n\nWill generate:\n\n```sql\nSELECT *\nFROM `Projects`\nWHERE (\n  `Projects`.`name` = 'a project'\n   AND NOT (`Projects`.`id` IN (1,2,3) OR `Projects`.`array` @> ARRAY[3,4,5]::INTEGER[])\n)\nLIMIT 1;\n```\n\n### Manipulating the dataset with limit, offset, order and group\n\nTo get more relevant data, you can use limit, offset, order and grouping:\n\n```js\n// limit the results of the query\nProject.findAll({ limit: 10 })\n\n// step over the first 10 elements\nProject.findAll({ offset: 10 })\n\n// step over the first 10 elements, and take 2\nProject.findAll({ offset: 10, limit: 2 })\n```\n\nThe syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group\n\n```js\nProject.findAll({order: [['title', 'DESC']]})\n// yields ORDER BY title DESC\n\nProject.findAll({group: 'name'})\n// yields GROUP BY name\n```\n\nNotice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column\n\n```js\nsomething.findOne({\n  order: [\n    // will return `name`\n    ['name'],\n    // will return `username` DESC\n    ['username', 'DESC'],\n    // will return max(`age`)\n    sequelize.fn('max', sequelize.col('age')),\n    // will return max(`age`) DESC\n    [sequelize.fn('max', sequelize.col('age')), 'DESC'],\n    // will return otherfunction(`col1`, 12, 'lalala') DESC\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],\n    // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite!\n    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC']\n  ]\n})\n```\n\nTo recap, the elements of the order/group array can be the following:\n\n* String - will be quoted\n* Array - first element will be quoted, second will be appended verbatim\n* Object -\n  * Raw will be added verbatim without quoting\n  * Everything else is ignored, and if raw is not set, the query will fail\n* Sequelize.fn and Sequelize.col returns functions and quoted column names\n\n### Raw queries\n\nSometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data.\n\n```js\n// Are you expecting a massive dataset from the DB,\n// and don't want to spend the time building DAOs for each entry?\n// You can pass an extra query option to get the raw data instead:\nProject.findAll({ where: { ... }, raw: true })\n```\n\n### `count` - Count the occurrences of elements in the database\n\nThere is also a method for counting database objects:\n\n```js\nProject.count().then(c => {\n  console.log(\"There are \" + c + \" projects!\")\n})\n\nProject.count({ where: {'id': {[Op.gt]: 25}} }).then(c => {\n  console.log(\"There are \" + c + \" projects with an id greater than 25.\")\n})\n```\n\n### `max` - Get the greatest value of a specific attribute within a specific table\n\nAnd here is a method for getting the max value of an attribute\n\n```js\n/*\n  Let's assume 3 person objects with an attribute age.\n  The first one is 10 years old,\n  the second one is 5 years old,\n  the third one is 40 years old.\n*/\nProject.max('age').then(max => {\n  // this will return 40\n})\n\nProject.max('age', { where: { age: { [Op.lt]: 20 } } }).then(max => {\n  // will be 10\n})\n```\n\n### `min` - Get the least value of a specific attribute within a specific table\n\nAnd here is a method for getting the min value of an attribute:\n\n```js\n/*\n  Let's assume 3 person objects with an attribute age.\n  The first one is 10 years old,\n  the second one is 5 years old,\n  the third one is 40 years old.\n*/\nProject.min('age').then(min => {\n  // this will return 5\n})\n\nProject.min('age', { where: { age: { [Op.gt]: 5 } } }).then(min => {\n  // will be 10\n})\n```\n\n### `sum` - Sum the value of specific attributes\n\nIn order to calculate the sum over a specific column of a table, you can\nuse the `sum` method.\n\n```js\n/*\n  Let's assume 3 person objects with an attribute age.\n  The first one is 10 years old,\n  the second one is 5 years old,\n  the third one is 40 years old.\n*/\nProject.sum('age').then(sum => {\n  // this will return 55\n})\n\nProject.sum('age', { where: { age: { [Op.gt]: 5 } } }).then(sum => {\n  // will be 50\n})\n```\n\n## Eager loading\n\nWhen you are retrieving data from the database there is a fair chance that you also want to get associations with the same query - this is called eager loading. The basic idea behind that, is the use of the attribute `include` when you are calling `find` or `findAll`. Lets assume the following setup:\n\n```js\nclass User extends Model {}\nUser.init({ name: Sequelize.STRING }, { sequelize, modelName: 'user' })\nclass Task extends Model {}\nTask.init({ name: Sequelize.STRING }, { sequelize, modelName: 'task' })\nclass Tool extends Model {}\nTool.init({ name: Sequelize.STRING }, { sequelize, modelName: 'tool' })\n\nTask.belongsTo(User)\nUser.hasMany(Task)\nUser.hasMany(Tool, { as: 'Instruments' })\n\nsequelize.sync().then(() => {\n  // this is where we continue ...\n})\n```\n\nOK. So, first of all, let's load all tasks with their associated user.\n\n```js\nTask.findAll({ include: [ User ] }).then(tasks => {\n  console.log(JSON.stringify(tasks))\n\n  /*\n    [{\n      \"name\": \"A Task\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:40.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:40.000Z\",\n      \"userId\": 1,\n      \"user\": {\n        \"name\": \"John Doe\",\n        \"id\": 1,\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\"\n      }\n    }]\n  */\n})\n```\n\nNotice that the accessor (the `User` property in the resulting instance) is singular because the association is one-to-something.\n\nNext thing: Loading of data with many-to-something associations!\n\n```js\nUser.findAll({ include: [ Task ] }).then(users => {\n  console.log(JSON.stringify(users))\n\n  /*\n    [{\n      \"name\": \"John Doe\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n      \"tasks\": [{\n        \"name\": \"A Task\",\n        \"id\": 1,\n        \"createdAt\": \"2013-03-20T20:31:40.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:40.000Z\",\n        \"userId\": 1\n      }]\n    }]\n  */\n})\n```\n\nNotice that the accessor (the `Tasks` property in the resulting instance) is plural because the association is many-to-something.\n\nIf an association is aliased (using the `as` option), you must specify this alias when including the model. Notice how the user's `Tool`s are aliased as `Instruments` above. In order to get that right you have to specify the model you want to load, as well as the alias:\n\n```js\nUser.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(users => {\n  console.log(JSON.stringify(users))\n\n  /*\n    [{\n      \"name\": \"John Doe\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n      \"Instruments\": [{\n        \"name\": \"Toothpick\",\n        \"id\": 1,\n        \"createdAt\": null,\n        \"updatedAt\": null,\n        \"userId\": 1\n      }]\n    }]\n  */\n})\n```\n\nYou can also include by alias name by specifying a string that matches the association alias:\n\n```js\nUser.findAll({ include: ['Instruments'] }).then(users => {\n  console.log(JSON.stringify(users))\n\n  /*\n    [{\n      \"name\": \"John Doe\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n      \"Instruments\": [{\n        \"name\": \"Toothpick\",\n        \"id\": 1,\n        \"createdAt\": null,\n        \"updatedAt\": null,\n        \"userId\": 1\n      }]\n    }]\n  */\n})\n\nUser.findAll({ include: [{ association: 'Instruments' }] }).then(users => {\n  console.log(JSON.stringify(users))\n\n  /*\n    [{\n      \"name\": \"John Doe\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n      \"Instruments\": [{\n        \"name\": \"Toothpick\",\n        \"id\": 1,\n        \"createdAt\": null,\n        \"updatedAt\": null,\n        \"userId\": 1\n      }]\n    }]\n  */\n})\n```\n\nWhen eager loading we can also filter the associated model using `where`. This will return all `User`s in which the `where` clause of `Tool` model matches rows.\n\n```js\nUser.findAll({\n    include: [{\n        model: Tool,\n        as: 'Instruments',\n        where: { name: { [Op.like]: '%ooth%' } }\n    }]\n}).then(users => {\n    console.log(JSON.stringify(users))\n\n    /*\n      [{\n        \"name\": \"John Doe\",\n        \"id\": 1,\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n        \"Instruments\": [{\n          \"name\": \"Toothpick\",\n          \"id\": 1,\n          \"createdAt\": null,\n          \"updatedAt\": null,\n          \"userId\": 1\n        }]\n      }],\n\n      [{\n        \"name\": \"John Smith\",\n        \"id\": 2,\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n        \"Instruments\": [{\n          \"name\": \"Toothpick\",\n          \"id\": 1,\n          \"createdAt\": null,\n          \"updatedAt\": null,\n          \"userId\": 1\n        }]\n      }],\n    */\n  })\n```\n\nWhen an eager loaded model is filtered using `include.where` then `include.required` is implicitly set to\n`true`. This means that an inner join is done returning parent models with any matching children.\n\n### Top level where with eagerly loaded models\n\nTo move the where conditions from an included model from the `ON` condition to the top level `WHERE` you can use the `'$nested.column$'` syntax:\n\n```js\nUser.findAll({\n    where: {\n        '$Instruments.name$': { [Op.iLike]: '%ooth%' }\n    },\n    include: [{\n        model: Tool,\n        as: 'Instruments'\n    }]\n}).then(users => {\n    console.log(JSON.stringify(users));\n\n    /*\n      [{\n        \"name\": \"John Doe\",\n        \"id\": 1,\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n        \"Instruments\": [{\n          \"name\": \"Toothpick\",\n          \"id\": 1,\n          \"createdAt\": null,\n          \"updatedAt\": null,\n          \"userId\": 1\n        }]\n      }],\n\n      [{\n        \"name\": \"John Smith\",\n        \"id\": 2,\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n        \"Instruments\": [{\n          \"name\": \"Toothpick\",\n          \"id\": 1,\n          \"createdAt\": null,\n          \"updatedAt\": null,\n          \"userId\": 1\n        }]\n      }],\n    */\n```\n\n### Including everything\n\nTo include all attributes, you can pass a single object with `all: true`:\n\n```js\nUser.findAll({ include: [{ all: true }]});\n```\n\n### Including soft deleted records\n\nIn case you want to eager load soft deleted records you can do that by setting `include.paranoid` to `false`\n\n```js\nUser.findAll({\n    include: [{\n        model: Tool,\n        where: { name: { [Op.like]: '%ooth%' } },\n        paranoid: false // query and loads the soft deleted records\n    }]\n});\n```\n\n### Ordering Eager Loaded Associations\n\nIn the case of a one-to-many relationship.\n\n```js\nCompany.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] });\nCompany.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] });\nCompany.findAll({\n  include: [ { model: Division, as: 'Div' } ],\n  order: [ [ { model: Division, as: 'Div' }, 'name' ] ]\n});\nCompany.findAll({\n  include: [ { model: Division, as: 'Div' } ],\n  order: [ [ { model: Division, as: 'Div' }, 'name', 'DESC' ] ]\n});\nCompany.findAll({\n  include: [ { model: Division, include: [ Department ] } ],\n  order: [ [ Division, Department, 'name' ] ]\n});\n```\n\nIn the case of many-to-many joins, you are also able to sort by attributes in the through table.\n\n```js\nCompany.findAll({\n  include: [ { model: Division, include: [ Department ] } ],\n  order: [ [ Division, DepartmentDivision, 'name' ] ]\n});\n```\n\n### Nested eager loading\n\nYou can use nested eager loading to load all related models of a related model:\n\n```js\nUser.findAll({\n  include: [\n    {model: Tool, as: 'Instruments', include: [\n      {model: Teacher, include: [ /* etc */]}\n    ]}\n  ]\n}).then(users => {\n  console.log(JSON.stringify(users))\n\n  /*\n    [{\n      \"name\": \"John Doe\",\n      \"id\": 1,\n      \"createdAt\": \"2013-03-20T20:31:45.000Z\",\n      \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\n      \"Instruments\": [{ // 1:M and N:M association\n        \"name\": \"Toothpick\",\n        \"id\": 1,\n        \"createdAt\": null,\n        \"updatedAt\": null,\n        \"userId\": 1,\n        \"Teacher\": { // 1:1 association\n          \"name\": \"Jimi Hendrix\"\n        }\n      }]\n    }]\n  */\n})\n```\n\nThis will produce an outer join. However, a `where` clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add `required: false`.\n\n```js\nUser.findAll({\n  include: [{\n    model: Tool,\n    as: 'Instruments',\n    include: [{\n      model: Teacher,\n      where: {\n        school: \"Woodstock Music School\"\n      },\n      required: false\n    }]\n  }]\n}).then(users => {\n  /* ... */\n})\n```\n\nThe query above will return all users, and all their instruments, but only those teachers associated with `Woodstock Music School`.\n\nInclude all also supports nested loading:\n\n```js\nUser.findAll({ include: [{ all: true, nested: true }]});\n```\n\n### Use right join for association\n\nBy default, associations are loaded using a left join, that is to say it only includes records from the parent table. You can change this behavior to a right join by passing the `right` property, if the dialect you are using supports it. Currently, `sqlite` *does not* support [right joins](https://www.sqlite.org/omitted.html).\n\n*Note:* `right` is only respected if `required` is false.\n\n```js\nUser.findAll({\n    include: [{\n        model: Tool // will create a left join\n    }]\n});\n\nUser.findAll({\n    include: [{\n        model: Tool,\n        right: true // will create a right join\n    }]\n});\n\nUser.findAll({\n    include: [{\n        model: Tool,\n        required: true,\n        right: true // has no effect, will create an inner join\n    }]\n});\n\nUser.findAll({\n    include: [{\n        model: Tool,\n        where: { name: { [Op.like]: '%ooth%' } },\n        right: true // has no effect, will create an inner join\n    }]\n});\n\nUser.findAll({\n    include: [{\n        model: Tool,\n        where: { name: { [Op.like]: '%ooth%' } },\n        required: false\n        right: true // because we set `required` to false, this will create a right join\n    }]\n});\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/hooks.md",
    "name": "./docs/manual/hooks.md",
    "content": "# Hooks\n\nHooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a `beforeUpdate` hook.\n\n**Note:** _You can't use hooks with instances. Hooks are used with models._\n\nFor a full list of hooks, see [Hooks file](https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7).\n\n## Order of Operations\n\n```text\n(1)\n  beforeBulkCreate(instances, options)\n  beforeBulkDestroy(options)\n  beforeBulkUpdate(options)\n(2)\n  beforeValidate(instance, options)\n(-)\n  validate\n(3)\n  afterValidate(instance, options)\n  - or -\n  validationFailed(instance, options, error)\n(4)\n  beforeCreate(instance, options)\n  beforeDestroy(instance, options)\n  beforeUpdate(instance, options)\n  beforeSave(instance, options)\n  beforeUpsert(values, options)\n(-)\n  create\n  destroy\n  update\n(5)\n  afterCreate(instance, options)\n  afterDestroy(instance, options)\n  afterUpdate(instance, options)\n  afterSave(instance, options)\n  afterUpsert(created, options)\n(6)\n  afterBulkCreate(instances, options)\n  afterBulkDestroy(options)\n  afterBulkUpdate(options)\n```\n\n## Declaring Hooks\n\nArguments to hooks are passed by reference. This means, that you can change the values, and this will be reflected in the insert / update statement. A hook may contain async actions - in this case the hook function should return a promise.\n\nThere are currently three ways to programmatically add hooks:\n\n```js\n// Method 1 via the .init() method\nclass User extends Model {}\nUser.init({\n  username: DataTypes.STRING,\n  mood: {\n    type: DataTypes.ENUM,\n    values: ['happy', 'sad', 'neutral']\n  }\n}, {\n  hooks: {\n    beforeValidate: (user, options) => {\n      user.mood = 'happy';\n    },\n    afterValidate: (user, options) => {\n      user.username = 'Toni';\n    }\n  },\n  sequelize\n});\n\n// Method 2 via the .addHook() method\nUser.addHook('beforeValidate', (user, options) => {\n  user.mood = 'happy';\n});\n\nUser.addHook('afterValidate', 'someCustomName', (user, options) => {\n  return Promise.reject(new Error(\"I'm afraid I can't let you do that!\"));\n});\n\n// Method 3 via the direct method\nUser.beforeCreate((user, options) => {\n  return hashPassword(user.password).then(hashedPw => {\n    user.password = hashedPw;\n  });\n});\n\nUser.afterValidate('myHookAfter', (user, options) => {\n  user.username = 'Toni';\n});\n```\n\n## Removing hooks\n\nOnly a hook with name param can be removed.\n\n```js\nclass Book extends Model {}\nBook.init({\n  title: DataTypes.STRING\n}, { sequelize });\n\nBook.addHook('afterCreate', 'notifyUsers', (book, options) => {\n  // ...\n});\n\nBook.removeHook('afterCreate', 'notifyUsers');\n```\n\nYou can have many hooks with same name. Calling `.removeHook()` will remove all of them.\n\n## Global / universal hooks\n\nGlobal hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics:\n\n### Default Hooks (Sequelize.options.define)\n\n```js\nconst sequelize = new Sequelize(..., {\n    define: {\n        hooks: {\n            beforeCreate: () => {\n              // Do stuff\n            }\n        }\n    }\n});\n```\n\nThis adds a default hook to all models, which is run if the model does not define its own `beforeCreate` hook:\n\n```js\nclass User extends Model {}\nUser.init({}, { sequelize });\nclass Project extends Model {}\nProject.init({}, {\n    hooks: {\n        beforeCreate: () => {\n            // Do other stuff\n        }\n    },\n    sequelize\n});\n\nUser.create() // Runs the global hook\nProject.create() // Runs its own hook (because the global hook is overwritten)\n```\n\n### Permanent Hooks (Sequelize.addHook)\n\n```js\nsequelize.addHook('beforeCreate', () => {\n    // Do stuff\n});\n```\n\nThis hook is always run before create, regardless of whether the model specifies its own `beforeCreate` hook. Local hooks are always run before global hooks:\n\n```js\nclass User extends Model {}\nUser.init({}, { sequelize });\nclass Project extends Model {}\nProject.init({}, {\n    hooks: {\n        beforeCreate: () => {\n            // Do other stuff\n        }\n    },\n    sequelize\n});\n\nUser.create() // Runs the global hook\nProject.create() // Runs its own hook, followed by the global hook\n```\n\nPermanent hooks may also be defined in `Sequelize.options`:\n\n```js\nnew Sequelize(..., {\n    hooks: {\n        beforeCreate: () => {\n            // do stuff\n        }\n    }\n});\n```\n\n### Connection Hooks\n\nSequelize provides four hooks that are executed immediately before and after a database connection is obtained or released:\n\n```text\nbeforeConnect(config)\nafterConnect(connection, config)\nbeforeDisconnect(connection)\nafterDisconnect(connection)\n```\n\nThese hooks can be useful if you need to asynchronously obtain database credentials, or need to directly access the low-level database connection after it has been created.\n\nFor example, we can asynchronously obtain a database password from a rotating token store, and mutate Sequelize's configuration object with the new credentials:\n\n```js\nsequelize.beforeConnect((config) => {\n    return getAuthToken()\n        .then((token) => {\n             config.password = token;\n         });\n    });\n```\n\nThese hooks may _only_ be declared as a permanent global hook, as the connection pool is shared by all models.\n\n## Instance hooks\n\nThe following hooks will emit whenever you're editing a single object\n\n```text\nbeforeValidate\nafterValidate or validationFailed\nbeforeCreate / beforeUpdate / beforeSave  / beforeDestroy\nafterCreate / afterUpdate / afterSave / afterDestroy\n```\n\n```js\n// ...define ...\nUser.beforeCreate(user => {\n  if (user.accessLevel > 10 && user.username !== \"Boss\") {\n    throw new Error(\"You can't grant this user an access level above 10!\")\n  }\n})\n```\n\nThis example will return an error:\n\n```js\nUser.create({username: 'Not a Boss', accessLevel: 20}).catch(err => {\n  console.log(err); // You can't grant this user an access level above 10!\n});\n```\n\nThe following example would return successful:\n\n```js\nUser.create({username: 'Boss', accessLevel: 20}).then(user => {\n  console.log(user); // user object with username as Boss and accessLevel of 20\n});\n```\n\n### Model hooks\n\nSometimes you'll be editing more than one record at a time by utilizing the `bulkCreate, update, destroy` methods on the model. The following will emit whenever you're using one of those methods:\n\n```text\nbeforeBulkCreate(instances, options)\nbeforeBulkUpdate(options)\nbeforeBulkDestroy(options)\nafterBulkCreate(instances, options)\nafterBulkUpdate(options)\nafterBulkDestroy(options)\n```\n\nIf you want to emit hooks for each individual record, along with the bulk hooks you can pass `individualHooks: true` to the call.\n\n**WARNING**: if you use individual hooks, *all instances that are updated or destroyed will get loaded into memory* before your hooks are called.  The number of instances Sequelize can handle with individual hooks is limited by available memory.\n\n```js\nModel.destroy({ where: {accessLevel: 0}, individualHooks: true});\n// Will select all records that are about to be deleted and emit before- + after- Destroy on each instance\n\nModel.update({username: 'Toni'}, { where: {accessLevel: 0}, individualHooks: true});\n// Will select all records that are about to be updated and emit before- + after- Update on each instance\n```\n\nThe `options` argument of hook method would be the second argument provided to the corresponding method or its\ncloned and extended version.\n\n```js\nModel.beforeBulkCreate((records, {fields}) => {\n  // records = the first argument sent to .bulkCreate\n  // fields = one of the second argument fields sent to .bulkCreate\n})\n\nModel.bulkCreate([\n    {username: 'Toni'}, // part of records argument\n    {username: 'Tobi'} // part of records argument\n  ], {fields: ['username']} // options parameter\n)\n\nModel.beforeBulkUpdate(({attributes, where}) => {\n  // where - in one of the fields of the clone of second argument sent to .update\n  // attributes - is one of the fields that the clone of second argument of .update would be extended with\n})\n\nModel.update({gender: 'Male'} /*attributes argument*/, { where: {username: 'Tom'}} /*where argument*/)\n\nModel.beforeBulkDestroy(({where, individualHooks}) => {\n  // individualHooks - default of overridden value of extended clone of second argument sent to Model.destroy\n  // where - in one of the fields of the clone of second argument sent to Model.destroy\n})\n\nModel.destroy({ where: {username: 'Tom'}} /*where argument*/)\n```\n\nIf you use `Model.bulkCreate(...)` with the `updateOnDuplicate` option, changes made in the hook to fields that aren't given in the `updateOnDuplicate` array will not be persisted to the database. However it is possible to change the updateOnDuplicate option inside the hook if this is what you want.\n\n```js\n// Bulk updating existing users with updateOnDuplicate option\nUsers.bulkCreate([\n  { id: 1, isMember: true },\n  { id: 2, isMember: false }\n], {\n  updateOnDuplicate: ['isMember']\n});\n\nUser.beforeBulkCreate((users, options) => {\n  for (const user of users) {\n    if (user.isMember) {\n      user.memberSince = new Date();\n    }\n  }\n\n  // Add memberSince to updateOnDuplicate otherwise the memberSince date wont be\n  // saved to the database\n  options.updateOnDuplicate.push('memberSince');\n});\n```\n\n## Associations\n\nFor the most part hooks will work the same for instances when being associated except a few things\n\n1. When using add/set functions the beforeUpdate/afterUpdate hooks will run.\n2. The only way to call beforeDestroy/afterDestroy hooks are on associations with `onDelete: 'cascade'` and the option `hooks: true`. For instance:\n\n```js\nclass Projects extends Model {}\nProjects.init({\n  title: DataTypes.STRING\n}, { sequelize });\n\nclass Tasks extends Model {}\nTasks.init({\n  title: DataTypes.STRING\n}, { sequelize });\n\nProjects.hasMany(Tasks, { onDelete: 'cascade', hooks: true });\nTasks.belongsTo(Projects);\n```\n\nThis code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a\n\n```sql\nDELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey\n```\n\nHowever, adding `hooks: true` explicitly tells Sequelize that optimization is not of your concern and will perform a `SELECT` on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.\n\nIf your association is of type `n:m`, you may be interested in firing hooks on the through model when using the `remove` call. Internally, sequelize is using `Model.destroy` resulting in calling the `bulkDestroy` instead of the `before/afterDestroy` hooks on each through instance.\n\nThis can be simply solved by passing `{individualHooks: true}` to the `remove` call, resulting on each hook to be called on each removed through instance object.\n\n## A Note About Transactions\n\nNote that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction _is_ specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:\n\n```js\n// Here we use the promise-style of async hooks rather than\n// the callback.\nUser.addHook('afterCreate', (user, options) => {\n  // 'transaction' will be available in options.transaction\n\n  // This operation will be part of the same transaction as the\n  // original User.create call.\n  return User.update({\n    mood: 'sad'\n  }, {\n    where: {\n      id: user.id\n    },\n    transaction: options.transaction\n  });\n});\n\n\nsequelize.transaction(transaction => {\n  User.create({\n    username: 'someguy',\n    mood: 'happy',\n    transaction\n  });\n});\n```\n\nIf we had not included the transaction option in our call to `User.update` in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.\n\n### Internal Transactions\n\nIt is very important to recognize that sequelize may make use of transactions internally for certain operations such as `Model.findOrCreate`. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify `{ transaction: options.transaction }`.\n\nIf the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified `{ transaction: null }` and can expect the default behaviour.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/querying.md",
    "name": "./docs/manual/querying.md",
    "content": "# Querying\n\n## Attributes\n\nTo select only some attributes, you can use the `attributes` option. Most often, you pass an array:\n\n```js\nModel.findAll({\n  attributes: ['foo', 'bar']\n});\n```\n\n```sql\nSELECT foo, bar ...\n```\n\nAttributes can be renamed using a nested array:\n\n```js\nModel.findAll({\n  attributes: ['foo', ['bar', 'baz']]\n});\n```\n\n```sql\nSELECT foo, bar AS baz ...\n```\n\nYou can use `sequelize.fn` to do aggregations:\n\n```js\nModel.findAll({\n  attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]\n});\n```\n\n```sql\nSELECT COUNT(hats) AS no_hats ...\n```\n\nWhen using aggregation function, you must give it an alias to be able to access it from the model. In the example above you can get the number of hats with `instance.get('no_hats')`.\n\nSometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation:\n\n```js\n// This is a tiresome way of getting the number of hats...\nModel.findAll({\n  attributes: ['id', 'foo', 'bar', 'baz', 'quz', [sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]\n});\n\n// This is shorter, and less error prone because it still works if you add / remove attributes\nModel.findAll({\n  attributes: { include: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }\n});\n```\n\n```sql\nSELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ...\n```\n\nSimilarly, it's also possible to remove a selected few attributes:\n\n```js\nModel.findAll({\n  attributes: { exclude: ['baz'] }\n});\n```\n\n```sql\nSELECT id, foo, bar, quz ...\n```\n\n## Where\n\nWhether you are querying with findAll/find or doing bulk updates/destroys you can pass a `where` object to filter the query.\n\n`where` generally takes an object from attribute:value pairs, where value can be primitives for equality matches or keyed objects for other operators.\n\nIt's also possible to generate complex AND/OR conditions by nesting sets of `or` and `and` `Operators`.\n\n### Basics\n\n```js\nconst Op = Sequelize.Op;\n\nPost.findAll({\n  where: {\n    authorId: 2\n  }\n});\n// SELECT * FROM post WHERE authorId = 2\n\nPost.findAll({\n  where: {\n    authorId: 12,\n    status: 'active'\n  }\n});\n// SELECT * FROM post WHERE authorId = 12 AND status = 'active';\n\nPost.findAll({\n  where: {\n    [Op.or]: [{authorId: 12}, {authorId: 13}]\n  }\n});\n// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;\n\nPost.findAll({\n  where: {\n    authorId: {\n      [Op.or]: [12, 13]\n    }\n  }\n});\n// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;\n\nPost.destroy({\n  where: {\n    status: 'inactive'\n  }\n});\n// DELETE FROM post WHERE status = 'inactive';\n\nPost.update({\n  updatedAt: null,\n}, {\n  where: {\n    deletedAt: {\n      [Op.ne]: null\n    }\n  }\n});\n// UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL;\n\nPost.findAll({\n  where: sequelize.where(sequelize.fn('char_length', sequelize.col('status')), 6)\n});\n// SELECT * FROM post WHERE char_length(status) = 6;\n```\n\n### Operators\n\nSequelize exposes symbol operators that can be used for to create more complex comparisons -\n\n```js\nconst Op = Sequelize.Op\n\n[Op.and]: [{a: 5}, {b: 6}] // (a = 5) AND (b = 6)\n[Op.or]: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)\n[Op.gt]: 6,                // > 6\n[Op.gte]: 6,               // >= 6\n[Op.lt]: 10,               // < 10\n[Op.lte]: 10,              // <= 10\n[Op.ne]: 20,               // != 20\n[Op.eq]: 3,                // = 3\n[Op.is]: null              // IS NULL\n[Op.not]: true,            // IS NOT TRUE\n[Op.between]: [6, 10],     // BETWEEN 6 AND 10\n[Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15\n[Op.in]: [1, 2],           // IN [1, 2]\n[Op.notIn]: [1, 2],        // NOT IN [1, 2]\n[Op.like]: '%hat',         // LIKE '%hat'\n[Op.notLike]: '%hat'       // NOT LIKE '%hat'\n[Op.iLike]: '%hat'         // ILIKE '%hat' (case insensitive) (PG only)\n[Op.notILike]: '%hat'      // NOT ILIKE '%hat'  (PG only)\n[Op.startsWith]: 'hat'     // LIKE 'hat%'\n[Op.endsWith]: 'hat'       // LIKE '%hat'\n[Op.substring]: 'hat'      // LIKE '%hat%'\n[Op.regexp]: '^[h|a|t]'    // REGEXP/~ '^[h|a|t]' (MySQL/PG only)\n[Op.notRegexp]: '^[h|a|t]' // NOT REGEXP/!~ '^[h|a|t]' (MySQL/PG only)\n[Op.iRegexp]: '^[h|a|t]'    // ~* '^[h|a|t]' (PG only)\n[Op.notIRegexp]: '^[h|a|t]' // !~* '^[h|a|t]' (PG only)\n[Op.like]: { [Op.any]: ['cat', 'hat']}\n                           // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike\n[Op.overlap]: [1, 2]       // && [1, 2] (PG array overlap operator)\n[Op.contains]: [1, 2]      // @> [1, 2] (PG array contains operator)\n[Op.contained]: [1, 2]     // <@ [1, 2] (PG array contained by operator)\n[Op.any]: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)\n\n[Op.col]: 'user.organization_id' // = \"user\".\"organization_id\", with dialect specific column identifiers, PG in this example\n[Op.gt]: { [Op.all]: literal('SELECT 1') }\n                          // > ALL (SELECT 1)\n```\n\n#### Range Operators\n\nRange types can be queried with all supported operators.\n\nKeep in mind, the provided range value can\n[define the bound inclusion/exclusion](data-types.html#range-types)\nas well.\n\n```js\n// All the above equality and inequality operators plus the following:\n\n[Op.contains]: 2           // @> '2'::integer (PG range contains element operator)\n[Op.contains]: [1, 2]      // @> [1, 2) (PG range contains range operator)\n[Op.contained]: [1, 2]     // <@ [1, 2) (PG range is contained by operator)\n[Op.overlap]: [1, 2]       // && [1, 2) (PG range overlap (have points in common) operator)\n[Op.adjacent]: [1, 2]      // -|- [1, 2) (PG range is adjacent to operator)\n[Op.strictLeft]: [1, 2]    // << [1, 2) (PG range strictly left of operator)\n[Op.strictRight]: [1, 2]   // >> [1, 2) (PG range strictly right of operator)\n[Op.noExtendRight]: [1, 2] // &< [1, 2) (PG range does not extend to the right of operator)\n[Op.noExtendLeft]: [1, 2]  // &> [1, 2) (PG range does not extend to the left of operator)\n```\n\n#### Combinations\n\n```js\nconst Op = Sequelize.Op;\n\n{\n  rank: {\n    [Op.or]: {\n      [Op.lt]: 1000,\n      [Op.eq]: null\n    }\n  }\n}\n// rank < 1000 OR rank IS NULL\n\n{\n  createdAt: {\n    [Op.lt]: new Date(),\n    [Op.gt]: new Date(new Date() - 24 * 60 * 60 * 1000)\n  }\n}\n// createdAt < [timestamp] AND createdAt > [timestamp]\n\n{\n  [Op.or]: [\n    {\n      title: {\n        [Op.like]: 'Boat%'\n      }\n    },\n    {\n      description: {\n        [Op.like]: '%boat%'\n      }\n    }\n  ]\n}\n// title LIKE 'Boat%' OR description LIKE '%boat%'\n```\n\n#### Operators Aliases\n\nSequelize allows setting specific strings as aliases for operators. With v5 this will give you deprecation warning.\n\n```js\nconst Op = Sequelize.Op;\nconst operatorsAliases = {\n  $gt: Op.gt\n}\nconst connection = new Sequelize(db, user, pass, { operatorsAliases })\n\n[Op.gt]: 6 // > 6\n$gt: 6 // same as using Op.gt (> 6)\n```\n\n#### Operators security\n\nBy default Sequelize will use Symbol operators. Using Sequelize without any aliases improves security. Not having any string aliases will make it extremely unlikely that operators could be injected but you should always properly validate and sanitize user input.\n\nSome frameworks automatically parse user input into js objects and if you fail to sanitize your input it might be possible to inject an Object with string operators to Sequelize.\n\nFor better security it is highly advised to use symbol operators from `Sequelize.Op` like `Op.and` / `Op.or` in your code and not depend on any string based operators like `$and` / `$or` at all. You can limit alias your application will need by setting `operatorsAliases` option, remember to sanitize user input especially when you are directly passing them to Sequelize methods.\n\n```js\nconst Op = Sequelize.Op;\n\n//use sequelize without any operators aliases\nconst connection = new Sequelize(db, user, pass, { operatorsAliases: false });\n\n//use sequelize with only alias for $and => Op.and\nconst connection2 = new Sequelize(db, user, pass, { operatorsAliases: { $and: Op.and } });\n```\n\nSequelize will warn you if you're using the default aliases and not limiting them\nif you want to keep using all default aliases (excluding legacy ones) without the warning you can pass the following operatorsAliases option -\n\n```js\nconst Op = Sequelize.Op;\nconst operatorsAliases = {\n  $eq: Op.eq,\n  $ne: Op.ne,\n  $gte: Op.gte,\n  $gt: Op.gt,\n  $lte: Op.lte,\n  $lt: Op.lt,\n  $not: Op.not,\n  $in: Op.in,\n  $notIn: Op.notIn,\n  $is: Op.is,\n  $like: Op.like,\n  $notLike: Op.notLike,\n  $iLike: Op.iLike,\n  $notILike: Op.notILike,\n  $regexp: Op.regexp,\n  $notRegexp: Op.notRegexp,\n  $iRegexp: Op.iRegexp,\n  $notIRegexp: Op.notIRegexp,\n  $between: Op.between,\n  $notBetween: Op.notBetween,\n  $overlap: Op.overlap,\n  $contains: Op.contains,\n  $contained: Op.contained,\n  $adjacent: Op.adjacent,\n  $strictLeft: Op.strictLeft,\n  $strictRight: Op.strictRight,\n  $noExtendRight: Op.noExtendRight,\n  $noExtendLeft: Op.noExtendLeft,\n  $and: Op.and,\n  $or: Op.or,\n  $any: Op.any,\n  $all: Op.all,\n  $values: Op.values,\n  $col: Op.col\n};\n\nconst connection = new Sequelize(db, user, pass, { operatorsAliases });\n```\n\n### JSON\n\nThe JSON data type is supported by the PostgreSQL, SQLite, MySQL and MariaDB dialects only.\n\n#### PostgreSQL\n\nThe JSON data type in PostgreSQL stores the value as plain text, as opposed to binary representation. If you simply want to store and retrieve a JSON representation, using JSON will take less disk space and less time to build from its input representation. However, if you want to do any operations on the JSON value, you should prefer the JSONB data type described below.\n\n#### MSSQL\n\nMSSQL does not have a JSON data type, however it does provide support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed separately.\n\n```js\n// ISJSON - to test if a string contains valid JSON\nUser.findAll({\n  where: sequelize.where(sequelize.fn('ISJSON', sequelize.col('userDetails')), 1)\n})\n\n// JSON_VALUE - extract a scalar value from a JSON string\nUser.findAll({\n  attributes: [[ sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), 'address line 1']]\n})\n\n// JSON_VALUE - query a scalar value from a JSON string\nUser.findAll({\n  where: sequelize.where(sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), '14, Foo Street')\n})\n\n// JSON_QUERY - extract an object or array\nUser.findAll({\n  attributes: [[ sequelize.fn('JSON_QUERY', sequelize.col('userDetails'), '$.address'), 'full address']]\n})\n```\n\n### JSONB\n\nJSONB can be queried in three different ways.\n\n#### Nested object\n\n```js\n{\n  meta: {\n    video: {\n      url: {\n        [Op.ne]: null\n      }\n    }\n  }\n}\n```\n\n#### Nested key\n\n```js\n{\n  \"meta.audio.length\": {\n    [Op.gt]: 20\n  }\n}\n```\n\n#### Containment\n\n```js\n{\n  \"meta\": {\n    [Op.contains]: {\n      site: {\n        url: 'http://google.com'\n      }\n    }\n  }\n}\n```\n\n### Relations / Associations\n\n```js\n// Find all projects with a least one task where task.state === project.state\nProject.findAll({\n    include: [{\n        model: Task,\n        where: { state: Sequelize.col('project.state') }\n    }]\n})\n```\n\n## Pagination / Limiting\n\n```js\n// Fetch 10 instances/rows\nProject.findAll({ limit: 10 })\n\n// Skip 8 instances/rows\nProject.findAll({ offset: 8 })\n\n// Skip 5 instances and fetch the 5 after that\nProject.findAll({ offset: 5, limit: 5 })\n```\n\n## Ordering\n\n`order` takes an array of items to order the query by or a sequelize method. Generally you will want to use a tuple/array of either attribute, direction or just direction to ensure proper escaping.\n\n```js\nSubtask.findAll({\n  order: [\n    // Will escape title and validate DESC against a list of valid direction parameters\n    ['title', 'DESC'],\n\n    // Will order by max(age)\n    sequelize.fn('max', sequelize.col('age')),\n\n    // Will order by max(age) DESC\n    [sequelize.fn('max', sequelize.col('age')), 'DESC'],\n\n    // Will order by  otherfunction(`col1`, 12, 'lalala') DESC\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],\n\n    // Will order an associated model's created_at using the model name as the association's name.\n    [Task, 'createdAt', 'DESC'],\n\n    // Will order through an associated model's created_at using the model names as the associations' names.\n    [Task, Project, 'createdAt', 'DESC'],\n\n    // Will order by an associated model's created_at using the name of the association.\n    ['Task', 'createdAt', 'DESC'],\n\n    // Will order by a nested associated model's created_at using the names of the associations.\n    ['Task', 'Project', 'createdAt', 'DESC'],\n\n    // Will order by an associated model's created_at using an association object. (preferred method)\n    [Subtask.associations.Task, 'createdAt', 'DESC'],\n\n    // Will order by a nested associated model's created_at using association objects. (preferred method)\n    [Subtask.associations.Task, Task.associations.Project, 'createdAt', 'DESC'],\n\n    // Will order by an associated model's created_at using a simple association object.\n    [{model: Task, as: 'Task'}, 'createdAt', 'DESC'],\n\n    // Will order by a nested associated model's created_at simple association objects.\n    [{model: Task, as: 'Task'}, {model: Project, as: 'Project'}, 'createdAt', 'DESC']\n  ]\n\n  // Will order by max age descending\n  order: sequelize.literal('max(age) DESC')\n\n  // Will order by max age ascending assuming ascending is the default order when direction is omitted\n  order: sequelize.fn('max', sequelize.col('age'))\n\n  // Will order by age ascending assuming ascending is the default order when direction is omitted\n  order: sequelize.col('age')\n\n  // Will order randomly based on the dialect (instead of fn('RAND') or fn('RANDOM'))\n  order: sequelize.random()\n})\n```\n\n## Table Hint\n\n`tableHint` can be used to optionally pass a table hint when using mssql. The hint must be a value from `Sequelize.TableHints` and should only be used when absolutely necessary. Only a single table hint is currently supported per query.\n\nTable hints override the default behavior of mssql query optimizer by specifying certain options. They only affect the table or view referenced in that clause.\n\n```js\nconst TableHints = Sequelize.TableHints;\n\nProject.findAll({\n  // adding the table hint NOLOCK\n  tableHint: TableHints.NOLOCK\n  // this will generate the SQL 'WITH (NOLOCK)'\n})\n```\n\n## Index Hints\n\n`indexHints` can be used to optionally pass index hints when using mysql. The hint type must be a value from `Sequelize.IndexHints` and the values should reference existing indexes.\n\nIndex hints [override the default behavior of the mysql query optimizer](https://dev.mysql.com/doc/refman/5.7/en/index-hints.html).\n\n```js\nProject.findAll({\n  indexHints: [\n    { type: IndexHints.USE, values: ['index_project_on_name'] }\n  ],\n  where: {\n    id: {\n      [Op.gt]: 623\n    },\n    name: {\n      [Op.like]: 'Foo %'\n    }\n  }\n})\n```\n\nWill generate a mysql query that looks like this:\n\n```sql\nSELECT * FROM Project USE INDEX (index_project_on_name) WHERE name LIKE 'FOO %' AND id > 623;\n```\n\n`Sequelize.IndexHints` includes `USE`, `FORCE`, and `IGNORE`.\n\nSee [Issue #9421](https://github.com/sequelize/sequelize/issues/9421) for the original API proposal.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/instances.md",
    "name": "./docs/manual/instances.md",
    "content": "# Instances\n\n## Building a non-persistent instance\n\nIn order to create instances of defined classes just do as follows&period; You might recognize the syntax if you coded Ruby in the past&period; Using the `build`-method will return an unsaved object&comma; which you explicitly have to save&period;\n\n```js\nconst project = Project.build({\n  title: 'my awesome project',\n  description: 'woot woot. this will make me a rich man'\n})\n\nconst task = Task.build({\n  title: 'specify the project idea',\n  description: 'bla',\n  deadline: new Date()\n})\n```\n\nBuilt instances will automatically get default values when they were defined&colon;\n\n```js\n// first define the model\nclass Task extends Model {}\nTask.init({\n  title: Sequelize.STRING,\n  rating: { type: Sequelize.TINYINT, defaultValue: 3 }\n}, { sequelize, modelName: 'task' });\n\n// now instantiate an object\nconst task = Task.build({title: 'very important task'})\n\ntask.title  // ==> 'very important task'\ntask.rating // ==> 3\n```\n\nTo get it stored in the database&comma; use the `save`-method and catch the events ... if needed&colon;\n\n```js\nproject.save().then(() => {\n  // my nice callback stuff\n})\n\ntask.save().catch(error => {\n  // mhhh, wth!\n})\n\n// you can also build, save and access the object with chaining:\nTask\n  .build({ title: 'foo', description: 'bar', deadline: new Date() })\n  .save()\n  .then(anotherTask => {\n    // you can now access the currently saved task with the variable anotherTask... nice!\n  })\n  .catch(error => {\n    // Ooops, do some error-handling\n  })\n```\n\n## Creating persistent instances\n\nWhile an instance created with `.build()` requires an explicit `.save()` call to be stored in the database&comma; `.create()` omits that requirement altogether and automatically stores your instance's data once called.\n\n```js\nTask.create({ title: 'foo', description: 'bar', deadline: new Date() }).then(task => {\n  // you can now access the newly created task via the variable task\n})\n```\n\nIt is also possible to define which attributes can be set via the create method&period; This can be especially very handy if you create database entries based on a form which can be filled by a user&period; Using that would for example allow you to restrict the `User` model to set only a username and an address but not an admin flag&colon;\n\n```js\nUser.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(user => {\n  // let's assume the default of isAdmin is false:\n  console.log(user.get({\n    plain: true\n  })) // => { username: 'barfooz', isAdmin: false }\n})\n```\n\n## Updating / Saving / Persisting an instance\n\nNow lets change some values and save changes to the database&period;&period;&period; There are two ways to do that&colon;\n\n```js\n// way 1\ntask.title = 'a very different title now'\ntask.save().then(() => {})\n\n// way 2\ntask.update({\n  title: 'a very different title now'\n}).then(() => {})\n```\n\nIt's also possible to define which attributes should be saved when calling `save`&comma; by passing an array of column names&period; This is useful when you set attributes based on a previously defined object&period; E&period;g&period; if you get the values of an object via a form of a web app&period; Furthermore this is used internally for `update`&period; This is how it looks like&colon;\n\n```js\ntask.title = 'foooo'\ntask.description = 'baaaaaar'\ntask.save({fields: ['title']}).then(() => {\n // title will now be 'foooo' but description is the very same as before\n})\n\n// The equivalent call using update looks like this:\ntask.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(() => {\n // title will now be 'foooo' but description is the very same as before\n})\n```\n\nWhen you call `save` without changing any attribute, this method will execute nothing;\n\n## Destroying / Deleting persistent instances\n\nOnce you created an object and got a reference to it&comma; you can delete it from the database&period; The relevant method is `destroy`&colon;\n\n```js\nTask.create({ title: 'a task' }).then(task => {\n  // now you see me...\n  return task.destroy();\n}).then(() => {\n// now i'm gone :)\n})\n```\n\nIf the `paranoid` options is true, the object will not be deleted, instead the `deletedAt` column will be set to the current timestamp. To force the deletion, you can pass `force: true` to the destroy call:\n\n```js\ntask.destroy({ force: true })\n```\n\nAfter an object is soft deleted in `paranoid` mode, you will not be able to create a new instance with the same primary key\nuntil you have force-deleted the old instance.\n\n## Restoring soft-deleted instances\n\nIf you have soft-deleted an instance of a model with `paranoid: true`, and would like to undo the deletion, use the `restore` method:\n\n```js\nTask.create({ title: 'a task' }).then(task => {\n  // now you see me...\n  return task.destroy();\n}).then((task) => {\n // now i'm gone, but wait...\n  return task.restore();\n})\n```\n\n## Working in bulk (creating, updating and destroying multiple rows at once)\n\nIn addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called\n\n* `Model.bulkCreate`\n* `Model.update`\n* `Model.destroy`\n\nSince you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike `create`, not have the resulting values of autoIncrement attributes.`update` and `destroy` will return the number of affected rows.\n\nFirst lets look at bulkCreate\n\n```js\nUser.bulkCreate([\n  { username: 'barfooz', isAdmin: true },\n  { username: 'foo', isAdmin: true },\n  { username: 'bar', isAdmin: false }\n]).then(() => { // Notice: There are no arguments here, as of right now you'll have to...\n  return User.findAll();\n}).then(users => {\n  console.log(users) // ... in order to get the array of user objects\n})\n```\n\nInsert several rows and return all columns (Postgres only):\n\n```js\nUser.bulkCreate([\n  { username: 'barfooz', isAdmin: true },\n  { username: 'foo', isAdmin: true },\n  { username: 'bar', isAdmin: false }\n], { returning: true }) // will return all columns for each row inserted\n.then((result) => {\n  console.log(result);\n});\n```\n\nInsert several rows and return specific columns (Postgres only):\n\n```js\nUser.bulkCreate([\n  { username: 'barfooz', isAdmin: true },\n  { username: 'foo', isAdmin: true },\n  { username: 'bar', isAdmin: false }\n], { returning: ['username'] }) // will return only the specified columns for each row inserted\n.then((result) => {\n  console.log(result);\n});\n```\n\nTo update several rows at once:\n\n```js\nTask.bulkCreate([\n  {subject: 'programming', status: 'executing'},\n  {subject: 'reading', status: 'executing'},\n  {subject: 'programming', status: 'finished'}\n]).then(() => {\n  return Task.update(\n    { status: 'inactive' }, /* set attributes' value */\n    { where: { subject: 'programming' }} /* where criteria */\n  );\n}).then(([affectedCount, affectedRows]) => {\n  // Notice that affectedRows will only be defined in dialects which support returning: true\n\n  // affectedCount will be 2\n  return Task.findAll();\n}).then(tasks => {\n  console.log(tasks) // the 'programming' tasks will both have a status of 'inactive'\n})\n```\n\nAnd delete them:\n\n```js\nTask.bulkCreate([\n  {subject: 'programming', status: 'executing'},\n  {subject: 'reading', status: 'executing'},\n  {subject: 'programming', status: 'finished'}\n]).then(() => {\n  return Task.destroy({\n    where: {\n      subject: 'programming'\n    },\n    truncate: true /* this will ignore where and truncate the table instead */\n  });\n}).then(affectedRows => {\n  // affectedRows will be 2\n  return Task.findAll();\n}).then(tasks => {\n  console.log(tasks) // no programming, just reading :(\n})\n```\n\nIf you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.`bulkCreate()`accepts an options object as the second parameter. The object can have a `fields` parameter, &lpar;an array&rpar; to let it know which fields you want to build explicitly\n\n```js\nUser.bulkCreate([\n  { username: 'foo' },\n  { username: 'bar', admin: true}\n], { fields: ['username'] }).then(() => {\n  // nope bar, you can't be admin!\n})\n```\n\n`bulkCreate` was originally made to be a mainstream&sol;fast way of inserting records&comma; however&comma; sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through&period; You can do by adding a `validate: true` property to the options object.\n\n```js\nclass Tasks extends Model {}\nTasks.init({\n  name: {\n    type: Sequelize.STRING,\n    validate: {\n      notNull: { args: true, msg: 'name cannot be null' }\n    }\n  },\n  code: {\n    type: Sequelize.STRING,\n    validate: {\n      len: [3, 10]\n    }\n  }\n}, { sequelize, modelName: 'tasks' })\n\nTasks.bulkCreate([\n  {name: 'foo', code: '123'},\n  {code: '1234'},\n  {name: 'bar', code: '1'}\n], { validate: true }).catch(errors => {\n  /* console.log(errors) would look like:\n  [\n    { record:\n    ...\n    name: 'SequelizeBulkRecordError',\n    message: 'Validation error',\n    errors:\n      { name: 'SequelizeValidationError',\n        message: 'Validation error',\n        errors: [Object] } },\n    { record:\n      ...\n      name: 'SequelizeBulkRecordError',\n      message: 'Validation error',\n      errors:\n        { name: 'SequelizeValidationError',\n        message: 'Validation error',\n        errors: [Object] } }\n  ]\n  */\n})\n```\n\n## Values of an instance\n\nIf you log an instance you will notice&comma; that there is a lot of additional stuff&period; In order to hide such stuff and reduce it to the very interesting information&comma; you can use the`get`-attribute&period; Calling it with the option `plain` = true will only return the values of an instance&period;\n\n```js\nPerson.create({\n  name: 'Rambow',\n  firstname: 'John'\n}).then(john => {\n  console.log(john.get({\n    plain: true\n  }))\n})\n\n// result:\n\n// { name: 'Rambow',\n//   firstname: 'John',\n//   id: 1,\n//   createdAt: Tue, 01 May 2012 19:12:16 GMT,\n//   updatedAt: Tue, 01 May 2012 19:12:16 GMT\n// }\n```\n\n**Hint&colon;**You can also transform an instance into JSON by using `JSON.stringify(instance)`&period; This will basically return the very same as `values`&period;\n\n## Reloading instances\n\nIf you need to get your instance in sync&comma; you can use the method`reload`&period; It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on&period;\n\n```js\nPerson.findOne({ where: { name: 'john' } }).then(person => {\n  person.name = 'jane'\n  console.log(person.name) // 'jane'\n\n  person.reload().then(() => {\n    console.log(person.name) // 'john'\n  })\n})\n```\n\n## Incrementing\n\nIn order to increment values of an instance without running into concurrency issues&comma; you may use `increment`&period;\n\nFirst of all you can define a field and the value you want to add to it&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.increment('my-integer-field', {by: 2})\n}).then(user => {\n  // Postgres will return the updated user by default (unless disabled by setting { returning: false })\n  // In other dialects, you'll want to call user.reload() to get the updated instance...\n})\n```\n\nSecond&comma; you can define multiple fields and the value you want to add to them&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.increment([ 'my-integer-field', 'my-very-other-field' ], {by: 2})\n}).then(/* ... */)\n```\n\nThird&comma; you can define an object containing fields and its increment values&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.increment({\n    'my-integer-field':    2,\n    'my-very-other-field': 3\n  })\n}).then(/* ... */)\n```\n\n## Decrementing\n\nIn order to decrement values of an instance without running into concurrency issues&comma; you may use `decrement`&period;\n\nFirst of all you can define a field and the value you want to add to it&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.decrement('my-integer-field', {by: 2})\n}).then(user => {\n  // Postgres will return the updated user by default (unless disabled by setting { returning: false })\n  // In other dialects, you'll want to call user.reload() to get the updated instance...\n})\n```\n\nSecond&comma; you can define multiple fields and the value you want to add to them&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.decrement([ 'my-integer-field', 'my-very-other-field' ], {by: 2})\n}).then(/* ... */)\n```\n\nThird&comma; you can define an object containing fields and its decrement values&period;\n\n```js\nUser.findByPk(1).then(user => {\n  return user.decrement({\n    'my-integer-field':    2,\n    'my-very-other-field': 3\n  })\n}).then(/* ... */)\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/associations.md",
    "name": "./docs/manual/associations.md",
    "content": "# Associations\n\nThis section describes the various association types in sequelize. There are four type of\nassociations available in Sequelize\n\n1. BelongsTo\n2. HasOne\n3. HasMany\n4. BelongsToMany\n\n## Basic Concepts\n\n### Source & Target\n\nLet's first begin with a basic concept that you will see used in most associations, **source** and **target** model. Suppose you are trying to add an association between two Models. Here we are adding a `hasOne` association between `User` and `Project`.\n\n```js\nclass User extends Model {}\nUser.init({\n  name: Sequelize.STRING,\n  email: Sequelize.STRING\n}, {\n  sequelize,\n  modelName: 'user'\n});\n\nclass Project extends Model {}\nProject.init({\n  name: Sequelize.STRING\n}, {\n  sequelize,\n  modelName: 'project'\n});\n\nUser.hasOne(Project);\n```\n\n`User` model (the model that the function is being invoked on) is the __source__. `Project` model (the model being passed as an argument) is the __target__.\n\n### Foreign Keys\n\nWhen you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below:\n\n```js\nclass Task extends Model {}\nTask.init({ title: Sequelize.STRING }, { sequelize, modelName: 'task' });\nclass User extends Model {}\nUser.init({ username: Sequelize.STRING }, { sequelize, modelName: 'user' });\n\nUser.hasMany(Task); // Will add userId to Task model\nTask.belongsTo(User); // Will also add userId to Task model\n```\n\nWill generate the following SQL:\n\n```sql\nCREATE TABLE IF NOT EXISTS \"users\" (\n  \"id\" SERIAL,\n  \"username\" VARCHAR(255),\n  \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE TABLE IF NOT EXISTS \"tasks\" (\n  \"id\" SERIAL,\n  \"title\" VARCHAR(255),\n  \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"userId\" INTEGER REFERENCES \"users\" (\"id\") ON DELETE\n  SET\n    NULL ON UPDATE CASCADE,\n    PRIMARY KEY (\"id\")\n);\n```\n\nThe relation between `tasks` and `users` model injects the `userId` foreign key on `tasks` table, and marks it as a reference to the `users` table. By default `userId` will be set to `NULL` if the referenced user is deleted, and updated if the id of the `userId` updated. These options can be overridden by passing `onUpdate` and `onDelete` options to the association calls. The validation options are `RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL`.\n\nFor 1:1 and 1:m associations the default option is `SET NULL` for deletion, and `CASCADE` for updates. For n:m, the default for both is `CASCADE`. This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated.\n\n#### underscored option\n\nSequelize allow setting `underscored` option for Model. When `true` this option will set the\n`field` option on all attributes to the underscored version of its name. This also applies to\nforeign keys generated by associations.\n\nLet's modify last example to use `underscored` option.\n\n```js\nclass Task extends Model {}\nTask.init({\n  title: Sequelize.STRING\n}, {\n  underscored: true,\n  sequelize,\n  modelName: 'task'\n});\n\nclass User extends Model {}\nUser.init({\n  username: Sequelize.STRING\n}, {\n  underscored: true,\n  sequelize,\n  modelName: 'user'\n});\n\n// Will add userId to Task model, but field will be set to `user_id`\n// This means column name will be `user_id`\nUser.hasMany(Task);\n\n// Will also add userId to Task model, but field will be set to `user_id`\n// This means column name will be `user_id`\nTask.belongsTo(User);\n```\n\nWill generate the following SQL:\n\n```sql\nCREATE TABLE IF NOT EXISTS \"users\" (\n  \"id\" SERIAL,\n  \"username\" VARCHAR(255),\n  \"created_at\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updated_at\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE TABLE IF NOT EXISTS \"tasks\" (\n  \"id\" SERIAL,\n  \"title\" VARCHAR(255),\n  \"created_at\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updated_at\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"user_id\" INTEGER REFERENCES \"users\" (\"id\") ON DELETE\n  SET\n    NULL ON UPDATE CASCADE,\n    PRIMARY KEY (\"id\")\n);\n```\n\nWith the underscored option attributes injected to model are still camel cased but `field` option is set to their underscored version.\n\n#### Cyclic dependencies & Disabling constraints\n\nAdding constraints between tables means that tables must be created in the database in a certain order, when using `sequelize.sync`. If `Task` has a reference to `User`, the `users` table must be created before the `tasks` table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has a reference to its current version.\n\n```js\nclass Document extends Model {}\nDocument.init({\n  author: Sequelize.STRING\n}, { sequelize, modelName: 'document' });\nclass Version extends Model {}\nVersion.init({\n  timestamp: Sequelize.DATE\n}, { sequelize, modelName: 'version' });\n\nDocument.hasMany(Version); // This adds documentId attribute to version\nDocument.belongsTo(Version, {\n  as: 'Current',\n  foreignKey: 'currentVersionId'\n}); // This adds currentVersionId attribute to document\n```\n\nHowever, the code above will result in the following error: `Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -> versions => documents`.\n\nIn order to alleviate that, we can pass `constraints: false` to one of the associations:\n\n```js\nDocument.hasMany(Version);\nDocument.belongsTo(Version, {\n  as: 'Current',\n  foreignKey: 'currentVersionId',\n  constraints: false\n});\n```\n\nWhich will allow us to sync the tables correctly:\n\n```sql\nCREATE TABLE IF NOT EXISTS \"documents\" (\n  \"id\" SERIAL,\n  \"author\" VARCHAR(255),\n  \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"currentVersionId\" INTEGER,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE TABLE IF NOT EXISTS \"versions\" (\n  \"id\" SERIAL,\n  \"timestamp\" TIMESTAMP WITH TIME ZONE,\n  \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n  \"documentId\" INTEGER REFERENCES \"documents\" (\"id\") ON DELETE\n  SET\n    NULL ON UPDATE CASCADE,\n    PRIMARY KEY (\"id\")\n);\n```\n\n#### Enforcing a foreign key reference without constraints\n\nSometimes you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them.\n\n```js\nclass Trainer extends Model {}\nTrainer.init({\n  firstName: Sequelize.STRING,\n  lastName: Sequelize.STRING\n}, { sequelize, modelName: 'trainer' });\n\n// Series will have a trainerId = Trainer.id foreign reference key\n// after we call Trainer.hasMany(series)\nclass Series extends Model {}\nSeries.init({\n  title: Sequelize.STRING,\n  subTitle: Sequelize.STRING,\n  description: Sequelize.TEXT,\n  // Set FK relationship (hasMany) with `Trainer`\n  trainerId: {\n    type: Sequelize.INTEGER,\n    references: {\n      model: Trainer,\n      key: 'id'\n    }\n  }\n}, { sequelize, modelName: 'series' });\n\n// Video will have seriesId = Series.id foreign reference key\n// after we call Series.hasOne(Video)\nclass Video extends Model {}\nVideo.init({\n  title: Sequelize.STRING,\n  sequence: Sequelize.INTEGER,\n  description: Sequelize.TEXT,\n  // set relationship (hasOne) with `Series`\n  seriesId: {\n    type: Sequelize.INTEGER,\n    references: {\n      model: Series, // Can be both a string representing the table name or a Sequelize model\n      key: 'id'\n    }\n  }\n}, { sequelize, modelName: 'video' });\n\nSeries.hasOne(Video);\nTrainer.hasMany(Series);\n```\n\n## One-To-One associations\n\nOne-To-One associations are associations between exactly two models connected by a single foreign key.\n\n### BelongsTo\n\nBelongsTo associations are associations where the foreign key for the one-to-one relation exists on the **source model**.\n\nA simple example would be a **Player** being part of a **Team** with the foreign key on the player.\n\n```js\nclass Player extends Model {}\nPlayer.init({/* attributes */}, { sequelize, modelName: 'player' });\nclass Team extends Model {}\nTeam.init({/* attributes */}, { sequelize, modelName: 'team' });\n\nPlayer.belongsTo(Team); // Will add a teamId attribute to Player to hold the primary key value for Team\n```\n\n#### Foreign keys\n\nBy default the foreign key for a belongsTo relation will be generated from the target model name and the target primary key name.\n\nThe default casing is `camelCase`. If the source model is configured with `underscored: true` the foreignKey will be created with field `snake_case`.\n\n```js\nclass User extends Model {}\nUser.init({/* attributes */}, { sequelize, modelName: 'user' })\nclass Company extends Model {}\nCompany.init({/* attributes */}, { sequelize, modelName: 'company' });\n\n// will add companyId to user\nUser.belongsTo(Company);\n\nclass User extends Model {}\nUser.init({/* attributes */}, { underscored: true, sequelize, modelName: 'user' })\nclass Company extends Model {}\nCompany.init({\n  uuid: {\n    type: Sequelize.UUID,\n    primaryKey: true\n  }\n}, { sequelize, modelName: 'company' });\n\n// will add companyUuid to user with field company_uuid\nUser.belongsTo(Company);\n```\n\nIn cases where `as` has been defined it will be used in place of the target model name.\n\n```js\nclass User extends Model {}\nUser.init({/* attributes */}, { sequelize, modelName: 'user' })\nclass UserRole extends Model {}\nUserRole.init({/* attributes */}, { sequelize, modelName: 'userRole' });\n\nUser.belongsTo(UserRole, {as: 'role'}); // Adds roleId to user rather than userRoleId\n```\n\nIn all cases the default foreign key can be overwritten with the `foreignKey` option.\nWhen the foreign key option is used, Sequelize will use it as-is:\n\n```js\nclass User extends Model {}\nUser.init({/* attributes */}, { sequelize, modelName: 'user' })\nclass Company extends Model {}\nCompany.init({/* attributes */}, { sequelize, modelName: 'company' });\n\nUser.belongsTo(Company, {foreignKey: 'fk_company'}); // Adds fk_company to User\n```\n\n#### Target keys\n\nThe target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the `targetKey` option.\n\n```js\nclass User extends Model {}\nUser.init({/* attributes */}, { sequelize, modelName: 'user' })\nclass Company extends Model {}\nCompany.init({/* attributes */}, { sequelize, modelName: 'company' });\n\nUser.belongsTo(Company, {foreignKey: 'fk_companyname', targetKey: 'name'}); // Adds fk_companyname to User\n```\n\n### HasOne\n\nHasOne associations are associations where the foreign key for the one-to-one relation exists on the **target model**.\n\n```js\nclass User extends Model {}\nUser.init({/* ... */}, { sequelize, modelName: 'user' })\nclass Project extends Model {}\nProject.init({/* ... */}, { sequelize, modelName: 'project' })\n\n// One-way associations\nProject.hasOne(User)\n\n/*\n  In this example hasOne will add an attribute projectId to the User model!\n  Furthermore, Project.prototype will gain the methods getUser and setUser according\n  to the first parameter passed to define. If you have underscore style\n  enabled, the added attribute will be project_id instead of projectId.\n\n  The foreign key will be placed on the users table.\n\n  You can also define the foreign key, e.g. if you already have an existing\n  database and want to work on it:\n*/\n\nProject.hasOne(User, { foreignKey: 'initiator_id' })\n\n/*\n  Because Sequelize will use the model's name (first parameter of define) for\n  the accessor methods, it is also possible to pass a special option to hasOne:\n*/\n\nProject.hasOne(User, { as: 'Initiator' })\n// Now you will get Project.getInitiator and Project.setInitiator\n\n// Or let's define some self references\nclass Person extends Model {}\nPerson.init({ /* ... */}, { sequelize, modelName: 'person' })\n\nPerson.hasOne(Person, {as: 'Father'})\n// this will add the attribute FatherId to Person\n\n// also possible:\nPerson.hasOne(Person, {as: 'Father', foreignKey: 'DadId'})\n// this will add the attribute DadId to Person\n\n// In both cases you will be able to do:\nPerson.setFather\nPerson.getFather\n\n// If you need to join a table twice you can double join the same table\nTeam.hasOne(Game, {as: 'HomeTeam', foreignKey : 'homeTeamId'});\nTeam.hasOne(Game, {as: 'AwayTeam', foreignKey : 'awayTeamId'});\n\nGame.belongsTo(Team);\n```\n\nEven though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target.\n\n#### Source keys\n\nThe source key is the attribute on the source model that the foreign key attribute on the target model points to. By default the source key for a `hasOne` relation will be the source model's primary attribute. To use a custom attribute, use the `sourceKey` option.\n\n```js\nclass User extends Model {}\nUser.init({/* attributes */}, { sequelize, modelName: 'user' })\nclass Company extends Model {}\nCompany.init({/* attributes */}, { sequelize, modelName: 'company' });\n\n// Adds companyName attribute to User\n// Use name attribute from Company as source attribute\nCompany.hasOne(User, {foreignKey: 'companyName', sourceKey: 'name'});\n```\n\n### Difference between HasOne and BelongsTo\n\nIn Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example.\n\nSuppose we have two tables to link **Player** and **Team**. Lets define their models.\n\n```js\nclass Player extends Model {}\nPlayer.init({/* attributes */}, { sequelize, modelName: 'player' })\nclass Team extends Model {}\nTeam.init({/* attributes */}, { sequelize, modelName: 'team' });\n```\n\nWhen we link two models in Sequelize we can refer them as pairs of **source** and **target** models. Like this\n\nHaving **Player** as the **source** and **Team** as the **target**\n\n```js\nPlayer.belongsTo(Team);\n//Or\nPlayer.hasOne(Team);\n```\n\nHaving **Team** as the **source** and **Player** as the **target**\n\n```js\nTeam.belongsTo(Player);\n//Or\nTeam.hasOne(Player);\n```\n\nHasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in **target** model whereas BelongsTo inserts the association key in the **source** model.\n\nHere is an example demonstrating use cases of BelongsTo and HasOne.\n\n```js\nclass Player extends Model {}\nPlayer.init({/* attributes */}, { sequelize, modelName: 'player' })\nclass Coach extends Model {}\nCoach.init({/* attributes */}, { sequelize, modelName: 'coach' })\nclass Team extends Model {}\nTeam.init({/* attributes */}, { sequelize, modelName: 'team' });\n```\n\nSuppose our `Player` model has information about its team as `teamId` column. Information about each Team's `Coach` is stored in the `Team` model as `coachId` column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time.\n\nWhen information about association is present in **source** model we can use `belongsTo`. In this case `Player` is suitable for `belongsTo` because it has `teamId` column.\n\n```js\nPlayer.belongsTo(Team)  // `teamId` will be added on Player / Source model\n```\n\nWhen information about association is present in **target** model we can use `hasOne`. In this case `Coach` is suitable for `hasOne` because `Team` model store information about its `Coach` as `coachId` field.\n\n```js\nCoach.hasOne(Team)  // `coachId` will be added on Team / Target model\n```\n\n## One-To-Many associations (hasMany)\n\nOne-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source.\n\n```js\nclass User extends Model {}\nUser.init({/* ... */}, { sequelize, modelName: 'user' })\nclass Project extends Model {}\nProject.init({/* ... */}, { sequelize, modelName: 'project' })\n\n// OK. Now things get more complicated (not really visible to the user :)).\n// First let's define a hasMany association\nProject.hasMany(User, {as: 'Workers'})\n```\n\nThis will add the attribute `projectId` to User. Depending on your setting for underscored the column in the table will either be called `projectId` or `project_id`. Instances of Project will get the accessors `getWorkers` and `setWorkers`.\n\nSometimes you may need to associate records on different columns, you may use `sourceKey` option:\n\n```js\nclass City extends Model {}\nCity.init({ countryCode: Sequelize.STRING }, { sequelize, modelName: 'city' });\nclass Country extends Model {}\nCountry.init({ isoCode: Sequelize.STRING }, { sequelize, modelName: 'country' });\n\n// Here we can connect countries and cities base on country code\nCountry.hasMany(City, {foreignKey: 'countryCode', sourceKey: 'isoCode'});\nCity.belongsTo(Country, {foreignKey: 'countryCode', targetKey: 'isoCode'});\n```\n\nSo far we dealt with a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section.\n\n## Belongs-To-Many associations\n\nBelongs-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources.\n\n```js\nProject.belongsToMany(User, {through: 'UserProject'});\nUser.belongsToMany(Project, {through: 'UserProject'});\n```\n\nThis will create a new model called UserProject with the equivalent foreign keys `projectId` and `userId`. Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project).\n\nDefining `through` is **required**. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups.\n\nThis will add methods `getUsers`, `setUsers`, `addUser`,`addUsers` to `Project`, and `getProjects`, `setProjects`, `addProject`, and `addProjects` to `User`.\n\nSometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias (`as`) option. We will also manually define the foreign keys to use:\n\n```js\nUser.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId' })\nProject.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' })\n```\n\n`foreignKey` will allow you to set **source model** key in the **through** relation.\n`otherKey` will allow you to set **target model** key in the **through** relation.\n\n```js\nUser.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'})\n```\n\nOf course you can also define self references with belongsToMany:\n\n```js\nPerson.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' })\n// This will create the table PersonChildren which stores the ids of the objects.\n\n```\n\n#### Source and target keys\n\nIf you want to create a belongs to many relationship that does not use the default primary key some setup work is required.\nYou must set the `sourceKey` (optionally `targetKey`) appropriately for the two ends of the belongs to many. Further you must also ensure you have appropriate indexes created on your relationships. For example:\n\n```js\nconst User = this.sequelize.define('User', {\n  id: {\n    type: DataTypes.UUID,\n    allowNull: false,\n    primaryKey: true,\n    defaultValue: DataTypes.UUIDV4,\n    field: 'user_id'\n  },\n  userSecondId: {\n    type: DataTypes.UUID,\n    allowNull: false,\n    defaultValue: DataTypes.UUIDV4,\n    field: 'user_second_id'\n  }\n}, {\n  tableName: 'tbl_user',\n  indexes: [\n    {\n      unique: true,\n      fields: ['user_second_id']\n    }\n  ]\n});\n\nconst Group = this.sequelize.define('Group', {\n  id: {\n    type: DataTypes.UUID,\n    allowNull: false,\n    primaryKey: true,\n    defaultValue: DataTypes.UUIDV4,\n    field: 'group_id'\n  },\n  groupSecondId: {\n    type: DataTypes.UUID,\n    allowNull: false,\n    defaultValue: DataTypes.UUIDV4,\n    field: 'group_second_id'\n  }\n}, {\n  tableName: 'tbl_group',\n  indexes: [\n    {\n      unique: true,\n      fields: ['group_second_id']\n    }\n  ]\n});\n\nUser.belongsToMany(Group, {\n  through: 'usergroups',\n  sourceKey: 'userSecondId'\n});\nGroup.belongsToMany(User, {\n  through: 'usergroups',\n  sourceKey: 'groupSecondId'\n});\n```\n\nIf you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one:\n\n```js\nclass User extends Model {}\nUser.init({}, { sequelize, modelName: 'user' })\nclass Project extends Model {}\nProject.init({}, { sequelize, modelName: 'project' })\nclass UserProjects extends Model {}\nUserProjects.init({\n  status: DataTypes.STRING\n}, { sequelize, modelName: 'userProjects' })\n\nUser.belongsToMany(Project, { through: UserProjects })\nProject.belongsToMany(User, { through: UserProjects })\n```\n\nTo add a new project to a user and set its status, you pass extra `options.through` to the setter, which contains the attributes for the join table\n\n```js\nuser.addProject(project, { through: { status: 'started' }})\n```\n\nBy default the code above will add projectId and userId to the UserProjects table, and _remove any previously defined primary key attribute_ - the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the `UserProjects` model you can add it manually.\n\n```js\nclass UserProjects extends Model {}\nUserProjects.init({\n  id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  status: DataTypes.STRING\n}, { sequelize, modelName: 'userProjects' })\n```\n\nWith Belongs-To-Many you can query based on **through** relation and select specific attributes. For example using `findAll` with **through**\n\n```js\nUser.findAll({\n  include: [{\n    model: Project,\n    through: {\n      attributes: ['createdAt', 'startedAt', 'finishedAt'],\n      where: {completed: true}\n    }\n  }]\n});\n```\n\nBelongs-To-Many creates a unique key when primary key is not present on through model. This unique key name can be overridden using **uniqueKey** option.\n\n```js\nProject.belongsToMany(User, { through: UserProjects, uniqueKey: 'my_custom_unique' })\n```\n\n## Naming strategy\n\nBy default sequelize will use the model name (the name passed to `sequelize.define`) to figure out the name of the model when used in associations. For example, a model named `user` will add the functions `get/set/add User` to instances of the associated model, and a property named `.user` in eager loading, while a model named `User` will add the same functions, but a property named `.User` (notice the upper case U) in eager loading.\n\nAs we've already seen, you can alias models in associations using `as`. In single associations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the [inflection][0] library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias:\n\n```js\nUser.belongsToMany(Project, { as: { singular: 'task', plural: 'tasks' }})\n// Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes.\n```\n\nIf you know that a model will always use the same alias in associations, you can provide it when creating the model\n\n```js\nclass Project extends Model {}\nProject.init(attributes, {\n  name: {\n    singular: 'task',\n    plural: 'tasks',\n  },\n  sequelize,\n  modelName: 'project'\n})\n\nUser.belongsToMany(Project);\n```\n\nThis will add the functions `add/set/get Tasks` to user instances.\n\nRemember, that using `as` to change the name of the association will also change the name of the foreign key. When using `as`, it is safest to also specify the foreign key.\n\n```js\nInvoice.belongsTo(Subscription)\nSubscription.hasMany(Invoice)\n```\n\nWithout `as`, this adds `subscriptionId` as expected. However, if you were to say `Invoice.belongsTo(Subscription, { as: 'TheSubscription' })`, you will have both `subscriptionId` and `theSubscriptionId`, because sequelize is not smart enough to figure that the calls are two sides of the same relation. 'foreignKey' fixes this problem;\n\n```js\nInvoice.belongsTo(Subscription, { as: 'TheSubscription', foreignKey: 'subscription_id' })\nSubscription.hasMany(Invoice, { foreignKey: 'subscription_id' })\n```\n\n## Associating objects\n\nBecause Sequelize is doing a lot of magic, you have to call `Sequelize.sync` after setting the associations! Doing so will allow you the following:\n\n```js\nProject.hasMany(Task)\nTask.belongsTo(Project)\n\nProject.create()...\nTask.create()...\nTask.create()...\n\n// save them... and then:\nproject.setTasks([task1, task2]).then(() => {\n  // saved!\n})\n\n// ok, now they are saved... how do I get them later on?\nproject.getTasks().then(associatedTasks => {\n  // associatedTasks is an array of tasks\n})\n\n// You can also pass filters to the getter method.\n// They are equal to the options you can pass to a usual finder method.\nproject.getTasks({ where: 'id > 10' }).then(tasks => {\n  // tasks with an id greater than 10 :)\n})\n\n// You can also only retrieve certain fields of a associated object.\nproject.getTasks({attributes: ['title']}).then(tasks => {\n  // retrieve tasks with the attributes \"title\" and \"id\"\n})\n```\n\nTo remove created associations you can just call the set method without a specific id:\n\n```js\n// remove the association with task1\nproject.setTasks([task2]).then(associatedTasks => {\n  // you will get task2 only\n})\n\n// remove 'em all\nproject.setTasks([]).then(associatedTasks => {\n  // you will get an empty array\n})\n\n// or remove 'em more directly\nproject.removeTask(task1).then(() => {\n  // it's gone\n})\n\n// and add 'em again\nproject.addTask(task1).then(() => {\n  // it's back again\n})\n```\n\nYou can of course also do it vice versa:\n\n```js\n// project is associated with task1 and task2\ntask2.setProject(null).then(() => {\n  // and it's gone\n})\n```\n\nFor hasOne/belongsTo it's basically the same:\n\n```js\nTask.hasOne(User, {as: \"Author\"})\nTask.setAuthor(anAuthor)\n```\n\nAdding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter):\n\n```js\n// Either by adding a property with the name of the join table model to the object, before creating the association\nproject.UserProjects = {\n  status: 'active'\n}\nu.addProject(project)\n\n// Or by providing a second options.through argument when adding the association, containing the data that should go in the join table\nu.addProject(project, { through: { status: 'active' }})\n\n\n// When associating multiple objects, you can combine the two options above. In this case the second argument\n// will be treated as a defaults object, that will be used if no data is provided\nproject1.UserProjects = {\n    status: 'inactive'\n}\n\nu.setProjects([project1, project2], { through: { status: 'active' }})\n// The code above will record inactive for project one, and active for project two in the join table\n```\n\nWhen getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance:\n\n```js\nu.getProjects().then(projects => {\n  const project = projects[0]\n\n  if (project.UserProjects.status === 'active') {\n    // .. do magic\n\n    // since this is a real DAO instance, you can save it directly after you are done doing magic\n    return project.UserProjects.save()\n  }\n})\n```\n\nIf you only need some of the attributes from the join table, you can provide an array with the attributes you want:\n\n```js\n// This will select only name from the Projects table, and only status from the UserProjects table\nuser.getProjects({ attributes: ['name'], joinTableAttributes: ['status']})\n```\n\n## Check associations\n\nYou can also check if an object is already associated with another one (N:M only). Here is how you'd do it:\n\n```js\n// check if an object is one of associated ones:\nProject.create({ /* */ }).then(project => {\n  return User.create({ /* */ }).then(user => {\n    return project.hasUser(user).then(result => {\n      // result would be false\n      return project.addUser(user).then(() => {\n        return project.hasUser(user).then(result => {\n          // result would be true\n        })\n      })\n    })\n  })\n})\n\n// check if all associated objects are as expected:\n// let's assume we have already a project and two users\nproject.setUsers([user1, user2]).then(() => {\n  return project.hasUsers([user1]);\n}).then(result => {\n  // result would be true\n  return project.hasUsers([user1, user2]);\n}).then(result => {\n  // result would be true\n})\n```\n\n## Advanced Concepts\n\n### Scopes\n\nThis section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see [Scopes](scopes.html).\n\nAssociation scopes allow you to place a scope (a set of default attributes for `get` and `create`) on the association. Scopes can be placed both on the associated model (the target of the association), and on the through table for n:m relations.\n\n#### 1:n\n\nAssume we have models Comment, Post, and Image. A comment can be associated to either an image or a post via `commentableId` and `commentable` - we say that Post and Image are `Commentable`\n\n```js\nclass Post extends Model {}\nPost.init({\n  title: Sequelize.STRING,\n  text: Sequelize.STRING\n}, { sequelize, modelName: 'post' });\n\nclass Image extends Model {}\nImage.init({\n  title: Sequelize.STRING,\n  link: Sequelize.STRING\n}, { sequelize, modelName: 'image' });\n\nclass Comment extends Model {\n  getItem(options) {\n    return this[\n      'get' +\n        this.get('commentable')\n          [0]\n          .toUpperCase() +\n        this.get('commentable').substr(1)\n    ](options);\n  }\n}\n\nComment.init({\n  title: Sequelize.STRING,\n  commentable: Sequelize.STRING,\n  commentableId: Sequelize.INTEGER\n}, { sequelize, modelName: 'comment' });\n\nPost.hasMany(Comment, {\n  foreignKey: 'commentableId',\n  constraints: false,\n  scope: {\n    commentable: 'post'\n  }\n});\n\nComment.belongsTo(Post, {\n  foreignKey: 'commentableId',\n  constraints: false,\n  as: 'post'\n});\n\nImage.hasMany(Comment, {\n  foreignKey: 'commentableId',\n  constraints: false,\n  scope: {\n    commentable: 'image'\n  }\n});\n\nComment.belongsTo(Image, {\n  foreignKey: 'commentableId',\n  constraints: false,\n  as: 'image'\n});\n```\n\n`constraints: false` disables references constraints, as `commentableId` column references several tables, we cannot add a `REFERENCES` constraint to it.\n\nNote that the Image -> Comment and Post -> Comment relations define a scope, `commentable: 'image'` and `commentable: 'post'` respectively. This scope is automatically applied when using the association functions:\n\n```js\nimage.getComments()\n// SELECT \"id\", \"title\", \"commentable\", \"commentableId\", \"createdAt\", \"updatedAt\" FROM \"comments\" AS\n// \"comment\" WHERE \"comment\".\"commentable\" = 'image' AND \"comment\".\"commentableId\" = 1;\n\nimage.createComment({\n  title: 'Awesome!'\n})\n// INSERT INTO \"comments\" (\"id\",\"title\",\"commentable\",\"commentableId\",\"createdAt\",\"updatedAt\") VALUES\n// (DEFAULT,'Awesome!','image',1,'2018-04-17 05:36:40.454 +00:00','2018-04-17 05:36:40.454 +00:00')\n// RETURNING *;\n\nimage.addComment(comment);\n// UPDATE \"comments\" SET \"commentableId\"=1,\"commentable\"='image',\"updatedAt\"='2018-04-17 05:38:43.948\n// +00:00' WHERE \"id\" IN (1)\n```\n\nThe `getItem` utility function on `Comment` completes the picture - it simply converts the `commentable` string into a call to either `getImage` or `getPost`, providing an abstraction over whether a comment belongs to a post or an image. You can pass a normal options object as a parameter to `getItem(options)` to specify any where conditions or includes.\n\n#### n:m\n\nContinuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items.\n\nFor brevity, the example only shows a Post model, but in reality Tag would be related to several other models.\n\n```js\nclass ItemTag extends Model {}\nItemTag.init({\n  id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  tagId: {\n    type: Sequelize.INTEGER,\n    unique: 'item_tag_taggable'\n  },\n  taggable: {\n    type: Sequelize.STRING,\n    unique: 'item_tag_taggable'\n  },\n  taggableId: {\n    type: Sequelize.INTEGER,\n    unique: 'item_tag_taggable',\n    references: null\n  }\n}, { sequelize, modelName: 'item_tag' });\n\nclass Tag extends Model {}\nTag.init({\n  name: Sequelize.STRING,\n  status: Sequelize.STRING\n}, { sequelize, modelName: 'tag' });\n\nPost.belongsToMany(Tag, {\n  through: {\n    model: ItemTag,\n    unique: false,\n    scope: {\n      taggable: 'post'\n    }\n  },\n  foreignKey: 'taggableId',\n  constraints: false\n});\n\nTag.belongsToMany(Post, {\n  through: {\n    model: ItemTag,\n    unique: false\n  },\n  foreignKey: 'tagId',\n  constraints: false\n});\n```\n\nNotice that the scoped column (`taggable`) is now on the through model (`ItemTag`).\n\nWe could also define a more restrictive association, for example, to get all pending tags for a post by applying a scope of both the through model (`ItemTag`) and the target model (`Tag`):\n\n```js\nPost.belongsToMany(Tag, {\n  through: {\n    model: ItemTag,\n    unique: false,\n    scope: {\n      taggable: 'post'\n    }\n  },\n  scope: {\n    status: 'pending'\n  },\n  as: 'pendingTags',\n  foreignKey: 'taggableId',\n  constraints: false\n});\n\npost.getPendingTags();\n```\n\n```sql\nSELECT\n  \"tag\".\"id\",\n  \"tag\".\"name\",\n  \"tag\".\"status\",\n  \"tag\".\"createdAt\",\n  \"tag\".\"updatedAt\",\n  \"item_tag\".\"id\" AS \"item_tag.id\",\n  \"item_tag\".\"tagId\" AS \"item_tag.tagId\",\n  \"item_tag\".\"taggable\" AS \"item_tag.taggable\",\n  \"item_tag\".\"taggableId\" AS \"item_tag.taggableId\",\n  \"item_tag\".\"createdAt\" AS \"item_tag.createdAt\",\n  \"item_tag\".\"updatedAt\" AS \"item_tag.updatedAt\"\nFROM\n  \"tags\" AS \"tag\"\n  INNER JOIN \"item_tags\" AS \"item_tag\" ON \"tag\".\"id\" = \"item_tag\".\"tagId\"\n  AND \"item_tag\".\"taggableId\" = 1\n  AND \"item_tag\".\"taggable\" = 'post'\nWHERE\n  (\"tag\".\"status\" = 'pending');\n```\n\n`constraints: false` disables references constraints on the `taggableId` column. Because the column is polymorphic, we cannot say that it `REFERENCES` a specific table.\n\n### Creating with associations\n\nAn instance can be created with nested association in one step, provided all elements are new.\n\n#### BelongsTo / HasMany / HasOne association\n\nConsider the following models:\n\n```js\nclass Product extends Model {}\nProduct.init({\n  title: Sequelize.STRING\n}, { sequelize, modelName: 'product' });\nclass User extends Model {}\nUser.init({\n  firstName: Sequelize.STRING,\n  lastName: Sequelize.STRING\n}, { sequelize, modelName: 'user' });\nclass Address extends Model {}\nAddress.init({\n  type: Sequelize.STRING,\n  line1: Sequelize.STRING,\n  line2: Sequelize.STRING,\n  city: Sequelize.STRING,\n  state: Sequelize.STRING,\n  zip: Sequelize.STRING,\n}, { sequelize, modelName: 'address' });\n\nProduct.User = Product.belongsTo(User);\nUser.Addresses = User.hasMany(Address);\n// Also works for `hasOne`\n```\n\nA new `Product`, `User`, and one or more `Address` can be created in one step in the following way:\n\n```js\nreturn Product.create({\n  title: 'Chair',\n  user: {\n    firstName: 'Mick',\n    lastName: 'Broadstone',\n    addresses: [{\n      type: 'home',\n      line1: '100 Main St.',\n      city: 'Austin',\n      state: 'TX',\n      zip: '78704'\n    }]\n  }\n}, {\n  include: [{\n    association: Product.User,\n    include: [ User.Addresses ]\n  }]\n});\n```\n\nHere, our user model is called `user`, with a lowercase u - This means that the property in the object should also be `user`. If the name given to `sequelize.define` was `User`, the key in the object should also be `User`. Likewise for `addresses`, except it's pluralized being a `hasMany` association.\n\n#### BelongsTo association with an alias\n\nThe previous example can be extended to support an association alias.\n\n```js\nconst Creator = Product.belongsTo(User, { as: 'creator' });\n\nreturn Product.create({\n  title: 'Chair',\n  creator: {\n    firstName: 'Matt',\n    lastName: 'Hansen'\n  }\n}, {\n  include: [ Creator ]\n});\n```\n\n#### HasMany / BelongsToMany association\n\nLet's introduce the ability to associate a product with many tags. Setting up the models could look like:\n\n```js\nclass Tag extends Model {}\nTag.init({\n  name: Sequelize.STRING\n}, { sequelize, modelName: 'tag' });\n\nProduct.hasMany(Tag);\n// Also works for `belongsToMany`.\n```\n\nNow we can create a product with multiple tags in the following way:\n\n```js\nProduct.create({\n  id: 1,\n  title: 'Chair',\n  tags: [\n    { name: 'Alpha'},\n    { name: 'Beta'}\n  ]\n}, {\n  include: [ Tag ]\n})\n```\n\nAnd, we can modify this example to support an alias as well:\n\n```js\nconst Categories = Product.hasMany(Tag, { as: 'categories' });\n\nProduct.create({\n  id: 1,\n  title: 'Chair',\n  categories: [\n    { id: 1, name: 'Alpha' },\n    { id: 2, name: 'Beta' }\n  ]\n}, {\n  include: [{\n    association: Categories,\n    as: 'categories'\n  }]\n})\n```\n\n***\n\n[0]: https://www.npmjs.org/package/inflection\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/raw-queries.md",
    "name": "./docs/manual/raw-queries.md",
    "content": "# Raw queries\n\nAs there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can use the function `sequelize.query`.\n\nBy default the function will return two arguments - a results array, and an object containing metadata (affected rows etc.). Note that since this is a raw query, the metadata (property names etc.) is dialect specific. Some dialects return the metadata \"within\" the results object (as properties on an array). However, two arguments will always be returned, but for MSSQL and MySQL it will be two references to the same object.\n\n```js\nsequelize.query(\"UPDATE users SET y = 42 WHERE x = 12\").then(([results, metadata]) => {\n  // Results will be an empty array and metadata will contain the number of affected rows.\n})\n```\n\nIn cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:\n\n```js\nsequelize.query(\"SELECT * FROM `users`\", { type: sequelize.QueryTypes.SELECT})\n  .then(users => {\n    // We don't need spread here, since only the results will be returned for select queries\n  })\n```\n\nSeveral other query types are available. [Peek into the source for details](https://github.com/sequelize/sequelize/blob/master/lib/query-types.js)\n\nA second option is the model. If you pass a model the returned data will be instances of that model.\n\n```js\n// Callee is the model definition. This allows you to easily map a query to a predefined model\nsequelize\n  .query('SELECT * FROM projects', {\n    model: Projects,\n    mapToModel: true // pass true here if you have any mapped fields\n  })\n  .then(projects => {\n    // Each record will now be an instance of Project\n  })\n```\n\nSee more options in the [query API reference](../class/lib/sequelize.js~Sequelize.html#instance-method-query). Some examples below:\n\n```js\nsequelize.query('SELECT 1', {\n  // A function (or false) for logging your queries\n  // Will get called for every SQL query that gets sent\n  // to the server.\n  logging: console.log,\n\n  // If plain is true, then sequelize will only return the first\n  // record of the result set. In case of false it will return all records.\n  plain: false,\n\n  // Set this to true if you don't have a model definition for your query.\n  raw: false,\n\n  // The type of query you are executing. The query type affects how results are formatted before they are passed back.\n  type: Sequelize.QueryTypes.SELECT\n})\n\n// Note the second argument being null!\n// Even if we declared a callee here, the raw: true would\n// supersede and return a raw object.\nsequelize\n  .query('SELECT * FROM projects', { raw: true })\n  .then(projects => {\n    console.log(projects)\n  })\n```\n\n## \"Dotted\" attributes\n\nIf an attribute name of the table contains dots, the resulting objects will be nested. This is due to the usage of [dottie.js](https://github.com/mickhansen/dottie.js/) under the hood. See below:\n\n```js\nsequelize.query('select 1 as `foo.bar.baz`').then(rows => {\n  console.log(JSON.stringify(rows))\n})\n```\n\n```json\n[{\n  \"foo\": {\n    \"bar\": {\n      \"baz\": 1\n    }\n  }\n}]\n```\n\n## Replacements\n\nReplacements in a query can be done in two different ways, either using named parameters (starting with `:`), or unnamed, represented by a `?`. Replacements are passed in the options object.\n\n* If an array is passed, `?` will be replaced in the order that they appear in the array\n* If an object is passed, `:key` will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.\n\n```js\nsequelize.query('SELECT * FROM projects WHERE status = ?',\n  { replacements: ['active'], type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n\nsequelize.query('SELECT * FROM projects WHERE status = :status ',\n  { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n```\n\nArray replacements will automatically be handled, the following query searches for projects where the status matches an array of values.\n\n```js\nsequelize.query('SELECT * FROM projects WHERE status IN(:status) ',\n  { replacements: { status: ['active', 'inactive'] }, type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n```\n\nTo use the wildcard operator %, append it to your replacement. The following query matches users with names that start with 'ben'.\n\n```js\nsequelize.query('SELECT * FROM users WHERE name LIKE :search_name ',\n  { replacements: { search_name: 'ben%'  }, type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n```\n\n## Bind Parameter\n\nBind parameters are like replacements. Except replacements are escaped and inserted into the query by sequelize before the query is sent to the database, while bind parameters are sent to the database outside the SQL query text. A query can have either bind parameters or replacements. Bind parameters are referred to by either $1, $2, ... (numeric) or $key (alpha-numeric). This is independent of the dialect.\n\n* If an array is passed, `$1` is bound to the 1st element in the array (`bind[0]`)\n* If an object is passed, `$key` is bound to `object['key']`. Each key must begin with a non-numeric char. `$1` is not a valid key, even if `object['1']` exists.\n* In either case `$$` can be used to escape a literal `$` sign.\n\nThe array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter.\n\nThe database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context `$1::varchar`.\n\n```js\nsequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1',\n  { bind: ['active'], type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n\nsequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status',\n  { bind: { status: 'active' }, type: sequelize.QueryTypes.SELECT }\n).then(projects => {\n  console.log(projects)\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/transactions.md",
    "name": "./docs/manual/transactions.md",
    "content": "# Transactions\n\nSequelize supports two ways of using transactions:\n\n1. **Managed**, One which will automatically commit or rollback the transaction based on the result of a promise chain and, (if CLS enabled) pass the transaction to all calls within the callback\n2. **Unmanaged**, One which leaves committing, rolling back and passing the transaction to the user\n\nThe key difference is that the managed transaction uses a callback that expects a promise to be returned to it while the unmanaged transaction returns a promise.\n\n## Managed transaction (auto-callback)\n\nManaged transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to `sequelize.transaction`.\n\nNotice how the callback passed to `transaction` returns a promise chain, and does not explicitly call `t.commit()` nor `t.rollback()`. If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back.\n\n```js\nreturn sequelize.transaction(t => {\n\n  // chain all your queries here. make sure you return them.\n  return User.create({\n    firstName: 'Abraham',\n    lastName: 'Lincoln'\n  }, {transaction: t}).then(user => {\n    return user.setShooter({\n      firstName: 'John',\n      lastName: 'Boothe'\n    }, {transaction: t});\n  });\n\n}).then(result => {\n  // Transaction has been committed\n  // result is whatever the result of the promise chain returned to the transaction callback\n}).catch(err => {\n  // Transaction has been rolled back\n  // err is whatever rejected the promise chain returned to the transaction callback\n});\n```\n\n### Throw errors to rollback\n\nWhen using the managed transaction you should _never_ commit or rollback the transaction manually. If all queries are successful, but you still want to rollback the transaction (for example because of a validation failure) you should throw an error to break and reject the chain:\n\n```js\nreturn sequelize.transaction(t => {\n  return User.create({\n    firstName: 'Abraham',\n    lastName: 'Lincoln'\n  }, {transaction: t}).then(user => {\n    // Woops, the query was successful but we still want to roll back!\n    throw new Error();\n  });\n});\n```\n\n### Automatically pass transactions to all queries\n\nIn the examples above, the transaction is still manually passed, by passing `{ transaction: t }` as the second argument. To automatically pass the transaction to all queries you must install the [continuation local storage](https://github.com/othiym23/node-continuation-local-storage) (CLS) module and instantiate a namespace in your own code:\n\n```js\nconst cls = require('continuation-local-storage');\nconst namespace = cls.createNamespace('my-very-own-namespace');\n```\n\nTo enable CLS you must tell sequelize which namespace to use by using a static method of the sequelize constructor:\n\n```js\nconst Sequelize = require('sequelize');\nSequelize.useCLS(namespace);\n\nnew Sequelize(....);\n```\n\nNotice, that the `useCLS()` method is on the *constructor*, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.\n\nCLS works like a thread-local storage for callbacks. What this means in practice is that different callback chains can access local variables by using the CLS namespace. When CLS is enabled sequelize will set the `transaction` property on the namespace when a new transaction is created. Since variables set within a callback chain are private to that chain several concurrent transactions can exist at the same time:\n\n```js\nsequelize.transaction((t1) => {\n  namespace.get('transaction') === t1; // true\n});\n\nsequelize.transaction((t2) => {\n  namespace.get('transaction') === t2; // true\n});\n```\n\nIn most case you won't need to access `namespace.get('transaction')` directly, since all queries will automatically look for a transaction on the namespace:\n\n```js\nsequelize.transaction((t1) => {\n  // With CLS enabled, the user will be created inside the transaction\n  return User.create({ name: 'Alice' });\n});\n```\n\nAfter you've used `Sequelize.useCLS()` all promises returned from sequelize will be patched to maintain CLS context. CLS is a complicated subject - more details in the docs for [cls-bluebird](https://www.npmjs.com/package/cls-bluebird), the patch used to make bluebird promises work with CLS.\n\n**Note:** _[CLS only supports async/await, at the moment, when using cls-hooked package](https://github.com/othiym23/node-continuation-local-storage/issues/98#issuecomment-323503807). Although, [cls-hooked](https://github.com/Jeff-Lewis/cls-hooked/blob/master/README.md) relies on *experimental API* [async_hooks](https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md)_\n\n## Concurrent/Partial transactions\n\nYou can have concurrent transactions within a sequence of queries or have some of them excluded from any transactions. Use the `{transaction: }` option to control which transaction a query belong to:\n\n**Warning:** _SQLite does not support more than one transaction at the same time._\n\n### Without CLS enabled\n\n```js\nsequelize.transaction((t1) => {\n  return sequelize.transaction((t2) => {\n    // With CLS enable, queries here will by default use t2\n    // Pass in the `transaction` option to define/alter the transaction they belong to.\n    return Promise.all([\n        User.create({ name: 'Bob' }, { transaction: null }),\n        User.create({ name: 'Mallory' }, { transaction: t1 }),\n        User.create({ name: 'John' }) // this would default to t2\n    ]);\n  });\n});\n```\n\n## Isolation levels\n\nThe possible isolations levels to use when starting a transaction:\n\n```js\nSequelize.Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // \"READ UNCOMMITTED\"\nSequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED // \"READ COMMITTED\"\nSequelize.Transaction.ISOLATION_LEVELS.REPEATABLE_READ  // \"REPEATABLE READ\"\nSequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE // \"SERIALIZABLE\"\n```\n\nBy default, sequelize uses the isolation level of the database. If you want to use a different isolation level, pass in the desired level as the first argument:\n\n```js\nreturn sequelize.transaction({\n  isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE\n  }, (t) => {\n\n  // your transactions\n\n  });\n```\n\nThe `isolationLevel` can either be set globally when initializing the Sequelize instance or\nlocally for every transaction:\n\n```js\n// globally\nnew Sequelize('db', 'user', 'pw', {\n  isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE\n});\n\n// locally\nsequelize.transaction({\n  isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE\n});\n```\n\n**Note:** _The SET ISOLATION LEVEL queries are not logged in case of MSSQL as the specified isolationLevel is passed directly to tedious_\n\n## Unmanaged transaction (then-callback)\n\nUnmanaged transactions force you to manually rollback or commit the transaction. If you don't do that, the transaction will hang until it times out. To start an unmanaged transaction, call `sequelize.transaction()` without a callback (you can still pass an options object) and call `then` on the returned promise. Notice that `commit()` and `rollback()` returns a promise.\n\n```js\nreturn sequelize.transaction().then(t => {\n  return User.create({\n    firstName: 'Bart',\n    lastName: 'Simpson'\n  }, {transaction: t}).then(user => {\n    return user.addSibling({\n      firstName: 'Lisa',\n      lastName: 'Simpson'\n    }, {transaction: t});\n  }).then(() => {\n    return t.commit();\n  }).catch((err) => {\n    return t.rollback();\n  });\n});\n```\n\n## Usage with other sequelize methods\n\nThe `transaction` option goes with most other options, which are usually the first argument of a method.\nFor methods that take values, like `.create`, `.update()`, etc. `transaction` should be passed to the option in the second argument.\nIf unsure, refer to the API documentation for the method you are using to be sure of the signature.\n\n## After commit hook\n\nA `transaction` object allows tracking if and when it is committed.\n\nAn `afterCommit` hook can be added to both managed and unmanaged transaction objects:\n\n```js\nsequelize.transaction(t => {\n  t.afterCommit((transaction) => {\n    // Your logic\n  });\n});\n\nsequelize.transaction().then(t => {\n  t.afterCommit((transaction) => {\n    // Your logic\n  });\n\n  return t.commit();\n})\n```\n\nThe function passed to `afterCommit` can optionally return a promise that will resolve before the promise chain\nthat created the transaction resolves\n\n`afterCommit` hooks are _not_ raised if a transaction is rolled back\n\n`afterCommit` hooks do _not_ modify the return value of the transaction, unlike standard hooks\n\nYou can use the `afterCommit` hook in conjunction with model hooks to know when a instance is saved and available outside\nof a transaction\n\n```js\nmodel.afterSave((instance, options) => {\n  if (options.transaction) {\n    // Save done within a transaction, wait until transaction is committed to\n    // notify listeners the instance has been saved\n    options.transaction.afterCommit(() => /* Notify */)\n    return;\n  }\n  // Save done outside a transaction, safe for callers to fetch the updated model\n  // Notify\n})\n```\n\n## Locks\n\nQueries within a `transaction` can be performed with locks\n\n```js\nreturn User.findAll({\n  limit: 1,\n  lock: true,\n  transaction: t1\n})\n```\n\nQueries within a transaction can skip locked rows\n\n```js\nreturn User.findAll({\n  limit: 1,\n  lock: true,\n  skipLocked: true,\n  transaction: t2\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/scopes.md",
    "name": "./docs/manual/scopes.md",
    "content": "# Scopes\n\nScoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, `where`, `include`, `limit` etc.\n\n## Definition\n\nScopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object:\n\n```js\nclass Project extends Model {}\nProject.init({\n  // Attributes\n}, {\n  defaultScope: {\n    where: {\n      active: true\n    }\n  },\n  scopes: {\n    deleted: {\n      where: {\n        deleted: true\n      }\n    },\n    activeUsers: {\n      include: [\n        { model: User, where: { active: true }}\n      ]\n    },\n    random () {\n      return {\n        where: {\n          someNumber: Math.random()\n        }\n      }\n    },\n    accessLevel (value) {\n      return {\n        where: {\n          accessLevel: {\n            [Op.gte]: value\n          }\n        }\n      }\n    }\n    sequelize,\n    modelName: 'project'\n  }\n});\n```\n\nYou can also add scopes after a model has been defined by calling `addScope`. This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined.\n\nThe default scope is always applied. This means, that with the model definition above, `Project.findAll()` will create the following query:\n\n```sql\nSELECT * FROM projects WHERE active = true\n```\n\nThe default scope can be removed by calling `.unscoped()`, `.scope(null)`, or by invoking another scope:\n\n```js\nProject.scope('deleted').findAll(); // Removes the default scope\n```\n\n```sql\nSELECT * FROM projects WHERE deleted = true\n```\n\nIt is also possible to include scoped models in a scope definition. This allows you to avoid duplicating `include`, `attributes` or `where` definitions.\nUsing the above example, and invoking the `active` scope on the included User model (rather than specifying the condition directly in that include object):\n\n```js\nactiveUsers: {\n  include: [\n    { model: User.scope('active')}\n  ]\n}\n```\n\n## Usage\n\nScopes are applied by calling `.scope` on the model definition, passing the name of one or more scopes. `.scope` returns a fully functional model instance with all the regular methods: `.findAll`, `.update`, `.count`, `.destroy` etc. You can save this model instance and reuse it later:\n\n```js\nconst DeletedProjects = Project.scope('deleted');\n\nDeletedProjects.findAll();\n// some time passes\n\n// let's look for deleted projects again!\nDeletedProjects.findAll();\n```\n\nScopes apply to `.find`, `.findAll`, `.count`, `.update`, `.increment` and `.destroy`.\n\nScopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object:\n\n```js\nProject.scope('random', { method: ['accessLevel', 19]}).findAll();\n```\n\n```sql\nSELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19\n```\n\n## Merging\n\nSeveral scopes can be applied simultaneously by passing an array of scopes to `.scope`, or by passing the scopes as consecutive arguments.\n\n```js\n// These two are equivalent\nProject.scope('deleted', 'activeUsers').findAll();\nProject.scope(['deleted', 'activeUsers']).findAll();\n```\n\n```sql\nSELECT * FROM projects\nINNER JOIN users ON projects.userId = users.id\nWHERE projects.deleted = true\nAND users.active = true\n```\n\nIf you want to apply another scope alongside the default scope, pass the key `defaultScope` to `.scope`:\n\n```js\nProject.scope('defaultScope', 'deleted').findAll();\n```\n\n```sql\nSELECT * FROM projects WHERE active = true AND deleted = true\n```\n\nWhen invoking several scopes, keys from subsequent scopes will overwrite previous ones (similarly to [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)), except for `where` and `include`, which will be merged. Consider two scopes:\n\n```js\n{\n  scope1: {\n    where: {\n      firstName: 'bob',\n      age: {\n        [Op.gt]: 20\n      }\n    },\n    limit: 2\n  },\n  scope2: {\n    where: {\n      age: {\n        [Op.gt]: 30\n      }\n    },\n    limit: 10\n  }\n}\n```\n\nCalling `.scope('scope1', 'scope2')` will yield the following query\n\n```sql\nWHERE firstName = 'bob' AND age > 30 LIMIT 10\n```\n\nNote how `limit` and `age` are overwritten by `scope2`, while `firstName` is preserved. The `limit`, `offset`, `order`, `paranoid`, `lock` and `raw` fields are overwritten, while `where` is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for `include` will be discussed later on.\n\nNote that `attributes` keys of multiple applied scopes are merged in such a way that `attributes.exclude` are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.\n\nThe same merge logic applies when passing a find object directly to `findAll` (and similar finders) on a scoped model:\n\n```js\nProject.scope('deleted').findAll({\n  where: {\n    firstName: 'john'\n  }\n})\n```\n\n```sql\nWHERE deleted = true AND firstName = 'john'\n```\n\nHere the `deleted` scope is merged with the finder. If we were to pass `where: { firstName: 'john', deleted: false }` to the finder, the `deleted` scope would be overwritten.\n\n### Merging includes\n\nIncludes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.\n\nConsider four models: Foo, Bar, Baz and Qux, with has-many associations as follows:\n\n```js\nclass Foo extends Model {}\nclass Bar extends Model {}\nclass Baz extends Model {}\nclass Qux extends Model {}\nFoo.init({ name: Sequelize.STRING }, { sequelize });\nBar.init({ name: Sequelize.STRING }, { sequelize });\nBaz.init({ name: Sequelize.STRING }, { sequelize });\nQux.init({ name: Sequelize.STRING }, { sequelize });\nFoo.hasMany(Bar, { foreignKey: 'fooId' });\nBar.hasMany(Baz, { foreignKey: 'barId' });\nBaz.hasMany(Qux, { foreignKey: 'bazId' });\n```\n\nNow, consider the following four scopes defined on Foo:\n\n```js\n{\n  includeEverything: {\n    include: {\n      model: this.Bar,\n      include: [{\n        model: this.Baz,\n        include: this.Qux\n      }]\n    }\n  },\n  limitedBars: {\n    include: [{\n      model: this.Bar,\n      limit: 2\n    }]\n  },\n  limitedBazs: {\n    include: [{\n      model: this.Bar,\n      include: [{\n        model: this.Baz,\n        limit: 2\n      }]\n    }]\n  },\n  excludeBazName: {\n    include: [{\n      model: this.Bar,\n      include: [{\n        model: this.Baz,\n        attributes: {\n          exclude: ['name']\n        }\n      }]\n    }]\n  }\n}\n```\n\nThese four scopes can be deeply merged easily, for example by calling `Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()`, which would be entirely equivalent to calling the following:\n\n```js\nFoo.findAll({\n  include: {\n    model: this.Bar,\n    limit: 2,\n    include: [{\n      model: this.Baz,\n      limit: 2,\n      attributes: {\n        exclude: ['name']\n      },\n      include: this.Qux\n    }]\n  }\n});\n```\n\nObserve how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.\n\nThe merge illustrated above works in the exact same way regardless of the order applied to the scopes. The order would only make a difference if a certain option was set by two different scopes - which is not the case of the above example, since each scope does a different thing.\n\nThis merge strategy also works in the exact same way with options passed to `.findAll`, `.findOne` and the like.\n\n## Associations\n\nSequelize has two different but related scope concepts in relation to associations. The difference is subtle but important:\n\n* **Association scopes** Allow you to specify default attributes when getting and setting associations - useful when implementing polymorphic associations. This scope is only invoked on the association between the two models, when using the `get`, `set`, `add` and `create` associated model functions\n* **Scopes on associated models** Allows you to apply default and other scopes when fetching associations, and allows you to pass a scoped model when creating associations. These scopes both apply to regular finds on the model and to find through the association.\n\nAs an example, consider the models Post and Comment. Comment is associated to several other models (Image, Video etc.) and the association between Comment and other models is polymorphic, which means that Comment stores a `commentable` column, in addition to the foreign key `commentable_id`.\n\nThe polymorphic association can be implemented with an _association scope_ :\n\n```js\nthis.Post.hasMany(this.Comment, {\n  foreignKey: 'commentable_id',\n  scope: {\n    commentable: 'post'\n  }\n});\n```\n\nWhen calling `post.getComments()`, this will automatically add `WHERE commentable = 'post'`. Similarly, when adding new comments to a post, `commentable` will automagically be set to `'post'`. The association scope is meant to live in the background without the programmer having to worry about it - it cannot be disabled. For a more complete polymorphic example, see [Association scopes](associations.html#scopes)\n\nConsider then, that Post has a default scope which only shows active posts: `where: { active: true }`. This scope lives on the associated model (Post), and not on the association like the `commentable` scope did. Just like the default scope is applied when calling `Post.findAll()`, it is also applied when calling `User.getPosts()` - this will only return the active posts for that user.\n\nTo disable the default scope, pass `scope: null` to the getter: `User.getPosts({ scope: null })`. Similarly, if you want to apply other scopes, pass an array like you would to `.scope`:\n\n```js\nUser.getPosts({ scope: ['scope1', 'scope2']});\n```\n\nIf you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user:\n\n```js\nclass Post extends Model {}\nPost.init(attributes, {\n  defaultScope: {\n    where: {\n      active: true\n    }\n  },\n  scopes: {\n    deleted: {\n      where: {\n        deleted: true\n      }\n    }\n  },\n  sequelize,\n});\n\nUser.hasMany(Post); // regular getPosts association\nUser.hasMany(Post.scope('deleted'), { as: 'deletedPosts' });\n\n```\n\n```js\nUser.getPosts(); // WHERE active = true\nUser.getDeletedPosts(); // WHERE deleted = true\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/read-replication.md",
    "name": "./docs/manual/read-replication.md",
    "content": "# Read replication\r\n\r\nSequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is **not** handled by Sequelize, but should be set up by database backend).\r\n\r\n```js\r\nconst sequelize = new Sequelize('database', null, null, {\r\n  dialect: 'mysql',\r\n  port: 3306\r\n  replication: {\r\n    read: [\r\n      { host: '8.8.8.8', username: 'read-username', password: 'some-password' },\r\n      { host: '9.9.9.9', username: 'another-username', password: null }\r\n    ],\r\n    write: { host: '1.1.1.1', username: 'write-username', password: 'any-password' }\r\n  },\r\n  pool: { // If you want to override the options used for the read/write pool you can do so here\r\n    max: 20,\r\n    idle: 30000\r\n  },\r\n})\r\n```\r\n\r\nIf you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:`host`,`port`,`username`,`password`,`database`.\r\n\r\nSequelize uses a pool to manage connections to your replicas. Internally Sequelize will maintain two pools created using `pool` configuration.\r\n\r\nIf you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.\r\n\r\nEach `write` or `useMaster: true` query will use write pool. For `SELECT` read pool will be used. Read replica are switched using a basic round robin scheduling.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/migrations.md",
    "name": "./docs/manual/migrations.md",
    "content": "# Migrations\n\nJust like you use Git / SVN to manage changes in your source code, you can use migrations to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.\n\nYou will need [Sequelize CLI][0]. The CLI ships support for migrations and project bootstrapping.\n\n## The CLI\n\n### Installing CLI\n\nLet's start with installing CLI, you can find instructions [here][0]. Most preferred way is installing locally like this\n\n```bash\n$ npm install --save sequelize-cli\n```\n\n### Bootstrapping\n\nTo create an empty project you will need to execute `init` command\n\n```bash\n$ npx sequelize-cli init\n```\n\nThis will create following folders\n\n- `config`, contains config file, which tells CLI how to connect with database\n- `models`, contains all models for your project\n- `migrations`, contains all migration files\n- `seeders`, contains all seed files\n\n#### Configuration\n\nBefore continuing further we will need to tell CLI how to connect to database. To do that let's open default config file `config/config.json`. It looks something like this\n\n```json\n{\n  \"development\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_development\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  },\n  \"test\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_test\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  },\n  \"production\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_production\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  }\n}\n```\n\nNow edit this file and set correct database credentials and dialect. The keys of the objects(ex. \"development\") are used on `model/index.js` for matching `process.env.NODE_ENV` (When undefined, \"development\" is a default value.).\n\n**Note:** _If your database doesn't exists yet, you can just call `db:create` command. With proper access it will create that database for you._\n\n### Creating first Model (and Migration)\n\nOnce you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.\n\nWe will use `model:generate` command. This command requires two options\n\n- `name`, Name of the model\n- `attributes`, List of model attributes\n\nLet's create a model named `User`.\n\n```bash\n$ npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string\n```\n\nThis will do following\n\n- Create a model file `user` in `models` folder\n- Create a migration file with name like `XXXXXXXXXXXXXX-create-user.js` in `migrations` folder\n\n**Note:** _Sequelize will only use Model files, it's the table representation. On the other hand, the migration file is a change in that model or more specifically that table, used by CLI. Treat migrations like a commit or a log for some change in database._\n\n### Running Migrations\n\nUntil this step, we haven't inserted anything into the database. We have just created required model and migration files for our first model `User`. Now to actually create that table in database you need to run `db:migrate` command.\n\n```bash\n$ npx sequelize-cli db:migrate\n```\n\nThis command will execute these steps:\n\n- Will ensure a table called `SequelizeMeta` in database. This table is used to record which migrations have run on the current database\n- Start looking for any migration files which haven't run yet. This is possible by checking `SequelizeMeta` table. In this case it will run `XXXXXXXXXXXXXX-create-user.js` migration, which we created in last step.\n- Creates a table called `Users` with all columns as specified in its migration file.\n\n### Undoing Migrations\n\nNow our table has been created and saved in database. With migration you can revert to old state by just running a command.\n\nYou can use `db:migrate:undo`, this command will revert most recent migration.\n\n```bash\n$ npx sequelize-cli db:migrate:undo\n```\n\nYou can revert back to initial state by undoing all migrations with `db:migrate:undo:all` command. You can also revert back to a specific migration by passing its name in `--to` option.\n\n```bash\n$ npx sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js\n```\n\n### Creating First Seed\n\nSuppose we want to insert some data into a few tables by default. If we follow up on previous example we can consider creating a demo user for `User` table.\n\nTo manage all data migrations you can use seeders. Seed files are some change in data that can be used to populate database table with sample data or test data.\n\nLet's create a seed file which will add a demo user to our `User` table.\n\n```bash\n$ npx sequelize-cli seed:generate --name demo-user\n```\n\nThis command will create a seed file in `seeders` folder. File name will look something like `XXXXXXXXXXXXXX-demo-user.js`. It follows the same `up / down` semantics as the migration files.\n\nNow we should edit this file to insert demo user to `User` table.\n\n```js\n'use strict';\n\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.bulkInsert('Users', [{\n        firstName: 'John',\n        lastName: 'Doe',\n        email: 'demo@demo.com',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }], {});\n  },\n\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.bulkDelete('Users', null, {});\n  }\n};\n\n```\n\n### Running Seeds\n\nIn last step you have create a seed file. It's still not committed to database. To do that we need to run a simple command.\n\n```bash\n$ npx sequelize-cli db:seed:all\n```\n\nThis will execute that seed file and you will have a demo user inserted into `User` table.\n\n**Note:** _Seeders execution is not stored anywhere unlike migrations, which use the `SequelizeMeta` table. If you wish to override this please read `Storage` section_\n\n### Undoing Seeds\n\nSeeders can be undone if they are using any storage. There are two commands available for that:\n\nIf you wish to undo most recent seed\n\n```bash\n$ npx sequelize-cli db:seed:undo\n```\n\nIf you wish to undo a specific seed\n\n```bash\n$ npx sequelize-cli db:seed:undo --seed name-of-seed-as-in-data\n```\n\nIf you wish to undo all seeds\n\n```bash\n$ npx sequelize-cli db:seed:undo:all\n```\n\n## Advance Topics\n\n### Migration Skeleton\n\nThe following skeleton shows a typical migration file.\n\n```js\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    // logic for transforming into the new state\n  },\n\n  down: (queryInterface, Sequelize) => {\n    // logic for reverting the changes\n  }\n}\n```\n\nWe can generate this file using `migration:generate`. This will create `xxx-migration-skeleton.js` in your migration folder.\n\n```bash\n$ npx sequelize-cli migration:generate --name migration-skeleton\n```\n\nThe passed `queryInterface` object can be used to modify the database. The `Sequelize` object stores the available data types such as `STRING` or `INTEGER`. Function `up` or `down` should return a `Promise`. Let's look at an example:\n\n```js\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Person', {\n        name: Sequelize.STRING,\n        isBetaMember: {\n          type: Sequelize.BOOLEAN,\n          defaultValue: false,\n          allowNull: false\n        }\n      });\n  },\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Person');\n  }\n}\n```\n\nThe following is an example of a migration that performs two changes in the database, using a transaction to ensure that all instructions are successfully executed or rolled back in case of failure:\n\n```js\nmodule.exports = {\n    up: (queryInterface, Sequelize) => {\n        return queryInterface.sequelize.transaction((t) => {\n            return Promise.all([\n                queryInterface.addColumn('Person', 'petName', {\n                    type: Sequelize.STRING\n                }, { transaction: t }),\n                queryInterface.addColumn('Person', 'favoriteColor', {\n                    type: Sequelize.STRING,\n                }, { transaction: t })\n            ])\n        })\n    },\n\n    down: (queryInterface, Sequelize) => {\n        return queryInterface.sequelize.transaction((t) => {\n            return Promise.all([\n                queryInterface.removeColumn('Person', 'petName', { transaction: t }),\n                queryInterface.removeColumn('Person', 'favoriteColor', { transaction: t })\n            ])\n        })\n    }\n};\n```\n\nThe next is an example of a migration that has a foreign key. You can use references to specify a foreign key:\n\n```js\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Person', {\n      name: Sequelize.STRING,\n      isBetaMember: {\n        type: Sequelize.BOOLEAN,\n        defaultValue: false,\n        allowNull: false\n      },\n      userId: {\n        type: Sequelize.INTEGER,\n        references: {\n          model: {\n            tableName: 'users',\n            schema: 'schema'\n          }\n          key: 'id'\n        },\n        allowNull: false\n      },\n    });\n  },\n\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Person');\n  }\n}\n\n```\n\nThe next is an example of a migration that has uses async/await where you create an unique index on a new column:\n\n```js\nmodule.exports = {\n  async up(queryInterface, Sequelize) {\n    const transaction = await queryInterface.sequelize.transaction();\n    try {\n      await queryInterface.addColumn(\n        'Person',\n        'petName',\n        {\n          type: Sequelize.STRING,\n        },\n        { transaction }\n      );\n      await queryInterface.addIndex(\n        'Person',\n        'petName',\n        {\n          fields: 'petName',\n          unique: true,\n        },\n        { transaction }\n      );\n      await transaction.commit();\n    } catch (err) {\n      await transaction.rollback();\n      throw err;\n    }\n  },\n\n  async down(queryInterface, Sequelize) {\n    const transaction = await queryInterface.sequelize.transaction();\n    try {\n      await queryInterface.removeColumn('Person', 'petName', { transaction });\n      await transaction.commit();\n    } catch (err) {\n      await transaction.rollback();\n      throw err;\n    }\n  },\n};\n```\n\n### The `.sequelizerc` File\n\nThis is a special configuration file. It lets you specify following options that you would usually pass as arguments to CLI:\n\n- `env`: The environment to run the command in\n- `config`: The path to the config file\n- `options-path`: The path to a JSON file with additional options\n- `migrations-path`: The path to the migrations folder\n- `seeders-path`: The path to the seeders folder\n- `models-path`: The path to the models folder\n- `url`: The database connection string to use. Alternative to using --config files\n- `debug`: When available show various debug information\n\nSome scenarios where you can use it.\n\n- You want to override default path to `migrations`, `models`, `seeders` or `config` folder.\n- You want to rename `config.json` to something else like `database.json`\n\nAnd a whole lot more. Let's see how you can use this file for custom configuration.\n\nFor starters, let's create an empty file in the root directory of your project.\n\n```bash\n$ touch .sequelizerc\n```\n\nNow let's work with an example config.\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  'config': path.resolve('config', 'database.json'),\n  'models-path': path.resolve('db', 'models'),\n  'seeders-path': path.resolve('db', 'seeders'),\n  'migrations-path': path.resolve('db', 'migrations')\n}\n```\n\nWith this config you are telling CLI to\n\n- Use `config/database.json` file for config settings\n- Use `db/models` as models folder\n- Use `db/seeders` as seeders folder\n- Use `db/migrations` as migrations folder\n\n### Dynamic Configuration\n\nConfiguration file is by default a JSON file called `config.json`. But sometimes you want to execute some code or access environment variables which is not possible in JSON files.\n\nSequelize CLI can read from both `JSON` and `JS` files. This can be setup with `.sequelizerc` file. Let see how\n\nFirst you need to create a `.sequelizerc` file in the root folder of your project. This file should override config path to a `JS` file. Like this\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  'config': path.resolve('config', 'config.js')\n}\n```\n\nNow Sequelize CLI will load `config/config.js` for getting configuration options. Since this is a JS file you can have any code executed and export final dynamic configuration file.\n\nAn example of `config/config.js` file\n\n```js\nconst fs = require('fs');\n\nmodule.exports = {\n  development: {\n    username: 'database_dev',\n    password: 'database_dev',\n    database: 'database_dev',\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  test: {\n    username: 'database_test',\n    password: null,\n    database: 'database_test',\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  production: {\n    username: process.env.DB_USERNAME,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_NAME,\n    host: process.env.DB_HOSTNAME,\n    dialect: 'mysql',\n    dialectOptions: {\n      ssl: {\n        ca: fs.readFileSync(__dirname + '/mysql-ca-master.crt')\n      }\n    }\n  }\n};\n```\n\n### Using Babel\n\nNow you know how to use `.sequelizerc` file. Now let's see how to use this file to use babel with `sequelize-cli` setup. This will allow you to write migrations and seeders with ES6/ES7 syntax.\n\nFirst install `babel-register`\n\n```bash\n$ npm i --save-dev babel-register\n```\n\nNow let's create `.sequelizerc` file, it can include any configuration you may want to change for `sequelize-cli` but in addition to that we want it to register babel for our codebase. Something like this\n\n```bash\n$ touch .sequelizerc # Create rc file\n```\n\nNow include `babel-register` setup in this file\n\n```js\nrequire(\"babel-register\");\n\nconst path = require('path');\n\nmodule.exports = {\n  'config': path.resolve('config', 'config.json'),\n  'models-path': path.resolve('models'),\n  'seeders-path': path.resolve('seeders'),\n  'migrations-path': path.resolve('migrations')\n}\n```\n\nNow CLI will be able to run ES6/ES7 code from migrations/seeders etc. Please keep in mind this depends upon your configuration of `.babelrc`. Please read more about that at [babeljs.io](https://babeljs.io).\n\n### Using Environment Variables\n\nWith CLI you can directly access the environment variables inside the `config/config.js`. You can use `.sequelizerc` to tell CLI to use `config/config.js` for configuration. This is explained in last section.\n\nThen you can just expose file with proper environment variables.\n\n```js\nmodule.exports = {\n  development: {\n    username: 'database_dev',\n    password: 'database_dev',\n    database: 'database_dev',\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  test: {\n    username: process.env.CI_DB_USERNAME,\n    password: process.env.CI_DB_PASSWORD,\n    database: process.env.CI_DB_NAME,\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  production: {\n    username: process.env.PROD_DB_USERNAME,\n    password: process.env.PROD_DB_PASSWORD,\n    database: process.env.PROD_DB_NAME,\n    host: process.env.PROD_DB_HOSTNAME,\n    dialect: 'mysql'\n  }\n};\n```\n\n### Specifying Dialect Options\n\nSometime you want to specify a dialectOption, if it's a general config you can just add it in `config/config.json`. Sometime you want to execute some code to get dialectOptions, you should use dynamic config file for those cases.\n\n```json\n{\n    \"production\": {\n        \"dialect\":\"mysql\",\n        \"dialectOptions\": {\n            \"bigNumberStrings\": true\n        }\n    }\n}\n```\n\n### Production Usages\n\nSome tips around using CLI and migration setup in production environment.\n\n1) Use environment variables for config settings. This is better achieved with dynamic configuration. A sample production safe configuration may look like.\n\n```js\nconst fs = require('fs');\n\nmodule.exports = {\n  development: {\n    username: 'database_dev',\n    password: 'database_dev',\n    database: 'database_dev',\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  test: {\n    username: 'database_test',\n    password: null,\n    database: 'database_test',\n    host: '127.0.0.1',\n    dialect: 'mysql'\n  },\n  production: {\n    username: process.env.DB_USERNAME,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_NAME,\n    host: process.env.DB_HOSTNAME,\n    dialect: 'mysql',\n    dialectOptions: {\n      ssl: {\n        ca: fs.readFileSync(__dirname + '/mysql-ca-master.crt')\n      }\n    }\n  }\n};\n```\n\nOur goal is to use environment variables for various database secrets and not accidentally check them in to source control.\n\n### Storage\n\nThere are three types of storage that you can use: `sequelize`, `json`, and `none`.\n\n- `sequelize` : stores migrations and seeds in a table on the sequelize database\n- `json` : stores migrations and seeds on a json file\n- `none` : does not store any migration/seed\n\n#### Migration Storage\n\nBy default the CLI will create a table in your database called `SequelizeMeta` containing an entry\nfor each executed migration. To change this behavior, there are three options you can add to the\nconfiguration file. Using `migrationStorage`, you can choose the type of storage to be used for\nmigrations. If you choose `json`, you can specify the path of the file using `migrationStoragePath`\nor the CLI will write to the file `sequelize-meta.json`. If you want to keep the information in the\ndatabase, using `sequelize`, but want to use a different table, you can change the table name using\n`migrationStorageTableName`. Also you can define a different schema for the `SequelizeMeta` table by\nproviding the `migrationStorageTableSchema` property.\n\n```json\n{\n  \"development\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_development\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\",\n\n    // Use a different storage type. Default: sequelize\n    \"migrationStorage\": \"json\",\n\n    // Use a different file name. Default: sequelize-meta.json\n    \"migrationStoragePath\": \"sequelizeMeta.json\",\n\n    // Use a different table name. Default: SequelizeMeta\n    \"migrationStorageTableName\": \"sequelize_meta\",\n\n    // Use a different schema for the SequelizeMeta table\n    \"migrationStorageTableSchema\": \"custom_schema\"\n  }\n}\n```\n\n**Note:** _The `none` storage is not recommended as a migration storage. If you decide to use it, be\naware of the implications of having no record of what migrations did or didn't run._\n\n#### Seed Storage\n\nBy default the CLI will not save any seed that is executed. If you choose to change this behavior (!),\nyou can use `seederStorage` in the configuration file to change the storage type. If you choose `json`,\nyou can specify the path of the file using `seederStoragePath` or the CLI will write to the file\n`sequelize-data.json`. If you want to keep the information in the database, using `sequelize`, you can\nspecify the table name using `seederStorageTableName`, or it will default to `SequelizeData`.\n\n```json\n{\n  \"development\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_development\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\",\n    // Use a different storage. Default: none\n    \"seederStorage\": \"json\",\n    // Use a different file name. Default: sequelize-data.json\n    \"seederStoragePath\": \"sequelizeData.json\",\n    // Use a different table name. Default: SequelizeData\n    \"seederStorageTableName\": \"sequelize_data\"\n  }\n}\n```\n\n### Configuration Connection String\n\nAs an alternative to the `--config` option with configuration files defining your database, you can\nuse the `--url` option to pass in a connection string. For example:\n\n```bash\n$ npx sequelize-cli db:migrate --url 'mysql://root:password@mysql_host.com/database_name'\n```\n\n### Passing Dialect Specific Options\n\n```json\n{\n    \"production\": {\n        \"dialect\":\"postgres\",\n        \"dialectOptions\": {\n            // dialect options like SSL etc here\n        }\n    }\n}\n```\n\n### Programmatic use\n\nSequelize has a [sister library][1] for programmatically handling execution and logging of migration tasks.\n\n## Query Interface\n\nUsing `queryInterface` object described before you can change database schema. To see full list of public methods it supports check [QueryInterface API][2]\n\n[0]: https://github.com/sequelize/cli\n[1]: https://github.com/sequelize/umzug\n[2]: ../class/lib/query-interface.js~QueryInterface.html\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/resources.md",
    "name": "./docs/manual/resources.md",
    "content": "# Resources\n\n## Addons & Plugins\n\n### ACL\n\n* [ssacl](https://github.com/pumpupapp/ssacl)\n* [ssacl-attribute-roles](https://github.com/mickhansen/ssacl-attribute-roles)\n\n### Auto Code Generation & Scaffolding\n\n* [meteor modeler](https://www.datensen.com/) - Desktop tool for visual definition of Sequelize models and asssociations.\n* [sequelize-ui](https://github.com/tomjschuster/sequelize-ui) - Online tool for building models, relations and more.\n* [sequelizer](https://github.com/andyforever/sequelizer) - A GUI Desktop App for generating Sequelize models. Support for Mysql, Mariadb, Postgres, Sqlite, Mssql.\n* [sequelize-auto](https://github.com/sequelize/sequelize-auto) Generating models for SequelizeJS via the command line is another choice.\n* [pg-generator](http://www.pg-generator.com/builtin-templates/sequelize/) - Auto generate/scaffold Sequelize models for PostgreSQL database.\n* [sequelizejs-decorators](https://www.npmjs.com/package/sequelizejs-decorators) decorators for composing sequelize models\n\n### Autoloader\n\n* [sequelize-autoload](https://github.com/boxsnake-nodejs/sequelize-autoload) - An autoloader for Sequelize, inspired by [PSR-0](https://www.php-fig.org/psr/psr-0/) and [PSR-4](https://www.php-fig.org/psr/psr-4/).\n\n### Caching\n\n* [sequelize-transparent-cache](https://github.com/DanielHreben/sequelize-transparent-cache)\n\n### Filters\n\n* [sequelize-transforms](https://www.npmjs.com/package/sequelize-transforms) - Add configurable attribute transforms.\n\n### Fixtures / mock data\n\n* [Fixer](https://github.com/olalonde/fixer)\n* [Sequelize-fixtures](https://github.com/domasx2/sequelize-fixtures)\n* [Sequelize-fixture](https://github.com/xudejian/sequelize-fixture)\n\n### Hierarchies\n\n* [sequelize-hierarchy](https://www.npmjs.com/package/sequelize-hierarchy) - Nested hierarchies for Sequelize.\n\n### Historical records / Time travel\n\n* [sequelize-temporal](https://github.com/bonaval/sequelize-temporal) - Temporal tables (aka historical records)\n\n### Migrations\n\n* [umzug](https://github.com/sequelize/umzug)\n\n### Slugification\n\n* [sequelize-slugify](https://www.npmjs.com/package/sequelize-slugify) - Add slugs to sequelize models\n\n### Tokens\n\n* [sequelize-tokenify](https://github.com/pipll/sequelize-tokenify) - Add unique tokens to sequelize models\n\n### Miscellaneous\n\n* [sequelize-deep-update](https://www.npmjs.com/package/sequelize-deep-update) - Update a sequelize instance and its included associated instances with new properties.\n* [sequelize-noupdate-attributes](https://www.npmjs.com/package/sequelize-noupdate-attributes) - Adds no update/readonly attributes support to models.\n* [sequelize-joi](https://www.npmjs.com/package/sequelize-joi) - Allows specifying [Joi](https://github.com/hapijs/joi) validation schema for JSONB model attributes in Sequelize.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/typescript.md",
    "name": "./docs/manual/typescript.md",
    "content": "# TypeScript\n\nSince v5, Sequelize provides its own TypeScript definitions. Please note that only TS >= 3.1 is supported.\n\nAs Sequelize heavily relies on runtime property assignments, TypeScript won't be very useful out of the box. A decent amount of manual type declarations are needed to make models workable.\n\n## Installation\n\nIn order to avoid installation bloat for non TS users, you must install the following typing packages manually:\n\n- `@types/node` (this is universally required)\n- `@types/validator`\n- `@types/bluebird`\n\n## Usage\n\nExample of a minimal TypeScript project:\n\n```ts\nimport { Sequelize, Model, DataTypes, BuildOptions } from 'sequelize';\nimport { HasManyGetAssociationsMixin, HasManyAddAssociationMixin, HasManyHasAssociationMixin, Association, HasManyCountAssociationsMixin, HasManyCreateAssociationMixin } from 'sequelize';\n\nclass User extends Model {\n  public id!: number; // Note that the `null assertion` `!` is required in strict mode.\n  public name!: string;\n  public preferredName!: string | null; // for nullable fields\n\n  // timestamps!\n  public readonly createdAt!: Date;\n  public readonly updatedAt!: Date;\n\n  // Since TS cannot determine model association at compile time\n  // we have to declare them here purely virtually\n  // these will not exist until `Model.init` was called.\n\n  public getProjects!: HasManyGetAssociationsMixin<Project>; // Note the null assertions!\n  public addProject!: HasManyAddAssociationMixin<Project, number>;\n  public hasProject!: HasManyHasAssociationMixin<Project, number>;\n  public countProjects!: HasManyCountAssociationsMixin;\n  public createProject!: HasManyCreateAssociationMixin<Project>;\n\n  // You can also pre-declare possible inclusions, these will only be populated if you\n  // actively include a relation.\n  public readonly projects?: Project[]; // Note this is optional since it's only populated when explicitly requested in code\n\n  public static associations: {\n    projects: Association<User, Project>;\n  };\n}\n\nconst sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb');\n\nclass Project extends Model {\n  public id!: number;\n  public ownerId!: number;\n  public name!: string;\n\n  public readonly createdAt!: Date;\n  public readonly updatedAt!: Date;\n}\n\nclass Address extends Model {\n  public userId!: number;\n  public address!: string;\n\n  public readonly createdAt!: Date;\n  public readonly updatedAt!: Date;\n}\n\nProject.init({\n  id: {\n    type: DataTypes.INTEGER.UNSIGNED, // you can omit the `new` but this is discouraged\n    autoIncrement: true,\n    primaryKey: true,\n  },\n  ownerId: {\n    type: DataTypes.INTEGER.UNSIGNED,\n    allowNull: false,\n  },\n  name: {\n    type: new DataTypes.STRING(128),\n    allowNull: false,\n  }\n}, {\n  sequelize,\n  tableName: 'projects',\n});\n\nUser.init({\n  id: {\n    type: DataTypes.INTEGER.UNSIGNED,\n    autoIncrement: true,\n    primaryKey: true,\n  },\n  name: {\n    type: new DataTypes.STRING(128),\n    allowNull: false,\n  },\n  preferredName: {\n    type: new DataTypes.STRING(128),\n    allowNull: true\n  }\n}, {\n  tableName: 'users',\n  sequelize: sequelize, // this bit is important\n});\n\nAddress.init({\n  userId: {\n    type: DataTypes.INTEGER.UNSIGNED,\n  },\n  address: {\n    type: new DataTypes.STRING(128),\n    allowNull: false,\n  }\n}, {\n  tableName: 'address',\n  sequelize: sequelize, // this bit is important\n});\n\n// Here we associate which actually populates out pre-declared `association` static and other methods.\nUser.hasMany(Project, {\n  sourceKey: 'id',\n  foreignKey: 'ownerId',\n  as: 'projects' // this determines the name in `associations`!\n});\n\nAddress.belongsTo(User, {targetKey: 'id'});\nUser.hasOne(Address,{sourceKey: 'id'});\n\nasync function stuff() {\n  // Please note that when using async/await you lose the `bluebird` promise context\n  // and you fall back to native\n  const newUser = await User.create({\n    name: 'Johnny',\n    preferredName: 'John',\n  });\n  console.log(newUser.id, newUser.name, newUser.preferredName);\n\n  const project = await newUser.createProject({\n    name: 'first!',\n  });\n\n  const ourUser = await User.findByPk(1, {\n    include: [User.associations.projects],\n    rejectOnEmpty: true, // Specifying true here removes `null` from the return type!\n  });\n  console.log(ourUser.projects![0].name); // Note the `!` null assertion since TS can't know if we included\n                                          // the model or not\n}\n```\n\n## Usage of `sequelize.define`\n\nTypeScript doesn't know how to generate a `class` definition when we use the `sequelize.define` method to define a Model. Therefore, we need to do some manual work and declare an interface and a type, and eventually cast the result of `.define` to the _static_ type.\n\n```ts\n// We need to declare an interface for our model that is basically what our class would be\ninterface MyModel extends Model {\n  readonly id: number;\n}\n\n// Need to declare the static model so `findOne` etc. use correct types.\ntype MyModelStatic = typeof Model & {\n  new (values?: object, options?: BuildOptions): MyModel;\n}\n\n// TS can't derive a proper class definition from a `.define` call, therefor we need to cast here.\nconst MyDefineModel = <MyModelStatic>sequelize.define('MyDefineModel', {\n  id: {\n    primaryKey: true,\n    type: DataTypes.INTEGER.UNSIGNED,\n  }\n});\n\nfunction stuffTwo() {\n  MyDefineModel.findByPk(1, {\n    rejectOnEmpty: true,\n  })\n  .then(myModel => {\n    console.log(myModel.id);\n  });\n}\n\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/upgrade-to-v5.md",
    "name": "./docs/manual/upgrade-to-v5.md",
    "content": "# Upgrade to v5\n\nSequelize v5 is the next major release after v4\n\n## Breaking Changes\n\n### Support for Node 6 and up\n\nSequelize v5 will only support Node 6 and up [#9015](https://github.com/sequelize/sequelize/issues/9015)\n\n### Secure Operators\n\nWith v4 you started to get a deprecation warning `String based operators are now deprecated`. Also concept of operators was introduced. These operators are Symbols which prevent hash injection attacks.\n\n[operators-security](querying.html#operators-security)\n\n**With v5**\n\n- Operators are now enabled by default.\n- You can still use string operators by passing an operators map in `operatorsAliases`, but that will give you deprecation warning.\n- Op.$raw is removed\n\n### Typescript Support\n\nSequelize now ship official typings [#10287](https://github.com/sequelize/sequelize/pull/10287). You can consider migrating away from external typings which may get out of sync.\n\n### Pooling\n\nWith v5 Sequelize now use `sequelize-pool` which is a modernized fork of <code>generic-pool&#64;2.5</code>. You no longer need to call `sequelize.close` to shutdown pool, this helps with lambda executions. [#8468](https://github.com/sequelize/sequelize/issues/8468)\n\n### Model\n\n**Validators**\n\nCustom validators defined per attribute (as opposed to the custom validators defined in the model's options) now run when the attribute's value is `null` and `allowNull` is `true` (while previously they didn't run and the validation succeeded immediately). To avoid problems when upgrading, please check all your custom validators defined per attribute, where `allowNull` is `true`, and make sure all these validators behave correctly when the value is `null`. See [#9143](https://github.com/sequelize/sequelize/issues/9143).\n\n**Attributes**\n\n`Model.attributes` now removed, use `Model.rawAttributes`. [#5320](https://github.com/sequelize/sequelize/issues/5320)\n\n__Note__: _Please don't confuse this with `options.attributes`, they are still valid_\n\n**Paranoid Mode**\n\nWith v5 if `deletedAt` is set, record will be considered as deleted. `paranoid` option will only use `deletedAt` as flag. [#8496](https://github.com/sequelize/sequelize/issues/8496)\n\n**Model.bulkCreate**\n\n`updateOnDuplicate` option which used to accept boolean and array, now only accepts non-empty array of attributes. [#9288](https://github.com/sequelize/sequelize/issues/9288)\n\n**Underscored Mode**\n\nImplementation of `Model.options.underscored` is changed. You can find full specifications [here](https://github.com/sequelize/sequelize/issues/6423#issuecomment-379472035).\n\nMain outline\n\n1. Both `underscoredAll` and `underscored` options are merged into single `underscored` option\n2. All attributes are now generated with camelcase naming by default. With the `underscored` option set to `true`, the `field` option for attributes will be set as underscored version of attribute name.\n3. `underscored` will control all attributes including timestamps, version and foreign keys. It will not affect any attribute which already specifies the `field` option.\n\n[#9304](https://github.com/sequelize/sequelize/pull/9304)\n\n**Removed aliases**\n\nMany model based aliases has been removed [#9372](https://github.com/sequelize/sequelize/issues/9372)\n\n| Removed in v5 | Official Alternative |\n| :------ | :------ |\n| insertOrUpdate | upsert |\n| find | findOne |\n| findAndCount | findAndCountAll |\n| findOrInitialize | findOrBuild |\n| updateAttributes | update |\n| findById, findByPrimary | findByPk |\n| all | findAll |\n| hook | addHook |\n\n### Datatypes\n\n**Range**\n\nNow supports only one standard format `[{ value: 1, inclusive: true }, { value: 20, inclusive: false }]` [#9364](https://github.com/sequelize/sequelize/pull/9364)\n\n**Case insensitive text**\n\nAdded support for `CITEXT` for Postgres and SQLite\n\n**Removed**\n\n`NONE` type has been removed, use `VIRTUAL` instead\n\n### Hooks\n\n**Removed aliases**\n\nHooks aliases has been removed [#9372](https://github.com/sequelize/sequelize/issues/9372)\n\n| Removed in v5 | Official Alternative |\n| :------ | :------ |\n| [after,before]BulkDelete | [after,before]BulkDestroy |\n| [after,before]Delete | [after,before]Destroy |\n| beforeConnection | beforeConnect |\n\n### Sequelize\n\n**Removed aliases**\n\nPrototype references for many constants, objects and classes has been removed [#9372](https://github.com/sequelize/sequelize/issues/9372)\n\n| Removed in v5 | Official Alternative |\n| :------ | :------ |\n| Sequelize.prototype.Utils | Sequelize.Utils |\n| Sequelize.prototype.Promise | Sequelize.Promise |\n| Sequelize.prototype.TableHints | Sequelize.TableHints |\n| Sequelize.prototype.Op | Sequelize.Op |\n| Sequelize.prototype.Transaction | Sequelize.Transaction |\n| Sequelize.prototype.Model | Sequelize.Model |\n| Sequelize.prototype.Deferrable | Sequelize.Deferrable |\n| Sequelize.prototype.Error | Sequelize.Error |\n| Sequelize.prototype[error] | Sequelize[error] |\n\n```js\nimport Sequelize from 'sequelize';\nconst sequelize = new Sequelize('postgres://user:password@127.0.0.1:mydb');\n\n/**\n * In v4 you can do this\n */\nconsole.log(sequelize.Op === Sequelize.Op) // logs `true`\nconsole.log(sequelize.UniqueConstraintError === Sequelize.UniqueConstraintError) // logs `true`\n\nModel.findAll({\n  where: {\n    [sequelize.Op.and]: [ // Using sequelize.Op or Sequelize.Op interchangeably\n      {\n        name: \"Abc\"\n      },\n      {\n        age: {\n          [Sequelize.Op.gte]: 18\n        }\n      }\n    ]\n  }\n}).catch(sequelize.ConnectionError, () => {\n  console.error('Something wrong with connection?');\n});\n\n/**\n * In v5 aliases has been removed from Sequelize prototype\n * You should use Sequelize directly to access Op, Errors etc\n */\n\nModel.findAll({\n  where: {\n    [Sequelize.Op.and]: [ // Don't use sequelize.Op, use Sequelize.Op instead\n      {\n        name: \"Abc\"\n      },\n      {\n        age: {\n          [Sequelize.Op.gte]: 18\n        }\n      }\n    ]\n  }\n}).catch(Sequelize.ConnectionError, () => {\n  console.error('Something wrong with connection?');\n});\n```\n\n### Query Interface\n\n- `changeColumn` no longer generates constraint with `_idx` suffix. Now Sequelize does not specify any name for constraints thus defaulting to database engine naming. This aligns behavior of `sync`, `createTable` and `changeColumn`.\n- `addIndex` aliases options aliases have been removed, use the following instead.\n  - `indexName` => `name`\n  - `indicesType` => `type`\n  - `indexType`/`method` => `using`\n\n### Others\n\n- Sequelize now use parameterized queries for all INSERT / UPDATE operations (except UPSERT). They provide better protection against SQL Injection attack.\n- `ValidationErrorItem` now holds reference to original error in the `original` property, rather than the `__raw` property.\n- [retry-as-promised](https://github.com/mickhansen/retry-as-promised) has been updated to `3.1.0`, which use [any-promise](https://github.com/kevinbeaty/any-promise). This module repeat all `sequelize.query` operations. You can configure `any-promise` to use `bluebird` for better performance on Node 4 or 6\n- Sequelize will throw for all `undefined` keys in `where` options, In past versions `undefined` was converted to `null`.\n\n### Dialect Specific\n\n#### MSSQL\n\n- Sequelize now works with `tedious >= 6.0.0`. Old `dialectOptions` has to be updated to match their new format. Please refer to tedious [documentation](http://tediousjs.github.io/tedious/api-connection.html#function_newConnection). An example of new `dialectOptions` is given below\n\n```javascript\ndialectOptions: {\n  authentication: {\n    domain: 'my-domain'\n  },\n  options: {\n    requestTimeout: 60000,\n    cryptoCredentialsDetails: {\n      ciphers: \"RC4-MD5\"\n    }\n  }\n}\n```\n\n#### MySQL\n\n- Requires `mysql2 >= 1.5.2` for prepared statements\n\n#### MariaDB\n\n- `dialect: 'mariadb'` is now [supported](https://github.com/sequelize/sequelize/pull/10192) with `mariadb` package\n\n### Packages\n\n- removed: terraformer-wkt-parser [#9545](https://github.com/sequelize/sequelize/pull/9545)\n- removed: `generic-pool`\n- added: `sequelize-pool`\n\n## Changelog\n\n### 5.0.0-beta.17\n\n- fix(build): default null for multiple primary keys\n- fix(util): improve performance of classToInvokable [#10534](https://github.com/sequelize/sequelize/pull/10534)\n- fix(model/update): propagate paranoid to individualHooks query [#10369](https://github.com/sequelize/sequelize/pull/10369)\n- fix(association): use minimal select for hasAssociation [#10529](https://github.com/sequelize/sequelize/pull/10529)\n- fix(query-interface): reject with error for describeTable [#10528](https://github.com/sequelize/sequelize/pull/10528)\n- fix(model): throw for invalid include type [#10527](https://github.com/sequelize/sequelize/pull/10527)\n- fix(types): additional options for db.query and add missing retry [#10512](https://github.com/sequelize/sequelize/pull/10512)\n- fix(query): don't prepare options & sql for every retry [#10498](https://github.com/sequelize/sequelize/pull/10498)\n- feat: expose Sequelize.BaseError\n- feat: upgrade to <code>tedious&#64;6.0.0</code> [#10494](https://github.com/sequelize/sequelize/pull/10494)\n- feat(sqlite/query-generator): support restart identity for truncate-table [#10522](https://github.com/sequelize/sequelize/pull/10522)\n- feat(data-types): handle numbers passed as objects [#10492](https://github.com/sequelize/sequelize/pull/10492)\n- feat(types): enabled string association [#10481](https://github.com/sequelize/sequelize/pull/10481)\n- feat(postgres): allow customizing client_min_messages [#10448](https://github.com/sequelize/sequelize/pull/10448)\n- refactor(data-types): move to classes [#10495](https://github.com/sequelize/sequelize/pull/10495)\n- docs(legacy): fix N:M example [#10509](https://github.com/sequelize/sequelize/pull/10509)\n- docs(migrations): use migrationStorageTableSchema [#10417](https://github.com/sequelize/sequelize/pull/10417)\n- docs(hooks): add documentation for connection hooks [#10410](https://github.com/sequelize/sequelize/pull/10410)\n- docs(addIndex): concurrently option [#10409](https://github.com/sequelize/sequelize/pull/10409)\n- docs(model): fix typo [#10405](https://github.com/sequelize/sequelize/pull/10405)\n- docs(usage): fix broken link on Basic Usage [#10381](https://github.com/sequelize/sequelize/pull/10381)\n- docs(package.json): add homepage [#10372](https://github.com/sequelize/sequelize/pull/10372)\n\n### 5.0.0-beta.16\n\n- feat: add typescript typings [#10287](https://github.com/sequelize/sequelize/pull/10117)\n- fix(mysql): match with newlines in error message [#10320](https://github.com/sequelize/sequelize/pull/10320)\n- fix(update): skips update when nothing to update [#10248](https://github.com/sequelize/sequelize/pull/10248)\n- fix(utils): flattenObject for null values [#10293](https://github.com/sequelize/sequelize/pull/10293)\n- fix(instance-validator): don't skip custom validators on null [#9143](https://github.com/sequelize/sequelize/pull/9143)\n- docs(transaction): after save example [#10280](https://github.com/sequelize/sequelize/pull/10280)\n- docs(query-generator): typo [#10277](https://github.com/sequelize/sequelize/pull/10277)\n- refactor(errors): restructure [#10355](https://github.com/sequelize/sequelize/pull/10355)\n- refactor(scope): documentation #9087 [#10312](https://github.com/sequelize/sequelize/pull/10312)\n- refactor: cleanup association and spread use [#10276](https://github.com/sequelize/sequelize/pull/10276)\n\n### 5.0.0-beta.15\n\n- fix(query-generator): fix addColumn create comment [#10117](https://github.com/sequelize/sequelize/pull/10117)\n- fix(sync): throw when no models defined [#10175](https://github.com/sequelize/sequelize/pull/10175)\n- fix(association): enable eager load with include all(#9928) [#10173](https://github.com/sequelize/sequelize/pull/10173)\n- fix(sqlite): simplify connection error handling\n- fix(model): prevent version number from being incremented as string [#10217](https://github.com/sequelize/sequelize/pull/10217)\n- feat(dialect): mariadb [#10192](https://github.com/sequelize/sequelize/pull/10192)\n- docs(migrations): improve dialect options docs\n- docs: fix favicon [#10242](https://github.com/sequelize/sequelize/pull/10242)\n- docs(model.init): `attribute.column.validate` option [#10237](https://github.com/sequelize/sequelize/pull/10237)\n- docs(bulk-create): update support information about ignoreDuplicates\n- docs: explain custom/new data types [#10170](https://github.com/sequelize/sequelize/pull/10170)\n- docs(migrations): Simplify CLI Call [#10201](https://github.com/sequelize/sequelize/pull/10201)\n- docs(migrations): added advanced skeleton example [#10190](https://github.com/sequelize/sequelize/pull/10190)\n- docs(transaction): default isolation level [#10111](https://github.com/sequelize/sequelize/pull/10111)\n- docs: typo in associations.md [#10157](https://github.com/sequelize/sequelize/pull/10157)\n- refactor: reduce code complexity [#10120](https://github.com/sequelize/sequelize/pull/10120)\n- refactor: optimize memoize use, misc cases [#10122](https://github.com/sequelize/sequelize/pull/10122)\n- chore(lint): enforce consistent spacing [#10193](https://github.com/sequelize/sequelize/pull/10193)\n\n### 5.0.0-beta.14\n\n- fix(query): correctly quote identifier for attributes (#9964) [#10118](https://github.com/sequelize/sequelize/pull/10118)\n- feat(postgres): dyanmic oids [#10077](https://github.com/sequelize/sequelize/pull/10077)\n- fix(error): optimistic lock message [#10068](https://github.com/sequelize/sequelize/pull/10068)\n- fix(package): update depd to version 2.0.0 [#10081](https://github.com/sequelize/sequelize/pull/10081)\n- fix(model): validate virtual attribute (#9947) [#10085](https://github.com/sequelize/sequelize/pull/10085)\n- fix(test): actually test get method with raw option [#10059](https://github.com/sequelize/sequelize/pull/10059)\n- fix(model): return deep cloned value for toJSON [#10058](https://github.com/sequelize/sequelize/pull/10058)\n- fix(model): create instance with many-to-many association with extra column (#10034) [#10050](https://github.com/sequelize/sequelize/pull/10050)\n- fix(query-generator): fix bad property access [#10056](https://github.com/sequelize/sequelize/pull/10056)\n- docs(upgrade-to-v4): typo [#10060](https://github.com/sequelize/sequelize/pull/10060)\n- docs(model-usage): order expression format [#10061](https://github.com/sequelize/sequelize/pull/10061)\n- chore(package): update retry-as-promised to version 3.1.0 [#10065](https://github.com/sequelize/sequelize/pull/10065)\n- refactor(scopes): just in time options conforming [#9735](https://github.com/sequelize/sequelize/pull/9735)\n- refactor: use sequelize-pool for pooling [#10051](https://github.com/sequelize/sequelize/pull/10051)\n- refactor(*): cleanup code [#10091](https://github.com/sequelize/sequelize/pull/10091)\n- refactor: use template strings [#10055](https://github.com/sequelize/sequelize/pull/10055)\n- refactor(query-generation): cleanup template usage [#10047](https://github.com/sequelize/sequelize/pull/10047)\n\n### 5.0.0-beta.13\n\n- fix: throw on undefined where parameters [#10048](https://github.com/sequelize/sequelize/pull/10048)\n- fix(model): improve wrong alias error message [#10041](https://github.com/sequelize/sequelize/pull/10041)\n- feat(sqlite): CITEXT datatype [#10036](https://github.com/sequelize/sequelize/pull/10036)\n- fix(postgres): remove if not exists and cascade from create/drop database queries [#10033](https://github.com/sequelize/sequelize/pull/10033)\n- fix(syntax): correct parentheses around union [#10003](https://github.com/sequelize/sequelize/pull/10003)\n- feat(query-interface): createDatabase / dropDatabase support [#10027](https://github.com/sequelize/sequelize/pull/10027)\n- feat(postgres): CITEXT datatype [#10024](https://github.com/sequelize/sequelize/pull/10024)\n- feat: pass uri query parameters to dialectOptions [#10025](https://github.com/sequelize/sequelize/pull/10025)\n- docs(query-generator): remove doc about where raw query [#10017](https://github.com/sequelize/sequelize/pull/10017)\n- fix(query): handle undefined field on unique constraint error [#10018](https://github.com/sequelize/sequelize/pull/10018)\n- fix(model): sum returns zero when empty matching [#9984](https://github.com/sequelize/sequelize/pull/9984)\n- feat(query-generator): add startsWith, endsWith and substring operators [#9999](https://github.com/sequelize/sequelize/pull/9999)\n- docs(sequelize): correct jsdoc annotations for authenticate [#10002](https://github.com/sequelize/sequelize/pull/10002)\n- docs(query-interface): add bulkUpdate docs [#10005](https://github.com/sequelize/sequelize/pull/10005)\n- fix(tinyint): ignore params for TINYINT on postgres [#9992](https://github.com/sequelize/sequelize/pull/9992)\n- fix(belongs-to): create now returns target model [#9980](https://github.com/sequelize/sequelize/pull/9980)\n- refactor(model): remove .all alias [#9975](https://github.com/sequelize/sequelize/pull/9975)\n- perf: fix memory leak due to instance reference by isImmutable [#9973](https://github.com/sequelize/sequelize/pull/9973)\n- feat(sequelize): dialectModule option [#9972](https://github.com/sequelize/sequelize/pull/9972)\n- fix(query): check valid warn message [#9948](https://github.com/sequelize/sequelize/pull/9948)\n- fix(model): check for own property when overriding association mixins [#9953](https://github.com/sequelize/sequelize/pull/9953)\n- fix(create-table): support for uniqueKeys [#9946](https://github.com/sequelize/sequelize/pull/9946)\n- refactor(transaction): remove autocommit mode [#9921](https://github.com/sequelize/sequelize/pull/9921)\n- feat(sequelize): getDatabaseName [#9937](https://github.com/sequelize/sequelize/pull/9937)\n- refactor: remove aliases [#9933](https://github.com/sequelize/sequelize/pull/9933)\n- feat(belongsToMany): override unique constraint name with uniqueKey [#9914](https://github.com/sequelize/sequelize/pull/9914)\n- fix(postgres): properly disconnect connections [#9911](https://github.com/sequelize/sequelize/pull/9911)\n- docs(instances.md): add section for restore() [#9917](https://github.com/sequelize/sequelize/pull/9917)\n- docs(hooks.md): add warning about memory limits of individual hooks [#9881](https://github.com/sequelize/sequelize/pull/9881)\n- fix(package): update debug to version 4.0.0 [#9908](https://github.com/sequelize/sequelize/pull/9908)\n- feat(postgres): support ignoreDuplicates with ON CONFLICT DO NOTHING [#9883](https://github.com/sequelize/sequelize/pull/9883)\n\n### 5.0.0-beta.12\n\n- fix(changeColumn): normalize attribute [#9897](https://github.com/sequelize/sequelize/pull/9897)\n- feat(describeTable): support string length for mssql [#9896](https://github.com/sequelize/sequelize/pull/9896)\n- feat(describeTable): support autoIncrement for mysql [#9894](https://github.com/sequelize/sequelize/pull/9894)\n- fix(sqlite): unable to reference foreignKey on primaryKey [#9893](https://github.com/sequelize/sequelize/pull/9893)\n- fix(postgres): enum with string COMMENT breaks query [#9891](https://github.com/sequelize/sequelize/pull/9891)\n- fix(changeColumn): use engine defaults for foreign/unique key naming [#9890](https://github.com/sequelize/sequelize/pull/9890)\n- fix(transaction): fixed unhandled rejection when connection acquire timeout [#9879](https://github.com/sequelize/sequelize/pull/9879)\n- fix(sqlite): close connection properly and cleanup files [#9851](https://github.com/sequelize/sequelize/pull/9851)\n- fix(model): incorrect error message for findCreateFind [#9849](https://github.com/sequelize/sequelize/pull/9849)\n\n### 5.0.0-beta.11\n\n- fix(count): duplicate mapping of fields break scopes [#9788](https://github.com/sequelize/sequelize/pull/9788)\n- fix(model): bulkCreate should populate dataValues directly [#9797](https://github.com/sequelize/sequelize/pull/9797)\n- fix(mysql): improve unique key violation handling [#9724](https://github.com/sequelize/sequelize/pull/9724)\n- fix(separate): don't propagate group to separated queries [#9754](https://github.com/sequelize/sequelize/pull/9754)\n- fix(scope): incorrect query generated when sequelize.fn used with scopes [#9730](https://github.com/sequelize/sequelize/pull/9730)\n- fix(json): access included data with attributes [#9662](https://github.com/sequelize/sequelize/pull/9662)\n- (fix): pass offset in UNION'ed queries [#9577](https://github.com/sequelize/sequelize/pull/9577)\n- fix(destroy): attributes updated in a beforeDestroy hook are now persisted on soft delete [#9319](https://github.com/sequelize/sequelize/pull/9319)\n- fix(addScope): only throw when defaultScope is defined [#9703](https://github.com/sequelize/sequelize/pull/9703)\n\n### 5.0.0-beta.10\n\n- fix(belongsToMany): association.add returns array of array of through records [#9700](https://github.com/sequelize/sequelize/pull/9700)\n- feat: association hooks [#9590](https://github.com/sequelize/sequelize/pull/9590)\n- fix(bulkCreate): dont map dataValue to fields for individualHooks:true[#9672](https://github.com/sequelize/sequelize/pull/9672)\n- feat(postgres): drop enum support [#9641](https://github.com/sequelize/sequelize/pull/9641)\n- feat(validation): improve validation for type[#9660](https://github.com/sequelize/sequelize/pull/9660)\n- feat: allow querying sqlite_master table [#9645](https://github.com/sequelize/sequelize/pull/9645)\n- fix(hasOne.sourceKey): setup sourceKeyAttribute for joins [#9658](https://github.com/sequelize/sequelize/pull/9658)\n- fix: throw when type of array values is not defined [#9649](https://github.com/sequelize/sequelize/pull/9649)\n- fix(query-generator): ignore undefined keys in query [#9548](https://github.com/sequelize/sequelize/pull/9548)\n- fix(model): unable to override rejectOnEmpty [#9632](https://github.com/sequelize/sequelize/pull/9632)\n- fix(reload): instance.changed() remains unaffected [#9615](https://github.com/sequelize/sequelize/pull/9615)\n- feat(model): column level comments [#9573](https://github.com/sequelize/sequelize/pull/9573)\n- docs: cleanup / correct jsdoc references [#9702](https://github.com/sequelize/sequelize/pull/9702)\n\n### 5.0.0-beta.9\n\n- fix(model): ignore undefined values in update payload [#9587](https://github.com/sequelize/sequelize/pull/9587)\n- fix(mssql): set encrypt as default false for dialect options [#9588](https://github.com/sequelize/sequelize/pull/9588)\n- fix(model): ignore VIRTUAL/getters with attributes.exclude [#9568](https://github.com/sequelize/sequelize/pull/9568)\n- feat(data-types): CIDR, INET, MACADDR support for Postgres [#9567](https://github.com/sequelize/sequelize/pull/9567)\n- fix: customize allowNull message with notNull validator [#9549](https://github.com/sequelize/sequelize/pull/9549)\n\n### 5.0.0-beta.8\n\n- feat(query-generator): Generate INSERT / UPDATE using bind parameters [#9431](https://github.com/sequelize/sequelize/pull/9431) [#9492](https://github.com/sequelize/sequelize/pull/9492)\n- performance: remove terraformer-wkt-parser dependency [#9545](https://github.com/sequelize/sequelize/pull/9545)\n- fix(constructor): set username, password, database via options in addition to connection string[#9517](https://github.com/sequelize/sequelize/pull/9517)\n- fix(associations/belongs-to-many): catch EmptyResultError in set/add helpers [#9535](https://github.com/sequelize/sequelize/pull/9535)\n- fix: sync with alter:true doesn't use field name [#9529](https://github.com/sequelize/sequelize/pull/9529)\n- fix(UnknownConstraintError): improper handling of error options [#9547](https://github.com/sequelize/sequelize/pull/9547)\n\n### 5.0.0-beta.7\n\n- fix(data-types/blob): only return null for mysql binary null [#9441](https://github.com/sequelize/sequelize/pull/9441)\n- fix(errors): use standard .original rather than .__raw for actual error\n- fix(connection-manager): mssql datatype parsing [#9470](https://github.com/sequelize/sequelize/pull/9470)\n- fix(query/removeConstraint): support schemas\n- fix: use Buffer.from\n- fix(transactions): return patched promise from sequelize.query [#9473](https://github.com/sequelize/sequelize/pull/9473)\n\n### 5.0.0-beta.6\n\n- fix(postgres/query-generator): syntax error with auto-increment SMALLINT [#9406](https://github.com/sequelize/sequelize/pull/9406)\n- fix(postgres/range): inclusive property lost in JSON format [#8471](https://github.com/sequelize/sequelize/issues/8471)\n- fix(postgres/range): range bound not applied [#8176](https://github.com/sequelize/sequelize/issues/8176)\n- fix(mssql): no unique constraint error thrown for PRIMARY case [#9415](https://github.com/sequelize/sequelize/pull/9415)\n- fix(query-generator): regexp operator escaping\n- docs: various improvements and hinting update\n\n### 5.0.0-beta.5\n\n- fix: inject foreignKey when using separate:true [#9396](https://github.com/sequelize/sequelize/pull/9396)\n- fix(isSoftDeleted): just use deletedAt as flag\n- feat(hasOne): sourceKey support with key validation [#9382](https://github.com/sequelize/sequelize/pull/9382)\n- fix(query-generator/deleteQuery): remove auto limit [#9377](https://github.com/sequelize/sequelize/pull/9377)\n- feat(postgres): skip locked support [#9197](https://github.com/sequelize/sequelize/pull/9197)\n- fix(mssql): case sensitive operation fails because of uppercased system table references [#9337](https://github.com/sequelize/sequelize/pull/9337)\n\n### 5.0.0-beta.4\n\n- change(model): setDataValue should not mark null to null as changed [#9347](https://github.com/sequelize/sequelize/pull/9347)\n- change(mysql/connection-manager): do not execute SET time_zone query if keepDefaultTimezone config is true [#9358](https://github.com/sequelize/sequelize/pull/9358)\n- feat(transactions): Add afterCommit hooks for transactions [#9287](https://github.com/sequelize/sequelize/pull/9287)\n\n### 5.0.0-beta.3\n\n- change(model): new options.underscored implementation [#9304](https://github.com/sequelize/sequelize/pull/9304)\n- fix(mssql): duplicate order generated with limit offset [#9307](https://github.com/sequelize/sequelize/pull/9307)\n- fix(scope): do not assign scope on eagerly loaded associations [#9292](https://github.com/sequelize/sequelize/pull/9292)\n- change(bulkCreate): only support non-empty array as updateOnDuplicate\n\n### 5.0.0-beta.2\n\n- change(operators): Symbol operators now enabled by default, removed deprecation warning\n- fix(model): don't add LIMIT in findOne() queries on unique key [#9248](https://github.com/sequelize/sequelize/pull/9248)\n- fix(model): use schema when generating foreign keys [#9029](https://github.com/sequelize/sequelize/issues/9029)\n\n### 5.0.0-beta.1\n\n- fix(postgres): reserved words support [#9236](https://github.com/sequelize/sequelize/pull/9236)\n- fix(findOrCreate): warn and handle unknown attributes in defaults\n- fix(query-generator): 1-to-many join in subQuery filter missing where clause [#9228](https://github.com/sequelize/sequelize/issues/9228)\n\n### 5.0.0-beta\n\n- `Model.attributes` now removed, use `Model.rawAttributes` [#5320](https://github.com/sequelize/sequelize/issues/5320)\n- `paranoid` mode will now treat any record with `deletedAt` as deleted [#8496](https://github.com/sequelize/sequelize/issues/8496)\n- Node 6 and up [#9015](https://github.com/sequelize/sequelize/issues/9015)\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/legacy.md",
    "name": "./docs/manual/legacy.md",
    "content": "# Working with legacy tables\n\nWhile out of the box Sequelize will seem a bit opinionated it's easy to work legacy tables and forward proof your application by defining (otherwise generated) table and field names.\n\n## Tables\n\n```js\nclass User extends Model {}\nUser.init({\n  // ...\n}, {\n  modelName: 'user',\n  tableName: 'users',\n  sequelize,\n});\n```\n\n## Fields\n\n```js\nclass MyModel extends Model {}\nMyModel.init({\n  userId: {\n    type: Sequelize.INTEGER,\n    field: 'user_id'\n  }\n}, { sequelize });\n```\n\n## Primary keys\n\nSequelize will assume your table has a `id` primary key property by default.\n\nTo define your own primary key:\n\n```js\nclass Collection extends Model {}\nCollection.init({\n  uid: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true // Automatically gets converted to SERIAL for postgres\n  }\n}, { sequelize });\n\nclass Collection extends Model {}\nCollection.init({\n  uuid: {\n    type: Sequelize.UUID,\n    primaryKey: true\n  }\n}, { sequelize });\n```\n\nAnd if your model has no primary key at all you can use `Model.removeAttribute('id');`\n\n## Foreign keys\n\n```js\n// 1:1\nOrganization.belongsTo(User, { foreignKey: 'owner_id' });\nUser.hasOne(Organization, { foreignKey: 'owner_id' });\n\n// 1:M\nProject.hasMany(Task, { foreignKey: 'tasks_pk' });\nTask.belongsTo(Project, { foreignKey: 'tasks_pk' });\n\n// N:M\nUser.belongsToMany(Role, { through: 'user_has_roles', foreignKey: 'user_role_user_id' });\nRole.belongsToMany(User, { through: 'user_has_roles', foreignKey: 'roles_identifier' });\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/whos-using.md",
    "name": "./docs/manual/whos-using.md",
    "content": "# Who's using sequelize?\n\n[![Walmart labs logo](asset/walmart-labs-logo.png)](http://www.walmartlabs.com/)\n\n> ... we are avid users of sequelize (and have been for the past 18 months) (Feb 2017)\n\n<hr />\n\n[![Snaplytics logo](asset/logo-snaplytics-green.png)](https://snaplytics.io)\n\n> We've been using sequelize since we started in the beginning of 2015. We use it for our graphql servers (in connection with [graphql-sequelize](http://github.com/mickhansen/graphql-sequelize)), and for all our background workers.\n\n<hr />\n\n[![Connected Cars logo](asset/connected-cars.png)](https://connectedcars.io/)\n\n<hr />\n\n[![Bitovi Logo](asset/bitovi-logo.png)](https://bitovi.com)\n\n> We have used Sequelize in enterprise projects for some of our Fortune 100 and Fortune 500 clients.  It is used in deployments that are depended on by hundreds of millions of devices every year.\n\n<hr />\n\n[![ErmesHotels Logo](asset/ermeshotels-logo.png)](https://www.ermeshotels.com)\n\n> Using Sequelize in production for two different apps with 30k+ daily users by 2 years. I doubt there is something better at this moment in terms of productivity and features.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/sequelize.org/sequelize.org/sequelize/docs/manual/legal.md",
    "name": "./docs/manual/legal.md",
    "content": "# Legal Notice\n\n## License\n\nSequelize library is distributed with MIT license. You can find original license [here.](https://github.com/sequelize/sequelize/blob/master/LICENSE)\n\n```text\nMIT License\n\nCopyright (c) 2014-present Sequelize contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n## AUTHOR(S)\n\n```text\nMain author:\n\nSascha Depold\nUhlandstr. 160\n10719 Berlin\nsascha [at] depold [dot] com\n[plus] 49 152 [slash] 03878582\n\n```\n\n## INHALTLICHE VERANTWORTUNG\n\n```text\nIch bernehme keine Haftung fr ausgehende Links.\nDaher musst du dich bei Problemen an deren Betreiber wenden!\n```\n",
    "static": true,
    "access": "public"
  }
]